#include "explorer.h"
#include "libmov.h"
#include "libinfra.h"
#include "libmov.nxc" //noetig da kein linking
#include "libinfra.nxc" //noetig da kein linking

task target()
{
 #if DEBUG == 1
 Acquire(print_mutex);
 lcd_print("zielsuche");//DEBUGINFO
 Release(print_mutex);
 #endif
 while(true)
 {
  #if DEBUG == 2
  if(!found)
  {
   if(SensorRaw(S4) < 480)
   {
    string fou;
    fou=StrCat(NumToStr(id++),";9,",NumToStr(MotorTachoCount(OUT_A))); // 9: found
    id %= 10;
    id += 10;
    Acquire(blue_mutex);
    SendResponseString(OUTBOX,fou);
    Release(blue_mutex);
    
    weiter=0;
    found = 1;
   }
  }
  else
  {
   Wait(5000);
   found = 0;
  }
  #endif
  Wait(100);
 }
}

task event()
{
 while(true)
 {
  #if DEBUG == 2
  string news;
  news=StrCat(NumToStr(id++),";1,",NumToStr(MotorTachoCount(OUT_A)));  // s: save_way
  id %= 10;
  id += 10;
  Acquire(blue_mutex);
  SendResponseString(OUTBOX,news);
  Release(blue_mutex);
  Wait(5000);
  #endif
 }
}
 
task movement()
{
 #if DEBUG == 1
 Acquire(print_mutex);
 lcd_print("movement gestartet");//DEBUGINFO
 Release(print_mutex);
 #endif
 payload dequeued;
 string streckeninfo;
 distance strecke;
 while(true)
 {
  streckeninfo="";
  if(!is_empty())
  {
   dequeued = dequeue(queue1, queue2);
   #if DEBUG == 3
   Acquire(print_mutex);
     lcd_print(StrCat("dequeue=",NumToStr(dequeued.funktion)));
     lcd_print(StrCat(" param=",NumToStr(dequeued.param)));
   Release(print_mutex);
   #endif
   if(dequeued.funktion == 1)
   {
		weiter = 1; 
	  int sen = vor(dequeued.param,strecke);
	  
	  string tmp = "";
    if(strecke.k!=0) tmp=NumToStr(strecke.k);
    if(hit)
    {
     streckeninfo=StrCat(NumToStr(id++),";2,",tmp,NumToStr(strecke.rest),",",NumToStr(sen));
     hit = 0;
    }
    else
    {
     streckeninfo=StrCat(NumToStr(id++),";3,",tmp,NumToStr(strecke.rest));
    }
    id %= 10;
    id += 10;
    Acquire(blue_mutex);
    SendResponseString(OUTBOX,streckeninfo);
    Release(blue_mutex);
	 }
   else if(dequeued.funktion == 2)
   {
    zurueck(dequeued.param);
    streckeninfo=StrCat(NumToStr(id++),";4,0");
    id %= 10;
    id += 10;
    Acquire(blue_mutex);
    SendResponseString(OUTBOX,streckeninfo);
    Release(blue_mutex);
   }
   else if(dequeued.funktion == 3)
   {
    drehen('l',dequeued.param);
    streckeninfo=StrCat(NumToStr(id++),";4,0");
    id %= 10;
    id += 10;
    Acquire(blue_mutex);
    SendResponseString(OUTBOX,streckeninfo);
    Release(blue_mutex);
   }
   else if(dequeued.funktion == 4)
   {
    drehen('r',dequeued.param);
    streckeninfo=StrCat(NumToStr(id++),";4,0");
    id %= 10;
    id += 10;
    Acquire(blue_mutex);
    SendResponseString(OUTBOX,streckeninfo);
    Release(blue_mutex);
   }
   else if(dequeued.funktion == 5)
   {
    int free = echo();
    streckeninfo=StrCat(NumToStr(id++),";5,",NumToStr(free));
    id %= 10;
    id += 10;
    Acquire(blue_mutex);
    SendResponseString(OUTBOX,streckeninfo);
    Release(blue_mutex);
    #if DEBUG == 2
     Acquire(print_mutex);
     lcd_print(streckeninfo);//DEBUGINFO
     Release(print_mutex);
    #endif
   }
   else
   {
    Acquire(print_mutex);
    lcd_print("M_PARSING-ERROR: ");
    lcd_print(StrCat("dequeue=",NumToStr(dequeued.funktion)));
    lcd_print(StrCat(" param=",NumToStr(dequeued.param)));
    Release(print_mutex);
   }
  }
  else
  {
   #if DEBUG == 3
   Acquire(print_mutex);
    lcd_print("queue is empty");//DEBUGINFO
   Release(print_mutex);
   #endif
   
   Wait(500);
  }
 }
}

task dispatcher()
{
 #if DEBUG == 1
 Acquire(print_mutex);
 lcd_print("dispatcher gestartet");//DEBUGINFO
 Release(print_mutex);
 #endif
 string in, tmp;
 message m;
 int test;
 while(true)
 {
  in = "";
  test = 1;
  Acquire(blue_mutex);
  test = ReceiveRemoteString(INBOX, true, in);//gibt 0 oder 64 zurueck
  Release(blue_mutex);
  if(in!="" && test==0)
  {
   #if DEBUG == 2
   Acquire(print_mutex);
    lcd_print("in != \"\" ");
   Release(print_mutex);
   #endif
   
   m = splitMsg(in);
   
   #if DEBUG == 2
   Acquire(print_mutex);
    lcd_print(StrCat("id=",NumToStr(m.id),";func=",NumToStr(m.msg.funktion)));
   Release(print_mutex);
   #endif
   
   if(m.msg.funktion == 0)
   {
    weiter = 0;
    Acquire(print_mutex);
    lcd_print("abbruch/halt");
    Release(print_mutex);
    clean_queue(queue1, queue2);
   }
   else
   {
    enqueue(queue1, queue2, m.msg);
   }
  }
  Wait(500);
 }
}

void undo_found()
{
    found=0;
}

task main()
{
 Precedes(dispatcher, movement, event, target);
 queueInit(queue1, queue2);

 //Init Sensoren:
 SetSensorLowspeed(S1);
 SetSensorTouch(S2);
 SetSensorTouch(S3);
 SetSensorLight(S4);

}
