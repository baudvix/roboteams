#include "libmov.h"

/* Kalibrierungsdaten:
* Umdrehung -> cm: 17,6cm +- 0,1cm
* SensorUS(S1)~14, ungefähr 10cm
*/

/*
* Methode zum vorwärts fahren
* Parameter:
* strecke = die zu fahrende Distanz in Grad oder "0" für endlos fahren
* d = Rückgabe des Motortachos in Grad
*/
int vor(int strecke, distance& d)
{
 Off(OUT_AB); // Motortacho reseten
 int k_strecke = 0;
 int sen = 0;
 if(strecke == 0) // distance || endless
 {
  while(weiter)
  {
   SetOutput(OUT_AB,Power, MOTOR_POWER,TachoLimit, 10000,RegMode, OUT_REGMODE_SYNC,RunState, OUT_RUNSTATE_RUNNING,OutputMode, 7,UpdateFlags, 7); // Motorsteuerbefehl
   while((MotorRunState(OUT_B) == OUT_RUNSTATE_RUNNING) && (SensorUS(S1) > 15) && (SENSOR_2 < 1) && (SENSOR_3 < 1) && weiter != 0); // Fahrschleife
   if(!((SensorUS(S1) > 15) && (SENSOR_2 < 1) && (SENSOR_3 < 1))) // Sensorevents
   {
    Acquire(weiter_mutex);
    weiter = 0; // nicht weiter fahren
    Release(weiter_mutex);
    
    hit=1; // Kollision merken
    if(SensorUS(S1) < 15){sen = 1;} // den Sensor merken der ausgelöst hat
    if(SENSOR_2 > 0){sen = 2;}
    if(SENSOR_3 > 0){sen = 3;}
   }
   if(weiter) // Tachoüberlauf verhindern
   {
    k_strecke++;
    ResetTachoCount(OUT_A);
    Wait(500);
   }
  }
 }
 else
 {
   SetOutput(OUT_AB,Power, MOTOR_POWER,TachoLimit, strecke,RegMode, OUT_REGMODE_SYNC,RunState, OUT_RUNSTATE_RUNNING,OutputMode, 7,UpdateFlags, 7); // Motorsteuerbefehl
   while((MotorRunState(OUT_B) == OUT_RUNSTATE_RUNNING) && (SensorUS(S1) > 15) && (SENSOR_2 < 1) && (SENSOR_3 < 1) && weiter != 0); // Fahrschleife
   if(!((SensorUS(S1) > 15) && (SENSOR_2 < 1) && (SENSOR_3 < 1))) // Sensorevents
   {
    hit=1; // Kollision merken
    if(SensorUS(S1) < 15){sen = 1;} // den Sensor merken der ausgelöst hat
    if(SENSOR_2 > 0){sen = 2;}   // rechts
    if(SENSOR_3 > 0){sen = 3;}   // links
   }
 }
 d.k = k_strecke; // Tachorückgabe
 d.rest = MotorTachoCount(OUT_A); // Tachorückgabe
 Off(OUT_AB); // Motortacho reseten
 return sen; // Ausgelösten Sensor zurück geben
}

/*
* Methode um zu wenden
* Parameter:
* richtung = l oder r (left/right)
* winkel = wie weit der Motor drehen soll (in Grad)
*/
void drehen(char richtung, int winkel){
 Off(OUT_AB);
 int lr; //links oder rechts
 switch(richtung)
 {
 case 'l':
      lr = 100;
      RotateMotorEx(OUT_AB, MOTOR_POWER, 2*winkel*TEPPICH_ABWEICHUNG_L, lr, true/*=sync*/, true/*=bremsen*/);
      break;
 case 'r':
      lr = -100;
      RotateMotorEx(OUT_AB, MOTOR_POWER, 2*winkel*TEPPICH_ABWEICHUNG_R, lr, true/*=sync*/, true/*=bremsen*/);
      break;
 default:
      lr = 100;
      RotateMotorEx(OUT_AB, MOTOR_POWER, 2*winkel*TEPPICH_ABWEICHUNG_L, lr, true/*=sync*/, true/*=bremsen*/);
 }
 Off(OUT_AB);
}

/*
* Methode zum rückwärts Fahren
* Parameter:
* umdrehung = die zu fahrende Distanz,
*           (in Grad)
*/
void zurueck(int umdrehungen)
{
 RotateMotorEx(OUT_AB, MOTOR_POWER, -1*umdrehungen, 0, true/*=sync*/, true/*=bremsen*/);
 Wait(300);
 Off(OUT_AB);
}

/*
* Methode um den Ultraschallsensor manuel abzufragen
* Rückgabe ist der Abstand zum nächsten Objekt
* gemittelt über 5 Messungen
*/
int echo()
{
 int l=0; //Schleifen-Variable
 int r=0; //Ergebnis

 while(l<5)
 {
  r += SensorUS(S1);
  l++;
  Wait(100);
 }
 r = r/5;
 return r;
}

