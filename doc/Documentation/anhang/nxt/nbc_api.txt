/** \file NBCCommon.h
 * \brief Constants and macros common to both NBC and NXC
 *
 * NBCCommon.h contains declarations for the NBC and NXC NXT API functions.
 *
 * License:
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Initial Developer of this code is John Hansen.
 * Portions created by John Hansen are Copyright (C) 2009-2012 John Hansen.
 * All Rights Reserved.
 *
 * ----------------------------------------------------------------------------
 *
 * \author John Hansen (bricxcc_at_comcast.net)
 * \date 2012-02-06
 * \version 70
 */

#ifndef NBCCOMMON_H
#define NBCCOMMON_H

/** @addtogroup MiscConstants
 * @{
 */
#define TRUE  1 /*!< A true value */
#define FALSE 0 /*!< A false value */

#define NA 0xFFFF /*!< The specified argument does not apply (aka unwired) */

/** @defgroup RCPropertyConstants Property constants
 * Use these constants for specifying the property for the GetProperty
 * and SetProperty direct commands.
 * @{
 */
#define RC_PROP_BTONOFF       0x0  /*!< Set/get whether bluetooth is on or off */
#define RC_PROP_SOUND_LEVEL   0x1  /*!< Set/get the NXT sound level */
#define RC_PROP_SLEEP_TIMEOUT 0x2  /*!< Set/get the NXT sleep timeout value (times 60000) */
#define RC_PROP_DEBUGGING     0xF  /*!< Set/get enhanced firmware debugging information */
/** @} */  // end of RCPropertyConstants group

/** @} */  // end of MiscConstants group

#ifdef __ENHANCED_FIRMWARE
/** @addtogroup CommandModuleConstants
 * @{
 */
/** @defgroup ArrayOpConstants Array operation constants
 * Constants for use with the NXC ArrayOp function and the NBC arrop statement.
 * @{
 */
// array operation definitions
#define OPARR_SUM     0x00 /*!< Calculate the sum of the elements in the numeric input array */
#define OPARR_MEAN    0x01 /*!< Calculate the mean value for the elements in the numeric input array */
#define OPARR_SUMSQR  0x02 /*!< Calculate the sum of the squares of the elements in the numeric input array */
#define OPARR_STD     0x03 /*!< Calculate the standard deviation of the elements in the numeric input array */
#define OPARR_MIN     0x04 /*!< Calculate the minimum value of the elements in the numeric input array */
#define OPARR_MAX     0x05 /*!< Calculate the maximum value of the elements in the numeric input array */
#define OPARR_SORT    0x06 /*!< Sort the elements in the numeric input array */
#define OPARR_TOUPPER 0x07 /*!< Uppercase the input string */
#define OPARR_TOLOWER 0x08 /*!< Lowercase the input string */
/** @} */  // end of ArrayOpConstants group
/** @} */  // end of CommandModuleConstants group
#endif

/** @addtogroup MiscConstants
 * @{
 */
#if __FIRMWARE_VERSION > 107
#define PI 3.141593               /*!< A constant for PI */
#define RADIANS_PER_DEGREE PI/180 /*!< Used for converting from degrees to radians */
#define DEGREES_PER_RADIAN 180/PI /*!< Used for converting from radians to degrees */
#endif
/** @} */  // end of MiscConstants group

#if __FIRMWARE_VERSION <= 107
/** @defgroup IOMapAddressConstants Direct IOMap data addresses
 * Constants for use in direct IOMap addressing (1.0x only).
 * @{
 */
#define IO_BASE    0xC000
#define MOD_INPUT  0x0000
#define MOD_OUTPUT 0x0200
#define IO_IN_FPP  6
#define IO_OUT_FPP 15

#define InputIOType(p)            (IO_BASE+MOD_INPUT+TypeField+((p)*IO_IN_FPP))
#define InputIOInputMode(p)       (IO_BASE+MOD_INPUT+InputModeField+((p)*IO_IN_FPP))
#define InputIORawValue(p)        (IO_BASE+MOD_INPUT+RawValueField+((p)*IO_IN_FPP))
#define InputIONormalizedValue(p) (IO_BASE+MOD_INPUT+NormalizedValueField+((p)*IO_IN_FPP))
#define InputIOScaledValue(p)     (IO_BASE+MOD_INPUT+ScaledValueField+((p)*IO_IN_FPP))
#define InputIOInvalidData(p)     (IO_BASE+MOD_INPUT+InvalidDataField+((p)*IO_IN_FPP))

#define OutputIOUpdateFlags(p)     (IO_BASE+MOD_OUTPUT+UpdateFlagsField+((p)*IO_OUT_FPP))
#define OutputIOOutputMode(p)      (IO_BASE+MOD_OUTPUT+OutputModeField+((p)*IO_OUT_FPP))
#define OutputIOPower(p)           (IO_BASE+MOD_OUTPUT+PowerField+((p)*IO_OUT_FPP))
#define OutputIOActualSpeed(p)     (IO_BASE+MOD_OUTPUT+ActualSpeedField+((p)*IO_OUT_FPP))
#define OutputIOTachoCount(p)      (IO_BASE+MOD_OUTPUT+TachoCountField+((p)*IO_OUT_FPP))
#define OutputIOTachoLimit(p)      (IO_BASE+MOD_OUTPUT+TachoLimitField+((p)*IO_OUT_FPP))
#define OutputIORunState(p)        (IO_BASE+MOD_OUTPUT+RunStateField+((p)*IO_OUT_FPP))
#define OutputIOTurnRatio(p)       (IO_BASE+MOD_OUTPUT+TurnRatioField+((p)*IO_OUT_FPP))
#define OutputIORegMode(p)         (IO_BASE+MOD_OUTPUT+RegModeField+((p)*IO_OUT_FPP))
#define OutputIOOverload(p)        (IO_BASE+MOD_OUTPUT+OverloadField+((p)*IO_OUT_FPP))
#define OutputIORegPValue(p)       (IO_BASE+MOD_OUTPUT+RegPValueField+((p)*IO_OUT_FPP))
#define OutputIORegIValue(p)       (IO_BASE+MOD_OUTPUT+RegIValueField+((p)*IO_OUT_FPP))
#define OutputIORegDValue(p)       (IO_BASE+MOD_OUTPUT+RegDValueField+((p)*IO_OUT_FPP))
#define OutputIOBlockTachoCount(p) (IO_BASE+MOD_OUTPUT+BlockTachoCountField+((p)*IO_OUT_FPP))
#define OutputIORotationCount(p)   (IO_BASE+MOD_OUTPUT+RotationCountField+((p)*IO_OUT_FPP))

#define InputIOType0             0xc000
#define InputIOInputMode0        0xc001
#define InputIORawValue0         0xc002
#define InputIONormalizedValue0  0xc003
#define InputIOScaledValue0      0xc004
#define InputIOInvalidData0      0xc005
#define InputIOType1             0xc006
#define InputIOInputMode1        0xc007
#define InputIORawValue1         0xc008
#define InputIONormalizedValue1  0xc009
#define InputIOScaledValue1      0xc00a
#define InputIOInvalidData1      0xc00b
#define InputIOType2             0xc00c
#define InputIOInputMode2        0xc00d
#define InputIORawValue2         0xc00e
#define InputIONormalizedValue2  0xc00f
#define InputIOScaledValue2      0xc010
#define InputIOInvalidData2      0xc011
#define InputIOType3             0xc012
#define InputIOInputMode3        0xc013
#define InputIORawValue3         0xc014
#define InputIONormalizedValue3  0xc015
#define InputIOScaledValue3      0xc016
#define InputIOInvalidData3      0xc017
// output IO Map addresses
#define OutputIOUpdateFlags0     0xc200
#define OutputIOOutputMode0      0xc201
#define OutputIOPower0           0xc202
#define OutputIOActualSpeed0     0xc203
#define OutputIOTachoCount0      0xc204
#define OutputIOTachoLimit0      0xc205
#define OutputIORunState0        0xc206
#define OutputIOTurnRatio0       0xc207
#define OutputIORegMode0         0xc208
#define OutputIOOverload0        0xc209
#define OutputIORegPValue0       0xc20a
#define OutputIORegIValue0       0xc20b
#define OutputIORegDValue0       0xc20c
#define OutputIOBlockTachoCount0 0xc20d
#define OutputIORotationCount0   0xc20e
#define OutputIOUpdateFlags1     0xc20f
#define OutputIOOutputMode1      0xc210
#define OutputIOPower1           0xc211
#define OutputIOActualSpeed1     0xc212
#define OutputIOTachoCount1      0xc213
#define OutputIOTachoLimit1      0xc214
#define OutputIORunState1        0xc215
#define OutputIOTurnRatio1       0xc216
#define OutputIORegMode1         0xc217
#define OutputIOOverload1        0xc218
#define OutputIORegPValue1       0xc219
#define OutputIORegIValue1       0xc21a
#define OutputIORegDValue1       0xc21b
#define OutputIOBlockTachoCount1 0xc21c
#define OutputIORotationCount1   0xc21d
#define OutputIOUpdateFlags2     0xc21e
#define OutputIOOutputMode2      0xc21f
#define OutputIOPower2           0xc220
#define OutputIOActualSpeed2     0xc221
#define OutputIOTachoCount2      0xc222
#define OutputIOTachoLimit2      0xc223
#define OutputIORunState2        0xc224
#define OutputIOTurnRatio2       0xc225
#define OutputIORegMode2         0xc226
#define OutputIOOverload2        0xc227
#define OutputIORegPValue2       0xc228
#define OutputIORegIValue2       0xc229
#define OutputIORegDValue2       0xc22a
#define OutputIOBlockTachoCount2 0xc22b
#define OutputIORotationCount2   0xc22c
/** @} */  // end of IOMapAddressConstants group
#endif

/** @addtogroup CommandModuleConstants
 * @{
 */
/** @defgroup SysCallConstants System Call function constants
 * Constants for use in the SysCall() function or NBC syscall statement.
 * @{
 */
#define FileOpenRead       0 /*!< Open a file for reading */
#define FileOpenWrite      1 /*!< Open a file for writing (creates a new file) */
#define FileOpenAppend     2 /*!< Open a file for appending to the end of the file */
#define FileRead           3 /*!< Read from the specified file */
#define FileWrite          4 /*!< Write to the specified file */
#define FileClose          5 /*!< Close the specified file */
#define FileResolveHandle  6 /*!< Get a file handle for the specified filename if it is already open */
#define FileRename         7 /*!< Rename a file */
#define FileDelete         8 /*!< Delete a file */
#define SoundPlayFile      9 /*!< Play a sound or melody file */
#define SoundPlayTone     10 /*!< Play a simple tone with the specified frequency and duration */
#define SoundGetState     11 /*!< Get the current sound module state */
#define SoundSetState     12 /*!< Set the sound module state */
#define DrawText          13 /*!< Draw text to one of 8 LCD lines */
#define DrawPoint         14 /*!< Draw a single pixel on the LCD screen */
#define DrawLine          15 /*!< Draw a line on the LCD screen */
#define DrawCircle        16 /*!< Draw a circle on the LCD screen */
#define DrawRect          17 /*!< Draw a rectangle on the LCD screen */
#define DrawGraphic       18 /*!< Draw a graphic image on the LCD screen */
#define SetScreenMode     19 /*!< Set the screen mode */
#define ReadButton        20 /*!< Read the current button state */
#define CommLSWrite       21 /*!< Write to a lowspeed (aka I2C) device */
#define CommLSRead        22 /*!< Read from a lowspeed (aka I2C) device */
#define CommLSCheckStatus 23 /*!< Check the status of a lowspeed (aka I2C) device */
#define RandomNumber      24 /*!< Generate a random number */
#define GetStartTick      25 /*!< Get the current system tick count */
#define MessageWrite      26 /*!< Write a message to a mailbox */
#define MessageRead       27 /*!< Read a message from a mailbox */
#define CommBTCheckStatus 28 /*!< Check the bluetooth status */
#define CommBTWrite       29 /*!< Write to a bluetooth connections */
#define CommBTRead        30 /*!< Read from a bluetooth connection */
#define KeepAlive         31 /*!< Reset the NXT sleep timer */
#define IOMapRead         32 /*!< Read data from one of the firmware module's IOMap structures using the module's name */
#define IOMapWrite        33 /*!< Write data to one of the firmware module's IOMap structures using the module's name */

#if __FIRMWARE_VERSION <= 107
#ifdef __ENHANCED_FIRMWARE
#define IOMapReadByID          34
#define IOMapWriteByID         35
#define DisplayExecuteFunction 36
#define CommExecuteFunction    37
#define LoaderExecuteFunction  38
#define FileFindFirst          39
#define FileFindNext           40
#define FileOpenWriteLinear    41
#define FileOpenWriteNonLinear 42
#define FileOpenReadLinear     43
#define CommHSControl          44
#define CommHSCheckStatus      45
#define CommHSWrite            46
#define CommHSRead             47 
#endif
#else
// NXT 2.0 firmwares
#define ColorSensorRead        34 /*!< Read data from the NXT 2.0 color sensor */
#define CommBTOnOff            35 /*!< Turn the bluetooth radio on or off */
#define CommBTConnection       36 /*!< Connect or disconnect to a known bluetooth device */
#define CommHSWrite            37 /*!< Write data to the hi-speed port */
#define CommHSRead             38 /*!< Read data from the hi-speed port */
#define CommHSCheckStatus      39 /*!< Check the status of the hi-speed port */
#define ReadSemData            40 /*!< Read motor semaphore data */
#define WriteSemData           41 /*!< Write motor semaphore data */
#define ComputeCalibValue      42 /*!< Compute a calibration value */
#define UpdateCalibCacheInfo   43 /*!< Update sensor calibration cache information */
#define DatalogWrite           44 /*!< Write to the datalog */
#define DatalogGetTimes        45 /*!< Get datalog timing information */
#define SetSleepTimeoutVal     46 /*!< Set the NXT sleep timeout value */
#define ListFiles              47 /*!< List files that match the specified filename pattern */

#ifdef __ENHANCED_FIRMWARE
#define InputPinFunction       77 /*!< Execute the Input module's pin function */
#define IOMapReadByID          78 /*!< Read data from one of the firmware module's IOMap structures using the module's ID */
#define IOMapWriteByID         79 /*!< Write data to one of the firmware module's IOMap structures using the module's ID */
#define DisplayExecuteFunction 80 /*!< Execute one of the Display module's internal functions */
#define CommExecuteFunction    81 /*!< Execute one of the Comm module's internal functions */
#define LoaderExecuteFunction  82 /*!< Execute one of the Loader module's internal functions */
#define FileFindFirst          83 /*!< Start a search for a file using a filename pattern */
#define FileFindNext           84 /*!< Continue searching for a file */
#define FileOpenWriteLinear    85 /*!< Open a linear file for writing */
#define FileOpenWriteNonLinear 86 /*!< Open a non-linear file for writing */
#define FileOpenReadLinear     87 /*!< Open a linear file for reading */
#define CommHSControl          88 /*!< Control the hi-speed port */
#define CommLSWriteEx          89 /*!< Write to a lowspeed (aka I2C) device with optional restart on read */
#define FileSeek               90 /*!< Seek to a specific position in an open file */
#define FileResize             91 /*!< Resize a file (not yet implemented) */
#define DrawGraphicArray       92 /*!< Draw a graphic image from a byte array to the LCD screen */
#define DrawPolygon            93 /*!< Draw a polygon on the LCD screen */
#define DrawEllipse            94 /*!< Draw an ellipse on the LCD screen */
#define DrawFont               95 /*!< Draw text using a custom RIC-based font to the LCD screen */
#define MemoryManager          96 /*!< Read memory manager information, optionally compacting the dataspace first */
#define ReadLastResponse       97 /*!< Read the last response packet received by the NXT.  Optionally clear the value after reading it. */
#define FileTell               98 /*!< Return the current file position in an open file */
#define RandomEx               99 /*!< Generate a random number or seed the RNG. */
#endif
#endif
/** @} */  // end of SysCallConstants group
/** @} */  // end of CommandModuleConstants group

/** @addtogroup DisplayModuleConstants
 * @{
 */
/** @defgroup LineConstants Line number constants
 * Line numbers for use with DrawText system function.
 * \sa SysDrawText(), TextOut(), NumOut()
 * @{
 */
#define LCD_LINE8  0 /*!< The 8th line of the LCD screen */
#define LCD_LINE7  8 /*!< The 7th line of the LCD screen */
#define LCD_LINE6 16 /*!< The 6th line of the LCD screen */
#define LCD_LINE5 24 /*!< The 5th line of the LCD screen */
#define LCD_LINE4 32 /*!< The 4th line of the LCD screen */
#define LCD_LINE3 40 /*!< The 3rd line of the LCD screen */
#define LCD_LINE2 48 /*!< The 2nd line of the LCD screen */
#define LCD_LINE1 56 /*!< The 1st line of the LCD screen */
/** @} */  // end of LineConstants group
/** @} */  // end of DisplayModuleConstants group

/** @addtogroup CommandModuleConstants
 * @{
 */
/** @defgroup TimeConstants Time constants
 * Constants for use with the Wait() function.
 * \sa Wait()
 * @{
 */
#define MS_1        1 /*!< 1 millisecond */
#define MS_2        2 /*!< 2 milliseconds */
#define MS_3        3 /*!< 3 milliseconds */
#define MS_4        4 /*!< 4 milliseconds */
#define MS_5        5 /*!< 5 milliseconds */
#define MS_6        6 /*!< 6 milliseconds */
#define MS_7        7 /*!< 7 milliseconds */
#define MS_8        8 /*!< 8 milliseconds */
#define MS_9        9 /*!< 9 milliseconds */
#define MS_10      10 /*!< 10 milliseconds */
#define MS_20      20 /*!< 20 milliseconds */
#define MS_30      30 /*!< 30 milliseconds */
#define MS_40      40 /*!< 40 milliseconds */
#define MS_50      50 /*!< 50 milliseconds */
#define MS_60      60 /*!< 60 milliseconds */
#define MS_70      70 /*!< 70 milliseconds */
#define MS_80      80 /*!< 80 milliseconds */
#define MS_90      90 /*!< 90 milliseconds */
#define MS_100    100 /*!< 100 milliseconds */
#define MS_150    150 /*!< 150 milliseconds */
#define MS_200    200 /*!< 200 milliseconds */
#define MS_250    250 /*!< 250 milliseconds */
#define MS_300    300 /*!< 300 milliseconds */
#define MS_350    350 /*!< 350 milliseconds */
#define MS_400    400 /*!< 400 milliseconds */
#define MS_450    450 /*!< 450 milliseconds */
#define MS_500    500 /*!< 500 milliseconds */
#define MS_600    600 /*!< 600 milliseconds */
#define MS_700    700 /*!< 700 milliseconds */
#define MS_800    800 /*!< 800 milliseconds */
#define MS_900    900 /*!< 900 milliseconds */
#define SEC_1    1000 /*!< 1 second */
#define SEC_2    2000 /*!< 2 seconds */
#define SEC_3    3000 /*!< 3 seconds */
#define SEC_4    4000 /*!< 4 seconds */
#define SEC_5    5000 /*!< 5 seconds */
#define SEC_6    6000 /*!< 6 seconds */
#define SEC_7    7000 /*!< 7 seconds */
#define SEC_8    8000 /*!< 8 seconds */
#define SEC_9    9000 /*!< 9 seconds */
#define SEC_10  10000 /*!< 10 seconds */
#define SEC_15  15000 /*!< 15 seconds */
#define SEC_20  20000 /*!< 20 seconds */
#define SEC_30  30000 /*!< 30 seconds */
#define MIN_1   60000 /*!< 1 minute */
/** @} */  // end of TimeConstants group
/** @} */ // end of CommandModuleConstants group

/** @addtogroup CommModuleConstants
 * @{
 */
/** @defgroup MailboxConstants Mailbox constants
 * Mailbox number constants should be used to avoid confusing NXT-G users.
 * \sa SysMessageWrite(), SysMessageRead(), SendMessage(), ReceiveMessage(),
 * SendRemoteBool(), SendRemoteNumber(), SendRemoteString(),
 * SendResponseBool(), SendResponseNumber(), SendResponseString(),
 * ReceiveRemoteBool(), ReceiveRemoteNumber(), ReceiveRemoteString(),
 * ReceiveRemoteMessageEx(), RemoteMessageRead(), RemoteMessageWrite()
 * @{
 */
#define MAILBOX1  0 /*!< Mailbox number 1 */
#define MAILBOX2  1 /*!< Mailbox number 2 */
#define MAILBOX3  2 /*!< Mailbox number 3 */
#define MAILBOX4  3 /*!< Mailbox number 4 */
#define MAILBOX5  4 /*!< Mailbox number 5 */
#define MAILBOX6  5 /*!< Mailbox number 6 */
#define MAILBOX7  6 /*!< Mailbox number 7 */
#define MAILBOX8  7 /*!< Mailbox number 8 */
#define MAILBOX9  8 /*!< Mailbox number 9 */
#define MAILBOX10 9 /*!< Mailbox number 10 */
/** @} */  // end of MailboxConstants group
/** @} */ // end of CommModuleConstants group

/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup ModuleNameConstants
 * @{
 */
#define CommandModuleName  "Command.mod"   /*!< The command module name */
#define IOCtrlModuleName   "IOCtrl.mod"    /*!< The IOCtrl module name */
#define LoaderModuleName   "Loader.mod"    /*!< The Loader module name */
#define SoundModuleName    "Sound.mod"     /*!< The sound module name */
#define ButtonModuleName   "Button.mod"    /*!< The button module name */
#define UIModuleName       "Ui.mod"        /*!< The Ui module name */
#define InputModuleName    "Input.mod"     /*!< The input module name. */
#define OutputModuleName   "Output.mod"    /*!< The output module name */
#define LowSpeedModuleName "Low Speed.mod" /*!< The low speed module name */
#define DisplayModuleName  "Display.mod"   /*!< The display module name */
#define CommModuleName     "Comm.mod"      /*!< The Comm module name */
/** @} */  // end of ModuleNameConstants group

/** @addtogroup ModuleIDConstants
 * @{
 */
#define CommandModuleID  0x00010001 /*!< The command module ID */
#define IOCtrlModuleID   0x00060001 /*!< The IOCtrl module ID */
#define LoaderModuleID   0x00090001 /*!< The Loader module ID */
#define SoundModuleID    0x00080001 /*!< The sound module ID */
#define ButtonModuleID   0x00040001 /*!< The button module ID */
#define UIModuleID       0x000C0001 /*!< The Ui module ID */
#define InputModuleID    0x00030001 /*!< The input module ID */
#define OutputModuleID   0x00020001 /*!< The output module ID */
#define LowSpeedModuleID 0x000B0001 /*!< The low speed module ID */
#define DisplayModuleID  0x000A0001 /*!< The display module ID */
#define CommModuleID     0x00050001 /*!< The Comm module ID */
/** @} */  // end of ModuleIDConstants group
/** @} */ // end of NXTFirmwareModules group


/** @addtogroup CommandModule
 * @{
 */
/** @addtogroup CommandModuleConstants
 * @{
 */
//Status/error codes for the VM internal code and bytecodes
#define STAT_MSG_EMPTY_MAILBOX 64 /*!< Specified mailbox contains no new messages */
#define STAT_COMM_PENDING 32      /*!< Pending setup operation in progress */

#define POOL_MAX_SIZE 32768      /*!< Maximum size of memory pool, in bytes */

/** @defgroup CommandVMState VM state constants
 * Constants defining possible VM states.
 * @{
 */
#define TIMES_UP      6 /*!< VM time is up */
#define ROTATE_QUEUE  5 /*!< VM should rotate queue */
#define STOP_REQ      4 /*!< VM should stop executing program */
#define BREAKOUT_REQ  3 /*!< VM should break out of current thread */
#define CLUMP_SUSPEND 2 /*!< VM should suspend thread */
#define CLUMP_DONE    1 /*!< VM has finished executing thread */
/** @} */  // end of CommandVMState group

#define NO_ERR        0 /*!< Successful execution of the specified command */

/** @defgroup CommandFatalErrors Fatal errors
 * Constants defining various fatal error conditions.
 * @{
 */
#define ERR_ARG             -1 /*!< 0xFF Bad arguments */
#define ERR_INSTR           -2 /*!< 0xFE Illegal bytecode instruction */
#define ERR_FILE            -3 /*!< 0xFD Malformed file contents */
#define ERR_VER             -4 /*!< 0xFC Version mismatch between firmware and compiler */
#define ERR_MEM             -5 /*!< 0xFB Insufficient memory available */
#define ERR_BAD_PTR         -6 /*!< 0xFA Someone passed us a bad pointer! */
#define ERR_CLUMP_COUNT     -7 /*!< 0xF9 (FileClumpCount == 0 || FileClumpCount >= NOT_A_CLUMP) */
#define ERR_NO_CODE         -8 /*!< 0xF8 VarsCmd.CodespaceCount == 0 */
#define ERR_INSANE_OFFSET   -9 /*!< 0xF7 CurrOffset != (DataSize - VarsCmd.CodespaceCount * 2) */
#define ERR_BAD_POOL_SIZE   -10 /*!< 0xF6 VarsCmd.PoolSize > POOL_MAX_SIZE */
#define ERR_LOADER_ERR      -11 /*!< 0xF5 LOADER_ERR(LStatus) != SUCCESS || pData == NULL || DataSize == 0 */
#define ERR_SPOTCHECK_FAIL  -12 /*!< 0xF4 ((UBYTE*)(VarsCmd.pCodespace) < pData) (c_cmd.c 1893) */
#define ERR_NO_ACTIVE_CLUMP -13 /*!< 0xF3 VarsCmd.RunQ.Head == NOT_A_CLUMP */
#define ERR_DEFAULT_OFFSETS -14 /*!< 0xF2 (DefaultsOffset != FileOffsets.DynamicDefaults) || (DefaultsOffset + FileOffsets.DynamicDefaultsSize != FileOffsets.DSDefaultsSize) */
#define ERR_MEMMGR_FAIL     -15 /*!< 0xF1 (UBYTE *)VarsCmd.MemMgr.pDopeVectorArray != VarsCmd.pDataspace + DV_ARRAY[0].Offset */

#define ERR_NON_FATAL -16 /*!< Fatal errors are greater than this value */
/** @} */  // end of CommandFatalErrors group

/** @defgroup CommandGenErrors General errors
 * Constants defining general error conditions.
 * @{
 */
#define ERR_INVALID_PORT   -16 /*!< 0xF0 Bad input or output port specified */
#define ERR_INVALID_FIELD  -17 /*!< 0xEF Attempted to access invalid field of a structure */
#define ERR_INVALID_QUEUE  -18 /*!< 0xEE Illegal queue ID specified */
#define ERR_INVALID_SIZE   -19 /*!< 0xED Illegal size specified */
#define ERR_NO_PROG        -20 /*!< 0xEC No active program */
/** @} */  // end of CommandGenErrors group

/** @defgroup CommandCommErrors Communications specific errors
 * Constants defining communication error conditions.
 * @{
 */
#define ERR_COMM_CHAN_NOT_READY -32 /*!< 0xE0 Specified channel/connection not configured or busy */
#define ERR_COMM_CHAN_INVALID   -33 /*!< 0xDF Specified channel/connection is not valid */
#define ERR_COMM_BUFFER_FULL    -34 /*!< 0xDE No room in comm buffer */
#define ERR_COMM_BUS_ERR        -35 /*!< 0xDD Something went wrong on the communications bus */
/** @} */  // end of CommandCommErrors group

/** @defgroup CommandRCErrors Remote control (direct commands) errors
 * Constants defining errors that can occur during remote control (RC) direct
 * command operations.
 * @{
 */
#define ERR_RC_ILLEGAL_VAL -64 /*!< 0xC0 Data contains out-of-range values */
#define ERR_RC_BAD_PACKET  -65 /*!< 0xBF Clearly insane packet */
#define ERR_RC_UNKNOWN_CMD -66 /*!< 0xBE Unknown command opcode */
#define ERR_RC_FAILED      -67 /*!< 0xBD Request failed (i.e. specified file not found) */
/** @} */  // end of CommandRCErrors group

/** @defgroup CommandProgStatus Program status constants
 * Constants defining various states of the command module virtual machine.
 * @{
 */
#define PROG_IDLE     0 /*!< Program state is idle */
#define PROG_OK       1 /*!< Program state is okay */
#define PROG_RUNNING  2 /*!< Program is running */
#define PROG_ERROR    3 /*!< A program error has occurred */
#define PROG_ABORT    4 /*!< Program has been aborted */
#define PROG_RESET    5 /*!< Program has been reset */
/** @} */  // end of CommandProgStatus group

/** @defgroup CommandIOMAP Command module IOMAP offsets
 * Constant offsets into the Command module IOMAP structure.
 * @{
 */
#define CommandOffsetFormatString   0 /*!< Offset to the format string */
#define CommandOffsetPRCHandler     16 /*!< Offset to the RC Handler function pointer */
#define CommandOffsetTick           20 /*!< Offset to the VM's current tick */
#define CommandOffsetOffsetDS       24 /*!< Offset to the running program's data space (DS) */
#define CommandOffsetOffsetDVA      26 /*!< Offset to the running program's DOPE vector address (DVA) */
#define CommandOffsetProgStatus     28 /*!< Offset to the running program's status */
#define CommandOffsetAwake          29 /*!< Offset to the VM's awake state */
#define CommandOffsetActivateFlag   30 /*!< Offset to the activate flag */
#define CommandOffsetDeactivateFlag 31 /*!< Offset to the deactivate flag */
#define CommandOffsetFileName       32 /*!< Offset to the running program's filename */
#define CommandOffsetMemoryPool     52 /*!< Offset to the VM's memory pool */
#if __FIRMWARE_VERSION > 107
#define CommandOffsetSyncTime       32820 /*!< Offset to the VM sync time */
#define CommandOffsetSyncTick       32824 /*!< Offset to the VM sync tick */
#endif
/** @} */  // end of CommandIOMAP group

/** @} */  // end of CommandModuleConstants group
/** @} */  // end of CommandModule group


/** @addtogroup IOCtrlModule
 * @{
 */
/** @defgroup IOCtrlModuleConstants IOCtrl module constants
 * Constants that are part of the NXT firmware's IOCtrl module.
 * @{
 */
/** @defgroup IOCtrlPO PowerOn constants
 * Use these constants to power down the NXT or boot it into SAMBA
 * (aka firmware download) mode.
 * @{
 */
#define IOCTRL_POWERDOWN  0x5A00 /*!< Power down the NXT */
#define IOCTRL_BOOT       0xA55A /*!< Reboot the NXT into SAMBA mode */
/** @} */  // end of IOCtrlPO group

/** @defgroup IOCtrlIOMAP IOCtrl module IOMAP offsets
 * Constant offsets into the IOCtrl module IOMAP structure.
 * @{
 */
#define IOCtrlOffsetPowerOn 0 /*!< Offset to power on field */
/** @} */  // end of IOCtrlIOMAP group

/** @} */  // end of IOCtrlModuleConstants group
/** @} */  // end of IOCtrlModule group


/** @addtogroup LoaderModule
 * @{
 */
/** @defgroup LoaderModuleConstants Loader module constants
 * Constants that are part of the NXT firmware's Loader module.
 * @{
 */
/** @defgroup LoaderIOMAP Loader module IOMAP offsets
 * Constant offsets into the Loader module IOMAP structure.
 * @{
 */
#define LoaderOffsetPFunc         0 /*!< Offset to the Loader module function pointer */
#define LoaderOffsetFreeUserFlash 4 /*!< Offset to the amount of free user flash */
/** @} */  // end of LoaderIOMAP group

#define EOF -1 /*!< A constant representing end of file */
#define NULL 0 /*!< A constant representing NULL */

/** @defgroup LoaderErrors Loader module error codes
 * Error codes returned by functions in the Loader module (file access).
 * @{
 */
#define LDR_SUCCESS             0x0000 /*!< The function completed successfully. */
#define LDR_INPROGRESS          0x0001 /*!< The function is executing but has not yet completed. */
#define LDR_REQPIN              0x0002 /*!< A PIN exchange request is in progress. */
#define LDR_NOMOREHANDLES       0x8100 /*!< All available file handles are in use. */
#define LDR_NOSPACE             0x8200 /*!< Not enough free flash memory for the specified file size. */
#define LDR_NOMOREFILES         0x8300 /*!< The maximum number of files has been reached. */
#define LDR_EOFEXPECTED         0x8400 /*!< EOF expected. */
#define LDR_ENDOFFILE           0x8500 /*!< The end of the file has been reached. */
#define LDR_NOTLINEARFILE       0x8600 /*!< The specified file is not linear. */
#define LDR_FILENOTFOUND        0x8700 /*!< No files matched the search criteria. */
#define LDR_HANDLEALREADYCLOSED 0x8800 /*!< The file handle has already been closed. */
#define LDR_NOLINEARSPACE       0x8900 /*!< Not enough linear flash memory is available. */
#define LDR_UNDEFINEDERROR      0x8A00 /*!< An undefined error has occurred. */
#define LDR_FILEISBUSY          0x8B00 /*!< The file is already being used. */
#define LDR_NOWRITEBUFFERS      0x8C00 /*!< No more write buffers are available. */
#define LDR_APPENDNOTPOSSIBLE   0x8D00 /*!< Only datafiles can be appended to. */
#define LDR_FILEISFULL          0x8E00 /*!< The allocated file size has been filled. */
#define LDR_FILEEXISTS          0x8F00 /*!< A file with the same name already exists. */
#define LDR_MODULENOTFOUND      0x9000 /*!< No modules matched the specified search criteria. */
#define LDR_OUTOFBOUNDARY       0x9100 /*!< Specified IOMap offset is outside the bounds of the IOMap. */
#define LDR_ILLEGALFILENAME     0x9200 /*!< Filename length to long or attempted open a system file (*.rxe, *.rtm, or *.sys) for writing as a datafile. */
#define LDR_ILLEGALHANDLE       0x9300 /*!< Invalid file handle. */
#define LDR_BTBUSY              0x9400 /*!< The bluetooth system is busy. */
#define LDR_BTCONNECTFAIL       0x9500 /*!< Bluetooth connection attempt failed. */
#define LDR_BTTIMEOUT           0x9600 /*!< A timeout in the bluetooth system has occurred. */
#define LDR_FILETX_TIMEOUT      0x9700 /*!< Error transmitting file: a timeout occurred. */
#define LDR_FILETX_DSTEXISTS    0x9800 /*!< Error transmitting file: destination file exists. */
#define LDR_FILETX_SRCMISSING   0x9900 /*!< Error transmitting file: source file is missing. */
#define LDR_FILETX_STREAMERROR  0x9A00 /*!< Error transmitting file: a stream error occurred. */
#define LDR_FILETX_CLOSEERROR   0x9B00 /*!< Error transmitting file: attempt to close file failed. */

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
#define LDR_INVALIDSEEK         0x9C00 /*!< Invalid file seek operation. */
#endif
/** @} */  // end of LoaderErrors group

/** @defgroup LoaderFunctionConstants Loader module function constants
 * Constants defining the functions provided by the Loader module.
 * @{
 */
#define LDR_CMD_OPENREAD        0x80 /*!< Open a file for reading */
#define LDR_CMD_OPENWRITE       0x81 /*!< Open a file for writing */
#define LDR_CMD_READ            0x82 /*!< Read from a file */
#define LDR_CMD_WRITE           0x83 /*!< Write to a file */
#define LDR_CMD_CLOSE           0x84 /*!< Close a file handle */
#define LDR_CMD_DELETE          0x85 /*!< Delete a file */
#define LDR_CMD_FINDFIRST       0x86 /*!< Find the first file matching the specified pattern */
#define LDR_CMD_FINDNEXT        0x87 /*!< Find the next file matching the specified pattern */
#define LDR_CMD_VERSIONS        0x88 /*!< Read firmware version information */
#define LDR_CMD_OPENWRITELINEAR 0x89 /*!< Open a linear file for writing */
#define LDR_CMD_OPENREADLINEAR  0x8A /*!< Open a linear file for reading */
#define LDR_CMD_OPENWRITEDATA   0x8B /*!< Open a data file for writing */
#define LDR_CMD_OPENAPPENDDATA  0x8C /*!< Open a data file for appending */
#if __FIRMWARE_VERSION > 107
#define LDR_CMD_CROPDATAFILE    0x8D /*!< Crop a data file to its used space */
#endif
#define LDR_CMD_FINDFIRSTMODULE 0x90 /*!< Find the first module matching the specified pattern */
#define LDR_CMD_FINDNEXTMODULE  0x91 /*!< Find the next module matching the specified pattern */
#define LDR_CMD_CLOSEMODHANDLE  0x92 /*!< Close a module handle */
#define LDR_CMD_IOMAPREAD       0x94 /*!< Read data from a module IOMAP */
#define LDR_CMD_IOMAPWRITE      0x95 /*!< Write data to a module IOMAP */
#define LDR_CMD_BOOTCMD         0x97 /*!< Reboot the NXT into SAMBA mode */
#define LDR_CMD_SETBRICKNAME    0x98 /*!< Set the NXT's brick name */
#define LDR_CMD_BTGETADR        0x9A /*!< Get the NXT's bluetooth brick address */
#define LDR_CMD_DEVICEINFO      0x9B /*!< Read device information */
#define LDR_CMD_DELETEUSERFLASH 0xA0 /*!< Delete all files from user flash memory */
#define LDR_CMD_POLLCMDLEN      0xA1 /*!< Read poll command length */
#define LDR_CMD_POLLCMD         0xA2 /*!< Poll command */
#define LDR_CMD_RENAMEFILE      0xA3 /*!< Rename a file */
#define LDR_CMD_BTFACTORYRESET  0xA4 /*!< Reset bluetooth configuration to factory defaults */
#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
#define LDR_CMD_RESIZEDATAFILE  0xD0 /*!< Resize a data file */
#define LDR_CMD_SEEKFROMSTART   0xD1 /*!< Seek from the start of the file */
#define LDR_CMD_SEEKFROMCURRENT 0xD2 /*!< Seek from the current position */
#define LDR_CMD_SEEKFROMEND     0xD3 /*!< Seek from the end of the file */
#endif
/** @} */  // end of LoaderFunctionConstants group

/** @} */  // end of LoaderModuleConstants group
/** @} */  // end of LoaderModule group


/** @addtogroup SoundModule
 * @{
 */
/** @defgroup SoundModuleConstants Sound module constants
 * Constants that are part of the NXT firmware's Sound module.
 * @{
 */
/** @defgroup SoundFlagsConstants SoundFlags constants
 * Constants for use with the SoundFlags() function.
 * \sa SoundFlags()
 * @{
 */
#define SOUND_FLAGS_IDLE    0x00 /*!< R  - Sound is idle */
#define SOUND_FLAGS_UPDATE  0x01 /*!< W  - Make changes take effect */
#define SOUND_FLAGS_RUNNING 0x02 /*!< R  - Currently processing a tone or file */
/** @} */  // end of SoundFlagsConstants group

/** @defgroup SoundStateConstants SoundState constants
 * Constants for use with the SoundState() function.
 * \sa SoundState()
 * @{
 */
#define SOUND_STATE_IDLE 0x00 /*!< R  - Idle, ready for start sound (SOUND_UPDATE) */
#define SOUND_STATE_FILE 0x02 /*!< R  - Processing a file of sound/melody data */
#define SOUND_STATE_TONE 0x03 /*!< R  - Processing a play tone request */
#define SOUND_STATE_STOP 0x04 /*!< W  - Stop sound immediately and close hardware */
/** @} */  // end of SoundStateConstants group

/** @defgroup SoundModeConstants SoundMode constants
 * Constants for use with the SoundMode() function.
 * \sa SoundMode()
 * @{
 */
#define SOUND_MODE_ONCE 0x00 /*!< W  - Only play file once */
#define SOUND_MODE_LOOP 0x01 /*!< W  - Play file until writing SOUND_STATE_STOP into SoundState */
#define SOUND_MODE_TONE 0x02 /*!< W  - Play tone specified in Frequency for Duration ms */
/** @} */  // end of SoundModeConstants group

/** @defgroup SoundIOMAP Sound module IOMAP offsets
 * Constant offsets into the Sound module IOMAP structure.
 * @{
 */
#define SoundOffsetFreq           0 /*!< RW - Tone frequency [Hz] (2 bytes) */
#define SoundOffsetDuration       2 /*!< RW - Tone duration  [mS] (2 bytes) */
#define SoundOffsetSampleRate     4 /*!< RW - Sound file sample rate [2000..16000] (2 bytes) */
#define SoundOffsetSoundFilename  6 /*!< RW - Sound/melody filename (20 bytes) */
#define SoundOffsetFlags         26 /*!< RW - Play flag  - described above (1 byte) \ref SoundFlagsConstants */
#define SoundOffsetState         27 /*!< RW - Play state - described above (1 byte) \ref SoundStateConstants */
#define SoundOffsetMode          28 /*!< RW - Play mode  - described above (1 byte) \ref SoundModeConstants */
#define SoundOffsetVolume        29 /*!< RW - Sound/melody volume [0..4] 0 = off (1 byte) */
/** @} */  // end of SoundIOMAP group

/** @defgroup SoundMisc Sound module miscellaneous constants
 * Constants defining miscellaneous sound module aspects.
 * @{
 */
#define FREQUENCY_MIN       220       /*!< Minimum frequency [Hz] */
#define FREQUENCY_MAX       14080     /*!< Maximum frequency [Hz] */

#define SAMPLERATE_MIN      2000      /*!< Min sample rate [sps] */
#define SAMPLERATE_DEFAULT  8000      /*!< Default sample rate [sps] */
#define SAMPLERATE_MAX      16000     /*!< Max sample rate [sps] */
/** @} */  // end of SoundMisc group

/** @defgroup ToneConstants Tone constants
 * Constants for use in the  SoundPlayTone() API function.
 * \sa SoundPlayTone()
 * @{
 */
#define TONE_A3               220 /*!< Third octave A */
#define TONE_AS3              233 /*!< Third octave A sharp */
#define TONE_B3               247 /*!< Third octave B */
#define TONE_C4               262 /*!< Fourth octave C */
#define TONE_CS4              277 /*!< Fourth octave C sharp */
#define TONE_D4               294 /*!< Fourth octave D */
#define TONE_DS4              311 /*!< Fourth octave D sharp */
#define TONE_E4               330 /*!< Fourth octave E */
#define TONE_F4               349 /*!< Fourth octave F */
#define TONE_FS4              370 /*!< Fourth octave F sharp */
#define TONE_G4               392 /*!< Fourth octave G */
#define TONE_GS4              415 /*!< Fourth octave G sharp */
#define TONE_A4               440 /*!< Fourth octave A */
#define TONE_AS4              466 /*!< Fourth octave A sharp */
#define TONE_B4               494 /*!< Fourth octave B */
#define TONE_C5               523 /*!< Fifth octave C */
#define TONE_CS5              554 /*!< Fifth octave C sharp */
#define TONE_D5               587 /*!< Fifth octave D */
#define TONE_DS5              622 /*!< Fifth octave D sharp */
#define TONE_E5               659 /*!< Fifth octave E */
#define TONE_F5               698 /*!< Fifth octave F */
#define TONE_FS5              740 /*!< Fifth octave F sharp */
#define TONE_G5               784 /*!< Fifth octave G */
#define TONE_GS5              831 /*!< Fifth octave G sharp */
#define TONE_A5               880 /*!< Fifth octave A */
#define TONE_AS5              932 /*!< Fifth octave A sharp */
#define TONE_B5               988 /*!< Fifth octave B */
#define TONE_C6               1047 /*!< Sixth octave C */
#define TONE_CS6              1109 /*!< Sixth octave C sharp */
#define TONE_D6               1175 /*!< Sixth octave D */
#define TONE_DS6              1245 /*!< Sixth octave D sharp */
#define TONE_E6               1319 /*!< Sixth octave E */
#define TONE_F6               1397 /*!< Sixth octave F */
#define TONE_FS6              1480 /*!< Sixth octave F sharp */
#define TONE_G6               1568 /*!< Sixth octave G */
#define TONE_GS6              1661 /*!< Sixth octave G sharp */
#define TONE_A6               1760 /*!< Sixth octave A */
#define TONE_AS6              1865 /*!< Sixth octave A sharp */
#define TONE_B6               1976 /*!< Sixth octave B */
#define TONE_C7               2093 /*!< Seventh octave C */
#define TONE_CS7              2217 /*!< Seventh octave C sharp */
#define TONE_D7               2349 /*!< Seventh octave D */
#define TONE_DS7              2489 /*!< Seventh octave D sharp */
#define TONE_E7               2637 /*!< Seventh octave E */
#define TONE_F7               2794 /*!< Seventh octave F */
#define TONE_FS7              2960 /*!< Seventh octave F sharp */
#define TONE_G7               3136 /*!< Seventh octave G */
#define TONE_GS7              3322 /*!< Seventh octave G sharp */
#define TONE_A7               3520 /*!< Seventh octave A */
#define TONE_AS7              3729 /*!< Seventh octave A sharp */
#define TONE_B7               3951 /*!< Seventh octave B */
/** @} */  // end of ToneConstants group

/** @} */  // end of SoundModuleConstants group
/** @} */  // end of SoundModule group


/** @addtogroup ButtonModule
 * @{
 */
/** @defgroup ButtonModuleConstants Button module constants
 * Constants that are part of the NXT firmware's Button module.
 * @{
 */
/** @defgroup ButtonNameConstants Button name constants
 * Constants to specify which button to use with button module functions.
 * \sa ButtonPressed(), ButtonState(), ButtonCount(), ReadButtonEx(),
 * SysReadButton(), ReadButtonType
 * @{
 */
#define BTN1 0 /*!< The exit button. */
#define BTN2 1 /*!< The right button. */
#define BTN3 2 /*!< The left button. */
#define BTN4 3 /*!< The enter button. */

#define BTNEXIT   BTN1 /*!< The exit button. */
#define BTNRIGHT  BTN2 /*!< The right button. */
#define BTNLEFT   BTN3 /*!< The left button. */
#define BTNCENTER BTN4 /*!< The enter button. */

#define NO_OF_BTNS 4 /*!< The number of NXT buttons. */
/** @} */  // end of ButtonNameConstants group

/** @defgroup ButtonStateConstants ButtonState constants
 * Constants for use with the ButtonState() function. The _EV values can be
 * combined together using a bitwise OR operation.
 * \sa ButtonState()
 * @{
 */
#define BTNSTATE_PRESSED_EV         0x01 /*!< Button is in the pressed state. */
#define BTNSTATE_SHORT_RELEASED_EV  0x02 /*!< Button is in the short released state. */
#define BTNSTATE_LONG_PRESSED_EV    0x04 /*!< Button is in the long pressed state. */
#define BTNSTATE_LONG_RELEASED_EV   0x08 /*!< Button is in the long released state. */
#define BTNSTATE_PRESSED_STATE      0x80 /*!< A bitmask for the button pressed state */
#define BTNSTATE_NONE               0x10 /*!< The default button state. */
/** @} */  // end of ButtonStateConstants group

/** @defgroup ButtonIOMAP Button module IOMAP offsets
 * Constant offsets into the Button module IOMAP structure.
 * @{
 */
#define ButtonOffsetPressedCnt(b)   (((b)*8)+0) /*!< Offset to the PressedCnt field. This field stores the press count. */
#define ButtonOffsetLongPressCnt(b) (((b)*8)+1) /*!< Offset to the LongPressCnt field. This field stores the long press count.*/
#define ButtonOffsetShortRelCnt(b)  (((b)*8)+2) /*!< Offset to the ShortRelCnt field. This field stores the short release count. */
#define ButtonOffsetLongRelCnt(b)   (((b)*8)+3) /*!< Offset to the LongRelCnt field. This field stores the long release count. */
#define ButtonOffsetRelCnt(b)       (((b)*8)+4) /*!< Offset to the RelCnt field. This field stores the release count. */
#define ButtonOffsetState(b)        ((b)+32)    /*!< Offset to the State field. This field stores the current button state. */
/** @} */  // end of ButtonIOMAP group
/** @} */  // end of ButtonModuleConstants group
/** @} */  // end of ButtonModule group


/** @addtogroup UiModule
 * @{
 */
/** @defgroup UiModuleConstants Ui module constants
 * Constants that are part of the NXT firmware's Ui module.
 * @{
 */
/** @defgroup UiFlagsConstants CommandFlags constants
 * Constants for use with the CommandFlags() function.
 * \sa CommandFlags()
 * @{
 */
#define UI_FLAGS_UPDATE                   0x01 /*!< W  - Make changes take effect */
#define UI_FLAGS_DISABLE_LEFT_RIGHT_ENTER 0x02 /*!< RW - Disable left, right and enter button */
#define UI_FLAGS_DISABLE_EXIT             0x04 /*!< RW - Disable exit button */
#define UI_FLAGS_REDRAW_STATUS            0x08 /*!< W  - Redraw entire status line */
#define UI_FLAGS_RESET_SLEEP_TIMER        0x10 /*!< W  - Reset sleep timeout timer */
#define UI_FLAGS_EXECUTE_LMS_FILE         0x20 /*!< W  - Execute LMS file in "LMSfilename" (Try It) */
#define UI_FLAGS_BUSY                     0x40 /*!< R  - UI busy running or datalogging (popup disabled) */
#define UI_FLAGS_ENABLE_STATUS_UPDATE     0x80 /*!< W  - Enable status line to be updated */
/** @} */  // end of UiFlagsConstants group

/** @defgroup UiStateConstants UIState constants
 * Constants for use with the UIState() function.
 * \sa UIState()
 * @{
 */
#define UI_STATE_INIT_DISPLAY       0 /*!< RW - Init display and load font, menu etc. */
#define UI_STATE_INIT_LOW_BATTERY   1 /*!< R  - Low battery voltage at power on */
#define UI_STATE_INIT_INTRO         2 /*!< R  - Display intro */
#define UI_STATE_INIT_WAIT          3 /*!< RW - Wait for initialization end */
#define UI_STATE_INIT_MENU          4 /*!< RW - Init menu system */
#define UI_STATE_NEXT_MENU          5 /*!< RW - Next menu icons ready for drawing */
#define UI_STATE_DRAW_MENU          6 /*!< RW - Execute function and draw menu icons */
#define UI_STATE_TEST_BUTTONS       7 /*!< RW - Wait for buttons to be pressed */
#define UI_STATE_LEFT_PRESSED       8 /*!< RW - Load selected function and next menu id */
#define UI_STATE_RIGHT_PRESSED      9 /*!< RW - Load selected function and next menu id */
#define UI_STATE_ENTER_PRESSED     10 /*!< RW - Load selected function and next menu id */
#define UI_STATE_EXIT_PRESSED      11 /*!< RW - Load selected function and next menu id */
#define UI_STATE_CONNECT_REQUEST   12 /*!< RW - Request for connection accept */
#define UI_STATE_EXECUTE_FILE      13 /*!< RW - Execute file in "LMSfilename" */
#define UI_STATE_EXECUTING_FILE    14 /*!< R  - Executing file in "LMSfilename" */
#define UI_STATE_LOW_BATTERY       15 /*!< R  - Low battery at runtime */
#define UI_STATE_BT_ERROR          16 /*!< R  - BT error */
/** @} */  // end of UiStateConstants group

/** @defgroup UiButtonConstants UIButton constants
 * Constants for use with the UIButton() function.
 * \sa UIButton()
 * @{
 */
#define UI_BUTTON_NONE             0 /*!< R  - Button inserted are executed */
#define UI_BUTTON_LEFT             1 /*!< W  - Insert left arrow button */
#define UI_BUTTON_ENTER            2 /*!< W  - Insert enter button */
#define UI_BUTTON_RIGHT            3 /*!< W  - Insert right arrow button */
#define UI_BUTTON_EXIT             4 /*!< W  - Insert exit button */
/** @} */  // end of UiButtonConstants group

/** @defgroup UiBluetoothStateConstants BluetoothState constants
 * Constants for use with the BluetoothState() function.
 * \sa BluetoothState()
 * @{
 */
#define UI_BT_STATE_VISIBLE        0x01 /*!< RW - BT visible */
#define UI_BT_STATE_CONNECTED      0x02 /*!< RW - BT connected to something */
#define UI_BT_STATE_OFF            0x04 /*!< RW - BT power off */
#define UI_BT_ERROR_ATTENTION      0x08 /*!< W  - BT error attention */
#define UI_BT_CONNECT_REQUEST      0x40 /*!< RW - BT get connect accept in progress */
#define UI_BT_PIN_REQUEST          0x80 /*!< RW - BT get pin code */
/** @} */  // end of UiBluetoothStateConstants group

/** @defgroup UiVMRunStateConstants VM run state constants
 * Constants for use with the VMRunState() function.
 * \sa VMRunState()
 * @{
 */
#define UI_VM_IDLE        0 /*!< VM_IDLE: Just sitting around.  Request to run program will lead to ONE of the VM_RUN* states. */
#define UI_VM_RUN_FREE    1 /*!< VM_RUN_FREE: Attempt to run as many instructions as possible within our timeslice */
#define UI_VM_RUN_SINGLE  2 /*!< VM_RUN_SINGLE: Run exactly one instruction per timeslice */
#define UI_VM_RUN_PAUSE   3 /*!< VM_RUN_PAUSE: Program still "active", but someone has asked us to pause */
#define UI_VM_RESET1      4 /*!< VM_RESET1: Initialize state variables and some I/O devices -- executed when programs end */
#define UI_VM_RESET2      5 /*!< VM_RESET2: Final clean up and return to IDLE */
/** @} */  // end of UiVMRunStateConstants group

/** @defgroup UiIOMAP Ui module IOMAP offsets
 * Constant offsets into the Ui module IOMAP structure.
 * @{
 */
#define UIOffsetPMenu            0 /*!< W  - Pointer to menu file (4 bytes) */
#define UIOffsetBatteryVoltage   4 /*!< R  - Battery voltage in millivolts (2 bytes) */
#define UIOffsetLMSfilename      6 /*!< W  - LMS filename to execute (Try It) (20 bytes) */
#define UIOffsetFlags           26 /*!< RW - Update command flags  (flags enumerated above) (1 byte) */
#define UIOffsetState           27 /*!< RW - UI state              (states enumerated above) (1 byte) */
#define UIOffsetButton          28 /*!< RW - Insert button         (buttons enumerated above) (1 byte) */
#define UIOffsetRunState        29 /*!< W  - VM Run state          (0 = stopped, 1 = running) (1 byte) */
#define UIOffsetBatteryState    30 /*!< W  - Battery state         (0..4 capacity) (1 byte) */
#define UIOffsetBluetoothState  31 /*!< W  - Bluetooth state       (0=on, 1=visible, 2=conn, 3=conn.visible, 4=off, 5=dfu) (1 byte) */
#define UIOffsetUsbState        32 /*!< W  - Usb state             (0=disconnected, 1=connected, 2=working) (1 byte) */
#define UIOffsetSleepTimeout    33 /*!< RW - Sleep timeout time    (min) (1 byte) */
#define UIOffsetSleepTimer      34 /*!< RW - Sleep timer           (min) (1 byte) */
#define UIOffsetRechargeable    35 /*!< R  - Rechargeable battery  (0 = no, 1 = yes) (1 byte) */
#define UIOffsetVolume          36 /*!< RW - Volume used in UI     (0 - 4) (1 byte) */
#define UIOffsetError           37 /*!< W  - Error code (1 byte) */
#define UIOffsetOBPPointer      38 /*!< W  - Actual OBP step       (0 - 4) (1 byte) */
#define UIOffsetForceOff        39 /*!< W  - Force off             (> 0 = off) (1 byte) */
#define UIOffsetAbortFlag       40 /*!< RW - Long Abort            (true == use long press to abort) (1 byte) */
/** @} */  // end of UiIOMAP group

/** @} */  // end of UiModuleConstants group
/** @} */  // end of UiModule group


/** @addtogroup InputModule
 * @{
 */
/** @addtogroup InputModuleConstants
 * @{
 */

/** @defgroup NBCInputPortConstants NBC Input port constants
 * Input port constants are used when calling sensor control API functions.
 * These constants are intended for use in NBC.
 * \sa SetSensorType(), SetSensorMode(), S1, S2, S3, S4
 * @{
 */
#define IN_1 0x00 /*!< Input port 1 */
#define IN_2 0x01 /*!< Input port 2 */
#define IN_3 0x02 /*!< Input port 3 */
#define IN_4 0x03 /*!< Input port 4 */
/** @} */  // end of InputPortConstants group

/** @addtogroup InputModuleTypesAndModes
 * @{
 */
/** @defgroup NBCSensorTypeConstants NBC sensor type constants
 * Use sensor type constants to configure an input port for a specific type
 * of sensor. These constants are intended for use in NBC.
 * \sa SetSensorType()
 * @{
 */
#define IN_TYPE_NO_SENSOR      0x00 /*!< No sensor configured */
#define IN_TYPE_SWITCH         0x01 /*!< NXT or RCX touch sensor */
#define IN_TYPE_TEMPERATURE    0x02 /*!< RCX temperature sensor */
#define IN_TYPE_REFLECTION     0x03 /*!< RCX light sensor */
#define IN_TYPE_ANGLE          0x04 /*!< RCX rotation sensor */
#define IN_TYPE_LIGHT_ACTIVE   0x05 /*!< NXT light sensor with light */
#define IN_TYPE_LIGHT_INACTIVE 0x06 /*!< NXT light sensor without light */
#define IN_TYPE_SOUND_DB       0x07 /*!< NXT sound sensor with dB scaling */
#define IN_TYPE_SOUND_DBA      0x08 /*!< NXT sound sensor with dBA scaling */
#define IN_TYPE_CUSTOM         0x09 /*!< NXT custom sensor */
#define IN_TYPE_LOWSPEED       0x0A /*!< NXT I2C digital sensor */
#define IN_TYPE_LOWSPEED_9V    0x0B /*!< NXT I2C digital sensor with 9V power */
#define IN_TYPE_HISPEED        0x0C /*!< NXT Hi-speed port (only S4) */
#if __FIRMWARE_VERSION > 107
#define IN_TYPE_COLORFULL      0x0D /*!< NXT 2.0 color sensor in full color mode */
#define IN_TYPE_COLORRED       0x0E /*!< NXT 2.0 color sensor with red light */
#define IN_TYPE_COLORGREEN     0x0F /*!< NXT 2.0 color sensor with green light */
#define IN_TYPE_COLORBLUE      0x10 /*!< NXT 2.0 color sensor with blue light */
#define IN_TYPE_COLORNONE      0x11 /*!< NXT 2.0 color sensor with no light */
#define IN_TYPE_COLOREXIT      0x12 /*!< NXT 2.0 color sensor internal state */
#endif
/** @} */  // end of NBCSensorTypeConstants group

/** @defgroup NBCSensorModeConstants NBC sensor mode constants
 * Use sensor mode constants to configure an input port for the desired
 * sensor mode. The constants are intended for use in NBC.
 * \sa SetSensorMode()
 * @{
 */
#define IN_MODE_RAW           0x00 /*!< Raw value from 0 to 1023 */
#define IN_MODE_BOOLEAN       0x20 /*!< Boolean value (0 or 1) */
#define IN_MODE_TRANSITIONCNT 0x40 /*!< Counts the number of boolean transitions */
#define IN_MODE_PERIODCOUNTER 0x60 /*!< Counts the number of boolean periods */
#define IN_MODE_PCTFULLSCALE  0x80 /*!< Scaled value from 0 to 100 */
#define IN_MODE_CELSIUS       0xA0 /*!< RCX temperature sensor value in degrees celcius */
#define IN_MODE_FAHRENHEIT    0xC0 /*!< RCX temperature sensor value in degrees fahrenheit */
#define IN_MODE_ANGLESTEP     0xE0 /*!< RCX rotation sensor (16 ticks per revolution) */
#define IN_MODE_SLOPEMASK     0x1F /*!< Mask for slope parameter added to mode */
#define IN_MODE_MODEMASK      0xE0 /*!< Mask for the mode without any slope value */
/** @} */  // end of NBCSensorModeConstants group
/** @} */  // end of InputModuleTypesAndModes group

/** @defgroup InputFieldConstants Input field constants
 * Constants for use with SetInput() and GetInput().
 * Each sensor has six fields that are used to define its state.
 * @{
 */
#define TypeField            0 /*!< Type field. Contains one of the sensor type constants. Read/write. */
#define InputModeField       1 /*!< Input mode field. Contains one of the sensor mode constants. Read/write. */
#define RawValueField        2 /*!< Raw value field. Contains the current raw analog sensor value. Read only. */
#define NormalizedValueField 3 /*!< Normalized value field. Contains the current normalized analog sensor value. Read only. */
#define ScaledValueField     4 /*!< Scaled value field. Contains the current scaled analog sensor value. Read/write. */
#define InvalidDataField     5 /*!< Invalid data field. Contains a boolean value indicating whether the sensor data is valid or not. Read/write. */
/** @} */  // end of InputFieldConstants group

/** @defgroup InputDigiPinConstants Input port digital pin constants
 * Constants for use when directly controlling or reading a port's digital pin
 * state.
 * @{
 */
#define INPUT_DIGI0    0x01 /*!< Digital pin 0 */
#define INPUT_DIGI1    0x02 /*!< Digital pin 1*/
/** @} */  // end of InputDigiPinConstants group

#define INPUT_CUSTOMINACTIVE 0x00 /*!< Custom sensor inactive */
#define INPUT_CUSTOM9V       0x01 /*!< Custom sensor 9V */
#define INPUT_CUSTOMACTIVE   0x02 /*!< Custom sensor active */

#define INPUT_INVALID_DATA   0x01 /*!< Invalid data flag */

#if __FIRMWARE_VERSION > 107

/** @defgroup InputColorIdxConstants Color sensor array indices
 * Constants for use with color sensor value arrays to index RGB and blank
 * return values.
 * \sa ReadSensorColorEx(), ReadSensorColorRaw(), SysColorSensorRead(),
 * ColorSensorReadType
 * @{
 */
#define INPUT_RED          0 /*!< Access the red value from color sensor value arrays */
#define INPUT_GREEN        1 /*!< Access the green value from color sensor value arrays */
#define INPUT_BLUE         2 /*!< Access the blue value from color sensor value arrays */
#define INPUT_BLANK        3 /*!< Access the blank value from color sensor value arrays */
#define INPUT_NO_OF_COLORS 4 /*!< The number of entries in the color sensor value arrays */
/** @} */  // end of InputColorIdxConstants group

/** @defgroup InputColorValueConstants Color values
 * Constants for use with the ColorValue returned by the color sensor in full
 * color mode.
 * \sa SensorValue(), SysColorSensorRead(), ColorSensorReadType
 * @{
 */
#define INPUT_BLACKCOLOR  1 /*!< The color value is black */
#define INPUT_BLUECOLOR   2 /*!< The color value is blue */
#define INPUT_GREENCOLOR  3 /*!< The color value is green */
#define INPUT_YELLOWCOLOR 4 /*!< The color value is yellow */
#define INPUT_REDCOLOR    5 /*!< The color value is red */
#define INPUT_WHITECOLOR  6 /*!< The color value is white */
/** @} */  // end of InputColorIdxConstants group

/** @defgroup InputColorCalibrationStateConstants Color calibration state constants
 * Constants for use with the color calibration state function.
 * \sa ColorCalibrationState()
 * @{
 */
#define INPUT_SENSORCAL  0x01 /*!< The state returned while the color sensor is calibrating */
#define INPUT_SENSOROFF  0x02 /*!< The state returned once calibration has completed */
#define INPUT_RUNNINGCAL 0x20 /*!< Unused calibration state constant */
#define INPUT_STARTCAL   0x40 /*!< Unused calibration state constant */
#define INPUT_RESETCAL   0x80 /*!< Unused calibration state constant */
/** @} */  // end of InputColorCalibrationStateConstants group

/** @defgroup InputColorCalibrationConstants Color calibration constants
 * Constants for use with the color calibration functions.
 * \sa ColorCalibration(), ColorCalLimits()
 * @{
 */
#define INPUT_CAL_POINT_0  0 /*!< Calibration point 0 */
#define INPUT_CAL_POINT_1  1 /*!< Calibration point 1 */
#define INPUT_CAL_POINT_2  2 /*!< Calibration point 2 */
#define INPUT_NO_OF_POINTS 3 /*!< The number of calibration points */
/** @} */  // end of InputColorCalibrationConstants group

#endif

/** @defgroup InputIOMAP Input module IOMAP offsets
 * Constant offsets into the Input module IOMAP structure.
 * @{
 */
#define InputOffsetCustomZeroOffset(p)   (((p)*20)+0)  /*!< Read/write the zero offset of a custom sensor (2 bytes) uword */
#define InputOffsetADRaw(p)              (((p)*20)+2)  /*!< Read the AD raw sensor value (2 bytes) uword */
#define InputOffsetSensorRaw(p)          (((p)*20)+4)  /*!< Read the raw sensor value (2 bytes) uword */
#define InputOffsetSensorValue(p)        (((p)*20)+6)  /*!< Read/write the scaled sensor value (2 bytes) sword */
#define InputOffsetSensorType(p)         (((p)*20)+8)  /*!< Read/write the sensor type */
#define InputOffsetSensorMode(p)         (((p)*20)+9)  /*!< Read/write the sensor mode */
#define InputOffsetSensorBoolean(p)      (((p)*20)+10) /*!< Read the sensor boolean value */
#define InputOffsetDigiPinsDir(p)        (((p)*20)+11) /*!< Read/write the direction of the Digital pins (1 is output, 0 is input) */
#define InputOffsetDigiPinsIn(p)         (((p)*20)+12) /*!< Read/write the status of the digital pins */
#define InputOffsetDigiPinsOut(p)        (((p)*20)+13) /*!< Read/write the output level of the digital pins */
#define InputOffsetCustomPctFullScale(p) (((p)*20)+14) /*!< Read/write the Pct full scale of the custom sensor */
#define InputOffsetCustomActiveStatus(p) (((p)*20)+15) /*!< Read/write the active or inactive state of the custom sensor */
#define InputOffsetInvalidData(p)        (((p)*20)+16) /*!< Indicates whether data is invalid (1) or valid (0) */

#if __FIRMWARE_VERSION > 107
#define InputOffsetColorCalibration(p, np, nc) (80+((p)*84)+0+((np)*16)+((nc)*4)) /*!< Read/write color calibration point values */
#define InputOffsetColorCalLimits(p, np)       (80+((p)*84)+48+((np)*2)) /*!< Read/write color calibration limits */
#define InputOffsetColorADRaw(p, nc)           (80+((p)*84)+52+((nc)*2)) /*!< Read AD raw color sensor values */
#define InputOffsetColorSensorRaw(p, nc)       (80+((p)*84)+60+((nc)*2)) /*!< Read raw color sensor values */
#define InputOffsetColorSensorValue(p, nc)     (80+((p)*84)+68+((nc)*2)) /*!< Read scaled color sensor values */
#define InputOffsetColorBoolean(p, nc)         (80+((p)*84)+76+((nc)*2)) /*!< Read color sensor boolean values */
#define InputOffsetColorCalibrationState(p)    (80+((p)*84)+80)          /*!< Read color sensor calibration state */
#endif
/** @} */  // end of InputIOMap group


#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/** @defgroup InputPinFuncConstants Constants to use with the Input module's Pin function
 * Constants for use with the Input module's Pin function.  These are the commands
 * that you can pass into the pin function to change digital pin directions,
 * set or clear pins, or read pin values. Also in this group are mask constants
 * and a macro for ORing a microsecond wait onto the command byte which will
 * occur after the command has been executed.
 * @{
 */
#define INPUT_PINCMD_DIR    0x00 /*!< Set digital pin(s) direction */
#define INPUT_PINCMD_SET    0x01 /*!< Set digital pin(s) */
#define INPUT_PINCMD_CLEAR  0x02 /*!< Clear digital pin(s) */
#define INPUT_PINCMD_READ   0x03 /*!< Read digital pin(s) */
#define INPUT_PINCMD_MASK   0x03 /*!< Mask for the two bits used by pin function commands */
#define INPUT_PINCMD_WAIT(_usec) ((_usec)<<2) /*!< A wait value in microseconds that can be added after one of the above commands by ORing with the command */
#define INPUT_PINDIR_OUTPUT 0x00 /*!< Use with the direction command to set direction to input.  OR this with the pin value. */
#define INPUT_PINDIR_INPUT  0x04 /*!< Use with the direction command to set direction to output.  OR this with the pin value. */
/** @} */  // end of InputPinFuncCmdConstants group
#endif

/** @} */  // end of InputModuleConstants group
/** @} */  // end of InputModule group


/** @addtogroup OutputModule
 * @{
 */
/** @addtogroup OutputModuleConstants
 * @{
 */
/** @defgroup OutputPortConstants Output port constants
 * Output port constants are used when calling motor control API functions.
 * @{
 */
#define OUT_A   0x00 /*!< Output port A */
#define OUT_B   0x01 /*!< Output port B */
#define OUT_C   0x02 /*!< Output port C */
#define OUT_AB  0x03 /*!< Output ports A and B */
#define OUT_AC  0x04 /*!< Output ports A and C */
#define OUT_BC  0x05 /*!< Output ports B and C */
#define OUT_ABC 0x06 /*!< Output ports A, B, and C */
/** @} */  // end of OutputPortConstants group

/** @defgroup PIDConstants PID constants
 * PID constants are for adjusting the Proportional, Integral, and Derivative
 * motor controller parameters.
 * \sa RotateMotorExPID(), RotateMotorPID(), OnFwdExPID(), OnRevExPID(),
 * \sa OnFwdRegExPID(), OnRevRegExPID(), OnFwdRegPID(), OnRevRegPID(),
 * \sa OnFwdSyncExPID(), OnRevSyncExPID(), OnFwdSyncPID(), OnRevSyncPID()
 * @{
 */
#define PID_0   0 /*!< PID zero */
#define PID_1  32 /*!< PID one */
#define PID_2  64 /*!< PID two */
#define PID_3  96 /*!< PID three */
#define PID_4 128 /*!< PID four */
#define PID_5 160 /*!< PID five */
#define PID_6 192 /*!< PID six */
#define PID_7 224 /*!< PID seven */
/** @} */  // end of PIDConstants group

/** @defgroup OutUFConstants Output port update flag constants
 * Use these constants to specify which motor values need to be updated.
 * Update flag constants can be combined with bitwise OR.
 * \sa SetOutput()
 * @{
 */
#define UF_UPDATE_MODE                 0x01 /*!< Commits changes to the \ref OutputModeField output property */
#define UF_UPDATE_SPEED                0x02 /*!< Commits changes to the \ref PowerField output property */
#define UF_UPDATE_TACHO_LIMIT          0x04 /*!< Commits changes to the \ref TachoLimitField output property */
#define UF_UPDATE_RESET_COUNT          0x08 /*!< Resets all rotation counters, cancels the current goal, and resets the rotation error-correction system */
#define UF_UPDATE_PID_VALUES           0x10 /*!< Commits changes to the PID motor regulation properties */
#define UF_UPDATE_RESET_BLOCK_COUNT    0x20 /*!< Resets the NXT-G block-relative rotation counter */
#define UF_UPDATE_RESET_ROTATION_COUNT 0x40 /*!< Resets the program-relative (user) rotation counter */
#define UF_PENDING_UPDATES             0x80 /*!< Are there any pending motor updates? */
/** @} */  // end of OutUFConstants group

/** @defgroup TachoResetConstants Tachometer counter reset flags
 * Use these constants to specify which of the three tachometer counters
 * should be reset. Reset constants can be combined with bitwise OR.
 * \sa OnFwdEx(), OnRevEx(), etc...
 * @{
 */
#define RESET_NONE           0x00 /*!< No counters will be reset */
#define RESET_COUNT          0x08 /*!< Reset the internal tachometer counter */
#define RESET_BLOCK_COUNT    0x20 /*!< Reset the NXT-G block tachometer counter */
#define RESET_ROTATION_COUNT 0x40 /*!< Reset the rotation counter */
#define RESET_BLOCKANDTACHO  0x28 /*!< Reset both the internal counter and the NXT-G block counter */
#define RESET_ALL            0x68 /*!< Reset all three tachometer counters */
/** @} */  // end of TachoResetConstants group

/** @defgroup OutModeConstants Output port mode constants
 * Use these constants to configure the desired mode for the
 * specified motor(s): coast, motoron, brake, or regulated. Mode constants
 * can be combined with bitwise OR.
 * \sa SetOutput()
 * @{
 */
#define OUT_MODE_COAST     0x00 /*!< No power and no braking so motors rotate freely. */
#define OUT_MODE_MOTORON   0x01 /*!< Enables PWM power to the outputs given the power setting */
#define OUT_MODE_BRAKE     0x02 /*!< Uses electronic braking to outputs */
#define OUT_MODE_REGULATED 0x04 /*!< Enables active power regulation using the regulation mode value */
#define OUT_MODE_REGMETHOD 0xF0 /*!< Mask for unimplemented regulation mode */
/** @} */  // end of OutModeConstants group

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/** @defgroup OutOptionConstants Output port option constants
 * Use these constants to configure the desired options for the
 * specified motor(s): hold at limit and ramp down to limit. Option constants
 * can be combined with bitwise OR.
 * \sa SetOutput()
 * @{
 */
#define OUT_OPTION_HOLDATLIMIT     0x10 /*!< Option to have the firmware hold the motor when it reaches the tachometer limit */
#define OUT_OPTION_RAMPDOWNTOLIMIT 0x20 /*!< Option to have the firmware rampdown the motor power as it approaches the tachometer limit */
/** @} */  // end of OutOptionConstants group

/** @defgroup OutRegOptionConstants Output regulation option constants
 * Use these constants to configure the desired options for
 * position regulation.
 * @{
 */
#define OUT_REGOPTION_NO_SATURATION 0x01 /*!< Do not limit intermediary regulation results */
/** @} */  // end of OutRegOptionConstants group
#endif

/** @defgroup OutRunStateConstants Output port run state constants
 * Use these constants to configure the desired run state for the
 * specified motor(s): idle, rampup, running, rampdown, or hold.
 * \sa SetOutput()
 * @{
 */
#define OUT_RUNSTATE_IDLE     0x00 /*!< Disable all power to motors. */
#define OUT_RUNSTATE_RAMPUP   0x10 /*!< Enable ramping up from a current power to a new (higher) power over a specified \ref TachoLimitField goal. */
#define OUT_RUNSTATE_RUNNING  0x20 /*!< Enable power to motors at the specified power level. */
#define OUT_RUNSTATE_RAMPDOWN 0x40 /*!< Enable ramping down from a current power to a new (lower) power over a specified \ref TachoLimitField goal. */
#define OUT_RUNSTATE_HOLD     0x60 /*!< Set motor run state to hold at the current position. */
/** @} */  // end of OutRunStateConstants group

/** @defgroup OutRegModeConstants Output port regulation mode constants
 * Use these constants to configure the desired regulation mode for the
 * specified motor(s): none, speed regulation, multi-motor synchronization,
 * or position regulation (requires the enhanced NBC/NXC firmware version 1.31+).
 * \sa SetOutput()
 * @{
 */
#define OUT_REGMODE_IDLE  0 /*!< No motor regulation. */
#define OUT_REGMODE_SPEED 1 /*!< Regulate a motor's speed (aka power). */
#define OUT_REGMODE_SYNC  2 /*!< Synchronize the rotation of two motors. */
#define OUT_REGMODE_POS   4 /*!< Regulate a motor's position. */
/** @} */  // end of OutRegModeConstants group

/** @defgroup OutputFieldConstants Output field constants
 * Constants for use with SetOutput() and GetOutput().
 * \sa SetOutput(), GetOutput()
 * @{
 */
/** Update flags field. Contains a combination of the update flag constants. Read/write.
 *  Use \ref UF_UPDATE_MODE, \ref UF_UPDATE_SPEED, \ref UF_UPDATE_TACHO_LIMIT, and \ref UF_UPDATE_PID_VALUES
 *  along with other fields to commit changes to the state of outputs. Set the appropriate
 *  flags after setting one or more of the output fields in order for the changes to actually
 *  go into affect. */
#define UpdateFlagsField     0
/** Mode field. Contains a combination of the output mode constants. Read/write.
 *  The \ref OUT_MODE_MOTORON bit must be set in order for power to be applied to the motors.
 *  Add \ref OUT_MODE_BRAKE to enable electronic braking. Braking means that the output voltage
 *  is not allowed to float between active PWM pulses. It improves the accuracy of motor
 *  output but uses more battery power.
 *  To use motor regulation include \ref OUT_MODE_REGULATED in the \ref OutputModeField value. Use
 *  \ref UF_UPDATE_MODE with \ref UpdateFlagsField to commit changes to this field. */
#define OutputModeField      1
/** Power field. Contains the desired power level (-100 to 100). Read/write.
 *  Specify the power level of the output. The absolute value of PowerField is a percentage of the
 *  full power of the motor. The sign of PowerField controls the rotation direction. Positive values
 *  tell the firmware to turn the motor forward, while negative values turn the motor backward.
 *  Use \ref UF_UPDATE_SPEED with \ref UpdateFlagsField to commit changes to this field. */
#define PowerField           2
/** Actual speed field. Contains the actual power level (-100 to 100). Read only.
 *  Return the percent of full power the firmware is applying to the output. This may vary from the
 *  PowerField value when auto-regulation code in the firmware responds to a load on the output. */
#define ActualSpeedField     3
/** Internal tachometer count field. Contains the current internal tachometer count. Read only.
 *  Return the internal position counter value for the specified output. The internal count is reset
 *  automatically when a new goal is set using the \ref TachoLimitField and the \ref UF_UPDATE_TACHO_LIMIT flag.
 *  Set the \ref UF_UPDATE_RESET_COUNT flag in \ref UpdateFlagsField to reset TachoCountField and cancel any \ref TachoLimitField.
 *  The sign of TachoCountField indicates the motor rotation direction. */
#define TachoCountField      4
/** Tachometer limit field. Contains the current tachometer limit. Read/write.
 *  Specify the number of degrees the motor should rotate.
 *  Use \ref UF_UPDATE_TACHO_LIMIT with the \ref UpdateFlagsField field to commit changes to the TachoLimitField.
 *  The value of this field is a relative distance from the current motor position at the moment when
 *  the \ref UF_UPDATE_TACHO_LIMIT flag is processed. */
#define TachoLimitField      5
/** Run state field. Contains one of the run state constants. Read/write.
 *  Use this field to specify the running state of an output. Set the RunStateField to \ref OUT_RUNSTATE_RUNNING
 *  to enable power to any output. Use \ref OUT_RUNSTATE_RAMPUP to enable automatic ramping to a new \ref PowerField
 *  level greater than the current \ref PowerField level. Use \ref OUT_RUNSTATE_RAMPDOWN to enable automatic ramping
 *  to a new \ref PowerField level less than the current \ref PowerField level.
 *  Both the rampup and rampdown bits must be used in conjunction with appropriate \ref TachoLimitField and \ref PowerField
 *  values. In this case the firmware smoothly increases or decreases the actual power to the new \ref PowerField
 *  level over the total number of degrees of rotation specified in \ref TachoLimitField. */
#define RunStateField        6
/** Turn ratio field. Contains the current turn ratio. Only applicable when synchronizing multiple motors. Read/write.
 *  Use this field to specify a proportional turning ratio. This field must be used in conjunction with other
 *  field values: \ref OutputModeField must include \ref OUT_MODE_MOTORON and \ref OUT_MODE_REGULATED, \ref RegModeField must be set to
 *  \ref OUT_REGMODE_SYNC, \ref RunStateField must not be \ref OUT_RUNSTATE_IDLE, and \ref PowerField must be non-zero.
 *  There are only three valid combinations of left and right motors for use with TurnRatioField: \ref OUT_AB, \ref OUT_BC,
 *  and \ref OUT_AC. In each of these three options the first motor listed is considered to be the left motor and
 *  the second motor is the right motor, regardless of the physical configuration of the robot.
 *  Negative turn ratio values shift power toward the left motor while positive values shift power toward the
 *  right motor. An absolute value of 50 usually results in one motor stopping. An absolute value of 100 usually
 *  results in two motors turning in opposite directions at equal power. */
#define TurnRatioField       7
/** Regulation mode field. Contains one of the regulation mode constants. Read/write.
 *  This field specifies the regulation mode to use with the specified port(s). It is ignored if
 *  the \ref OUT_MODE_REGULATED bit is not set in the \ref OutputModeField field. Unlike \ref OutputModeField, RegModeField is
 *  not a bitfield. Only one regulation mode value can be set at a time.
 *  Speed regulation means that the firmware tries to maintain a certain speed based on the \ref PowerField setting. The
 *  firmware adjusts the PWM duty cycle if the motor is affected by a physical load. This adjustment is
 *  reflected by the value of the \ref ActualSpeedField property. When using speed regulation, do not set \ref PowerField to its
 *  maximum value since the firmware cannot adjust to higher power levels in that situation.
 *  Synchronization means the firmware tries to keep two motors in sync regardless of physical loads. Use
 *  this mode to maintain a straight path for a mobile robot automatically. Also use this mode with the
 *  \ref TurnRatioField property to provide proportional turning.
 *  Set \ref OUT_REGMODE_SYNC on at least two motor ports in order for synchronization to function. Setting
 *  \ref OUT_REGMODE_SYNC on all three motor ports will result in only the first two (\ref OUT_A and \ref OUT_B) being
 *  synchronized. */
#define RegModeField         8
/** Overload field. Contains a boolean value which is TRUE if the motor is overloaded. Read only.
 *  This field will have a value of 1 (true) if the firmware speed regulation cannot overcome a physical
 *  load on the motor. In other words, the motor is turning more slowly than expected.
 *  If the motor speed can be maintained in spite of loading then this field value is zero (false).
 *  In order to use this field the motor must have a non-idle \ref RunStateField, an \ref OutputModeField which includes
 *  \ref OUT_MODE_MOTORON and \ref OUT_MODE_REGULATED, and its \ref RegModeField must be set to \ref OUT_REGMODE_SPEED. */
#define OverloadField        9
/** Proportional field. Contains the proportional constant for the PID motor controller. Read/write.
 *  This field specifies the proportional term used in the internal proportional-integral-derivative
 *  (PID) control algorithm.
 *  Set \ref UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously. */
#define RegPValueField       10
/** Integral field. Contains the integral constant for the PID motor controller. Read/write.
 *  This field specifies the integral term used in the internal proportional-integral-derivative
 *  (PID) control algorithm.
 *  Set \ref UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously. */
#define RegIValueField       11
/** Derivative field. Contains the derivative constant for the PID motor controller. Read/write.
 *  This field specifies the derivative term used in the internal proportional-integral-derivative
 *  (PID) control algorithm.
 *  Set \ref UF_UPDATE_PID_VALUES to commit changes to RegPValue, RegIValue, and RegDValue simultaneously. */
#define RegDValueField       12
/** NXT-G block tachometer count field. Contains the current NXT-G block tachometer count. Read only.
 *  Return the block-relative position counter value for the specified port.
 *  Refer to the \ref UpdateFlagsField description for information about how to use block-relative
 *  position counts.
 *  Set the \ref UF_UPDATE_RESET_BLOCK_COUNT flag in \ref UpdateFlagsField to request that the firmware
 *  reset the BlockTachoCountField.
 *  The sign of BlockTachoCountField indicates the direction of rotation. Positive values indicate
 *  forward rotation and negative values indicate reverse rotation. Forward and reverse depend on
 *  the orientation of the motor. */
#define BlockTachoCountField 13
/** Rotation counter field. Contains the current rotation count. Read only.
 *  Return the program-relative position counter value for the specified port.
 *  Refer to the \ref UpdateFlagsField description for information about how to use program-relative
 *  position counts.
 *  Set the \ref UF_UPDATE_RESET_ROTATION_COUNT flag in \ref UpdateFlagsField to request that the firmware reset
 *  the RotationCountField.
 *  The sign of RotationCountField indicates the direction of rotation. Positive values indicate forward
 *  rotation and negative values indicate reverse rotation. Forward and reverse depend on the
 *  orientation of the motor. */
#define RotationCountField   14
#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/** Options field. Contains a combination of the output options constants. Read/write.
 *  Set options for how the output module will act when a tachometer limit is reached. Option
 *  constants can be combined with bitwise OR.  Use OUT_OPTION_HOLDATLIMIT to have the output
 *  module hold the motor when it reaches the tachometer limit.  Use OUT_OPTION_RAMPDOWNTOLIMIT
 *  to have the output module ramp down the motor power as it approaches the tachometer limit.
 */
#define OutputOptionsField   15
/** MaxSpeed field. Contains the current max speed value. Read/write.
 *  Set the maximum speed to be used during position regulation.
 */
#define MaxSpeedField   16
/** MaxAcceleration field. Contains the current max acceleration value. Read/write.
 *  Set the maximum acceleration to be used during position regulation.
 */
#define MaxAccelerationField   17
#endif
/** @} */  // end of OutputFieldConstants group

/** @defgroup OutputIOMAP Output module IOMAP offsets
 * Constant offsets into the Output module IOMAP structure.
 * @{
 */
#define OutputOffsetTachoCount(p)        (((p)*32)+0)  /*!< R  - Holds current number of counts, since last reset, updated every 1 mS (4 bytes) slong */
#define OutputOffsetBlockTachoCount(p)   (((p)*32)+4)  /*!< R  - Holds current number of counts for the current output block (4 bytes) slong */
#define OutputOffsetRotationCount(p)     (((p)*32)+8)  /*!< R  - Holds current number of counts for the rotation counter to the output (4 bytes) slong */
#define OutputOffsetTachoLimit(p)        (((p)*32)+12) /*!< RW - Holds number of counts to travel, 0 => Run forever (4 bytes) ulong */
#define OutputOffsetMotorRPM(p)          (((p)*32)+16) /*!< Not updated, will be removed later !! (2 bytes) sword */
#define OutputOffsetFlags(p)             (((p)*32)+18) /*!< RW - Holds flags for which data should be updated (1 byte) ubyte */
#define OutputOffsetMode(p)              (((p)*32)+19) /*!< RW - Holds motor mode: Run, Break, regulated, ... (1 byte) ubyte */
#define OutputOffsetSpeed(p)             (((p)*32)+20) /*!< RW - Holds the wanted speed (1 byte) sbyte */
#define OutputOffsetActualSpeed(p)       (((p)*32)+21) /*!< R  - Holds the current motor speed (1 byte) sbyte */
#define OutputOffsetRegPParameter(p)     (((p)*32)+22) /*!< RW - Holds the P-constant used in the regulation (1 byte) ubyte */
#define OutputOffsetRegIParameter(p)     (((p)*32)+23) /*!< RW - Holds the I-constant used in the regulation (1 byte) ubyte */
#define OutputOffsetRegDParameter(p)     (((p)*32)+24) /*!< RW - Holds the D-constant used in the regulation (1 byte) ubyte */
#define OutputOffsetRunState(p)          (((p)*32)+25) /*!< RW - Holds the current motor run state in the output module (1 byte) ubyte */
#define OutputOffsetRegMode(p)           (((p)*32)+26) /*!< RW - Tells which regulation mode should be used (1 byte) ubyte */
#define OutputOffsetOverloaded(p)        (((p)*32)+27) /*!< R  - True if the motor has been overloaded within speed control regulation (1 byte) ubyte */
#define OutputOffsetSyncTurnParameter(p) (((p)*32)+28) /*!< RW - Holds the turning parameter need within MoveBlock (1 byte) sbyte */
#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
#define OutputOffsetOptions(p)           (((p)*32)+29) /*!< RW - holds extra motor options related to the tachometer limit (1 byte) ubyte  (NBC/NXC) */
#define OutputOffsetMaxSpeed(p)          (((p)*32)+30) /*!< RW - holds the maximum speed for position regulation (1 byte) sbyte  (NBC/NXC) */
#define OutputOffsetMaxAccel(p)          (((p)*32)+31) /*!< RW - holds the maximum acceleration for position regulation (1 byte) sbyte  (NBC/NXC) */
#endif
#define OutputOffsetRegulationTime       96 /*!< use for frequency of checking regulation mode (1 byte) ubyte (NBC/NXC) */
#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
#define OutputOffsetRegulationOptions    97 /*!< use for position regulation options (1 byte) ubyte (NBC/NXC) */
#endif
/** @} */  // end of OutputIOMAP group
/** @} */  // end of OutputModuleConstants group
/** @} */  // end of OutputModule group


/** @addtogroup LowSpeedModule
 * @{
 */
/** @defgroup LowSpeedModuleConstants LowSpeed module constants
 * Constants that are part of the NXT firmware's LowSpeed module.
 * @{
 */
/** @defgroup LowSpeedStateConstants LSState constants
 * Constants for the low speed module LSState function. These values are
 * combined together using a bitwise OR operation.
 * \sa LSState()
 * @{
 */
#define COM_CHANNEL_NONE_ACTIVE  0x00 /*!< None of the low speed channels are active */
#define COM_CHANNEL_ONE_ACTIVE   0x01 /*!< Low speed channel 1 is active */
#define COM_CHANNEL_TWO_ACTIVE   0x02 /*!< Low speed channel 2 is active */
#define COM_CHANNEL_THREE_ACTIVE 0x04 /*!< Low speed channel 3 is active */
#define COM_CHANNEL_FOUR_ACTIVE  0x08 /*!< Low speed channel 4 is active */
/** @} */  // end of LowSpeedStateConstants group

/** @defgroup LowSpeedChannelStateConstants LSChannelState constants
 * Constants for the low speed module LSChannelState function.
 * \sa LSChannelState()
 * @{
 */
#define LOWSPEED_IDLE          0 /*!< Channel is idle */
#define LOWSPEED_INIT          1 /*!< Channel is being initialized */
#define LOWSPEED_LOAD_BUFFER   2 /*!< Channel buffer is loading */
#define LOWSPEED_COMMUNICATING 3 /*!< Channel is actively communicating */
#define LOWSPEED_ERROR         4 /*!< Channel is in an error state */
#define LOWSPEED_DONE          5 /*!< Channel is done communicating */
/** @} */  // end of LowSpeedChannelStateConstants group

/** @defgroup LowSpeedModeConstants LSMode constants
 * Constants for the low speed module LSMode function.
 * \sa LSMode()
 * @{
 */
#define LOWSPEED_TRANSMITTING   1 /*!< Lowspeed port is in transmitting mode */
#define LOWSPEED_RECEIVING      2 /*!< Lowspeed port is in receiving mode */
#define LOWSPEED_DATA_RECEIVED  3 /*!< Lowspeed port is in data received mode */
/** @} */  // end of LowSpeedModeConstants group

/** @defgroup LowSpeedErrorTypeConstants LSErrorType constants
 * Constants for the low speed module LSErrorType function.
 * \sa LSErrorType()
 * @{
 */
#define LOWSPEED_NO_ERROR     0 /*!< Lowspeed port has no error */
#define LOWSPEED_CH_NOT_READY 1 /*!< Lowspeed port is not ready */
#define LOWSPEED_TX_ERROR     2 /*!< Lowspeed port encountered an error while transmitting data */
#define LOWSPEED_RX_ERROR     3 /*!< Lowspeed port encountered an error while receiving data */
/** @} */  // end of LowSpeedErrorTypeConstants group

/** @defgroup LowSpeedIOMAP Low speed module IOMAP offsets
 * Constant offsets into the low speed module IOMAP structure.
 * @{
 */
#define LowSpeedOffsetInBufBuf(p)       (((p)*19)+0)  /*!< RW - Input buffer data buffer field offset (16 bytes) */
#define LowSpeedOffsetInBufInPtr(p)     (((p)*19)+16) /*!< RW - Input buffer in pointer field offset (1 byte) */
#define LowSpeedOffsetInBufOutPtr(p)    (((p)*19)+17) /*!< RW - Input buffer out pointer field offset (1 byte) */
#define LowSpeedOffsetInBufBytesToRx(p) (((p)*19)+18) /*!< RW - Input buffer bytes to receive field offset (1 byte) */

#define LowSpeedOffsetOutBufBuf(p)       (((p)*19)+76) /*!< RW - Output buffer data buffer field offset (16 bytes) */
#define LowSpeedOffsetOutBufInPtr(p)     (((p)*19)+92) /*!< RW - Output buffer in pointer field offset (1 byte) */
#define LowSpeedOffsetOutBufOutPtr(p)    (((p)*19)+93) /*!< RW - Output buffer out pointer field offset (1 byte) */
#define LowSpeedOffsetOutBufBytesToRx(p) (((p)*19)+94) /*!< RW - Output buffer bytes to receive field offset (1 byte) */

#define LowSpeedOffsetMode(p)            ((p)+152) /*!< R - Lowspeed port mode (1 byte) */
#define LowSpeedOffsetChannelState(p)    ((p)+156) /*!< R - Lowspeed channgel state (1 byte) */
#define LowSpeedOffsetErrorType(p)       ((p)+160) /*!< R - Lowspeed port error type (1 byte) */

#define LowSpeedOffsetState            164 /*!< R - Lowspeed state (all channels) */
#define LowSpeedOffsetSpeed            165 /*!< R - Lowspeed speed (unused) */

#ifdef __ENHANCED_FIRMWARE
#define LowSpeedOffsetNoRestartOnRead  166 /*!< RW - Lowspeed option for no restart on read (all channels) (NBC/NXC) */
#endif
/** @} */  // end of LowSpeedIOMAP group

/** @defgroup LowSpeedNoRestartConstants LSNoRestartOnRead constants
 * Constants for the low speed module LSNoRestartOnRead and
 * SetLSNoRestartOnRead functions. These values are combined with a bitwise
 * OR operation.
 * \sa LSNoRestartOnRead(), SetLSNoRestartOnRead()
 * @{
 */
#ifdef __ENHANCED_FIRMWARE
#define LSREAD_RESTART_ALL     0x00 /*!< Restart on read for all channels (default) */
#define LSREAD_NO_RESTART_1    0x01 /*!< No restart on read for channel 1 */
#define LSREAD_NO_RESTART_2    0x02 /*!< No restart on read for channel 2 */
#define LSREAD_NO_RESTART_3    0x04 /*!< No restart on read for channel 3 */
#define LSREAD_NO_RESTART_4    0x08 /*!< No restart on read for channel 4 */
#define LSREAD_RESTART_NONE    0x0F /*!< No restart on read for all channels */
#define LSREAD_NO_RESTART_MASK 0x10 /*!< No restart mask */
#endif
/** @} */  // end of LowSpeedNoRestartConstants group

/** @defgroup GenericI2CConstants Standard I2C constants
 * Constants for use with standard I2C devices.
 * @{
 */
#define I2C_ADDR_DEFAULT  0x02 /*!< Standard NXT I2C device address */
#define I2C_REG_VERSION   0x00 /*!< Standard NXT I2C version register */
#define I2C_REG_VENDOR_ID 0x08 /*!< Standard NXT I2C vendor ID register */
#define I2C_REG_DEVICE_ID 0x10 /*!< Standard NXT I2C device ID register */
#define I2C_REG_CMD       0x41 /*!< Standard NXT I2C device command register */
/** @} */  // end of GenericI2CConstants group

/** @defgroup LEGOI2CAddressConstants LEGO I2C address constants
 * Constants for LEGO I2C device addresses.
 * @{
 */
#define LEGO_ADDR_US         0x02 /*!< The LEGO ultrasonic sensor's I2C address */
#define LEGO_ADDR_TEMP       0x98 /*!< The LEGO temperature sensor's I2C address */
#define LEGO_ADDR_EMETER     0x04 /*!< The LEGO e-meter sensor's I2C address */
/** @} */  // end of LEGOI2CAddressConstants group

/** @defgroup USI2CConstants Ultrasonic sensor constants
 * Constants for use with the ultrasonic sensor.
 * @{
 */
#define US_CMD_OFF           0x00 /*!< Command to turn off the ultrasonic sensor */
#define US_CMD_SINGLESHOT    0x01 /*!< Command to put the ultrasonic sensor into single shot mode */
#define US_CMD_CONTINUOUS    0x02 /*!< Command to put the ultrasonic sensor into continuous polling mode (default) */
#define US_CMD_EVENTCAPTURE  0x03 /*!< Command to put the ultrasonic sensor into event capture mode */
#define US_CMD_WARMRESET     0x04 /*!< Command to warm reset the ultrasonic sensor */

#define US_REG_CM_INTERVAL   0x40 /*!< The register address used to store the CM interval */
#define US_REG_ACTUAL_ZERO   0x50 /*!< The register address used to store the actual zero value */
#define US_REG_SCALE_FACTOR  0x51 /*!< The register address used to store the scale factor value */
#define US_REG_SCALE_DIVISOR 0x52 /*!< The register address used to store the scale divisor value */

#define US_REG_FACTORY_ACTUAL_ZERO   0x11 /*!< The register address containing the factory setting for the actual zero value */
#define US_REG_FACTORY_SCALE_FACTOR  0x12 /*!< The register address containing the factory setting for the scale factor value */
#define US_REG_FACTORY_SCALE_DIVISOR 0x13 /*!< The register address containing the factory setting for the scale divisor value */
#define US_REG_MEASUREMENT_UNITS     0x14 /*!< The register address containing the measurement units (degrees C or F) */
/** @} */  // end of USI2CConstants group

/** @defgroup TempI2CConstants LEGO temperature sensor constants
 * Constants for use with the LEGO temperature sensor.
 * @{
 */
// R1/R0
#define TEMP_RES_9BIT      0x00 /*!< Set the temperature conversion resolution to 9 bit */
#define TEMP_RES_10BIT     0x20 /*!< Set the temperature conversion resolution to 10 bit */
#define TEMP_RES_11BIT     0x40 /*!< Set the temperature conversion resolution to 11 bit */
#define TEMP_RES_12BIT     0x60 /*!< Set the temperature conversion resolution to 12 bit */
// SD (shutdown mode)
#define TEMP_SD_CONTINUOUS 0x00 /*!< Set the sensor mode to continuous */
#define TEMP_SD_SHUTDOWN   0x01 /*!< Set the sensor mode to shutdown. The device will shut down after the current conversion is completed. */
// TM (thermostat mode)
#define TEMP_TM_COMPARATOR 0x00 /*!< Set the thermostat mode to comparator */
#define TEMP_TM_INTERRUPT  0x02 /*!< Set the thermostat mode to interrupt */
// OS (one shot)
#define TEMP_OS_ONESHOT    0x80 /*!< Set the sensor into oneshot mode. When the device is in shutdown mode this will start a single temperature conversion. The device returns to shutdown mode when it completes. */
// F1/F0 (fault queue)
#define TEMP_FQ_1          0x00 /*!< Set fault queue to 1 fault before alert */
#define TEMP_FQ_2          0x08 /*!< Set fault queue to 2 faults before alert */
#define TEMP_FQ_4          0x10 /*!< Set fault queue to 4 faults before alert */
#define TEMP_FQ_6          0x18 /*!< Set fault queue to 6 faults before alert */
// POL (polarity)
#define TEMP_POL_LOW       0x00 /*!< Set polarity of ALERT pin to be active LOW */
#define TEMP_POL_HIGH      0x04 /*!< Set polarity of ALERT pin to be active HIGH */

#define TEMP_REG_TEMP      0x00 /*!< The register where temperature values can be read */
#define TEMP_REG_CONFIG    0x01 /*!< The register for reading/writing sensor configuration values */
#define TEMP_REG_TLOW      0x02 /*!< The register for reading/writing a user-defined low temperature limit */
#define TEMP_REG_THIGH     0x03 /*!< The register for reading/writing a user-defined high temperature limit */
/** @} */  // end of TempI2CConstants group

/** @defgroup EMeterI2CConstants E-Meter sensor constants
 * Constants for use with the e-meter sensor.
 * @{
 */
#define EMETER_REG_VIN    0x0a /*!< The register address for voltage in */
#define EMETER_REG_AIN    0x0c /*!< The register address for amps in */
#define EMETER_REG_VOUT   0x0e /*!< The register address for voltage out */
#define EMETER_REG_AOUT   0x10 /*!< The register address for amps out */
#define EMETER_REG_JOULES 0x12 /*!< The register address for joules */
#define EMETER_REG_WIN    0x14 /*!< The register address for watts in */
#define EMETER_REG_WOUT   0x16 /*!< The register address for watts out */
/** @} */  // end of EMeterI2CConstants group

/** @defgroup I2COptionConstants I2C option constants
 * Constants for the SetI2COptions function. These values are combined with a bitwise
 * OR operation.
 * \sa SetI2COptions()
 * @{
 */
#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
#define I2C_OPTION_STANDARD  0x00 /*!< Standard I2C speed */
#define I2C_OPTION_NORESTART 0x04 /*!< Use no restart on I2C read */
#define I2C_OPTION_FAST      0x08 /*!< Fast I2C speed */
#endif
/** @} */  // end of I2COptionConstants group


/** @} */  // end of LowSpeedModuleConstants group
/** @} */  // end of LowSpeedModule group


/** @addtogroup DisplayModule
 * @{
 */
/** @defgroup DisplayModuleConstants Display module constants
 * Constants that are part of the NXT firmware's Display module.
 * @{
 */
/** @defgroup DisplayExecuteFunctionConstants DisplayExecuteFunction constants
 * Constants that are for use with the DisplayExecuteFunction system call.
 * @{
 */
#define DISPLAY_ERASE_ALL       0x00     /*!< W - erase entire screen     (CMD,x,x,x,x,x) */
#define DISPLAY_PIXEL           0x01     /*!< W - set pixel (on/off)      (CMD,TRUE/FALSE,X,Y,x,x) */
#define DISPLAY_HORIZONTAL_LINE 0x02     /*!< W - draw horizontal line    (CMD,TRUE/FALSE,X1,Y1,X2,x) */
#define DISPLAY_VERTICAL_LINE   0x03     /*!< W - draw vertical line      (CMD,TRUE/FALSE,X1,Y1,x,Y2) */
#define DISPLAY_CHAR            0x04     /*!< W - draw char (actual font) (CMD,TRUE,X1,Y1,Char,x) */
#define DISPLAY_ERASE_LINE      0x05     /*!< W - erase a single line     (CMD,x,LINE,x,x,x) */
#define DISPLAY_FILL_REGION     0x06     /*!< W - fill screen region      (CMD,TRUE/FALSE,X1,Y1,X2,Y2) */
#define DISPLAY_FRAME           0x07     /*!< W - draw a frame (on/off)   (CMD,TRUE/FALSE,X1,Y1,X2,Y2) */
/** @} */  // end of DisplayExecuteFunctionConstants group

/** @defgroup DisplayDrawOptionConstants Drawing option constants
 * Constants that are for specifying drawing options in several display module API functions.
 * Bits 0 & 1 (values 0,1,2,3) control screen clearing behaviour (Not within RIC files).
 * Bit 2 (value 4) controls the NOT operation, i.e. draw in white or invert text/graphics.
 * Bits 3 & 4 (values 0,8,16,24) control pixel logical combinations (COPY/AND/OR/XOR).
 * Bit 5 (value 32) controls shape filling, or overrides text/graphic bitmaps with set pixels.
 * These may be ORed together for the full instruction
 * (e.g., DRAW_OPT_NORMAL|DRAW_OPT_LOGICAL_XOR)
 * These operations are resolved into the separate, common parameters
 * defined in 'c_display.iom' before any drawing function is called.
 * Note that when drawing a RIC file, the initial 'DrawingOptions' parameter
 * supplied in the drawing instruction controls screen clearing, but nothing else.
 * The 'CopyOptions' parameter from each instruction in the RIC file then controls
 * graphic operations, but the screen-clearing bits are ignored.
 * \sa TextOut(), NumOut(), PointOut(), LineOut(), CircleOut(), RectOut(),
 * PolyOut(), EllipseOut(), FontTextOut(), FontNumOut(), GraphicOut(),
 * GraphicArrayOut()
 * @{
 */
#define DRAW_OPT_NORMAL                     (0x0000) /*!< Normal drawing */
#define DRAW_OPT_CLEAR_WHOLE_SCREEN         (0x0001) /*!< Clear the entire screen before drawing */
#define DRAW_OPT_CLEAR_EXCEPT_STATUS_SCREEN (0x0002) /*!< Clear the screen except for the status line before drawing */

#define DRAW_OPT_CLEAR_PIXELS               (0x0004) /*!< Clear pixels while drawing (aka draw in white) */
#define DRAW_OPT_CLEAR                      (0x0004) /*!< Clear pixels while drawing (aka draw in white) */
#define DRAW_OPT_INVERT                     (0x0004) /*!< Invert text or graphics */

#define DRAW_OPT_LOGICAL_COPY               (0x0000) /*!< Draw pixels using a logical copy operation */
#define DRAW_OPT_LOGICAL_AND                (0x0008) /*!< Draw pixels using a logical AND operation */
#define DRAW_OPT_LOGICAL_OR                 (0x0010) /*!< Draw pixels using a logical OR operation */
#define DRAW_OPT_LOGICAL_XOR                (0x0018) /*!< Draw pixels using a logical XOR operation */

#define DRAW_OPT_FILL_SHAPE                 (0x0020) /*!< Fill the shape while drawing (rectangle, circle, ellipses, and polygon) */

#define DRAW_OPT_CLEAR_SCREEN_MODES         (0x0003) /*!< Bit mask for the clear screen modes */
#define DRAW_OPT_LOGICAL_OPERATIONS         (0x0018) /*!< Bit mask for the logical drawing operations */

#define DRAW_OPT_POLYGON_POLYLINE           (0x0400) /*!< When drawing polygons, do not close (i.e., draw a polyline instead) */

/** @defgroup DisplayFontDrawOptionConstants Font drawing option constants
 * These addition drawing option constants are only for use when drawing
 * text and numbers on the LCD using an RIC-based font.
 * \sa FontTextOut(), FontNumOut()
 * @{
 */
#define DRAW_OPT_FONT_DIRECTIONS            (0x01C0) /*!< Bit mask for the font direction bits */

#define DRAW_OPT_FONT_WRAP       (0x0200) /*!< Option to have text wrap in \ref FontNumOut and \ref FontTextOut calls */

#define DRAW_OPT_FONT_DIR_L2RB   (0x0000) /*!< Font left to right bottom align */
#define DRAW_OPT_FONT_DIR_L2RT   (0x0040) /*!< Font left to right top align */
#define DRAW_OPT_FONT_DIR_R2LB   (0x0080) /*!< Font right to left bottom align */
#define DRAW_OPT_FONT_DIR_R2LT   (0x00C0) /*!< Font right to left top align */
#define DRAW_OPT_FONT_DIR_B2TL   (0x0100) /*!< Font bottom to top left align */
#define DRAW_OPT_FONT_DIR_B2TR   (0x0140) /*!< Font bottom to top right align */
#define DRAW_OPT_FONT_DIR_T2BL   (0x0180) /*!< Font top to bottom left align */
#define DRAW_OPT_FONT_DIR_T2BR   (0x01C0) /*!< Font top to bottom right align */
/** @} */  // end of DisplayFontDrawOptionConstants group
/** @} */  // end of DisplayDrawOptionConstants group

/** @defgroup DisplayFlagsGroup Display flags
 * Constants that are for use with the display flags functions.
 * \sa SetDisplayFlags(), DisplayFlags()
 * @{
 */
#define DISPLAY_ON               0x01     /*!< W  - Display on */
#define DISPLAY_REFRESH          0x02     /*!< W  - Enable refresh */
#define DISPLAY_POPUP            0x08     /*!< W  - Use popup display memory */
#define DISPLAY_REFRESH_DISABLED 0x40     /*!< R  - Refresh disabled */
#define DISPLAY_BUSY             0x80     /*!< R  - Refresh in progress */
/** @} */  // end of DisplayFlagsGroup group

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/** @defgroup DisplayContrastConstants Display contrast constants
 * Constants that are for use with the display contrast API functions.
 * \sa SetDisplayContrast(), DisplayContrast()
 * @{
 */
#define DISPLAY_CONTRAST_DEFAULT 0x5A /*!< Default display contrast value */
#define DISPLAY_CONTRAST_MAX     0x7F /*!< Maximum display contrast value */
/** @} */  // end of DisplayContrastConstants group
#endif

#define SCREEN_MODE_RESTORE 0x00 /*!< Restore the screen \sa SetScreenMode() */
#define SCREEN_MODE_CLEAR   0x01 /*!< Clear the screen \sa SetScreenMode() */

#define DISPLAY_HEIGHT 64  /*!< The height of the LCD screen in pixels */
#define DISPLAY_WIDTH  100 /*!< The width of the LCD screen in pixels */

#define DISPLAY_MENUICONS_Y       40 /*!< */
#define DISPLAY_MENUICONS_X_OFFS  7  /*!< */
#define DISPLAY_MENUICONS_X_DIFF  31 /*!< */

/** @defgroup DisplayTextLineConstants Text line constants
 * Constants that are for use with getting/setting display data.
 * \sa SetDisplayNormal(), GetDisplayNormal(), SetDisplayPopup(), GetDisplayPopup()
 * @{
 */
#define TEXTLINE_1 0 /*!< Text line 1 */
#define TEXTLINE_2 1 /*!< Text line 2 */
#define TEXTLINE_3 2 /*!< Text line 3 */
#define TEXTLINE_4 3 /*!< Text line 4 */
#define TEXTLINE_5 4 /*!< Text line 5 */
#define TEXTLINE_6 5 /*!< Text line 6 */
#define TEXTLINE_7 6 /*!< Text line 7 */
#define TEXTLINE_8 7 /*!< Text line 8 */
#define TEXTLINES  8 /*!< The number of text lines on the LCD */
/** @} */  // end of DisplayTextLineConstants group

// Used in macro "MENUICON_BIT"
#define MENUICON_LEFT   0 /*!< Left icon */
#define MENUICON_CENTER 1 /*!< Center icon */
#define MENUICON_RIGHT  2 /*!< Right icon */
#define MENUICONS       3 /*!< The number of menu icons */

// Used in macro "SPECIAL_BIT"
#define FRAME_SELECT 0   /*!< Center icon select frame */
#define STATUSTEXT   1   /*!< Status text (BT name) */
#define MENUTEXT     2   /*!< Center icon text */
#define STEPLINE     3   /*!< Step collection lines */
#define TOPLINE      4   /*!< Top status underline */
#define SPECIALS     5   /*!< The number of special bit values */

// Used in macro "STATUSICON_BIT"
#define STATUSICON_BLUETOOTH 0 /*!< BlueTooth status icon collection */
#define STATUSICON_USB       1 /*!< USB status icon collection */
#define STATUSICON_VM        2 /*!< VM status icon collection */
#define STATUSICON_BATTERY   3 /*!< Battery status icon collection */
#define STATUSICONS          4 /*!< The number of status icons */

// Used in macro "SCREEN_BIT"
#define SCREEN_BACKGROUND 0 /*!< Entire screen */
#define SCREEN_LARGE      1 /*!< Entire screen except status line */
#define SCREEN_SMALL      2 /*!< Screen between menu icons and status line */
#define SCREENS           3 /*!< The number of screen bits */

// Used in macro "BITMAP_BIT"
#define BITMAP_1 0 /*!< Bitmap 1 */
#define BITMAP_2 1 /*!< Bitmap 2 */
#define BITMAP_3 2 /*!< Bitmap 3 */
#define BITMAP_4 3 /*!< Bitmap 4 */
#define BITMAPS  4 /*!< The number of bitmap bits */

// Used in macro "STEPICON_BIT"
#define STEPICON_1 0 /*!< Left most step icon */
#define STEPICON_2 1 /*!< */
#define STEPICON_3 2 /*!< */
#define STEPICON_4 3 /*!< */
#define STEPICON_5 4 /*!< Right most step icon */
#define STEPICONS  5 /*!< */

/** @defgroup DisplayIOMAP Display module IOMAP offsets
 * Constant offsets into the display module IOMAP structure.
 * @{
 */
#define DisplayOffsetPFunc          0             /*!< Simple draw entry */
#define DisplayOffsetEraseMask      4             /*!< Section erase mask   (executed first) */
#define DisplayOffsetUpdateMask     8             /*!< Section update mask  (executed next) */
#define DisplayOffsetPFont          12            /*!< Pointer to font file */
#define DisplayOffsetPTextLines(p)  (((p)*4)+16)  /*!< Pointer to text strings */
#define DisplayOffsetPStatusText    48            /*!< Pointer to status text string */
#define DisplayOffsetPStatusIcons   52            /*!< Pointer to status icon collection file */
#define DisplayOffsetPScreens(p)    (((p)*4)+56)  /*!< Pointer to screen bitmap file */
#define DisplayOffsetPBitmaps(p)    (((p)*4)+68)  /*!< Pointer to free bitmap files */
#define DisplayOffsetPMenuText      84            /*!< Pointer to menu icon text (NULL == none) */
#define DisplayOffsetPMenuIcons(p)  (((p)*4)+88)  /*!< Pointer to menu icon images (NULL == none) */
#define DisplayOffsetPStepIcons     100           /*!< Pointer to step icon collection file */
#define DisplayOffsetDisplay        104           /*!< Display content copied to physical display every 17 mS */
#define DisplayOffsetStatusIcons(p) ((p)+108)     /*!< Index in status icon collection file (index = 0 -> none) */
#define DisplayOffsetStepIcons(p)   ((p)+112)     /*!< Index in step icon collection file (index = 0 -> none) */
#define DisplayOffsetFlags          117           /*!< Update flags enumerated above */
#define DisplayOffsetTextLinesCenterFlags 118     /*!< Mask to center TextLines */
#define DisplayOffsetNormal(l,w)    (((l)*100)+(w)+119) /*!< Raw display memory for normal screen */
#define DisplayOffsetPopup(l,w)     (((l)*100)+(w)+919) /*!< Raw display memory for popup screen */

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
#define DisplayOffsetContrast       1719 /*!< Adjust the display contrast with this field */
#endif
/** @} */  // end of DisplayIOMAP group
/** @} */  // end of DisplayModuleConstants group
/** @} */  // end of DisplayModule group


/** @addtogroup CommModule
 * @{
 */
/** @defgroup CommModuleConstants Comm module constants
 * Constants that are part of the NXT firmware's Comm module.
 * @{
 */
/** @defgroup CommMiscConstants Miscellaneous Comm module constants
 * Miscellaneous constants related to the Comm module.
 * @{
 */
#define SIZE_OF_USBBUF                64  /*!< Size of USB Buffer in bytes */
#define USB_PROTOCOL_OVERHEAD         2   /*!< Size of USB Overhead in bytes -- Command type byte + Command*/
#define SIZE_OF_USBDATA               62  /*!< Size of USB Buffer available for data */
#define SIZE_OF_HSBUF                 128 /*!< Size of High Speed Port 4 buffer */
#define SIZE_OF_BTBUF                 128 /*!< Size of Bluetooth buffer*/

#define BT_CMD_BYTE                   1  /*!< Size of Bluetooth command*/
#define SIZE_OF_BT_DEVICE_TABLE       30 /*!< Size of Bluetooth device table */
#define SIZE_OF_BT_CONNECT_TABLE      4  /*!< Size of Bluetooth connection table -- Index 0 is always incoming connection */
#define SIZE_OF_BT_NAME               16 /*!< Size of Bluetooth name */
#define SIZE_OF_BRICK_NAME            8  /*!< Size of NXT Brick name */
#define SIZE_OF_CLASS_OF_DEVICE       4  /*!< Size of class of device */
#define SIZE_OF_BT_PINCODE            16 /*!< Size of Bluetooth PIN */
#define SIZE_OF_BDADDR                7  /*!< Size of Bluetooth Address*/
#define MAX_BT_MSG_SIZE               60000 /*!< Max Bluetooth Message Size */

#define BT_DEFAULT_INQUIRY_MAX        0   /*!< Bluetooth default inquiry Max (0 == unlimited)*/
#define BT_DEFAULT_INQUIRY_TIMEOUT_LO 15  /*!< Bluetooth inquiry timeout (15*1.28 sec = 19.2 sec) */
/** @} */  // end of CommMiscConstants group

/** @defgroup CommBtStateConstants Bluetooth State constants
 * Constants related to the bluetooth state.
 * @{
 */
#define BT_ARM_OFF              0 /*!< BtState constant bluetooth off */
#define BT_ARM_CMD_MODE         1 /*!< BtState constant bluetooth command mode */
#define BT_ARM_DATA_MODE        2 /*!< BtState constant bluetooth data mode */
/** @} */  // end of CommBtStateConstants group

/** @defgroup CommDataModeConstants Data mode constants
 * Constants related to the bluetooth and hi-speed data modes.
 * @{
 */
#define DATA_MODE_NXT    0x00 /*!< Use NXT data mode */
#define DATA_MODE_GPS    0x01 /*!< Use GPS data mode */
#define DATA_MODE_RAW    0x02 /*!< Use RAW data mode */
#define DATA_MODE_MASK   0x07 /*!< A mask for the data mode bits. */
#define DATA_MODE_UPDATE 0x08 /*!< Indicates that the data mode has been changed. */
/** @} */  // end of CommDataModeConstants group

/** @defgroup CommBtStateStatusConstants Bluetooth state status constants
 * Constants related to the bluetooth state status.
 * @{
 */
#define BT_BRICK_VISIBILITY     0x01 /*!< BtStateStatus brick visibility bit */
#define BT_BRICK_PORT_OPEN      0x02 /*!< BtStateStatus port open bit */
#define BT_CONNECTION_0_ENABLE  0x10 /*!< BtStateStatus connection 0 enable/disable bit */
#define BT_CONNECTION_1_ENABLE  0x20 /*!< BtStateStatus connection 1 enable/disable bit */
#define BT_CONNECTION_2_ENABLE  0x40 /*!< BtStateStatus connection 2 enable/disable bit */
#define BT_CONNECTION_3_ENABLE  0x80 /*!< BtStateStatus connection 3 enable/disable bit */
/** @} */  // end of CommBtStateStatusConstants group

/** @defgroup CommConnectionConstants Remote connection constants
 * Constants for specifying remote connection slots.
 * @{
 */
#define CONN_BT0    0x0 /*!< Bluetooth connection 0 */
#define CONN_BT1    0x1 /*!< Bluetooth connection 1 */
#define CONN_BT2    0x2 /*!< Bluetooth connection 2 */
#define CONN_BT3    0x3 /*!< Bluetooth connection 3 */
#define CONN_HS4    0x4 /*!< RS485 (hi-speed) connection (port 4, all devices) */
#define CONN_HS_ALL 0x4 /*!< RS485 (hi-speed) connection (port 4, all devices) */
#define CONN_HS_1   0x5 /*!< RS485 (hi-speed) connection (port 4, device address 1) */
#define CONN_HS_2   0x6 /*!< RS485 (hi-speed) connection (port 4, device address 2) */
#define CONN_HS_3   0x7 /*!< RS485 (hi-speed) connection (port 4, device address 3) */
#define CONN_HS_4   0x8 /*!< RS485 (hi-speed) connection (port 4, device address 4) */
#define CONN_HS_5   0x9 /*!< RS485 (hi-speed) connection (port 4, device address 5) */
#define CONN_HS_6   0xa /*!< RS485 (hi-speed) connection (port 4, device address 6) */
#define CONN_HS_7   0xb /*!< RS485 (hi-speed) connection (port 4, device address 7) */
#define CONN_HS_8   0xc /*!< RS485 (hi-speed) connection (port 4, device address 8) */
/** @} */  // end of CommConnectionConstants group

/** @defgroup CommBtHwStatusConstants Bluetooth hardware status constants
 * Constants related to the bluetooth hardware status.
 * @{
 */
#define BT_ENABLE               0x00 /*!< BtHwStatus bluetooth enable */
#define BT_DISABLE              0x01 /*!< BtHwStatus bluetooth disable */
/** @} */  // end of CommBtHwStatusConstants group

/** @defgroup CommHiSpeedConstants Hi-speed port constants
 * Constants related to the hi-speed port.
 * @{
 */
/** @defgroup CommHiSpeedFlagsConstants Hi-speed port flags constants
 * Constants related to the hi-speed port flags.
 * @{
 */
#define HS_UPDATE        1 /*!< HsFlags high speed update required */
/** @} */  // end of CommHiSpeedFlagsConstants group

/** @defgroup CommHiSpeedStateConstants Hi-speed port state constants
 * Constants related to the hi-speed port state.
 * @{
 */
#define HS_INITIALISE       1 /*!< HsState initialize */
#define HS_INIT_RECEIVER    2 /*!< HsState initialize receiver */
#define HS_SEND_DATA        3 /*!< HsState send data */
#define HS_DISABLE          4 /*!< HsState disable */
#define HS_ENABLE           5 /*!< HsState enable */
#define HS_DEFAULT          6 /*!< HsState default */
#define HS_BYTES_REMAINING 16 /*!< HsState bytes remaining to be sent */
/** @} */  // end of CommHiSpeedStateConstants group

#ifdef __ENHANCED_FIRMWARE

/** @defgroup CommHiSpeedCtrlConstants Hi-speed port SysCommHSControl constants
 * Constants for use with the SysCommHSControl API function.
 * \sa SysCommHSControl()
 * @{
 */
#define HS_CTRL_INIT 0 /*!< Enable the high speed port */
#define HS_CTRL_UART 1 /*!< Setup the high speed port UART configuration */
#define HS_CTRL_EXIT 2 /*!< Ddisable the high speed port */
/** @} */  // end of CommHiSpeedCtrlConstants group

#if __FIRMWARE_VERSION > 107

/** @defgroup CommHiSpeedBaudConstants Hi-speed port baud rate constants
 * Constants for configuring the hi-speed port baud rate (HsSpeed).
 * @{
 */
#define HS_BAUD_1200     0 /*!< HsSpeed 1200 Baud */
#define HS_BAUD_2400     1 /*!< HsSpeed 2400 Baud */
#define HS_BAUD_3600     2 /*!< HsSpeed 3600 Baud */
#define HS_BAUD_4800     3 /*!< HsSpeed 4800 Baud */
#define HS_BAUD_7200     4 /*!< HsSpeed 7200 Baud */
#define HS_BAUD_9600     5 /*!< HsSpeed 9600 Baud */
#define HS_BAUD_14400    6 /*!< HsSpeed 14400 Baud */
#define HS_BAUD_19200    7 /*!< HsSpeed 19200 Baud */
#define HS_BAUD_28800    8 /*!< HsSpeed 28800 Baud */
#define HS_BAUD_38400    9 /*!< HsSpeed 38400 Baud */
#define HS_BAUD_57600   10 /*!< HsSpeed 57600 Baud */
#define HS_BAUD_76800   11 /*!< HsSpeed 76800 Baud */
#define HS_BAUD_115200  12 /*!< HsSpeed 115200 Baud */
#define HS_BAUD_230400  13 /*!< HsSpeed 230400 Baud */
#define HS_BAUD_460800  14 /*!< HsSpeed 460800 Baud */
#define HS_BAUD_921600  15 /*!< HsSpeed 921600 Baud */
#define HS_BAUD_DEFAULT 15 /*!< HsSpeed default Baud (921600) */
/** @} */  // end of CommHiSpeedBaudConstants group


/** @defgroup CommHiSpeedModeConstants Hi-speed port UART mode constants
 * Constants referring to HsMode UART configuration settings
 * @{
 */
#define HS_MODE_UART_RS485 0x0    /*!< HsMode UART in default or RS485 mode */
#define HS_MODE_UART_RS232 0x1    /*!< HsMode UART in normal or RS232 mode */

#define HS_MODE_MASK 0x3EC0        /*!< HsMode mode mask */
#define HS_UART_MASK 0x000F        /*!< HsMode UART mask */

#define HS_MODE_DEFAULT HS_MODE_8N1 /*!< HsMode default mode (8 data bits, no parity, 1 stop bit) */

/** @defgroup CommHiSpeedDataBitsConstants Hi-speed port data bits constants
 * Constants referring to HsMode (number of data bits)
 * @{
 */
#define HS_MODE_5_DATA 0x0000 /*!< HsMode 5 data bits */
#define HS_MODE_6_DATA 0x0040 /*!< HsMode 6 data bits */
#define HS_MODE_7_DATA 0x0080 /*!< HsMode 7 data bits */
#define HS_MODE_8_DATA 0x00C0 /*!< HsMode 8 data bits */
/** @} */  // end of CommHiSpeedDataBitsConstants group

/** @defgroup CommHiSpeedStopBitsConstants Hi-speed port stop bits constants
 * Constants referring to HsMode (number of stop bits)
 * @{
 */
#define HS_MODE_10_STOP 0x0000 /*!< HsMode 1 stop bit */
#define HS_MODE_15_STOP 0x1000 /*!< HsMode 1.5 stop bits */
#define HS_MODE_20_STOP 0x2000 /*!< HsMode 2 stop bits */
/** @} */  // end of CommHiSpeedStopBitsConstants group

/** @defgroup CommHiSpeedParityConstants Hi-speed port parity constants
 * Constants referring to HsMode (parity)
 * @{
 */
#define HS_MODE_E_PARITY 0x0000 /*!< HsMode Even parity */
#define HS_MODE_O_PARITY 0x0200 /*!< HsMode Odd parity */
#define HS_MODE_S_PARITY 0x0400 /*!< HsMode Space parity */
#define HS_MODE_M_PARITY 0x0600 /*!< HsMode Mark parity */
#define HS_MODE_N_PARITY 0x0800 /*!< HsMode No parity */
/** @} */  // end of CommHiSpeedParityConstants group

/** @defgroup CommHiSpeedCombinedConstants Hi-speed port combined UART constants
 * Constants that combine data bits, parity, and stop bits into a single value.
 * @{
 */
#define HS_MODE_8N1 (HS_MODE_8_DATA|HS_MODE_N_PARITY|HS_MODE_10_STOP) /*!< HsMode 8 data bits, no parity, 1 stop bit */
#define HS_MODE_7E1 (HS_MODE_7_DATA|HS_MODE_E_PARITY|HS_MODE_10_STOP) /*!< HsMode 7 data bits, even parity, 1 stop bit */
/** @} */  // end of CommHiSpeedCombinedConstants group
/** @} */  // end of CommHiSpeedModeConstants group


/** @defgroup CommHiSpeedAddressConstants Hi-speed port address constants
 * Constants that are used to specify the Hi-speed (RS-485) port device address.
 * @{
 */
#define HS_ADDRESS_ALL 0 /*!< HsAddress all devices */
#define HS_ADDRESS_1   1 /*!< HsAddress device address 1 */
#define HS_ADDRESS_2   2 /*!< HsAddress device address 2 */
#define HS_ADDRESS_3   3 /*!< HsAddress device address 3 */
#define HS_ADDRESS_4   4 /*!< HsAddress device address 4 */
#define HS_ADDRESS_5   5 /*!< HsAddress device address 5 */
#define HS_ADDRESS_6   6 /*!< HsAddress device address 6 */
#define HS_ADDRESS_7   7 /*!< HsAddress device address 7 */
#define HS_ADDRESS_8   8 /*!< HsAddress device address 8 */
/** @} */  // end of CommHiSpeedAddressConstants group

#endif
#endif
/** @} */  // end of CommHiSpeedConstants group

/** @defgroup CommDeviceStatusConstants Device status constants
 * Constants refering to DeviceStatus within DeviceTable
 * @{
 */
#define BT_DEVICE_EMPTY   0x00 /*!< Bluetooth device table empty */
#define BT_DEVICE_UNKNOWN 0x01 /*!< Bluetooth device unknown */
#define BT_DEVICE_KNOWN   0x02 /*!< Bluetooth device known */
#define BT_DEVICE_NAME    0x40 /*!< Bluetooth device name */
#define BT_DEVICE_AWAY    0x80 /*!< Bluetooth device away */
/** @} */  // end of CommDeviceStatusConstants group

/** @defgroup CommInterfaceConstants Comm module interface function constants
 * Constants for all the Comm module interface functions executable via SysCommExecuteFunction.
 * \sa SysCommExecuteFunction()
 * @{
 */
#define INTF_SENDFILE      0 /*!< Send a file via bluetooth to another device */
#define INTF_SEARCH        1 /*!< Search for bluetooth devices */
#define INTF_STOPSEARCH    2 /*!< Stop searching for bluetooth devices */
#define INTF_CONNECT       3 /*!< Connect to one of the known devices */
#define INTF_DISCONNECT    4 /*!< Disconnect from one of the connected devices */
#define INTF_DISCONNECTALL 5 /*!< Disconnect all devices */
#define INTF_REMOVEDEVICE  6 /*!< Remove a device from the known devices table */
#define INTF_VISIBILITY    7 /*!< Set the bluetooth visibility on or off */
#define INTF_SETCMDMODE    8 /*!< Set bluetooth into command mode */
#define INTF_OPENSTREAM    9 /*!< Open a bluetooth stream */
#define INTF_SENDDATA      10 /*!< Send data over a bluetooth connection */
#define INTF_FACTORYRESET  11 /*!< Reset bluetooth settings to factory values */
#define INTF_BTON          12 /*!< Turn on the bluetooth radio */
#define INTF_BTOFF         13 /*!< Turn off the bluetooth radio */
#define INTF_SETBTNAME     14 /*!< Set the bluetooth name */
#define INTF_EXTREAD       15 /*!< External read request */
#define INTF_PINREQ        16 /*!< Bluetooth PIN request */
#define INTF_CONNECTREQ    17 /*!< Connection request from another device */

#if __FIRMWARE_VERSION > 107
#define INTF_CONNECTBYNAME 18 /*!< Connect to a bluetooth device by name */
#endif
/** @} */  // end of CommInterfaceConstants group

/** @defgroup CommStatusCodesConstants Comm module status code constants
 * Constants for Comm module status codes.
 * @{
 */
#define LR_SUCCESS        0x50 /*!< Bluetooth list result success */
#define LR_COULD_NOT_SAVE 0x51 /*!< Bluetooth list result could not save */
#define LR_STORE_IS_FULL  0x52 /*!< Bluetooth list result store is full */
#define LR_ENTRY_REMOVED  0x53 /*!< Bluetooth list result entry removed */
#define LR_UNKNOWN_ADDR   0x54 /*!< Bluetooth list result unknown address */

#define USB_CMD_READY     0x01 /*!< A constant representing usb direct command */
#define BT_CMD_READY      0x02 /*!< A constant representing bluetooth direct command */
#define HS_CMD_READY      0x04 /*!< A constant representing high speed direct command */
/** @} */  // end of CommStatusCodesConstants group

/** @defgroup CommIOMAP Comm module IOMAP offsets
 * Constant offsets into the Comm module IOMAP structure.
 * @{
 */
#define CommOffsetPFunc    0 /*!< Offset to the Comm module first function pointer (4 bytes) */
#define CommOffsetPFuncTwo 4 /*!< Offset to the Comm module second function pointer (4 bytes) */
// BtDeviceTable[30] (930 bytes)
#define CommOffsetBtDeviceTableName(p)           (((p)*31)+8) /*!< Offset to BT device table name (16 bytes) */
#define CommOffsetBtDeviceTableClassOfDevice(p)  (((p)*31)+24) /*!< Offset to Bluetooth device table device class (4 bytes) */
#define CommOffsetBtDeviceTableBdAddr(p)         (((p)*31)+28) /*!< Offset to Bluetooth device table address (7 bytes) */
#define CommOffsetBtDeviceTableDeviceStatus(p)   (((p)*31)+35) /*!< Offset to Bluetooth device table status (1 byte) */
//  BDCONNECTTABLE BtConnectTable[4]; (188 bytes)
#define CommOffsetBtConnectTableName(p)          (((p)*47)+938) /*!< Offset to Bluetooth connect table name (16 bytes) */
#define CommOffsetBtConnectTableClassOfDevice(p) (((p)*47)+954) /*!< Offset to Bluetooth connect table device class (4 bytes) */
#define CommOffsetBtConnectTablePinCode(p)       (((p)*47)+958) /*!< Offset to Bluetooth connect table pin code (16 bytes) */
#define CommOffsetBtConnectTableBdAddr(p)        (((p)*47)+974) /*!< Offset to Bluetooth connect table address (7 bytes) */
#define CommOffsetBtConnectTableHandleNr(p)      (((p)*47)+981) /*!< Offset to Bluetooth connect table handle (1 byte) */
#define CommOffsetBtConnectTableStreamStatus(p)  (((p)*47)+982) /*!< Offset to Bluetooth connect table stream status (1 byte) */
#define CommOffsetBtConnectTableLinkQuality(p)   (((p)*47)+983) /*!< Offset to Bluetooth connect table link quality (1 byte) */
//General brick data
//  BRICKDATA      BrickData; (31 bytes)
#define CommOffsetBrickDataName            1126 /*!< Offset to brick name (16 bytes) */
#define CommOffsetBrickDataBluecoreVersion 1142 /*!< Offset to Bluecore version (2 bytes) */
#define CommOffsetBrickDataBdAddr          1144 /*!< Offset to Bluetooth address (7 bytes) */
#define CommOffsetBrickDataBtStateStatus   1151 /*!< Offset to BtStateStatus (1 byte) */
#define CommOffsetBrickDataBtHwStatus      1152 /*!< Offset to BtHwStatus (1 byte) */
#define CommOffsetBrickDataTimeOutValue    1153 /*!< Offset to data timeout value (1 byte) */
//  BTBUF          BtInBuf; (132 bytes)
#define CommOffsetBtInBufBuf       1157 /*!< Offset to Bluetooth input buffer data (128 bytes) */
#define CommOffsetBtInBufInPtr     1285 /*!< Offset to Bluetooth input buffer front pointer (1 byte) */
#define CommOffsetBtInBufOutPtr    1286 /*!< Offset to Bluetooth output buffer back pointer (1 byte) */
//  BTBUF          BtOutBuf; (132 bytes)
#define CommOffsetBtOutBufBuf      1289 /*!< Offset to Bluetooth output buffer offset data (128 bytes) */
#define CommOffsetBtOutBufInPtr    1417 /*!< Offset to Bluetooth output buffer front pointer (1 byte) */
#define CommOffsetBtOutBufOutPtr   1418 /*!< Offset to Bluetooth output buffer back pointer (1 byte) */
// HI Speed related entries
//  HSBUF          HsInBuf; (132 bytes)
#define CommOffsetHsInBufBuf       1421 /*!< Offset to High Speed input buffer data (128 bytes) */
#define CommOffsetHsInBufInPtr     1549 /*!< Offset to High Speed input buffer front pointer (1 byte) */
#define CommOffsetHsInBufOutPtr    1550 /*!< Offset to High Speed input buffer back pointer (1 byte) */
//  HSBUF          HsOutBuf; (132 bytes)
#define CommOffsetHsOutBufBuf      1553 /*!< Offset to High Speed output buffer data (128 bytes) */
#define CommOffsetHsOutBufInPtr    1681 /*!< Offset to High Speed output buffer front pointer (1 byte) */
#define CommOffsetHsOutBufOutPtr   1682 /*!< Offset to High Speed output buffer back pointer (1 byte) */
// USB related entries
//  USBBUF         UsbInBuf; (68 bytes)
#define CommOffsetUsbInBufBuf        1685 /*!< Offset to Usb input buffer data (64 bytes) */
#define CommOffsetUsbInBufInPtr      1749 /*!< Offset to Usb input buffer front pointer (1 byte) */
#define CommOffsetUsbInBufOutPtr     1750 /*!< Offset to Usb input buffer back pointer (1 byte) */
//  USBBUF         UsbOutBuf; (68 bytes)
#define CommOffsetUsbOutBufBuf       1753 /*!< Offset to Usb output buffer data (64 bytes) */
#define CommOffsetUsbOutBufInPtr     1817 /*!< Offset to Usb output buffer front pointer (1 byte) */
#define CommOffsetUsbOutBufOutPtr    1818 /*!< Offset to Usb output buffer back pointer (1 byte) */
//  USBBUF         UsbPollBuf; (68 bytes)
#define CommOffsetUsbPollBufBuf      1821 /*!< Offset to Usb Poll buffer data (64 bytes) */
#define CommOffsetUsbPollBufInPtr    1885 /*!< Offset to Usb Poll buffer front pointer (1 byte) */
#define CommOffsetUsbPollBufOutPtr   1886 /*!< Offset to Usb Poll buffer back pointer (1 byte) */

#define CommOffsetBtDeviceCnt      1889 /*!< Offset to Bluetooth device count (1 byte) */
#define CommOffsetBtDeviceNameCnt  1890 /*!< Offset to Bluetooth device name count (1 byte) */
#define CommOffsetHsFlags          1891 /*!< Offset to High Speed flags (1 byte) */
#define CommOffsetHsSpeed          1892 /*!< Offset to High Speed speed (1 byte) */
#define CommOffsetHsState          1893 /*!< Offset to High Speed state (1 byte) */
#define CommOffsetUsbState         1894 /*!< Offset to Usb State (1 byte) */
#define CommOffsetHsAddress        1895 /*!< Offset to High Speed address (1 byte) */
#ifdef __ENHANCED_FIRMWARE
#define CommOffsetHsMode           1896 /*!< Offset to High Speed mode (2 bytes) */
#define CommOffsetBtDataMode       1898 /*!< Offset to Bluetooth data mode (1 byte) */
#define CommOffsetHsDataMode       1899 /*!< Offset to High Speed data mode (1 byte) */
#endif
/** @} */  // end of CommIOMAP group
/** @} */  // end of CommModuleConstants group
/** @} */  // end of CommModule group


/** @addtogroup ThirdPartyDevices
 * @{
 */
/** @defgroup RCXAPIConstants RCX constants
 * Constants that are for use with devices that communicate with the RCX or
 * Scout programmable bricks via IR such as the HiTechnic IRLink or the
 * MindSensors nRLink.
 * @{
 */
/** @defgroup RCXOutputConstants RCX output constants
 * Constants for use when choosing RCX outputs.
 * @{
 */
#define RCX_OUT_A   0x01 /*!< RCX Output A */
#define RCX_OUT_B   0x02 /*!< RCX Output B */
#define RCX_OUT_C   0x04 /*!< RCX Output C */
#define RCX_OUT_AB  0x03 /*!< RCX Outputs A and B */
#define RCX_OUT_AC  0x05 /*!< RCX Outputs A and C */
#define RCX_OUT_BC  0x06 /*!< RCX Outputs B and C */
#define RCX_OUT_ABC 0x07 /*!< RCX Outputs A, B, and C */
/** @} */  // end of RCXOutputConstants group

/** @defgroup RCXOutputMode RCX output mode constants
 * Constants for use when configuring RCX output mode.
 * @{
 */
#define RCX_OUT_FLOAT 0    /*!< Set RCX output to float */
#define RCX_OUT_OFF   0x40 /*!< Set RCX output to off */
#define RCX_OUT_ON    0x80 /*!< Set RCX output to on */
/** @} */  // end of RCXOutputMode group

/** @defgroup RCXOutputDirection RCX output direction constants
 * Constants for use when configuring RCX output direction.
 * @{
 */
#define RCX_OUT_REV    0    /*!< Set RCX output direction to reverse */
#define RCX_OUT_TOGGLE 0x40 /*!< Set RCX output direction to toggle */
#define RCX_OUT_FWD    0x80 /*!< Set RCX output direction to forward */
/** @} */  // end of RCXOutputConstants group

/** @defgroup RCXOutputPower RCX output power constants
 * Constants for use when configuring RCX output power.
 * @{
 */
#define RCX_OUT_LOW  0 /*!< Set RCX output power level to low */
#define RCX_OUT_HALF 3 /*!< Set RCX output power level to half */
#define RCX_OUT_FULL 7 /*!< Set RCX output power level to full */
/** @} */  // end of RCXOutputPower group

/** @defgroup RCXRemoteConstants RCX IR remote constants
 * Constants for use when simulating RCX IR remote messages.
 * @{
 */
#define RCX_RemoteKeysReleased 0x0000 /*!< All remote keys have been released */
#define RCX_RemotePBMessage1   0x0100 /*!< Send PB message 1 */
#define RCX_RemotePBMessage2   0x0200 /*!< Send PB message 2 */
#define RCX_RemotePBMessage3   0x0400 /*!< Send PB message 3 */
#define RCX_RemoteOutAForward  0x0800 /*!< Set output A forward */
#define RCX_RemoteOutBForward  0x1000 /*!< Set output B forward */
#define RCX_RemoteOutCForward  0x2000 /*!< Set output C forward */
#define RCX_RemoteOutABackward 0x4000 /*!< Set output A backward */
#define RCX_RemoteOutBBackward 0x8000 /*!< Set output B backward */
#define RCX_RemoteOutCBackward 0x0001 /*!< Set output C backward */
#define RCX_RemoteSelProgram1  0x0002 /*!< Select program 1 */
#define RCX_RemoteSelProgram2  0x0004 /*!< Select program 2 */
#define RCX_RemoteSelProgram3  0x0008 /*!< Select program 3 */
#define RCX_RemoteSelProgram4  0x0010 /*!< Select program 4 */
#define RCX_RemoteSelProgram5  0x0020 /*!< Select program 5 */
#define RCX_RemoteStopOutOff   0x0040 /*!< Stop and turn off outputs */
#define RCX_RemotePlayASound   0x0080 /*!< Play a sound */
/** @} */  // end of RCXRemoteConstants group

/** @defgroup RCXSoundConstants RCX and Scout sound constants
 * Constants for use when playing standard RCX and Scout sounds.
 * @{
 */
#define SOUND_CLICK       0 /*!< Play the standard key click sound */
#define SOUND_DOUBLE_BEEP 1 /*!< Play the standard double beep sound */
#define SOUND_DOWN        2 /*!< Play the standard sweep down sound */
#define SOUND_UP          3 /*!< Play the standard sweep up sound */
#define SOUND_LOW_BEEP    4 /*!< Play the standard low beep sound */
#define SOUND_FAST_UP     5 /*!< Play the standard fast up sound */
/** @} */  // end of RCXSoundConstants group

/** @defgroup ScoutConstants Scout constants
 * Constants for use when controlling the Scout brick.
 * @{
 */
/** @defgroup ScoutLightConstants Scout light constants
 * Constants for use when controlling the Scout light settings.
 * @{
 */
#define SCOUT_LIGHT_ON        0x80 /*!< Turn on the scout light */
#define SCOUT_LIGHT_OFF       0    /*!< Turn off the scout light */
/** @} */  // end of ScoutLightConstants group

/** @defgroup ScoutSoundConstants Scout sound constants
 * Constants for use when playing standard Scout sounds.
 * @{
 */
#define SCOUT_SOUND_REMOTE           6 /*!< Play the Scout remote sound */
#define SCOUT_SOUND_ENTERSA          7 /*!< Play the Scout enter standalone sound */
#define SCOUT_SOUND_KEYERROR         8 /*!< Play the Scout key error sound */
#define SCOUT_SOUND_NONE             9 /*!< Play the Scout none sound */
#define SCOUT_SOUND_TOUCH1_PRES     10 /*!< Play the Scout touch 1 pressed sound */
#define SCOUT_SOUND_TOUCH1_REL      11 /*!< Play the Scout touch 1 released sound */
#define SCOUT_SOUND_TOUCH2_PRES     12 /*!< Play the Scout touch 2 pressed sound */
#define SCOUT_SOUND_TOUCH2_REL      13 /*!< Play the Scout touch 2 released sound */
#define SCOUT_SOUND_ENTER_BRIGHT    14 /*!< Play the Scout enter bright sound */
#define SCOUT_SOUND_ENTER_NORMAL    15 /*!< Play the Scout enter normal sound */
#define SCOUT_SOUND_ENTER_DARK      16 /*!< Play the Scout enter dark sound */
#define SCOUT_SOUND_1_BLINK         17 /*!< Play the Scout 1 blink sound */
#define SCOUT_SOUND_2_BLINK         18 /*!< Play the Scout 2 blink sound */
#define SCOUT_SOUND_COUNTER1        19 /*!< Play the Scout counter 1 sound */
#define SCOUT_SOUND_COUNTER2        20 /*!< Play the Scout counter 2 sound */
#define SCOUT_SOUND_TIMER1          21 /*!< Play the Scout timer 1 sound */
#define SCOUT_SOUND_TIMER2          22 /*!< Play the Scout timer 2 sound */
#define SCOUT_SOUND_TIMER3          23 /*!< Play the Scout timer 3 sound */
#define SCOUT_SOUND_MAIL_RECEIVED   24 /*!< Play the Scout mail received sound */
#define SCOUT_SOUND_SPECIAL1        25 /*!< Play the Scout special 1 sound */
#define SCOUT_SOUND_SPECIAL2        26 /*!< Play the Scout special 2 sound */
#define SCOUT_SOUND_SPECIAL3        27 /*!< Play the Scout special 3 sound */
/** @} */  // end of ScoutSoundConstants group

/** @defgroup ScoutSndSetConstants Scout sound set constants
 * Constants for use when choosing standard Scout sound sets.
 * @{
 */
#define SCOUT_SNDSET_NONE           0 /*!< Set sound set to none */
#define SCOUT_SNDSET_BASIC          1 /*!< Set sound set to basic */
#define SCOUT_SNDSET_BUG            2 /*!< Set sound set to bug */
#define SCOUT_SNDSET_ALARM          3 /*!< Set sound set to alarm */
#define SCOUT_SNDSET_RANDOM         4 /*!< Set sound set to random */
#define SCOUT_SNDSET_SCIENCE        5 /*!< Set sound set to science */
/** @} */  // end of ScoutSndSetConstants group

/** @defgroup ScoutModeConstants Scout mode constants
 * Constants for use when setting the scout mode.
 * @{
 */
#define SCOUT_MODE_STANDALONE       0 /*!< Enter stand alone mode */
#define SCOUT_MODE_POWER            1 /*!< Enter power mode */
/** @} */  // end of ScoutModeConstants group

/** @defgroup ScoutMotionRuleConstants Scout motion rule constants
 * Constants for use when setting the scout motion rule.
 * @{
 */
#define SCOUT_MR_NO_MOTION          0 /*!< Motion rule none */
#define SCOUT_MR_FORWARD            1 /*!< Motion rule forward */
#define SCOUT_MR_ZIGZAG             2 /*!< Motion rule zigzag */
#define SCOUT_MR_CIRCLE_RIGHT       3 /*!< Motion rule circle right */
#define SCOUT_MR_CIRCLE_LEFT        4 /*!< Motion rule circle left */
#define SCOUT_MR_LOOP_A             5 /*!< Motion rule loop A */
#define SCOUT_MR_LOOP_B             6 /*!< Motion rule loop B */
#define SCOUT_MR_LOOP_AB            7 /*!< Motion rule loop A then B */
/** @} */  // end of ScoutMotionRuleConstants group

/** @defgroup ScoutTouchRuleConstants Scout touch rule constants
 * Constants for use when setting the scout touch rule.
 * @{
 */
#define SCOUT_TR_IGNORE             0 /*!< Touch rule ignore */
#define SCOUT_TR_REVERSE            1 /*!< Touch rule reverse */
#define SCOUT_TR_AVOID              2 /*!< Touch rule avoid */
#define SCOUT_TR_WAIT_FOR           3 /*!< Touch rule wait for */
#define SCOUT_TR_OFF_WHEN           4 /*!< Touch rule off when */
/** @} */  // end of ScoutTouchRuleConstants group

/** @defgroup ScoutLightRuleConstants Scout light rule constants
 * Constants for use when setting the scout light rule.
 * @{
 */
#define SCOUT_LR_IGNORE             0 /*!< Light rule ignore */
#define SCOUT_LR_SEEK_LIGHT         1 /*!< Light rule seek light */
#define SCOUT_LR_SEEK_DARK          2 /*!< Light rule seek dark */
#define SCOUT_LR_AVOID              3 /*!< Light rule avoid */
#define SCOUT_LR_WAIT_FOR           4 /*!< Light rule wait for */
#define SCOUT_LR_OFF_WHEN           5 /*!< Light rule off when */
/** @} */  // end of ScoutLightRuleConstants group

/** @defgroup ScoutTransmitRuleConstants Scout transmit rule constants
 * Constants for use when setting the scout transmit rule.
 * @{
 */
#define SCOUT_TGS_SHORT             0 /*!< Transmit level short */
#define SCOUT_TGS_MEDIUM            1 /*!< Transmit level medium */
#define SCOUT_TGS_LONG              2 /*!< Transmit level long */
/** @} */  // end of ScoutTransmitRuleConstants group

/** @defgroup ScoutSpecialEffectConstants Scout special effect constants
 * Constants for use when setting the scout special effect.
 * @{
 */
#define SCOUT_FXR_NONE              0 /*!< No special effects */
#define SCOUT_FXR_BUG               1 /*!< Bug special effects */
#define SCOUT_FXR_ALARM             2 /*!< Alarm special effects */
#define SCOUT_FXR_RANDOM            3 /*!< Random special effects */
#define SCOUT_FXR_SCIENCE           4 /*!< Science special effects */
/** @} */  // end of ScoutSpecialEffectConstants group
/** @} */  // end of ScoutConstants group

/** @defgroup RCXSourceConstants RCX and Scout source constants
 * Constants for use when specifying RCX and Scout sources.
 * @{
 */
#define RCX_VariableSrc             0  /*!< The RCX variable source */
#define RCX_TimerSrc                1  /*!< The RCX timer source */
#define RCX_ConstantSrc             2  /*!< The RCX constant value source */
#define RCX_OutputStatusSrc         3  /*!< The RCX output status source */
#define RCX_RandomSrc               4  /*!< The RCX random number source */
#define RCX_ProgramSlotSrc          8  /*!< The RCX program slot source */
#define RCX_InputValueSrc           9  /*!< The RCX input value source */
#define RCX_InputTypeSrc            10 /*!< The RCX input type source */
#define RCX_InputModeSrc            11 /*!< The RCX input mode source */
#define RCX_InputRawSrc             12 /*!< The RCX input raw source */
#define RCX_InputBooleanSrc         13 /*!< The RCX input boolean source */
#define RCX_WatchSrc                14 /*!< The RCX watch source */
#define RCX_MessageSrc              15 /*!< The RCX message source */
#define RCX_GlobalMotorStatusSrc    17 /*!< The RCX global motor status source */
#define RCX_ScoutRulesSrc           18 /*!< The Scout rules source */
#define RCX_ScoutLightParamsSrc     19 /*!< The Scout light parameters source */
#define RCX_ScoutTimerLimitSrc      20 /*!< The Scout timer limit source */
#define RCX_CounterSrc              21 /*!< The RCX counter source */
#define RCX_ScoutCounterLimitSrc    22 /*!< The Scout counter limit source */
#define RCX_TaskEventsSrc           23 /*!< The RCX task events source */
#define RCX_ScoutEventFBSrc         24 /*!< The Scout event feedback source */
#define RCX_EventStateSrc           25 /*!< The RCX event static source */
#define RCX_TenMSTimerSrc           26 /*!< The RCX 10ms timer source */
#define RCX_ClickCounterSrc         27 /*!< The RCX event click counter source */
#define RCX_UpperThresholdSrc       28 /*!< The RCX event upper threshold source */
#define RCX_LowerThresholdSrc       29 /*!< The RCX event lower threshold source */
#define RCX_HysteresisSrc           30 /*!< The RCX event hysteresis source */
#define RCX_DurationSrc             31 /*!< The RCX event duration source */
#define RCX_UARTSetupSrc            33 /*!< The RCX UART setup source */
#define RCX_BatteryLevelSrc         34 /*!< The RCX battery level source */
#define RCX_FirmwareVersionSrc      35 /*!< The RCX firmware version source */
#define RCX_IndirectVarSrc          36 /*!< The RCX indirect variable source */
#define RCX_DatalogSrcIndirectSrc   37 /*!< The RCX indirect datalog source source */
#define RCX_DatalogSrcDirectSrc     38 /*!< The RCX direct datalog source source */
#define RCX_DatalogValueIndirectSrc 39 /*!< The RCX indirect datalog value source */
#define RCX_DatalogValueDirectSrc   40 /*!< The RCX direct datalog value source */
#define RCX_DatalogRawIndirectSrc   41 /*!< The RCX indirect datalog raw source */
#define RCX_DatalogRawDirectSrc     42 /*!< The RCX direct datalog raw source */
/** @} */  // end of RCXSourceConstants group

/** @defgroup RCXOpcodeConstants RCX and Scout opcode constants
 * Constants for use when specifying RCX and Scout opcodes.
 * @{
 */
#define RCX_PingOp           0x10 /*!< Ping the brick */
#define RCX_BatteryLevelOp   0x30 /*!< Read the battery level */
#define RCX_DeleteTasksOp    0x40 /*!< Delete tasks */
#define RCX_StopAllTasksOp   0x50 /*!< Stop all tasks */
#define RCX_PBTurnOffOp      0x60 /*!< Turn off the brick */
#define RCX_DeleteSubsOp     0x70 /*!< Delete subroutines */
#define RCX_ClearSoundOp     0x80 /*!< Clear sound */
#define RCX_ClearMsgOp       0x90 /*!< Clear message */
#define RCX_LSCalibrateOp    0xc0 /*!< Calibrate the light sensor */
#define RCX_MuteSoundOp      0xd0 /*!< Mute sound */
#define RCX_UnmuteSoundOp    0xe0 /*!< Unmute sound */
#define RCX_ClearAllEventsOp 0x06 /*!< Clear all events */
#define RCX_OnOffFloatOp     0x21 /*!< Control motor state - on, off, float */
#define RCX_IRModeOp         0x31 /*!< Set the IR transmit mode */
#define RCX_PlaySoundOp      0x51 /*!< Play a sound */
#define RCX_DeleteTaskOp     0x61 /*!< Delete a task */
#define RCX_StartTaskOp      0x71 /*!< Start a task */
#define RCX_StopTaskOp       0x81 /*!< Stop a task */
#define RCX_SelectProgramOp  0x91 /*!< Select a program slot */
#define RCX_ClearTimerOp     0xa1 /*!< Clear a timer */
#define RCX_AutoOffOp        0xb1 /*!< Set auto off timer */
#define RCX_DeleteSubOp      0xc1 /*!< Delete a subroutine */
#define RCX_ClearSensorOp    0xd1 /*!< Clear a sensor */
#define RCX_OutputDirOp      0xe1 /*!< Set the motor direction */
#define RCX_PlayToneVarOp    0x02 /*!< Play a tone using a variable */
#define RCX_PollOp           0x12 /*!< Poll a source/value combination */
#define RCX_SetWatchOp       0x22 /*!< Set the watch source/value */
#define RCX_InputTypeOp      0x32 /*!< Set the input type */
#define RCX_InputModeOp      0x42 /*!< Set the input mode */
#define RCX_SetDatalogOp     0x52 /*!< Set the datalog size */
#define RCX_DatalogOp        0x62 /*!< Datalog the specified source/value*/
#define RCX_SendUARTDataOp   0xc2 /*!< Send data via IR using UART settings */
#define RCX_RemoteOp         0xd2 /*!< Execute simulated remote control buttons */
#define RCX_VLLOp            0xe2 /*!< Send visual light link (VLL) data */
#define RCX_DirectEventOp    0x03 /*!< Fire an event */
#define RCX_OutputPowerOp    0x13 /*!< Set the motor power level */
#define RCX_PlayToneOp       0x23 /*!< Play a tone */
#define RCX_DisplayOp        0x33 /*!< Set LCD display value */
#define RCX_PollMemoryOp     0x63 /*!< Poll a memory location */
#define RCX_SetFeedbackOp    0x83 /*!< Set Scout feedback */
#define RCX_SetEventOp       0x93 /*!< Set an event */
#define RCX_GOutputPowerOp   0xa3 /*!< Set global motor power levels */
#define RCX_LSUpperThreshOp  0xb3 /*!< Set the light sensor upper threshold */
#define RCX_LSLowerThreshOp  0xc3 /*!< Set the light sensor lower threshold */
#define RCX_LSHysteresisOp   0xd3 /*!< Set the light sensor hysteresis */
#define RCX_LSBlinkTimeOp    0xe3 /*!< Set the light sensor blink time */
#define RCX_CalibrateEventOp 0x04 /*!< Calibrate event */
#define RCX_SetVarOp         0x14 /*!< Set function */
#define RCX_SumVarOp         0x24 /*!< Sum function */
#define RCX_SubVarOp         0x34 /*!< Subtract function */
#define RCX_DivVarOp         0x44 /*!< Divide function */
#define RCX_MulVarOp         0x54 /*!< Multiply function */
#define RCX_SgnVarOp         0x64 /*!< Sign function */
#define RCX_AbsVarOp         0x74 /*!< Absolute value function */
#define RCX_AndVarOp         0x84 /*!< AND function */
#define RCX_OrVarOp          0x94 /*!< OR function */
#define RCX_UploadDatalogOp  0xa4 /*!< Upload datalog contents */
#define RCX_SetTimerLimitOp  0xc4 /*!< Set timer limit */
#define RCX_SetCounterOp     0xd4 /*!< Set counter value */
#define RCX_SetSourceValueOp 0x05 /*!< Set a source/value*/
#define RCX_UnlockOp         0x15 /*!< Unlock the brick */
#define RCX_BootModeOp       0x65 /*!< Set into book mode */
#define RCX_UnlockFirmOp     0xa5 /*!< Unlock the firmware */
#define RCX_ScoutRulesOp     0xd5 /*!< Set Scout rules */
#define RCX_ViewSourceValOp  0xe5 /*!< View a source/value */
#define RCX_ScoutOp          0x47 /*!< Scout opcode */
#define RCX_SoundOp          0x57 /*!< Sound opcode */
#define RCX_GOutputModeOp    0x67 /*!< Set global motor mode */
#define RCX_GOutputDirOp     0x77 /*!< Set global motor direction */
#define RCX_LightOp          0x87 /*!< Light opcode */
#define RCX_IncCounterOp     0x97 /*!< Increment a counter */
#define RCX_DecCounterOp     0xa7 /*!< Decrement a counter */
#define RCX_ClearCounterOp   0xb7 /*!< Clear a counter */
#define RCX_SetPriorityOp    0xd7 /*!< Set task priority */
#define RCX_MessageOp        0xf7 /*!< Set message */
/** @} */  // end of RCXOpcodeConstants group
/** @} */  // end of RCXAPIConstants group

/** @defgroup HTIRLinkPFConstants HiTechnic/mindsensors Power Function/IR Train constants
 * Constants that are for use with the HiTechnic IRLink or mindsensors nRLink
 * in Power Function or IR Train mode.
 * @{
 */
/** @defgroup PFCmdConstants Power Function command constants
 * Constants that are for sending Power Function commands.
 * @{
 */
#define PF_CMD_STOP  0 /*!< Power function command stop */
#define PF_CMD_FLOAT 0 /*!< Power function command float (same as stop) */
#define PF_CMD_FWD   1 /*!< Power function command forward */
#define PF_CMD_REV   2 /*!< Power function command reverse */
#define PF_CMD_BRAKE 3 /*!< Power function command brake */
/** @} */  // end of PFCmdConstants group

/** @defgroup PFChannelConstants Power Function channel constants
 * Constants that are for specifying Power Function channels.
 * @{
 */
#define PF_CHANNEL_1 0 /*!< Power function channel 1 */
#define PF_CHANNEL_2 1 /*!< Power function channel 2 */
#define PF_CHANNEL_3 2 /*!< Power function channel 3 */
#define PF_CHANNEL_4 3 /*!< Power function channel 4 */
/** @} */  // end of PFChannelConstants group

/** @defgroup PFModeConstants Power Function mode constants
 * Constants that are for choosing Power Function modes.
 * @{
 */
#define PF_MODE_TRAIN             0 /*!< Power function mode IR Train */
#define PF_MODE_COMBO_DIRECT      1 /*!< Power function mode combo direct */
#define PF_MODE_SINGLE_PIN_CONT   2 /*!< Power function mode single pin continuous */
#define PF_MODE_SINGLE_PIN_TIME   3 /*!< Power function mode single pin timed */
#define PF_MODE_COMBO_PWM         4 /*!< Power function mode combo pulse width modulation (PWM) */
#define PF_MODE_SINGLE_OUTPUT_PWM 4 /*!< Power function mode single output pulse width modulation (PWM) */
#define PF_MODE_SINGLE_OUTPUT_CST 6 /*!< Power function mode single output clear, set, toggle (CST) */
/** @} */  // end of PFModeConstants group

/** @defgroup IRTrainFuncs PF/IR Train function constants
 * Constants that are for sending PF/IR Train functions.
 * @{
 */
#define TRAIN_FUNC_STOP         0 /*!< PF/IR Train function stop */
#define TRAIN_FUNC_INCR_SPEED   1 /*!< PF/IR Train function increment speed */
#define TRAIN_FUNC_DECR_SPEED   2 /*!< PF/IR Train function decrement speed */
#define TRAIN_FUNC_TOGGLE_LIGHT 4 /*!< PF/IR Train function toggle light */
/** @} */  // end of IRTrainFuncs group

/** @defgroup IRTrainChannels IR Train channel constants
 * Constants that are for specifying IR Train channels.
 * @{
 */
#define TRAIN_CHANNEL_1   0 /*!< IR Train channel 1 */
#define TRAIN_CHANNEL_2   1 /*!< IR Train channel 2 */
#define TRAIN_CHANNEL_3   2 /*!< IR Train channel 3 */
#define TRAIN_CHANNEL_ALL 3 /*!< IR Train channel all */
/** @} */  // end of IRTrainChannels group

/** @defgroup PFOutputs Power Function output constants
 * Constants that are for choosing a Power Function output.
 * @{
 */
#define PF_OUT_A 0 /*!< Power function output A */
#define PF_OUT_B 1 /*!< Power function output B */
/** @} */  // end of PFOutputs group

/** @defgroup PFPinConstants Power Function pin constants
 * Constants that are for choosing a Power Function pin.
 * @{
 */
#define PF_PIN_C1 0 /*!< Power function pin C1 */
#define PF_PIN_C2 1 /*!< Power function pin C2 */
/** @} */  // end of PFOutputs group

/** @defgroup PFPinFuncs Power Function single pin function constants
 * Constants that are for sending Power Function single pin functions.
 * @{
 */
#define PF_FUNC_NOCHANGE 0 /*!< Power function single pin - no change */
#define PF_FUNC_CLEAR    1 /*!< Power function single pin - clear */
#define PF_FUNC_SET      2 /*!< Power function single pin - set */
#define PF_FUNC_TOGGLE   3 /*!< Power function single pin - toggle */
/** @} */  // end of PFCSTFuncs group

/** @defgroup PFCSTOptions Power Function CST options constants
 * Constants that are for specifying Power Function CST options.
 * @{
 */
#define PF_CST_CLEAR1_CLEAR2 0 /*!< Power function CST clear 1 and clear 2 */
#define PF_CST_SET1_CLEAR2   1 /*!< Power function CST set 1 and clear 2*/
#define PF_CST_CLEAR1_SET2   2 /*!< Power function CST clear 1 and set 2 */
#define PF_CST_SET1_SET2     3 /*!< Power function CST set 1 and set 2 */
#define PF_CST_INCREMENT_PWM 4 /*!< Power function CST increment PWM */
#define PF_CST_DECREMENT_PWM 5 /*!< Power function CST decrement PWM */
#define PF_CST_FULL_FWD      6 /*!< Power function CST full forward */
#define PF_CST_FULL_REV      7 /*!< Power function CST full reverse */
#define PF_CST_TOGGLE_DIR    8 /*!< Power function CST toggle direction*/
/** @} */  // end of PFCSTOptions group

/** @defgroup PFPWMOptions Power Function PWM option constants
 * Constants that are for specifying Power Function PWM options.
 * @{
 */
#define PF_PWM_FLOAT 0  /*!< Power function PWM float */
#define PF_PWM_FWD1  1  /*!< Power function PWM foward level 1 */
#define PF_PWM_FWD2  2  /*!< Power function PWM foward level 2 */
#define PF_PWM_FWD3  3  /*!< Power function PWM foward level 3 */
#define PF_PWM_FWD4  4  /*!< Power function PWM foward level 4 */
#define PF_PWM_FWD5  5  /*!< Power function PWM foward level 5 */
#define PF_PWM_FWD6  6  /*!< Power function PWM foward level 6 */
#define PF_PWM_FWD7  7  /*!< Power function PWM foward level 7 */
#define PF_PWM_BRAKE 8  /*!< Power function PWM brake */
#define PF_PWM_REV7  9  /*!< Power function PWM reverse level 7  */
#define PF_PWM_REV6  10 /*!< Power function PWM reverse level 6 */
#define PF_PWM_REV5  11 /*!< Power function PWM reverse level 5 */
#define PF_PWM_REV4  12 /*!< Power function PWM reverse level 4 */
#define PF_PWM_REV3  13 /*!< Power function PWM reverse level 3 */
#define PF_PWM_REV2  14 /*!< Power function PWM reverse level 2 */
#define PF_PWM_REV1  15 /*!< Power function PWM reverse level 1 */
/** @} */  // end of PFPWMOptions group
/** @} */  // end of HTIRLinkPFConstants group

/** @addtogroup HiTechnicAPI
 * @{
 */
/** @defgroup HiTechnicConstants HiTechnic device constants
 * Constants that are for use with HiTechnic devices.
 * @{
 */

#define HT_ADDR_IRSEEKER   0x02 /*!< HiTechnic IRSeeker I2C address */
#define HT_ADDR_IRSEEKER2  0x10 /*!< HiTechnic IRSeeker2 I2C address */
#define HT_ADDR_IRRECEIVER 0x02 /*!< HiTechnic IRReceiver I2C address */
#define HT_ADDR_COMPASS    0x02 /*!< HiTechnic Compass I2C address */
#define HT_ADDR_ACCEL      0x02 /*!< HiTechnic Accel I2C address */
#define HT_ADDR_COLOR      0x02 /*!< HiTechnic Color I2C address */
#define HT_ADDR_COLOR2     0x02 /*!< HiTechnic Color2 I2C address */
#define HT_ADDR_IRLINK     0x02 /*!< HiTechnic IRLink I2C address */
#define HT_ADDR_ANGLE      0x02 /*!< HiTechnic Angle I2C address */
#define HT_ADDR_BAROMETRIC 0x02 /*!< HiTechnic Barometric I2C address */
#define HT_ADDR_PROTOBOARD 0x02 /*!< HiTechnic Prototype board I2C address */
#define HT_ADDR_SUPERPRO   0x10 /*!< HiTechnic SuperPro board I2C address */

/** @defgroup HTIRSeeker2Constants HiTechnic IRSeeker2 constants
 * Constants that are for use with the HiTechnic IRSeeker2 device.
 * @{
 */
#define HTIR2_MODE_1200 0 /*!< Set IRSeeker2 to 1200 mode */
#define HTIR2_MODE_600  1 /*!< Set IRSeeker2 to 600 mode */

#define HTIR2_REG_MODE  0x41 /*!< IRSeeker2 mode register */
#define HTIR2_REG_DCDIR 0x42 /*!< IRSeeker2 DC direction register */
#define HTIR2_REG_DC01  0x43 /*!< IRSeeker2 DC 01 register */
#define HTIR2_REG_DC02  0x44 /*!< IRSeeker2 DC 02 register */
#define HTIR2_REG_DC03  0x45 /*!< IRSeeker2 DC 03 register */
#define HTIR2_REG_DC04  0x46 /*!< IRSeeker2 DC 04 register */
#define HTIR2_REG_DC05  0x47 /*!< IRSeeker2 DC 05 register */
#define HTIR2_REG_DCAVG 0x48 /*!< IRSeeker2 DC average register */
#define HTIR2_REG_ACDIR 0x49 /*!< IRSeeker2 AC direction register */
#define HTIR2_REG_AC01  0x4A /*!< IRSeeker2 AC 01 register */
#define HTIR2_REG_AC02  0x4B /*!< IRSeeker2 AC 02 register */
#define HTIR2_REG_AC03  0x4C /*!< IRSeeker2 AC 03 register */
#define HTIR2_REG_AC04  0x4D /*!< IRSeeker2 AC 04 register */
#define HTIR2_REG_AC05  0x4E /*!< IRSeeker2 AC 05 register */
/** @} */  // end of HTIRSeeker2Constants group

/** @defgroup HTIRReceiverConstants HiTechnic IRReceiver constants
 * Constants that are for use with the HiTechnic IRReceiver device.
 * @{
 */
#define HT_CH1_A 0 /*!< Use IRReceiver channel 1 output A */
#define HT_CH1_B 1 /*!< Use IRReceiver channel 1 output B */
#define HT_CH2_A 2 /*!< Use IRReceiver channel 2 output A */
#define HT_CH2_B 3 /*!< Use IRReceiver channel 2 output B */
#define HT_CH3_A 4 /*!< Use IRReceiver channel 3 output A */
#define HT_CH3_B 5 /*!< Use IRReceiver channel 3 output B */
#define HT_CH4_A 6 /*!< Use IRReceiver channel 4 output A */
#define HT_CH4_B 7 /*!< Use IRReceiver channel 4 output B */
/** @} */  // end of HTIRSeeker2Constants group

/** @defgroup HTColor2Constants HiTechnic Color2 constants
 * Constants that are for use with the HiTechnic Color2 device.
 * @{
 */
#define HT_CMD_COLOR2_ACTIVE  0x00 /*!< Set the Color2 sensor to active mode */
#define HT_CMD_COLOR2_PASSIVE 0x01 /*!< Set the Color2 sensor to passive mode */
#define HT_CMD_COLOR2_RAW     0x03 /*!< Set the Color2 sensor to raw mode */
#define HT_CMD_COLOR2_50HZ    0x35 /*!< Set the Color2 sensor to 50Hz mode */
#define HT_CMD_COLOR2_60HZ    0x36 /*!< Set the Color2 sensor to 60Hz mode */
#define HT_CMD_COLOR2_BLCAL   0x42 /*!< Set the Color2 sensor to black level calibration mode */
#define HT_CMD_COLOR2_WBCAL   0x43 /*!< Set the Color2 sensor to white level calibration mode */
#define HT_CMD_COLOR2_FAR     0x46 /*!< Set the Color2 sensor to far mode */
#define HT_CMD_COLOR2_LED_HI  0x48 /*!< Set the Color2 sensor to LED high mode */
#define HT_CMD_COLOR2_LED_LOW 0x4C /*!< Set the Color2 sensor to LED low mode */
#define HT_CMD_COLOR2_NEAR    0x4E /*!< Set the Color2 sensor to near mode */
/** @} */  // end of HTColor2Constants group

/** @defgroup HTAngleConstants HiTechnic Angle sensor constants
 * Constants that are for use with the HiTechnic Angle sensor device.
 * @{
 */
#define HTANGLE_MODE_NORMAL    0x00 /*!< Normal angle measurement mode */
#define HTANGLE_MODE_CALIBRATE 0x43 /*!< Resets 0 degree position to current shaft angle */
#define HTANGLE_MODE_RESET     0x52 /*!< Resets the accumulated angle */

#define HTANGLE_REG_MODE  0x41 /*!< Angle mode register */
#define HTANGLE_REG_DCDIR 0x42 /*!< Angle current angle (2 degree increments) register */
#define HTANGLE_REG_DC01  0x43 /*!< Angle current angle (1 degree adder) register */
#define HTANGLE_REG_DC02  0x44 /*!< Angle 32 bit accumulated angle, high byte register */
#define HTANGLE_REG_DC03  0x45 /*!< Angle 32 bit accumulated angle, mid byte register */
#define HTANGLE_REG_DC04  0x46 /*!< Angle 32 bit accumulated angle, mid byte register */
#define HTANGLE_REG_DC05  0x47 /*!< Angle 32 bit accumulated angle, low byte register */
#define HTANGLE_REG_DCAVG 0x48 /*!< Angle 16 bit revolutions per minute, high byte register */
#define HTANGLE_REG_ACDIR 0x49 /*!< Angle 16 bit revolutions per minute, low byte register */
/** @} */  // end of HTAngleConstants group

/** @defgroup HTBarometricConstants HiTechnic Barometric sensor constants
 * Constants that are for use with the HiTechnic Barometric sensor device.
 * @{
 */
#define HTBAR_REG_COMMAND     0x40 /*!< Barometric sensor command register */
#define HTBAR_REG_TEMPERATURE 0x42 /*!< Barometric sensor temperature register (2 bytes msb/lsb) */
#define HTBAR_REG_PRESSURE    0x44 /*!< Barometric sensor pressure register (2 bytes msb/lsb) */
#define HTBAR_REG_CALIBRATION 0x46 /*!< Barometric sensor calibration register (2 bytes msb/lsb) */
/** @} */  // end of HTBarometricConstants group

/** @defgroup HTProtoConstants HiTechnic Prototype board constants
 * Constants that are for use with the HiTechnic Prototype board.
 * @{
 */
#define HTPROTO_REG_A0    0x42 /*!< Prototype board analog 0 register (2 bytes msb/lsb) */
#define HTPROTO_REG_A1    0x44 /*!< Prototype board analog 1 register (2 bytes msb/lsb) */
#define HTPROTO_REG_A2    0x46 /*!< Prototype board analog 2 register (2 bytes msb/lsb) */
#define HTPROTO_REG_A3    0x48 /*!< Prototype board analog 3 register (2 bytes msb/lsb) */
#define HTPROTO_REG_A4    0x4A /*!< Prototype board analog 4 register (2 bytes msb/lsb) */
#define HTPROTO_REG_DIN   0x4C /*!< Prototype board digital pin input register (6 bits) */
#define HTPROTO_REG_DOUT  0x4D /*!< Prototype board digital pin output register (6 bits) */
#define HTPROTO_REG_DCTRL 0x4E /*!< Prototype board digital pin control register (6 bits) */
#define HTPROTO_REG_SRATE 0x4F /*!< Prototype board sample rate register */

/** @defgroup HTProtoAnalogInputConstants HiTechnic Prototype board analog input constants
 * Constants that are for use with reading the HiTechnic Prototype board analog input values.
 * @{
 */
#define HTPROTO_A0 0x42 /*!< Read Prototype board analog input 0 */
#define HTPROTO_A1 0x44 /*!< Read Prototype board analog input 1 */
#define HTPROTO_A2 0x46 /*!< Read Prototype board analog input 2 */
#define HTPROTO_A3 0x48 /*!< Read Prototype board analog input 3 */
#define HTPROTO_A4 0x4A /*!< Read Prototype board analog input 4 */
/** @} */  // end of HTProtoAnalogInputConstants group
/** @} */  // end of HTProtoConstants group

/** @defgroup HTSuperProConstants HiTechnic SuperPro constants
 * Constants that are for use with the HiTechnic SuperPro board.
 * @{
 */

#define HTSPRO_REG_CTRL         0x40 /*!< SuperPro program control register */
#define HTSPRO_REG_A0           0x42 /*!< SuperPro analog 0 register (10 bits) */
#define HTSPRO_REG_A1           0x44 /*!< SuperPro analog 1 register (10 bits) */
#define HTSPRO_REG_A2           0x46 /*!< SuperPro analog 2 register (10 bits) */
#define HTSPRO_REG_A3           0x48 /*!< SuperPro analog 3 register (10 bits) */
#define HTSPRO_REG_DIN          0x4C /*!< SuperPro digital pin input register (8 bits) */
#define HTSPRO_REG_DOUT         0x4D /*!< SuperPro digital pin output register (8 bits) */
#define HTSPRO_REG_DCTRL        0x4E /*!< SuperPro digital pin control register (8 bits) */
#define HTSPRO_REG_STROBE       0x50 /*!< SuperPro strobe control register */
#define HTSPRO_REG_LED          0x51 /*!< SuperPro LED control register */
#define HTSPRO_REG_DAC0_MODE    0x52 /*!< SuperPro analog output 0 mode register */
#define HTSPRO_REG_DAC0_FREQ    0x53 /*!< SuperPro analog output 0 frequency register (2 bytes msb/lsb) */
#define HTSPRO_REG_DAC0_VOLTAGE 0x55 /*!< SuperPro analog output 0 voltage register (10 bits) */
#define HTSPRO_REG_DAC1_MODE    0x57 /*!< SuperPro analog output 1 mode register */
#define HTSPRO_REG_DAC1_FREQ    0x58 /*!< SuperPro analog output 1 frequency register (2 bytes msb/lsb) */
#define HTSPRO_REG_DAC1_VOLTAGE 0x5A /*!< SuperPro analog output 1 voltage register (10 bits) */
#define HTSPRO_REG_DLADDRESS    0x60 /*!< SuperPro download address register (2 bytes msb/lsb) */
#define HTSPRO_REG_DLDATA       0x62 /*!< SuperPro download data register (8 bytes) */
#define HTSPRO_REG_DLCHKSUM     0x6A /*!< SuperPro download checksum register */
#define HTSPRO_REG_DLCONTROL    0x6B /*!< SuperPro download control register */
#define HTSPRO_REG_MEMORY_20    0x80 /*!< SuperPro memory address 0x20 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_21    0x84 /*!< SuperPro memory address 0x21 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_22    0x88 /*!< SuperPro memory address 0x22 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_23    0x8C /*!< SuperPro memory address 0x23 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_24    0x90 /*!< SuperPro memory address 0x24 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_25    0x94 /*!< SuperPro memory address 0x25 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_26    0x98 /*!< SuperPro memory address 0x26 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_27    0x9C /*!< SuperPro memory address 0x27 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_28    0xA0 /*!< SuperPro memory address 0x28 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_29    0xA4 /*!< SuperPro memory address 0x29 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_2A    0xA8 /*!< SuperPro memory address 0x2A register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_2B    0xAC /*!< SuperPro memory address 0x2B register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_2C    0xB0 /*!< SuperPro memory address 0x2C register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_2D    0xB4 /*!< SuperPro memory address 0x2D register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_2E    0xB8 /*!< SuperPro memory address 0x2E register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_2F    0xBC /*!< SuperPro memory address 0x2F register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_30    0xC0 /*!< SuperPro memory address 0x30 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_31    0xC4 /*!< SuperPro memory address 0x31 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_32    0xC8 /*!< SuperPro memory address 0x32 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_33    0xCC /*!< SuperPro memory address 0x33 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_34    0xD0 /*!< SuperPro memory address 0x34 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_35    0xD4 /*!< SuperPro memory address 0x35 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_36    0xD8 /*!< SuperPro memory address 0x36 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_37    0xDC /*!< SuperPro memory address 0x37 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_38    0xE0 /*!< SuperPro memory address 0x38 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_39    0xE4 /*!< SuperPro memory address 0x39 register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_3A    0xE8 /*!< SuperPro memory address 0x3A register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_3B    0xEC /*!< SuperPro memory address 0x3B register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_3C    0xF0 /*!< SuperPro memory address 0x3C register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_3D    0xF4 /*!< SuperPro memory address 0x3D register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_3E    0xF8 /*!< SuperPro memory address 0x3E register (4 bytes msb/lsb) */
#define HTSPRO_REG_MEMORY_3F    0xFC /*!< SuperPro memory address 0x3F register (4 bytes msb/lsb) */

/** @defgroup HTSProAnalogInputConstants HiTechnic SuperPro analog input index constants
 * Constants that are for use with reading the HiTechnic SuperPro analog input values.
 * @{
 */
#define HTSPRO_A0 0x42 /*!< Read SuperPro analog input 0 */
#define HTSPRO_A1 0x44 /*!< Read SuperPro analog input 1 */
#define HTSPRO_A2 0x46 /*!< Read SuperPro analog input 2 */
#define HTSPRO_A3 0x48 /*!< Read SuperPro analog input 3 */
/** @} */  // end of HTSProAnalogInputConstants group

/** @defgroup HTSProDACIndexConstants HiTechnic SuperPro analog output index constants
 * Constants that are for use with configuraing the HiTechnic SuperPro analog outputs.
 * @{
 */
#define HTSPRO_DAC0 0x52 /*!< Set SuperPro analog output 0 configuration */
#define HTSPRO_DAC1 0x57 /*!< Set SuperPro analog output 1 configuration */
/** @} */  // end of HTSProDACIndexConstants group


/** @addtogroup LEDCtrlConstants
 * @{
 */
#define LED_BLUE 0x02 /*!< Turn on the blue onboard LED. */
#define LED_RED  0x01 /*!< Turn on the red onboard LED. */
#define LED_NONE 0x00 /*!< Turn off the onboard LEDs. */
/** @} */  // end of LEDCtrlConstants group

/** @addtogroup DacModeConstants
 * @{
 */
#define DAC_MODE_DCOUT        0 /*!< Steady (DC) voltage output. */
#define DAC_MODE_SINEWAVE     1 /*!< Sine wave output. */
#define DAC_MODE_SQUAREWAVE   2 /*!< Square wave output. */
#define DAC_MODE_SAWPOSWAVE   3 /*!< Positive going sawtooth output. */
#define DAC_MODE_SAWNEGWAVE   4 /*!< Negative going sawtooth output. */
#define DAC_MODE_TRIANGLEWAVE 5 /*!< Triangle wave output. */
#define DAC_MODE_PWMVOLTAGE   6 /*!< PWM square wave output. */
/** @} */  // end of DacModeConstants group

/** @addtogroup DigitalPinConstants
 * @{
 */
#define DIGI_PIN0 0x01 /*!< Access digital pin 0 (B0) */
#define DIGI_PIN1 0x02 /*!< Access digital pin 1 (B1) */
#define DIGI_PIN2 0x04 /*!< Access digital pin 2 (B2) */
#define DIGI_PIN3 0x08 /*!< Access digital pin 3 (B3) */
#define DIGI_PIN4 0x10 /*!< Access digital pin 4 (B4) */
#define DIGI_PIN5 0x20 /*!< Access digital pin 5 (B5) */
#define DIGI_PIN6 0x40 /*!< Access digital pin 6 (B6) */
#define DIGI_PIN7 0x80 /*!< Access digital pin 7 (B7) */
/** @} */  // end of DigitalPinConstants group

/** @addtogroup StrobeCtrlConstants
 * @{
 */
#define STROBE_S0    0x01 /*!< Access strobe 0 pin (S0) */
#define STROBE_S1    0x02 /*!< Access strobe 1 pin (S1) */
#define STROBE_S2    0x04 /*!< Access strobe 2 pin (S2) */
#define STROBE_S3    0x08 /*!< Access strobe 3 pin (S3) */
#define STROBE_READ  0x10 /*!< Access read pin (RD) */
#define STROBE_WRITE 0x20 /*!< Access write pin (WR) */
/** @} */  // end of StrobeCtrlConstants group

/** @} */  // end of HTSuperProConstants group

/** @} */  // end of HiTechnicConstants group
/** @} */  // end of HiTechnicAPI group


/** @addtogroup MindSensorsAPI
 * @{
 */
/** @defgroup MindSensorsConstants MindSensors device constants
 * Constants that are for use with MindSensors devices.
 * @{
 */
// MindSensors constants
#define MS_CMD_ENERGIZED   0x45 /*!< Energize the MindSensors device */
#define MS_CMD_DEENERGIZED 0x44 /*!< De-energize the MindSensors device */
#define MS_CMD_ADPA_ON     0x4E /*!< Turn MindSensors ADPA mode on */
#define MS_CMD_ADPA_OFF    0x4F /*!< Turn MindSensors ADPA mode off */

#define MS_ADDR_RTCLOCK     0xD0 /*!< MindSensors RTClock I2C address */
#define MS_ADDR_DISTNX      0x02 /*!< MindSensors DIST-Nx I2C address */
#define MS_ADDR_NRLINK      0x02 /*!< MindSensors NRLink I2C address */
#define MS_ADDR_ACCLNX      0x02 /*!< MindSensors ACCL-Nx I2C address */
#define MS_ADDR_CMPSNX      0x02 /*!< MindSensors CMPS-Nx I2C address */
#define MS_ADDR_PSPNX       0x02 /*!< MindSensors PSP-Nx I2C address */
#define MS_ADDR_LINELDR     0x02 /*!< MindSensors LineLdr I2C address */
#define MS_ADDR_NXTCAM      0x02 /*!< MindSensors NXTCam I2C address */
#define MS_ADDR_NXTHID      0x04 /*!< MindSensors NXTHID I2C address */
#define MS_ADDR_NXTSERVO    0xB0 /*!< MindSensors NXTServo I2C address */
#define MS_ADDR_NXTSERVO_EM 0x40 /*!< MindSensors NXTServo in edit macro mode I2C address */
#define MS_ADDR_PFMATE      0x48 /*!< MindSensors PFMate I2C address */
#define MS_ADDR_MTRMUX      0xB4 /*!< MindSensors MTRMux I2C address */
#define MS_ADDR_NXTMMX      0x06 /*!< MindSensors NXTMMX I2C address */
#define MS_ADDR_IVSENS      0x12 /*!< MindSensors IVSens (NXTPowerMeter) I2C address */
#define MS_ADDR_RXMUX       0x7E /*!< MindSensors RXMux I2C address */
#define MS_ADDR_NUMERICPAD  0xB4 /*!< MindSensors NumericPad I2C address */
#define MS_ADDR_TOUCHPANEL  0x04 /*!< MindSensors TouchPanel I2C address */

/** @defgroup MSDistNX MindSensors DIST-Nx constants
 * Constants that are for use with the MindSensors DIST-Nx device.
 * @{
 */
// DIST-Nx Commands
#define DIST_CMD_GP2D12      0x31 /*!< Set the DIST-Nx to GP2D12 mode */
#define DIST_CMD_GP2D120     0x32 /*!< Set the DIST-Nx to GP2D120 mode */
#define DIST_CMD_GP2YA21     0x33 /*!< Set the DIST-Nx to GP2YA21 mode */
#define DIST_CMD_GP2YA02     0x34 /*!< Set the DIST-Nx to GP2YA02 mode */
#define DIST_CMD_CUSTOM      0x35 /*!< Set the DIST-Nx to a custom mode */

// DIST-Nx Registers
#define DIST_REG_DIST          0x42 /*!< The DIST-Nx distance register */
#define DIST_REG_VOLT          0x44 /*!< The DIST-Nx voltage register */
#define DIST_REG_MODULE_TYPE   0x50 /*!< The DIST-Nx module type register */
#define DIST_REG_NUM_POINTS    0x51 /*!< The DIST-Nx number of data points in Custom curve register */
#define DIST_REG_DIST_MIN      0x52 /*!< The DIST-Nx minimum distance register */
#define DIST_REG_DIST_MAX      0x54 /*!< The DIST-Nx maximum distance register */
#define DIST_REG_VOLT1         0x56 /*!< The DIST-Nx voltage 1 register */
#define DIST_REG_DIST1         0x58 /*!< The DIST-Nx distance 1 register */
/** @} */  // end of MSDistNX group

/** @defgroup MSPSPNX MindSensors PSP-Nx constants
 * Constants that are for use with the MindSensors PSP-Nx device.
 * @{
 */
// PSP-Nx commands
#define PSP_CMD_DIGITAL 0x41 /*!< Set the PSP-Nx to digital mode */
#define PSP_CMD_ANALOG  0x73 /*!< Set the PSP-Nx to analog mode */

// PSP-Nx registers
#define PSP_REG_BTNSET1 0x42 /*!< The PSP-Nx button set 1 register */
#define PSP_REG_BTNSET2 0x43 /*!< The PSP-Nx button set 2 register */
#define PSP_REG_XLEFT   0x44 /*!< The PSP-Nx X left register */
#define PSP_REG_YLEFT   0x45 /*!< The PSP-Nx Y left register */
#define PSP_REG_XRIGHT  0x46 /*!< The PSP-Nx X right register */
#define PSP_REG_YRIGHT  0x47 /*!< The PSP-Nx Y right register */

/** @defgroup MSPSPNXBtnSet1 MindSensors PSP-Nx button set 1 constants
 * Constants that are for interpretting MindSensors PSP-Nx button set 1 values.
 * @{
 */
#define PSP_BTNSET1_LEFT     0x80 /*!< The PSP-Nx button set 1 left arrow */
#define PSP_BTNSET1_DOWN     0x40 /*!< The PSP-Nx button set 1 down arrow */
#define PSP_BTNSET1_RIGHT    0x20 /*!< The PSP-Nx button set 1 right arrow */
#define PSP_BTNSET1_UP       0x10 /*!< The PSP-Nx button set 1 up arrow */
#define PSP_BTNSET1_START    0x08 /*!< The PSP-Nx button set 1 start */
#define PSP_BTNSET1_R3       0x04 /*!< The PSP-Nx button set 1 R3 */
#define PSP_BTNSET1_L3       0x02 /*!< The PSP-Nx button set 1 L3 */
#define PSP_BTNSET1_SELECT   0x01 /*!< The PSP-Nx button set 1 select */
/** @} */  // end of MSPSPNXBtnSet1 group

/** @defgroup MSPSPNXBtnSet2 MindSensors PSP-Nx button set 2 constants
 * Constants that are for interpretting MindSensors PSP-Nx button set 2 values.
 * @{
 */
#define PSP_BTNSET2_SQUARE   0x80 /*!< The PSP-Nx button set 2 square */
#define PSP_BTNSET2_CROSS    0x40 /*!< The PSP-Nx button set 2 cross */
#define PSP_BTNSET2_CIRCLE   0x20 /*!< The PSP-Nx button set 2 circle */
#define PSP_BTNSET2_TRIANGLE 0x10 /*!< The PSP-Nx button set 2 triangle */
#define PSP_BTNSET2_R1       0x08 /*!< The PSP-Nx button set 2 R1 */
#define PSP_BTNSET2_L1       0x04 /*!< The PSP-Nx button set 2 L1 */
#define PSP_BTNSET2_R2       0x02 /*!< The PSP-Nx button set 2 R2 */
#define PSP_BTNSET2_L2       0x01 /*!< The PSP-Nx button set 2 L2 */
/** @} */  // end of MSPSPNXBtnSet2 group
/** @} */  // end of MSPSPNX group

/** @defgroup MSNRLink MindSensors nRLink constants
 * Constants that are for use with the MindSensors nRLink device.
 * @{
 */
// NRLink commands
#define NRLINK_CMD_2400      0x44 /*!< Set NRLink to 2400 baud */
#define NRLINK_CMD_FLUSH     0x46 /*!< Flush the NRLink */
#define NRLINK_CMD_4800      0x48 /*!< Set NRLink to 4800 baud */
#define NRLINK_CMD_IR_LONG   0x4C /*!< Set the NRLink to long range IR */
#define NRLINK_CMD_IR_SHORT  0x53 /*!< Set the NRLink to short range IR */
#define NRLINK_CMD_RUN_MACRO 0x52 /*!< Run an NRLink macro */
#define NRLINK_CMD_TX_RAW    0x55 /*!< Set the NRLink to transmit raw bytes */
#define NRLINK_CMD_SET_RCX   0x58 /*!< Set the NRLink to RCX mode */
#define NRLINK_CMD_SET_TRAIN 0x54 /*!< Set the NRLink to IR Train mode */
#define NRLINK_CMD_SET_PF    0x50 /*!< Set the NRLink to Power Function mode */

// NRLink registers
#define NRLINK_REG_BYTES  0x40 /*!< The NRLink bytes register */
#define NRLINK_REG_DATA   0x42 /*!< The NRLink data register */
#define NRLINK_REG_EEPROM 0x50 /*!< The NRLink eeprom register */

/** @} */  // end of MSNRLink group

/** @defgroup MSACCLNx MindSensors ACCL-Nx constants
 * Constants that are for use with the MindSensors ACCL-Nx device.
 * @{
 */
// ACCL-Nx commands
#define ACCL_CMD_X_CAL      0x58 /*!< Acquire X-axis calibration point */
#define ACCL_CMD_Y_CAL      0x59 /*!< Acquire Y-axis calibration point */
#define ACCL_CMD_Z_CAL      0x5a /*!< Acquire Z-axis calibration point */
#define ACCL_CMD_X_CAL_END  0x78 /*!< Acquire X-axis calibration point and end calibration */
#define ACCL_CMD_Y_CAL_END  0x79 /*!< Acquire Y-axis calibration point and end calibration */
#define ACCL_CMD_Z_CAL_END  0x7a /*!< Acquire Z-axis calibration point and end calibration */
#define ACCL_CMD_RESET_CAL  0x52 /*!< Reset to factory calibration */

// ACCL-Nx registers
#define ACCL_REG_SENS_LVL 0x19 /*!< The current sensitivity */
#define ACCL_REG_X_TILT   0x42 /*!< The X-axis tilt data */
#define ACCL_REG_Y_TILT   0x43 /*!< The Y-axis tilt data */
#define ACCL_REG_Z_TILT   0x44 /*!< The Z-axis tilt data */
#define ACCL_REG_X_ACCEL  0x45 /*!< The X-axis acceleration data */
#define ACCL_REG_Y_ACCEL  0x47 /*!< The Y-axis acceleration data */
#define ACCL_REG_Z_ACCEL  0x49 /*!< The Z-axis acceleration data */
#define ACCL_REG_X_OFFSET 0x4b /*!< The X-axis offset */
#define ACCL_REG_X_RANGE  0x4d /*!< The X-axis range */
#define ACCL_REG_Y_OFFSET 0x4f /*!< The Y-axis offset */
#define ACCL_REG_Y_RANGE  0x51 /*!< The Y-axis range */
#define ACCL_REG_Z_OFFSET 0x53 /*!< The Z-axis offset */
#define ACCL_REG_Z_RANGE  0x55 /*!< The Z-axis range */

/** @defgroup MSACCLNxSLevel MindSensors ACCL-Nx sensitivity level constants
 * Constants that are for setting the MindSensors ACCL-Nx sensitivity level.
 * @{
 */
#define ACCL_SENSITIVITY_LEVEL_1 0x31 /*!< The ACCL-Nx sensitivity level 1 */
#define ACCL_SENSITIVITY_LEVEL_2 0x32 /*!< The ACCL-Nx sensitivity level 2 */
#define ACCL_SENSITIVITY_LEVEL_3 0x33 /*!< The ACCL-Nx sensitivity level 3 */
#define ACCL_SENSITIVITY_LEVEL_4 0x34 /*!< The ACCL-Nx sensitivity level 4 */
/** @} */  // end of MSACCLNxSLevel group

/** @} */  // end of MSACCLNx group

/** @defgroup PFMateConstants MindSensors PFMate constants
 * Constants that are for use with the MindSensors PFMate device.
 * @{
 */
#define PFMATE_REG_CMD     0x41 /*!< PFMate command */
#define PFMATE_REG_CHANNEL 0x42 /*!< PF channel? 1, 2, 3, or 4 */
#define PFMATE_REG_MOTORS  0x43 /*!< PF motors? (0 = both, 1 = A, 2 = B) */
#define PFMATE_REG_A_CMD   0x44 /*!< PF command for motor A? (PF_CMD_FLOAT, PF_CMD_FWD, PF_CMD_REV, PF_CMD_BRAKE) */
#define PFMATE_REG_A_SPEED 0x45 /*!< PF speed for motor A? (0-7) */
#define PFMATE_REG_B_CMD   0x46 /*!< PF command for motor B? (PF_CMD_FLOAT, PF_CMD_FWD, PF_CMD_REV, PF_CMD_BRAKE) */
#define PFMATE_REG_B_SPEED 0x47 /*!< PF speed for motor B? (0-7) */

#define PFMATE_CMD_GO      0x47 /*!< Send IR signal to IR receiver */
#define PFMATE_CMD_RAW     0x52 /*!< Send raw IR signal to IR receiver */

/** @defgroup PFMateMotorConstants PFMate motor constants
 * Constants that are for specifying PFMate motors.
 * @{
 */
#define PFMATE_MOTORS_BOTH 0x00 /*!< Control both motors */
#define PFMATE_MOTORS_A    0x01 /*!< Control only motor A */
#define PFMATE_MOTORS_B    0x02 /*!< Control only motor B */
/** @} */  // end of PFMateMotorConstants group

/** @defgroup PFMateChannelConstants PFMate channel constants
 * Constants that are for specifying PFMate channels.
 * @{
 */
#define PFMATE_CHANNEL_1 1 /*!< Power function channel 1 */
#define PFMATE_CHANNEL_2 2 /*!< Power function channel 2 */
#define PFMATE_CHANNEL_3 3 /*!< Power function channel 3 */
#define PFMATE_CHANNEL_4 4 /*!< Power function channel 4 */
/** @} */  // end of PFMateChannelConstants group

/** @} */  // end of PFMateConstants group

/** @defgroup NXTServoConstants MindSensors NXTServo constants
 * Constants that are for use with the MindSensors NXTServo device.
 * @{
 */
/** @defgroup NXTServoRegisters MindSensors NXTServo registers
 * NXTServo device register constants.
 * @{
 */
#define NXTSERVO_REG_VOLTAGE   0x41 /*!< Battery voltage register. (read only) */
#define NXTSERVO_REG_CMD       0x41 /*!< NXTServo command register.  See \ref NXTServoCommands group. (write only) */
// position registers (2 bytes little endian)
#define NXTSERVO_REG_S1_POS    0x42 /*!< NXTServo servo 1 position register. */
#define NXTSERVO_REG_S2_POS    0x44 /*!< NXTServo servo 2 position register. */
#define NXTSERVO_REG_S3_POS    0x46 /*!< NXTServo servo 3 position register. */
#define NXTSERVO_REG_S4_POS    0x48 /*!< NXTServo servo 4 position register. */
#define NXTSERVO_REG_S5_POS    0x4A /*!< NXTServo servo 5 position register. */
#define NXTSERVO_REG_S6_POS    0x4C /*!< NXTServo servo 6 position register. */
#define NXTSERVO_REG_S7_POS    0x4E /*!< NXTServo servo 7 position register. */
#define NXTSERVO_REG_S8_POS    0x50 /*!< NXTServo servo 8 position register. */
// speed registers
#define NXTSERVO_REG_S1_SPEED  0x52 /*!< NXTServo servo 1 speed register. */
#define NXTSERVO_REG_S2_SPEED  0x53 /*!< NXTServo servo 2 speed register. */
#define NXTSERVO_REG_S3_SPEED  0x54 /*!< NXTServo servo 3 speed register. */
#define NXTSERVO_REG_S4_SPEED  0x55 /*!< NXTServo servo 4 speed register. */
#define NXTSERVO_REG_S5_SPEED  0x56 /*!< NXTServo servo 5 speed register. */
#define NXTSERVO_REG_S6_SPEED  0x57 /*!< NXTServo servo 6 speed register. */
#define NXTSERVO_REG_S7_SPEED  0x58 /*!< NXTServo servo 7 speed register. */
#define NXTSERVO_REG_S8_SPEED  0x59 /*!< NXTServo servo 8 speed register. */
// quick position registers
#define NXTSERVO_REG_S1_QPOS   0x5A /*!< NXTServo servo 1 quick position register. (write only) */
#define NXTSERVO_REG_S2_QPOS   0x5B /*!< NXTServo servo 2 quick position register. (write only) */
#define NXTSERVO_REG_S3_QPOS   0x5C /*!< NXTServo servo 3 quick position register. (write only) */
#define NXTSERVO_REG_S4_QPOS   0x5D /*!< NXTServo servo 4 quick position register. (write only) */
#define NXTSERVO_REG_S5_QPOS   0x5E /*!< NXTServo servo 5 quick position register. (write only) */
#define NXTSERVO_REG_S6_QPOS   0x5F /*!< NXTServo servo 6 quick position register. (write only) */
#define NXTSERVO_REG_S7_QPOS   0x60 /*!< NXTServo servo 7 quick position register. (write only) */
#define NXTSERVO_REG_S8_QPOS   0x61 /*!< NXTServo servo 8 quick position register. (write only) */

#define NXTSERVO_EM_REG_CMD          0x00 /*!< NXTServo in macro edit mode command register. */
#define NXTSERVO_EM_REG_EEPROM_START 0x21 /*!< NXTServo in macro edit mode EEPROM start register. */
#define NXTSERVO_EM_REG_EEPROM_END   0xFF /*!< NXTServo in macro edit mode EEPROM end register. */
/** @} */  // end of NXTServoRegisters group

/** @defgroup NXTServoPos MindSensors NXTServo position constants
 * NXTServo device position constants.
 * @{
 */
#define NXTSERVO_POS_CENTER 1500 /*!< Center position for 1500us servos. */
#define NXTSERVO_POS_MIN     500 /*!< Minimum position for 1500us servos. */
#define NXTSERVO_POS_MAX    2500 /*!< Maximum position for 1500us servos. */
/** @} */  // end of NXTServoPos group

/** @defgroup NXTServoQPos MindSensors NXTServo quick position constants
 * NXTServo device quick position constants.
 * @{
 */
#define NXTSERVO_QPOS_CENTER 150 /*!< Center quick position for 1500us servos. */
#define NXTSERVO_QPOS_MIN     50 /*!< Minimum quick position for 1500us servos. */
#define NXTSERVO_QPOS_MAX    250 /*!< Maximum quick position for 1500us servos. */
/** @} */  // end of NXTServoQPos group

/** @defgroup NXTServoNumbers MindSensors NXTServo servo numbers
 * NXTServo device servo number constants.
 * @{
 */
#define NXTSERVO_SERVO_1 0 /*!< NXTServo server number 1. */
#define NXTSERVO_SERVO_2 1 /*!< NXTServo server number 2. */
#define NXTSERVO_SERVO_3 2 /*!< NXTServo server number 3. */
#define NXTSERVO_SERVO_4 3 /*!< NXTServo server number 4. */
#define NXTSERVO_SERVO_5 4 /*!< NXTServo server number 5. */
#define NXTSERVO_SERVO_6 5 /*!< NXTServo server number 6. */
#define NXTSERVO_SERVO_7 6 /*!< NXTServo server number 7. */
#define NXTSERVO_SERVO_8 7 /*!< NXTServo server number 8. */
/** @} */  // end of NXTServoNumbers group

/** @defgroup NXTServoCommands MindSensors NXTServo commands
 * NXTServo device command constants. These are written to the command register
 * to control the device.
 * @{
 */
#define NXTSERVO_CMD_INIT    0x49 /*!< Store the initial speed and position properties of the servo motor 'n'. Current speed and position values of the nth servo is read from the servo speed register and servo position register and written to permanent memory. */
#define NXTSERVO_CMD_RESET   0x53 /*!< Reset servo properties to factory default.  Initial Position of servos to 1500, and speed to 0. */
#define NXTSERVO_CMD_HALT    0x48 /*!< Halt Macro. This command re-initializes the macro environment. */
#define NXTSERVO_CMD_RESUME  0x52 /*!< Resume macro Execution. This command resumes macro where it was paused last, using the same environment. */
#define NXTSERVO_CMD_GOTO    0x47 /*!< Goto EEPROM position x. This command re-initializes the macro environment. */
#define NXTSERVO_CMD_PAUSE   0x50 /*!< Pause Macro. This command will pause the macro, and save the environment for subsequent resumption. */
#define NXTSERVO_CMD_EDIT1   0x45 /*!< Edit Macro (part 1 of 2 character command sequence) */
#define NXTSERVO_CMD_EDIT2   0x4D /*!< Edit Macro (part 2 of 2 character command sequence) */
#define NXTSERVO_EM_CMD_QUIT 0x51 /*!< Exit edit macro mode */
/** @} */  // end of NXTServoCommands group
/** @} */  // end of NXTServoConstants group

/** @defgroup NXTHIDConstants MindSensors NXTHID constants
 * Constants that are for use with the MindSensors NXTHID device.
 * @{
 */
/** @defgroup NXTHIDRegisters MindSensors NXTHID registers
 * NXTHID device register constants.
 * @{
 */
#define NXTHID_REG_CMD       0x41 /*!< NXTHID command register.  See \ref NXTHIDCommands group. */
#define NXTHID_REG_MODIFIER  0x42 /*!< NXTHID modifier register.  See \ref NXTHIDModifiers group. */
#define NXTHID_REG_DATA      0x43 /*!< NXTHID data register. */
/** @} */  // end of NXTHIDRegisters group

/** @defgroup NXTHIDModifiers MindSensors NXTHID modifier keys
 * NXTHID device modifier key constants.
 * @{
 */
#define NXTHID_MOD_NONE        0x00 /*!< NXTHID no modifier. */
#define NXTHID_MOD_LEFT_CTRL   0x01 /*!< NXTHID left control modifier. */
#define NXTHID_MOD_LEFT_SHIFT  0x02 /*!< NXTHID left shift modifier. */
#define NXTHID_MOD_LEFT_ALT    0x04 /*!< NXTHID left alt modifier. */
#define NXTHID_MOD_LEFT_GUI    0x08 /*!< NXTHID left gui modifier. */
#define NXTHID_MOD_RIGHT_CTRL  0x10 /*!< NXTHID right control modifier. */
#define NXTHID_MOD_RIGHT_SHIFT 0x20 /*!< NXTHID right shift modifier. */
#define NXTHID_MOD_RIGHT_ALT   0x40 /*!< NXTHID right alt modifier. */
#define NXTHID_MOD_RIGHT_GUI   0x80 /*!< NXTHID right gui modifier. */
/** @} */  // end of NXTHIDModifiers group

/** @defgroup NXTHIDCommands MindSensors NXTHID commands
 * NXTHID device command constants. These are written to the command register
 * to control the device.
 * @{
 */
#define NXTHID_CMD_ASCII    0x41 /*!< Use ASCII data mode. In ASCII mode no non-printable characters can be sent. */
#define NXTHID_CMD_DIRECT   0x44 /*!< Use direct data mode In direct mode any character can be sent. */
#define NXTHID_CMD_TRANSMIT 0x54 /*!< Transmit data to the host computer. */
/** @} */  // end of NXTHIDCommands group
/** @} */  // end of NXTHIDConstants group

/** @defgroup NXTPowerMeterConstants MindSensors NXTPowerMeter constants
 * Constants that are for use with the MindSensors NXTPowerMeter device.
 * @{
 */
/** @defgroup NXTPowerMeterRegisters MindSensors NXTPowerMeter registers
 * NXTPowerMeter device register constants.
 * @{
 */
#define NXTPM_REG_CMD        0x41 /*!< NXTPowerMeter command register.  See the \ref NXTPowerMeterCommands group. */
#define NXTPM_REG_CURRENT    0x42 /*!< NXTPowerMeter present current in mA register. (2 bytes) */
#define NXTPM_REG_VOLTAGE    0x44 /*!< NXTPowerMeter present voltage in mV register. (2 bytes) */
#define NXTPM_REG_CAPACITY   0x46 /*!< NXTPowerMeter capacity used since last reset register. (2 bytes) */
#define NXTPM_REG_POWER      0x48 /*!< NXTPowerMeter present power register. (2 bytes) */
#define NXTPM_REG_TOTALPOWER 0x4A /*!< NXTPowerMeter total power consumed since last reset register. (4 bytes) */
#define NXTPM_REG_MAXCURRENT 0x4E /*!< NXTPowerMeter max current register. (2 bytes) */
#define NXTPM_REG_MINCURRENT 0x50 /*!< NXTPowerMeter min current register. (2 bytes) */
#define NXTPM_REG_MAXVOLTAGE 0x52 /*!< NXTPowerMeter max voltage register. (2 bytes) */
#define NXTPM_REG_MINVOLTAGE 0x54 /*!< NXTPowerMeter min voltage register. (2 bytes) */
#define NXTPM_REG_TIME       0x56 /*!< NXTPowerMeter time register. (4 bytes) */
#define NXTPM_REG_USERGAIN   0x5A /*!< NXTPowerMeter user gain register. Not yet implemented. (4 bytes) */
#define NXTPM_REG_GAIN       0x5E /*!< NXTPowerMeter gain register. (1 byte) */
#define NXTPM_REG_ERRORCOUNT 0x5F /*!< NXTPowerMeter error count register. (2 bytes) */
/** @} */  // end of NXTPowerMeterRegisters group

/** @defgroup NXTPowerMeterCommands MindSensors NXTPowerMeter commands
 * NXTPowerMeter device command constants. These are written to the command register
 * to control the device.
 * @{
 */
#define NXTPM_CMD_RESET    0x52 /*!< Reset counters. */
/** @} */  // end of NXTPowerMeterCommands group
/** @} */  // end of NXTPowerMeterConstants group

/** @defgroup NXTSumoEyesConstants MindSensors NXTSumoEyes constants
 * Constants that are for use with the MindSensors NXTSumoEyes device.
 * @{
 */
#define NXTSE_ZONE_NONE  0 /*!< Obstacle zone none. */
#define NXTSE_ZONE_FRONT 1 /*!< Obstacle zone front. */
#define NXTSE_ZONE_LEFT  2 /*!< Obstacle zone left. */
#define NXTSE_ZONE_RIGHT 3 /*!< Obstacle zone right. */
/** @} */  // end of NXTSumoEyesConstants group

/** @defgroup NXTLineLeaderConstants MindSensors NXTLineLeader constants
 * Constants that are for use with the MindSensors NXTLineLeader device.
 * @{
 */
/** @defgroup NXTLineLeaderRegisters MindSensors NXTLineLeader registers
 * NXTLineLeader device register constants.
 * @{
 */
#define NXTLL_REG_CMD         0x41 /*!< NXTLineLeader command register.  See the \ref NXTLineLeaderCommands group. */
#define NXTLL_REG_STEERING    0x42 /*!< NXTLineLeader steering register. */
#define NXTLL_REG_AVERAGE     0x43 /*!< NXTLineLeader average result register. */
#define NXTLL_REG_RESULT      0x44 /*!< NXTLineLeader result register (sensor bit values). */
#define NXTLL_REG_SETPOINT    0x45 /*!< NXTLineLeader user settable average (setpoint) register. Default = 45. */
#define NXTLL_REG_KP_VALUE    0x46 /*!< NXTLineLeader Kp value register. Default = 25. */
#define NXTLL_REG_KI_VALUE    0x47 /*!< NXTLineLeader Ki value register. Default = 0. */
#define NXTLL_REG_KD_VALUE    0x48 /*!< NXTLineLeader Kd value register. Default = 8. */
#define NXTLL_REG_CALIBRATED  0x49 /*!< NXTLineLeader calibrated sensor reading registers. 8 bytes. */
#define NXTLL_REG_WHITELIMITS 0x51 /*!< NXTLineLeader white limit registers. 8 bytes. */
#define NXTLL_REG_BLACKLIMITS 0x59 /*!< NXTLineLeader black limit registers. 8 bytes. */
#define NXTLL_REG_KP_FACTOR   0x61 /*!< NXTLineLeader Kp factor register. Default = 32. */
#define NXTLL_REG_KI_FACTOR   0x62 /*!< NXTLineLeader Ki factor register. Default = 32. */
#define NXTLL_REG_KD_FACTOR   0x63 /*!< NXTLineLeader Kd factor register. Default = 32. */
#define NXTLL_REG_WHITEDATA   0x64 /*!< NXTLineLeader white calibration data registers. 8 bytes. */
#define NXTLL_REG_BLACKDATA   0x6C /*!< NXTLineLeader black calibration data registers. 8 bytes. */
#define NXTLL_REG_RAWVOLTAGE  0x74 /*!< NXTLineLeader uncalibrated sensor voltage registers. 16 bytes. */
/** @} */  // end of NXTLineLeaderRegisters group

/** @defgroup NXTLineLeaderCommands MindSensors NXTLineLeader commands
 * NXTLineLeader device command constants. These are written to the command register
 * to control the device.
 * @{
 */
#define NXTLL_CMD_USA       0x41 /*!< USA power frequency. (60hz) */
#define NXTLL_CMD_BLACK     0x42 /*!< Black calibration. */
#define NXTLL_CMD_POWERDOWN 0x44 /*!< Power down the device. */
#define NXTLL_CMD_EUROPEAN  0x45 /*!< European power frequency. (50hz) */
#define NXTLL_CMD_INVERT    0x49 /*!< Invert color. */
#define NXTLL_CMD_POWERUP   0x50 /*!< Power up the device. */
#define NXTLL_CMD_RESET     0x52 /*!< Reset inversion. */
#define NXTLL_CMD_SNAPSHOT  0x53 /*!< Setpoint based on snapshot (automatically sets invert if needed). */
#define NXTLL_CMD_UNIVERSAL 0x55 /*!< Universal power frequency. The sensor auto adjusts for any frequency. This is the default mode. */
#define NXTLL_CMD_WHITE     0x57 /*!< White balance calibration. */
/** @} */  // end of NXTLineLeaderCommands group
/** @} */  // end of NXTLineLeaderConstants group

/** @defgroup NXTNumericPadConstants MindSensors NXTNumericPad constants
 * Constants that are for use with the MindSensors NXTNumericPad device.
 * @{
 */
/** @defgroup NXTNumericPadRegisters MindSensors NXTNumericPad registers
 * NXTNumericPad device register constants.
 * @{
 */
#define NXTNP_REG_BUTTONS  0x00 /*!< NXTNumericPad buttons register. */
/** @} */  // end of NXTNumericPadRegisters group
/** @} */  // end of NXTNumericPadConstants group

/** @defgroup NXTTouchPanelConstants MindSensors NXTTouchPanel constants
 * Constants that are for use with the MindSensors NXTTouchPanel device.
 * @{
 */
/** @defgroup NXTTouchPanelRegisters MindSensors NXTTouchPanel registers
 * NXTTouchPanel device register constants.
 * @{
 */
#define NXTTP_REG_CMD         0x41 /*!< NXTTouchPanel command register.  See the \ref NXTTouchPanelCommands group. */
/** @} */  // end of NXTTouchPanelRegisters group

/** @defgroup NXTTouchPanelCommands MindSensors NXTTouchPanel commands
 * NXTTouchPanel device command constants. These are written to the command register
 * to control the device.
 * @{
 */
#define NXTTP_CMD_USA       0x41 /*!< USA power frequency. (60hz) */
/** @} */  // end of NXTTouchPanelCommands group
/** @} */  // end of NXTTouchPanelConstants group

/** @} */  // end of MindSensorsConstants group
/** @} */  // end of MindSensorsAPI group


/** @addtogroup CodatexAPI
 * @{
 */
/** @defgroup CodatexConstants Codatex device constants
 * Constants that are for use with Codatex devices.
 * @{
 */
/** @defgroup CTRFIDConstants Codatex RFID sensor constants
 * Constants that are for use with the Codatex RFID sensor device.
 * @{
 */
/** @defgroup CTRFIDModeConstants Codatex RFID sensor modes
 * Constants that are for configuring the Codatex RFID sensor mode.
 * @{
 */
#define RFID_MODE_STOP       0  /*!< Stop the RFID device */
#define RFID_MODE_SINGLE     1  /*!< Configure the RFID device for a single reading */
#define RFID_MODE_CONTINUOUS 2  /*!< Configure the RFID device for continuous reading */
/** @} */  // end of CTRFIDModeConstants group

#define CT_ADDR_RFID     0x04   /*!< RFID I2C address */

#define CT_REG_STATUS    0x32   /*!< RFID status register */
#define CT_REG_MODE      0x41   /*!< RFID mode register */
#define CT_REG_DATA      0x42   /*!< RFID data register */

/** @} */  // end of CTRFIDConstants group
/** @} */  // end of CodatexConstants group
/** @} */  // end of CodatexAPI group

/** @addtogroup DexterIndustriesAPI
 * @{
 */
/** @defgroup DIConstants Dexter Industries device constants
 * Constants that are for use with Dexter Industries devices.
 * @{
 */
/** @defgroup DIGPSConstants Dexter Industries GPS sensor constants
 * Constants that are for use with the Dexter Industries GPS sensor.
 * @{
 */

#define DI_ADDR_DGPS          0x06 /*!< Dexter Industries DGPS I2C address */

#define DGPS_REG_TIME         0x00 /*!< Read time in UTC (hhmmss). */
#define DGPS_REG_STATUS       0x01 /*!< Read status of the GPS (0 - invalid signal, 1 - valid signal). */
#define DGPS_REG_LATITUDE     0x02 /*!< Read integer latitude.(dddddddd; Positive = North; Negative = South). */
#define DGPS_REG_LONGITUDE    0x04 /*!< Read integer longitude (ddddddddd; Positive = East; Negative = West). */
#define DGPS_REG_VELOCITY     0x06 /*!< Read velocity in cm/s. */
#define DGPS_REG_HEADING      0x07 /*!< Read heading in degrees. */
#define DGPS_REG_DISTANCE     0x08 /*!< Read distance to current waypoint in meters. */
#define DGPS_REG_WAYANGLE     0x09 /*!< Read angle to current waypoint in degrees. */
#define DGPS_REG_LASTANGLE    0x0A /*!< Read angle travelled since last request, resets the request coordinates on the GPS sensor, sends the angle of travel since last reset. */
#define DGPS_REG_SETLATITUDE  0x0B /*!< Set waypoint latitude as a 4 byte integer. */
#define DGPS_REG_SETLONGITUDE 0x0C /*!< Set waypoint longitude as a 4 byte integer. */

/** @} */  // end of DIGPSConstants group

/** @defgroup DIIMUConstants Dexter Industries IMU sensor constants
 * Constants that are for use with the Dexter Industries IMU sensor.
 * @{
 */

#define DI_ADDR_GYRO     0xD2  /*!< Dexter Industries DIMU Gyro I2C address */
#define DI_ADDR_ACCL     0x3A  /*!< Dexter Industries DIMU Accelerometer I2C address */

/** @defgroup DIIMUGyroRegisterConstants Dexter Industries IMU Gyro register constants
 * Constants that define the Dexter Industries IMU Gyro registers.
 * @{
 */

#define DIGYRO_REG_WHOAMI    0x0F  /*!< Gyro device identification register (read only) */
#define DIGYRO_REG_CTRL1     0x20  /*!< Gyro control register 1 */
#define DIGYRO_REG_CTRL2     0x21  /*!< Gyro control register 2 */
#define DIGYRO_REG_CTRL3     0x22  /*!< Gyro control register 3 */
#define DIGYRO_REG_CTRL4     0x23  /*!< Gyro control register 4 */
#define DIGYRO_REG_CTRL5     0x24  /*!< Gyro control register 5 */
#define DIGYRO_REG_REFERENCE 0x25  /*!< Gyro reference register - stores the reference value used for interrupt generation */
#define DIGYRO_REG_OUTTEMP   0x26  /*!< Gyro temperature register (read only) - stores temperature data */
#define DIGYRO_REG_STATUS    0x27  /*!< Gyro status register (read only) */
#define DIGYRO_REG_XLOW      0x28  /*!< Gyro x-axis low byte register (read only) */
#define DIGYRO_REG_XHIGH     0x29  /*!< Gyro x-axis high byte register (read only) */
#define DIGYRO_REG_YLOW      0x2A  /*!< Gyro y-axis low byte register (read only) */
#define DIGYRO_REG_YHIGH     0x2B  /*!< Gyro y-axis high byte register (read only) */
#define DIGYRO_REG_ZLOW      0x2C  /*!< Gyro z-axis low byte register (read only) */
#define DIGYRO_REG_ZHIGH     0x2D  /*!< Gyro z-axis high byte register (read only) */
#define DIGYRO_REG_FIFOCTRL  0x2E  /*!< Gyro FIFO control register */
#define DIGYRO_REG_FIFOSRC   0x2F  /*!< Gyro FIFO source register (read only) */
#define DIGYRO_REG_INT1_CFG  0x30  /*!< Gyro interrupt 1 config register */
#define DIGYRO_REG_INT1_SRC  0x31  /*!< Gyro interrupt 1 source register */
#define DIGYRO_REG_INT1_XHI  0x32  /*!< Gyro interrupt 1 x-axis high threshold register */
#define DIGYRO_REG_INT1_XLO  0x33  /*!< Gyro interrupt 1 x-axis low threshold register */
#define DIGYRO_REG_INT1_YHI  0x34  /*!< Gyro interrupt 1 y-axis high threshold register */
#define DIGYRO_REG_INT1_YLO  0x35  /*!< Gyro interrupt 1 y-axis low threshold register */
#define DIGYRO_REG_INT1_ZHI  0x36  /*!< Gyro interrupt 1 z-axis high threshold register */
#define DIGYRO_REG_INT1_ZLO  0x37  /*!< Gyro interrupt 1 z-axis low threshold register */
#define DIGYRO_REG_INT1_DUR  0x38  /*!< Gyro interrupt 1 duration register */

#define DIGYRO_REG_CTRL1AUTO 0xA0  /*!< Gyro control register 1 - auto increment write */
#define DIGYRO_REG_TEMPAUTO  0xA6  /*!< Gyro temperature register - read burst mode (read only) */
#define DIGYRO_REG_XLOWBURST 0xA8  /*!< Gyro x-axis low byte register - read burst mode (read only) */
#define DIGYRO_REG_YLOWBURST 0xAA  /*!< Gyro y-axis low byte register - read burst mode (read only) */
#define DIGYRO_REG_ZLOWBURST 0xAC  /*!< Gyro y-axis low byte register - read burst mode (read only) */


/** @} */  // end of DIIMUGyroRegisterConstants group

/** @defgroup DIIMUGyroCtrl1Constants Dexter Industries IMU Gyro control register 1 constants
 * Constants that are for use with the Dexter Industries IMU Gyro sensor's control register 1.
 * @{
 */

#define DIGYRO_CTRL1_XENABLE      0x01 /*!< Gyro enable X axis */
#define DIGYRO_CTRL1_YENABLE      0x02 /*!< Gyro enable Y axis */
#define DIGYRO_CTRL1_ZENABLE      0x04 /*!< Gyro enable Z axis */
#define DIGYRO_CTRL1_POWERDOWN    0x00 /*!< Gyro enable power down mode */
#define DIGYRO_CTRL1_NORMAL       0x08 /*!< Gyro disable power down mode */
#define DIGYRO_CTRL1_BANDWIDTH_1  0x00 /*!< Gyro LPF2 cut-off frequency bandwidth level 1 (12.5hz, 12.5hz, 20hz, 30hz) */
#define DIGYRO_CTRL1_BANDWIDTH_2  0x10 /*!< Gyro LPF2 cut-off frequency bandwidth level 2 (12.5hz, 25hz, 50hz, 70hz) */
#define DIGYRO_CTRL1_BANDWIDTH_3  0x20 /*!< Gyro LPF2 cut-off frequency bandwidth level 3 (20hz, 25hz, 50hz, 110hz) */
#define DIGYRO_CTRL1_BANDWIDTH_4  0x30 /*!< Gyro LPF2 cut-off frequency bandwidth level 4 (30hz, 35hz, 50hz, 110hz) */
#define DIGYRO_CTRL1_DATARATE_100 0x00 /*!< Gyro output data rate 100 hz */
#define DIGYRO_CTRL1_DATARATE_200 0x40 /*!< Gyro output data rate 200 hz */
#define DIGYRO_CTRL1_DATARATE_400 0x80 /*!< Gyro output data rate 400 hz */
#define DIGYRO_CTRL1_DATARATE_800 0xC0 /*!< Gyro output data rate 800 hz */

/** @} */  // end of DIIMUGyroCtrl1Constants group

/** @defgroup DIIMUGyroCtrl2Constants Dexter Industries IMU Gyro control register 2 constants
 * Constants that are for use with the Dexter Industries IMU Gyro sensor's control register 2.
 * @{
 */

#define DIGYRO_CTRL2_CUTOFF_FREQ_8   0x00 /*!< Gyro high pass filter cutoff frequency 8 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_4   0x01 /*!< Gyro high pass filter cutoff frequency 4 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_2   0x02 /*!< Gyro high pass filter cutoff frequency 2 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_1   0x03 /*!< Gyro high pass filter cutoff frequency 1 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_05  0x04 /*!< Gyro high pass filter cutoff frequency 0.5 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_02  0x05 /*!< Gyro high pass filter cutoff frequency 0.2 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_01  0x06 /*!< Gyro high pass filter cutoff frequency 0.1 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_005 0x07 /*!< Gyro high pass filter cutoff frequency 0.05 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_002 0x08 /*!< Gyro high pass filter cutoff frequency 0.02 hz */
#define DIGYRO_CTRL2_CUTOFF_FREQ_001 0x09 /*!< Gyro high pass filter cutoff frequency 0.01 hz */
#define DIGYRO_CTRL2_HPMODE_RESET    0x00 /*!< Gyro high pass filter reset mode */
#define DIGYRO_CTRL2_HPMODE_REFSIG   0x10 /*!< Gyro high pass filter reference signal mode */
#define DIGYRO_CTRL2_HPMODE_NORMAL   0x20 /*!< Gyro high pass filter normal mode */
#define DIGYRO_CTRL2_HPMODE_AUTOINT  0x30 /*!< Gyro high pass filter autoreset on interrupt event mode */

/** @} */  // end of DIIMUGyroCtrl2Constants group

/** @defgroup DIIMUGyroCtrl3Constants Dexter Industries IMU Gyro control register 3 constants
 * Constants that are for use with the Dexter Industries IMU Gyro sensor's control register 3.
 * @{
 */

#define DIGYRO_CTRL3_INT1_ENABLE    0x80 /*!< Gyro interrupt enable on INT1 pin */
#define DIGYRO_CTRL3_INT1_BOOT      0x40 /*!< Gyro boot status available on INT1 */
#define DIGYRO_CTRL3_INT1_LOWACTIVE 0x20 /*!< Gyro interrupt active low on INT1 */
#define DIGYRO_CTRL3_OPENDRAIN      0x10 /*!< Gyro use open drain rather than push-pull */
#define DIGYRO_CTRL3_INT2_DATAREADY 0x08 /*!< Gyro data ready on DRDY/INT2 */
#define DIGYRO_CTRL3_INT2_WATERMARK 0x04 /*!< Gyro FIFO watermark interrupt on DRDY/INT2 */
#define DIGYRO_CTRL3_INT2_OVERRUN   0x02 /*!< Gyro FIFO overrun interrupt on DRDY/INT2 */
#define DIGYRO_CTRL3_INT2_EMPTY     0x01 /*!< Gyro FIFO empty interrupt on DRDY/INT2 */

/** @} */  // end of DIIMUGyroCtrl3Constants group

/** @defgroup DIIMUGyroCtrl4Constants Dexter Industries IMU Gyro control register 4 constants
 * Constants that are for use with the Dexter Industries IMU Gyro sensor's control register 4.
 * @{
 */

#define DIGYRO_CTRL4_BLOCKDATA  0x80 /*!< Gyro block data update - output registers are not updated until MSB and LSB reading */
#define DIGYRO_CTRL4_BIGENDIAN  0x40 /*!< Gyro use big endian - MSB/LSB rather than LSB/MSB in output registers */
#define DIGYRO_CTRL4_SCALE_250  0x00 /*!< Gyro 250 degrees per second scale */
#define DIGYRO_CTRL4_SCALE_500  0x10 /*!< Gyro 500 degrees per second scale */
#define DIGYRO_CTRL4_SCALE_2000 0x30 /*!< Gyro 2000 degrees per second scale */

/** @} */  // end of DIIMUGyroCtrl4Constants group

/** @defgroup DIIMUGyroCtrl5Constants Dexter Industries IMU Gyro control register 5 constants
 * Constants that are for use with the Dexter Industries IMU Gyro sensor's control register 5.
 * @{
 */

#define DIGYRO_CTRL5_REBOOTMEM  0x80 /*!< Gyro reboot memory content */
#define DIGYRO_CTRL5_FIFOENABLE 0x40 /*!< Gyro enable FIFO */
#define DIGYRO_CTRL5_HPENABLE   0x10 /*!< Gyro enable high pass filter */
#define DIGYRO_CTRL5_OUT_SEL_1  0x00 /*!< Gyro data in data registers and FIFO are not high-pass filtered */
#define DIGYRO_CTRL5_OUT_SEL_2  0x01 /*!< Gyro data in data registers and FIFO are high-pass filtered */
#define DIGYRO_CTRL5_OUT_SEL_3  0x02 /*!< Gyro data in data registers and FIFO are low-pass filtered by LPF2 */
#define DIGYRO_CTRL5_INT1_SEL_1 0x00 /*!< Gyro non-high-pass-filtered data are used for interrupt generation */
#define DIGYRO_CTRL5_INT1_SEL_2 0x04 /*!< Gyro high-pass-filtered data are used for interrupt generation */
#define DIGYRO_CTRL5_INT1_SEL_3 0x08 /*!< Gyro low-pass-filtered data are used for interrupt generation */

/** @} */  // end of DIIMUGyroCtrl5Constants group

/** @defgroup DIIMUGyroFifoCtrlConstants Dexter Industries IMU Gyro FIFO control register onstants
 * Constants that are for use with the Dexter Industries IMU Gyro sensor's FIFO control register.
 * @{
 */

#define DIGYRO_FIFOCTRL_BYPASS        0x00 /*!< Gyro FIFO bypass mode */
#define DIGYRO_FIFOCTRL_FIFO          0x20 /*!< Gyro FIFO mode */
#define DIGYRO_FIFOCTRL_STREAM        0x40 /*!< Gyro FIFO stream mode */
#define DIGYRO_FIFOCTRL_STREAM2FIFO   0x60 /*!< Gyro FIFO stream-to-FIFO mode */
#define DIGYRO_FIFOCTRL_BYPASS2STREAM 0x80 /*!< Gyro FIFO bypass-to-stream mode */

#define DIGYRO_FIFOCTRL_WATERMARK_MASK 0x1F /*!< Gyro FIFO threshold. Watermark level setting mask (values from 0x00 to 0x1F) */

/** @} */  // end of DIIMUGyroFifoCtrlConstants group

/** @defgroup DIIMUGyroStatusConstants Dexter Industries IMU Gyro status register constants
 * Constants that are for use with the Dexter Industries IMU Gyro sensor's status register.
 * @{
 */

#define DIGYRO_STATUS_XDATA   0x01 /*!< Gyro X-axis new data available */
#define DIGYRO_STATUS_YDATA   0x02 /*!< Gyro Y-axis new data available */
#define DIGYRO_STATUS_ZDATA   0x04 /*!< Gyro Z-axis new data available */
#define DIGYRO_STATUS_XYZDATA 0x08 /*!< Gyro X, Y, or Z-axis new data available - a new set of data is available */
#define DIGYRO_STATUS_XOVER   0x10 /*!< Gyro X-axis data overrun - new data for the X-axis has overwritten the previous one */
#define DIGYRO_STATUS_YOVER   0x20 /*!< Gyro Y-axis data overrun - new data for the Y-axis has overwritten the previous one */
#define DIGYRO_STATUS_ZOVER   0x40 /*!< Gyro Z-axis data overrun - new data for the Z-axis has overwritten the previous one */
#define DIGYRO_STATUS_XYZOVER 0x80 /*!< Gyro X, Y, or Z-axis data overrun - new data has overwritten the previous one before it was read */

/** @} */  // end of DIIMUGyroStatusConstants group

/** @defgroup DIIMUAcclRegisterConstants Dexter Industries IMU Accelerometer register constants
 * Constants that define the Dexter Industries IMU Accelerometer registers.
 * @{
 */

#define DIACCL_REG_XLOW       0x00  /*!< Accelerometer x-axis low byte register (read only) */
#define DIACCL_REG_XHIGH      0x01  /*!< Accelerometer x-axis high byte register (read only) */
#define DIACCL_REG_YLOW       0x02  /*!< Accelerometer y-axis low byte register (read only) */
#define DIACCL_REG_YHIGH      0x03  /*!< Accelerometer y-axis high byte register (read only) */
#define DIACCL_REG_ZLOW       0x04  /*!< Accelerometer z-axis low byte register (read only) */
#define DIACCL_REG_ZHIGH      0x05  /*!< Accelerometer z-axis high byte register (read only) */
#define DIACCL_REG_X8         0x06  /*!< Accelerometer x-axis 8-bit register (read only) */
#define DIACCL_REG_Y8         0x07  /*!< Accelerometer x-axis 8-bit register (read only) */
#define DIACCL_REG_Z8         0x08  /*!< Accelerometer x-axis 8-bit register (read only) */
#define DIACCL_REG_STATUS     0x09  /*!< Accelerometer status register (read only) */
#define DIACCL_REG_DETECTSRC  0x0A  /*!< Accelerometer detection source register (read only) */
#define DIACCL_REG_OUTTEMP    0x0B  /*!< Accelerometer temperature output register (read only) */
#define DIACCL_REG_I2CADDR    0x0D  /*!< Accelerometer I2C address register (read only) */
#define DIACCL_REG_USERINFO   0x0E  /*!< Accelerometer user information register (read only) */
#define DIACCL_REG_WHOAMI     0x0F  /*!< Accelerometer device identification register (read only) */
#define DIACCL_REG_XLOWDRIFT  0x10  /*!< Accelerometer x-axis offset drift low byte register (read/write) */
#define DIACCL_REG_XHIGHDRIFT 0x11  /*!< Accelerometer x-axis offset drift high byte register (read/write) */
#define DIACCL_REG_YLOWDRIFT  0x12  /*!< Accelerometer y-axis offset drift low byte register (read/write) */
#define DIACCL_REG_YHIGHDRIFT 0x13  /*!< Accelerometer y-axis offset drift high byte register (read/write) */
#define DIACCL_REG_ZLOWDRIFT  0x14  /*!< Accelerometer z-axis offset drift low byte register (read/write) */
#define DIACCL_REG_ZHIGHDRIFT 0x15  /*!< Accelerometer z-axis offset drift high byte register (read/write) */
#define DIACCL_REG_MODECTRL   0x16  /*!< Accelerometer mode control register (read/write) */
#define DIACCL_REG_INTLATCH   0x17  /*!< Accelerometer interrupt latch reset register (read/write) */
#define DIACCL_REG_CTRL1      0x18  /*!< Accelerometer control register 1 (read/write) */
#define DIACCL_REG_CTRL2      0x19  /*!< Accelerometer control register 1 (read/write) */
#define DIACCL_REG_LVLDETTHR  0x1A  /*!< Accelerometer level detection threshold limit value register (read/write) */
#define DIACCL_REG_PLSDETTHR  0x1B  /*!< Accelerometer pulse detection threshold limit value register (read/write) */
#define DIACCL_REG_PLSDURVAL  0x1C  /*!< Accelerometer pulse duration value register (read/write) */
#define DIACCL_REG_LATENCYTM  0x1D  /*!< Accelerometer latency time value register (read/write) */
#define DIACCL_REG_TIMEWINDOW 0x1E  /*!< Accelerometer time window for 2nd pulse value register (read/write) */

/** @} */  // end of DIIMUAcclRegisterConstants group

/** @defgroup DIIMUAccelStatusConstants Dexter Industries IMU Accelerometer status register constants
 * Constants that are for use with the Dexter Industries IMU Accelerometer sensor's status register.
 * @{
 */

#define DIACCL_STATUS_DATAREADY 0x01  /*!< Accelerometer data is ready */
#define DIACCL_STATUS_DATAOVER  0x02  /*!< Accelerometer data is overwritten */
#define DIACCL_STATUS_PARITYERR 0x04  /*!< Accelerometer parity error is detected in trim data */

/** @} */  // end of DIIMUGyroStatusConstants group

/** @defgroup DIIMUAccelModeConstants Dexter Industries IMU Accelerometer mode control register constants
 * Constants that are for use with the Dexter Industries IMU Accelerometer sensor's mode control register.
 * @{
 */

#define DIACCL_MODE_STANDBY   0x00  /*!< Accelerometer standby mode */
#define DIACCL_MODE_MEASURE   0x01  /*!< Accelerometer measurement mode */
#define DIACCL_MODE_LVLDETECT 0x02  /*!< Accelerometer level detect mode */
#define DIACCL_MODE_PLSDETECT 0x03  /*!< Accelerometer pulse detect mode */
#define DIACCL_MODE_GLVL8     0x00  /*!< Accelerometer 8G measurement range */
#define DIACCL_MODE_GLVL2     0x04  /*!< Accelerometer 2G measurement range */
#define DIACCL_MODE_GLVL4     0x08  /*!< Accelerometer 4G measurement range */

/** @} */  // end of DIIMUAccelModeConstants group

/** @defgroup DIIMUAccelInterruptLatchConstants Dexter Industries IMU Accelerometer interrupt latch reset register constants
 * Constants that are for use with the Dexter Industries IMU Accelerometer sensor's interrupt latch reset register.
 * @{
 */

#define DIACCL_INTERRUPT_LATCH_CLEAR1 0x01  /*!< Accelerometer clear interrupt 1 */
#define DIACCL_INTERRUPT_LATCH_CLEAR2 0x02  /*!< Accelerometer clear interrupt 2 */

/** @} */  // end of DIIMUAccelInterruptLatchConstants group

/** @defgroup DIIMUAccelCtrl1Constants Dexter Industries IMU Accelerometer control register 1 constants
 * Constants that are for use with the Dexter Industries IMU Accelerometer sensor's control register 1.
 * @{
 */

#define DIACCL_CTRL1_INT2TOINT1 0x01  /*!< Accelerometer INT2 pin is routed to INT1 bit in Detection Source Register ($0A) and INT1 pin is routed to INT2 bit in Detection Source Register ($0A) */
#define DIACCL_CTRL1_LEVELPULSE 0x00  /*!< Accelerometer INT1 register is detecting Level while INT2 is detecting pulse */
#define DIACCL_CTRL1_PULSELEVEL 0x02  /*!< Accelerometer INT1 Register is detecting Pulse while INT2 is detecting Level */
#define DIACCL_CTRL1_PULSEPULSE 0x04  /*!< Accelerometer INT1 Register is detecting a Single Pulse and INT2 is detecting Single Pulse (if 2nd Time Window = 0) or if there is a latency time window and second time window > 0 then INT2 will detect the double pulse only. */
#define DIACCL_CTRL1_NO_XDETECT 0x08  /*!< Accelerometer disable x-axis detection. */
#define DIACCL_CTRL1_NO_YDETECT 0x10  /*!< Accelerometer disable y-axis detection. */
#define DIACCL_CTRL1_NO_ZDETECT 0x20  /*!< Accelerometer disable z-axis detection. */
#define DIACCL_CTRL1_THRESH_INT 0x40  /*!< Accelerometer threshold value can be an integer. */
#define DIACCL_CTRL1_FILT_BW125 0x80  /*!< Accelerometer digital filter band width is 125 Hz. */

/** @} */  // end of DIIMUAccelCtrl1Constants group

/** @defgroup DIIMUAccelCtrl2Constants Dexter Industries IMU Accelerometer control register 2 constants
 * Constants that are for use with the Dexter Industries IMU Accelerometer sensor's control register 2.
 * @{
 */

#define DIACCL_CTRL2_LVLPOL_NEGAND 0x01  /*!< Accelerometer level detection polarity is negative and detecting condition is AND all 3 axes */
#define DIACCL_CTRL2_DETPOL_NEGAND 0x02  /*!< Accelerometer pulse detection polarity is negative and detecting condition is AND all 3 axes */
#define DIACCL_CTRL2_DRIVE_STRONG  0x04  /*!< Accelerometer strong drive strength on SDA/SDO pin */

/** @} */  // end of DIIMUAccelCtrl2Constants group

/** @} */  // end of DIIMUConstants group

/** @} */  // end of DIConstants group
/** @} */  // end of DexterIndustriesAPI group

/** @addtogroup MicroinfinityAPI
 * @{
 */
/** @defgroup MIConstants Microinfinity device constants
 * Constants that are for use with Microinfinity devices.
 * @{
 */
/** @defgroup XG1300LConstants Microinfinity CruizCore XG1300L sensor constants
 * Constants that are for use with the CruizCore XG1300L sensor.
 * @{
 */

#define MI_ADDR_XG1300L      0x02 /*!< XG1300L I2C address */

#define XG1300L_REG_ANGLE    0x42 /*!< Read accumulated angle (2 bytes little endian) in 1/100s of degrees. */
#define XG1300L_REG_TURNRATE 0x44 /*!< Read rate of turn (2 bytes little endian) in 1/100s of degrees/second. */
#define XG1300L_REG_XAXIS    0x46 /*!< Read x-axis acceleration (2 bytes little endian) in m/s^2 scaled by 100/ACC_RANGE*2, where ACC_RANGE is 2, 4, or 8. */
#define XG1300L_REG_YAXIS    0x48 /*!< Read y-axis acceleration (2 bytes little endian) in m/s^2 scaled by 100/ACC_RANGE*2, where ACC_RANGE is 2, 4, or 8. */
#define XG1300L_REG_ZAXIS    0x4A /*!< Read z-axis acceleration (2 bytes little endian) in m/s^2 scaled by 100/ACC_RANGE*2, where ACC_RANGE is 2, 4, or 8. */

#define XG1300L_REG_RESET    0x60 /*!< Reset the XG1300L device. */
#define XG1300L_REG_2G       0x61 /*!< Select +/- 2G accelerometer range. */
#define XG1300L_REG_4G       0x62 /*!< Select +/- 4G accelerometer range. */
#define XG1300L_REG_8G       0x63 /*!< Select +/- 8G accelerometer range. */

/** @defgroup XG1300LScaleConstants Microinfinity CruizCore XG1300L
 * sensor scale factor constants
 * Constants for setting the scale factor of the CruizCore XG1300L sensor.
 * @{
 */
#define XG1300L_SCALE_2G     0x01 /*!< Select +/- 2G accelerometer range. */
#define XG1300L_SCALE_4G     0x02 /*!< Select +/- 4G accelerometer range. */
#define XG1300L_SCALE_8G     0x04 /*!< Select +/- 8G accelerometer range. */
/** @} */  // end of XG1300LScaleConstants group

/** @} */  // end of XG1300LConstants group
/** @} */  // end of MIConstants group
/** @} */  // end of MicroinfinityAPI group

/** @} */  // end of ThirdPartyDevices group


/** @addtogroup RICMacros
 * @{
 */
/**
 * Output an RIC ImgPoint structure
 * \param _X The X coordinate.
 * \param _Y The Y coordinate.
 */
#define RICImgPoint(_X, _Y) (_X)&0xFF, (_X)>>8, (_Y)&0xFF, (_Y)>>8

/**
 * Output an RIC ImgRect structure
 * \param _Pt An ImgPoint. See \ref RICImgPoint.
 * \param _W The rectangle width.
 * \param _H The rectangle height.
 */
#define RICImgRect(_Pt, _W, _H) _Pt, (_W)&0xFF, (_W)>>8, (_H)&0xFF, (_H)>>8

/**
 * Output an RIC Description opcode
 * \param _Options RIC options.
 * \param _Width The total RIC width.
 * \param _Height The total RIC height.
 */
#define RICOpDescription(_Options, _Width, _Height) 8, 0, 0, 0, (_Options)&0xFF, (_Options)>>8, (_Width)&0xFF, (_Width)>>8, (_Height)&0xFF, (_Height)>>8

/**
 * Output an RIC CopyBits opcode
 * \param _CopyOptions CopyBits copy options.  See \ref DisplayDrawOptionConstants.
 * \param _DataAddr The address of the sprite from which to copy data.
 * \param _SrcRect The rectangular portion of the sprite to copy.  See \ref RICImgRect.
 * \param _DstPoint The LCD coordinate to which to copy the data.  See \ref RICImgPoint.
 */
#define RICOpCopyBits(_CopyOptions, _DataAddr, _SrcRect, _DstPoint) 18, 0, 3, 0, (_CopyOptions)&0xFF, (_CopyOptions)>>8, (_DataAddr)&0xFF, (_DataAddr)>>8, _SrcRect, _DstPoint

/**
 * Output an RIC Pixel opcode
 * \param _CopyOptions Pixel copy options.  See \ref DisplayDrawOptionConstants.
 * \param _Point The pixel coordinate. See \ref RICImgPoint.
 * \param _Value The pixel value (unused).
 */
#define RICOpPixel(_CopyOptions, _Point, _Value) 10, 0, 4, 0, (_CopyOptions)&0xFF, (_CopyOptions)>>8, _Point, (_Value)&0xFF, (_Value)>>8

/**
 * Output an RIC Line opcode
 * \param _CopyOptions Line copy options.  See \ref DisplayDrawOptionConstants.
 * \param _Point1 The starting point of the line.  See \ref RICImgPoint.
 * \param _Point2 The ending point of the line.  See \ref RICImgPoint.
 */
#define RICOpLine(_CopyOptions, _Point1, _Point2) 12, 0, 5, 0, (_CopyOptions)&0xFF, (_CopyOptions)>>8, _Point1, _Point2

/**
 * Output an RIC Rect opcode
 * \param _CopyOptions Rect copy options.  See \ref DisplayDrawOptionConstants.
 * \param _Point The rectangle's top left corner.  See \ref RICImgPoint.
 * \param _Width The rectangle's width.
 * \param _Height The rectangle's height.
 */
#define RICOpRect(_CopyOptions, _Point, _Width, _Height) 12, 0, 6, 0, (_CopyOptions)&0xFF, (_CopyOptions)>>8, _Point, (_Width)&0xFF, (_Width)>>8, (_Height)&0xFF, (_Height)>>8

/**
 * Output an RIC Circle opcode
 * \param _CopyOptions Circle copy options.  See \ref DisplayDrawOptionConstants.
 * \param _Point The circle's center point.  See \ref RICImgPoint.
 * \param _Radius The circle's radius.
 */
#define RICOpCircle(_CopyOptions, _Point, _Radius) 10, 0, 7, 0, (_CopyOptions)&0xFF, (_CopyOptions)>>8, _Point, (_Radius)&0xFF, (_Radius)>>8

/**
 * Output an RIC NumBox opcode
 * \param _CopyOptions NumBox copy options.  See \ref DisplayDrawOptionConstants.
 * \param _Point The numbox bottom left corner.  See \ref RICImgPoint.
 * \param _Value The number to draw.
 */
#define RICOpNumBox(_CopyOptions, _Point, _Value) 10, 0, 8, 0, (_CopyOptions)&0xFF, (_CopyOptions)>>8, _Point, (_Value)&0xFF, (_Value)>>8

/**
 * Output an RIC Sprite opcode
 * \param _DataAddr The address of the sprite.
 * \param _Rows The number of rows of data.
 * \param _BytesPerRow The number of bytes per row.
 * \param _SpriteData The actual sprite data. See \ref RICSpriteData.
 */
#define RICOpSprite(_DataAddr, _Rows, _BytesPerRow, _SpriteData) ((_Rows*_BytesPerRow)+((_Rows*_BytesPerRow)%2)+8)&0xFF, ((_Rows*_BytesPerRow)+((_Rows*_BytesPerRow)%2)+8)>>8, 1, 0, (_DataAddr)&0xFF, (_DataAddr)>>8, (_Rows)&0xFF, (_Rows)>>8, (_BytesPerRow)&0xFF, (_BytesPerRow)>>8, _SpriteData

/**
 * Output RIC sprite data
 */
#define RICSpriteData(...) __VA_ARGS__

/**
 * Output an RIC VarMap opcode
 * \param _DataAddr The address of the varmap.
 * \param _MapCount The number of points in the function.
 * \param _MapFunction The definition of the varmap function.  See \ref RICMapFunction.
 */
#define RICOpVarMap(_DataAddr, _MapCount, _MapFunction) ((_MapCount*4)+6)&0xFF, ((_MapCount*4)+6)>>8, 2, 0, (_DataAddr)&0xFF, (_DataAddr)>>8, (_MapCount)&0xFF, (_MapCount)>>8, _MapFunction

/**
 * Output an RIC map element
 * \param _Domain The map element domain.
 * \param _Range The map element range.
 */
#define RICMapElement(_Domain, _Range) (_Domain)&0xFF, (_Domain)>>8, (_Range)&0xFF, (_Range)>>8

/**
 * Output an RIC VarMap function
 * \param _MapElement An entry in the varmap function.  At least 2 elements are
 * required.  See \ref RICMapElement.
 */
#define RICMapFunction(_MapElement, ...) _MapElement, __VA_ARGS__

/**
 * Output an RIC parameterized argument
 * \param _arg The argument that you want to parameterize.
 */
#define RICArg(_arg) ((_arg)|0x1000)

/**
 * Output an RIC parameterized and mapped argument
 * \param _mapidx The varmap data address.
 * \param _arg The parameterized argument you want to pass through a varmap.
 */
#define RICMapArg(_mapidx, _arg) ((_arg)|0x1000|(((_mapidx)&0xF)<<8))

/**
 * Output an RIC Polygon opcode
 * \param _CopyOptions Polygon copy options.  See \ref DisplayDrawOptionConstants.
 * \param _Count The number of points in the polygon.
 * \param _ThePoints The list of polygon points.  See \ref RICPolygonPoints.
 */
#define RICOpPolygon(_CopyOptions, _Count, _ThePoints)  ((_Count*4)+6)&0xFF, ((_Count*4)+6)>>8, 10, 0, (_CopyOptions)&0xFF, (_CopyOptions)>>8, (_Count)&0xFF, (_Count)>>8, _ThePoints

/**
 * Output RIC polygon points
 * \param _pPoint1 The first polygon point.  See \ref RICImgPoint.
 * \param _pPoint2 The second polygon point (at least 3 points are required).
 * See \ref RICImgPoint.
 */
#define RICPolygonPoints(_pPoint1, _pPoint2, ...) _pPoint1, _pPoint2, __VA_ARGS__

/**
 * Output an RIC Ellipse opcode
 * \param _CopyOptions Ellipse copy options.  See \ref DisplayDrawOptionConstants.
 * \param _Point The center of the ellipse. See \ref RICImgPoint.
 * \param _RadiusX The x-axis radius of the ellipse.
 * \param _RadiusY The y-axis radius of the ellipse.
 */
#define RICOpEllipse(_CopyOptions, _Point, _RadiusX, _RadiusY) 12, 0, 9, 0, (_CopyOptions)&0xFF, (_CopyOptions)>>8, _Point, (_RadiusX)&0xFF, (_RadiusX)>>8, (_RadiusY)&0xFF, (_RadiusY)>>8

/** @} */  // end of RICMacros group

/** @addtogroup MiscConstants
 * @{
 */
/** @defgroup NXTLimits Data type limits
 * Constants that define various data type limits.
 * @{
 */
#define CHAR_BIT   8           /*!< The number of bits in the char type */
#define SCHAR_MIN  -128        /*!< The minimum value of the signed char type */
#define SCHAR_MAX  127         /*!< The maximum value of the signed char type */
#define UCHAR_MAX  255         /*!< The maximum value of the unsigned char type */
#define CHAR_MIN   -128        /*!< The minimum value of the char type */
#define CHAR_MAX   127         /*!< The maximum value of the char type */
#define SHRT_MIN   -32768      /*!< The minimum value of the short type */
#define SHRT_MAX   32767       /*!< The maximum value of the short type */
#define USHRT_MAX  65535       /*!< The maximum value of the unsigned short type */
#define INT_MIN    -32768      /*!< The minimum value of the int type */
#define INT_MAX    32767       /*!< The maximum value of the int type */
#define UINT_MAX   65535       /*!< The maximum value of the unsigned int type */
#define LONG_MIN   -2147483648 /*!< The minimum value of the long type */
#define LONG_MAX   2147483647  /*!< The maximum value of the long type */
#define ULONG_MAX  4294967295  /*!< The maximum value of the unsigned long type */
#ifdef __ENHANCED_FIRMWARE
#define RAND_MAX   2147483646  /*!< The maximum long random number returned by rand */
#else
#define RAND_MAX   65535       /*!< The maximum unsigned int random number returned by rand */
#endif
/** @} */  // end of NXTLimits group
/** @} */  // end of MiscConstants group


/** @addtogroup GraphicsLibrary
 * @{
 */
/*------------------------------------------------------------------------------
; File          : nbcGL.nbc
; Description   : Data and subroutines for a very simple 3D engine.
; Programmed by : Arno van der Vegt, avandervegt@home.nl
;-----------------------------------------------------------------------------*/

/** @defgroup GLConstantsBeginModes Graphics library begin modes
 * Constants that are used to specify the polygon surface begin mode.
 * @{
 */
#define GL_POLYGON             1 /*!< Use polygon mode. */
#define GL_LINE                2 /*!< Use line mode. */
#define GL_POINT               3 /*!< Use point mode. */
#define GL_CIRCLE              4 /*!< Use circle mode. */
/** @} */  // end of GLConstantsBeginModes group

/** @defgroup GLConstantsActions Graphics library actions
 * Constants that are used to specify a graphics library action.
 * @{
 */
#define GL_TRANSLATE_X       1 /*!< Translate along the X axis. */
#define GL_TRANSLATE_Y       2 /*!< Translate along the Y axis. */
#define GL_TRANSLATE_Z       3 /*!< Translate along the Z axis. */
#define GL_ROTATE_X          4 /*!< Rotate around the X axis. */
#define GL_ROTATE_Y          5 /*!< Rotate around the Y axis. */
#define GL_ROTATE_Z          6 /*!< Rotate around the Z axis. */
#define GL_SCALE_X           7 /*!< Scale along the X axis. */
#define GL_SCALE_Y           8 /*!< Scale along the Y axis. */
#define GL_SCALE_Z           9 /*!< Scale along the Z axis. */
/** @} */  // end of GLConstantsSettings group

/** @defgroup GLConstantsSettings Graphics library settings
 * Constants that are used to configure the graphics library settings.
 * @{
 */
#define GL_CIRCLE_SIZE          1 /*!< Set the circle size. */
#define GL_CULL_MODE            2 /*!< Set the cull mode.  */
#define GL_CAMERA_DEPTH         3 /*!< Set the camera depth. */
#define GL_ZOOM_FACTOR          4 /*!< Set the zoom factor. */
/** @} */  // end of GLConstantsSettings group

/** @defgroup GLConstantsCullMode Graphics library cull mode
 * Constants to use when setting the graphics library cull mode.
 * @{
 */
#define GL_CULL_BACK           2 /*!< Cull lines in back. */
#define GL_CULL_FRONT          3 /*!< Cull lines in front. */
#define GL_CULL_NONE           4 /*!< Do not cull any lines. */
/** @} */  // end of GLConstantsCullMode group

/** @} */  // end of GraphicsLibrary group

#endif // NBCCOMMON_H
/* NXTDefs.h
 * Constants, macros, and API functions for use in NBC
 *
 * NXTDefs.h contains declarations for the NBC NXT API resources
 *
 * License:
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Initial Developer of this code is John Hansen.
 * Portions created by John Hansen are Copyright (C) 2009-2012 John Hansen.
 * All Rights Reserved.
 *
 * ----------------------------------------------------------------------------
 *
 * author John Hansen (bricxcc_at_comcast.net)
 * date 2012-02-06
 * version 85
 */
#ifndef NXTDEFS__H
#define NXTDEFS__H

#include "NBCCommon.h"

/** @addtogroup cmpconst
 * @{
 */
#define LT   0x00 /*!< The first value is less than the second. */
#define GT   0x01 /*!< The first value is greater than the second. */
#define LTEQ 0x02 /*!< The first value is less than or equal to the second. */
#define GTEQ 0x03 /*!< The first value is greater than or equal to the second. */
#define EQ   0x04 /*!< The first value is equal to the second. */
#define NEQ  0x05 /*!< The first value is not equal to the second. */
/** @} */  // end of cmpconst group

#ifdef __DOXYGEN_DOCS
// nothing to see here
#else
// define structures for various system calls

dseg	segment

TLocation	struct
 X		sword
 Y		sword
TLocation	ends

TSize	struct
 Width	sword
 Height	sword
TSize	ends

// FileOpenRead, FileOpenWrite, FileOpenAppend, FileOpenWriteLinear, FileOpenWriteNonLinear, FileOpenReadLinear
TFileOpen	struct
 Result		word
 FileHandle	byte
 Filename	byte[]
 Length		dword
TFileOpen	ends

// FileRead, FileWrite
TFileReadWrite	struct
 Result		word
 FileHandle	byte
 Buffer		byte[]
 Length		dword
TFileReadWrite	ends

// FileClose
TFileClose	struct
 Result		word
 FileHandle	byte
TFileClose	ends

// FileResolveHandle
TFileResolveHandle	struct
 Result		word
 FileHandle	byte
 WriteHandle	byte
 Filename	byte[]
TFileResolveHandle	ends

// FileRename
TFileRename	struct
 Result		word
 OldFilename	byte[]
 NewFilename	byte[]
TFileRename	ends

// FileDelete
TFileDelete	struct
 Result		word
 Filename	byte[]
TFileDelete	ends

// SoundPlayFile
TSoundPlayFile	struct
 Result		sbyte
 Filename	byte[]
 Loop		byte
 Volume		byte
TSoundPlayFile	ends

// SoundPlayTone
TSoundPlayTone	struct
 Result		sbyte
 Frequency	word
 Duration	word
 Loop		byte
 Volume		byte
TSoundPlayTone	ends

// SoundGetState
TSoundGetState	struct
 State		byte
 Flags		byte
TSoundGetState	ends

// SoundSetState
TSoundSetState	struct
 Result		byte
 State		byte
 Flags		byte
TSoundSetState	ends

// DrawText
TDrawText	struct
 Result		sbyte
 Location	TLocation
 Text		byte[]
 Options	dword
TDrawText	ends

// DrawPoint
TDrawPoint	struct
 Result		sbyte
 Location	TLocation
 Options	dword
TDrawPoint	ends

// DrawLine
TDrawLine	struct
 Result		sbyte
 StartLoc	TLocation
 EndLoc		TLocation
 Options	dword
TDrawLine	ends

// DrawCircle
TDrawCircle	struct
 Result		sbyte
 Center		TLocation
 Size		byte
 Options	dword
TDrawCircle	ends

// DrawRect
TDrawRect	struct
 Result		sbyte
 Location	TLocation
 Size		TSize
 Options	dword
TDrawRect	ends

// DrawGraphic
TDrawGraphic	struct
 Result		sbyte
 Location	TLocation
 Filename	byte[]
 Variables	sdword[]
 Options	dword
TDrawGraphic	ends

// SetScreenMode
TSetScreenMode	struct
 Result		sbyte
 ScreenMode	dword
TSetScreenMode	ends

// ReadButton
TReadButton	struct
 Result		sbyte
 Index		byte
 Pressed	byte
 Count		byte
 Reset		byte
TReadButton	ends

// CommLSWrite
TCommLSWrite	struct
 Result		sbyte
 Port		byte
 Buffer		byte[]
 ReturnLen	byte
TCommLSWrite	ends

// CommLSRead
TCommLSRead	struct
 Result		sbyte
 Port		byte
 Buffer		byte[]
 BufferLen	byte
TCommLSRead	ends

// CommLSCheckStatus
TCommLSCheckStatus	struct
 Result		sbyte
 Port		byte
 BytesReady	byte
TCommLSCheckStatus	ends

// RandomNumber
TRandomNumber	struct
 Result		sword
TRandomNumber	ends

// GetStartTick
TGetStartTick	struct
 Result		dword
TGetStartTick	ends

// MessageWrite
TMessageWrite	struct
 Result		sbyte
 QueueID	byte
 Message	byte[]
TMessageWrite	ends

// MessageRead
TMessageRead	struct
 Result		sbyte
 QueueID	byte
 Remove		byte
 Message	byte[]
TMessageRead	ends

// CommBTCheckStatus
TCommBTCheckStatus	struct
 Result		sbyte
 Connection	byte
TCommBTCheckStatus	ends

// CommBTWrite
TCommBTWrite	struct
 Result		sbyte
 Connection	byte
 Buffer		byte[]
TCommBTWrite	ends

// CommBTRead
TCommBTRead	struct
 Result		sbyte
 Count		byte
 Buffer		byte[]
TCommBTRead	ends

// KeepAlive
TKeepAlive	struct
 Result		dword
TKeepAlive	ends

// IOMapRead
TIOMapRead	struct
 Result		sbyte
 ModuleName	byte[]
 Offset		word
 Count		word
 Buffer		byte[]
TIOMapRead	ends

// IOMapWrite
TIOMapWrite	struct
 Result		sbyte
 ModuleName	byte[]
 Offset		word
 Buffer		byte[]
TIOMapWrite	ends

#ifdef __ENHANCED_FIRMWARE

TIOMapReadByID struct
  Result    sbyte
  ModuleID  long
  Offset    word
  Count     word
  Buffer    byte[]
TIOMapReadByID ends

TIOMapWriteByID struct
  Result   sbyte
  ModuleID long
  Offset   word
  Buffer   byte[]
TIOMapWriteByID ends

TDisplayExecuteFunction struct
  Status byte
  Cmd    byte
  On     byte
  X1     byte
  Y1     byte
  X2     byte
  Y2     byte
TDisplayExecuteFunction ends

TCommExecuteFunction struct
  Result word
  Cmd    byte
  Param1 byte
  Param2 byte
  Param3 byte
  Name   byte[]
  RetVal word
TCommExecuteFunction ends

TLoaderExecuteFunction struct
  Result   word
  Cmd      byte
  Filename byte[]
  Buffer   byte[]
  Length   long
TLoaderExecuteFunction ends

// FileFindFirst, FileFindNext
TFileFind	struct
 Result		word
 FileHandle	byte
 Filename	byte[]
 Length		dword
TFileFind	ends

TCommHSControl	struct
 Result		sbyte
 Command	byte
 BaudRate	byte
#if __FIRMWARE_VERSION > 107
 Mode		word
#endif
TCommHSControl	ends

TCommHSCheckStatus	struct
 SendingData	byte
 DataAvailable	byte
TCommHSCheckStatus	ends

// CommHSRead, CommHSWrite
TCommHSReadWrite	struct
 Status	sbyte
 Buffer	byte[]
#if __FIRMWARE_VERSION > 107
 BufferLen	byte
#endif
TCommHSReadWrite	ends

// CommLSWriteEx
TCommLSWriteEx	struct
 Result		sbyte
 Port		byte
 Buffer		byte[]
 ReturnLen	byte
 NoRestartOnRead	byte
TCommLSWriteEx	ends

#if __FIRMWARE_VERSION > 107
//FileSeek
TFileSeek	struct
 Result		word
 FileHandle	byte
 Origin		byte
 Length		sdword
TFileSeek	ends

//FileResize
TFileResize	struct
 Result		word
 FileHandle	byte
 NewSize	word
TFileResize	ends

// DrawGraphicArray
TDrawGraphicArray	struct
 Result		sbyte
 Location	TLocation
 Data		byte[]
 Variables	sdword[]
 Options	dword
TDrawGraphicArray	ends

// DrawPolygon
TDrawPolygon	struct
 Result		sbyte
 Points		TLocation[]
 Options	dword
TDrawPolygon	ends

// DrawEllipse
TDrawEllipse	struct
 Result		sbyte
 Center		TLocation
 SizeX		byte
 SizeY		byte
 Options	dword
TDrawEllipse	ends

// DrawFont
TDrawFont	struct
 Result		sbyte
 Location	TLocation
 Filename	byte[]
 Text		byte[]
 Options	dword
TDrawFont	ends

// MemoryManager
TMemoryManager struct
 Result        sbyte
 Compact       byte
 PoolSize      word
 DataspaceSize word
TMemoryManager ends

// ReadLastResponse
TReadLastResponse struct
 Result  sbyte
 Clear   byte
 Length  byte
 Command byte
 Buffer	 byte[]
TReadLastResponse ends

// FileTell
TFileTell struct
 Result     sbyte
 FileHandle byte
 Position   dword
TFileTell ends

// RandomEx
TRandomEx	struct
 Seed   long
 ReSeed byte
TRandomEx	ends

// InputPinFunction
TInputPinFunction struct
 Result word
 Cmd    byte
 Port   byte
 Pin    byte
 Data   byte
TInputPinFunction ends

#endif
#endif

#if __FIRMWARE_VERSION > 107

// ColorSensorRead
TColorSensorRead	struct
 Result			sbyte
 Port			byte
 ColorValue		sword
 RawArray		word[]
 NormalizedArray	word[]
 ScaledArray		sword[]
 Invalid		byte
TColorSensorRead	ends

// DatalogWrite
TDatalogWrite	struct
 Result		sbyte
 Message	byte[]
TDatalogWrite	ends

// DatalogGetTimes
TDatalogGetTimes	struct
 SyncTime	dword
 SyncTick	dword
TDatalogGetTimes	ends

// SetSleepTimeout
TSetSleepTimeout	struct
 Result		sbyte
 TheSleepTimeoutMS	dword
TSetSleepTimeout	ends

// CommBTOnOff
TCommBTOnOff	struct
#ifdef __ENHANCED_FIRMWARE
 Result		word
#else
 Result		sbyte
#endif
 PowerState	byte
TCommBTOnOff	ends

// CommBTConnection
TCommBTConnection	struct
#ifdef __ENHANCED_FIRMWARE
 Result		word
#else
 Result		sbyte
#endif
 Action		byte
 Name		byte[]
 ConnectionSlot	byte
TCommBTConnection	ends

// ReadSemData
TReadSemData struct
 SemData byte
 Request byte
TReadSemData ends

// WriteSemData
TWriteSemData struct
 SemData byte
 Request byte
 NewVal byte
 ClearBits byte
TWriteSemData ends

// UpdateCalibCacheInfo
TUpdateCalibCacheInfo struct
 Result byte
 Name byte[]
 MinVal word
 MaxVal word
TUpdateCalibCacheInfo ends

// ComputeCalibValue
TComputeCalibValue struct
 Result byte
 Name byte[]
 RawVal word
TComputeCalibValue ends

// ListFiles
TListFiles	struct
 Result		sbyte
 Pattern	byte[]
 FileList	byte[][]
TListFiles	ends

#endif

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
TOutputState struct // for use with the RemoteGetOutputState direct command response
  Port            byte
  Power           sbyte
  Mode            byte
  RegMode         byte
  TurnRatio       sbyte
  RunState        byte
  TachoLimit      dword
  TachoCount      sdword
  BlockTachoCount sdword
  RotationCount   sdword
TOutputState ends

TInputValues struct // for use with the RemoteGetInputValues direct command response
  Port            byte
  Valid           byte
  Calibrated      byte
  SensorType      byte
  SensorMode      byte
  RawValue        word
  NormalizedValue word
  ScaledValue     sword
  CalibratedValue sword
TInputValues ends

TInput struct
  CustomZeroOffset   word
  ADRaw              word
  SensorRaw          word
  SensorValue        sword
  SensorType         byte
  SensorMode         byte
  SensorBoolean      byte
  DigiPinsDir        byte
  DigiPinsIn         byte
  DigiPinsOut        byte
  CustomPctFullScale byte
  CustomActiveStatus byte
  InvalidData        byte
TInput ends // 17 bytes

TOutput struct
  TachoCnt          sdword
  BlockTachoCount   sdword
  RotationCount     sdword
  TachoLimit        dword
  MotorRPM          sword
  Flags             byte
  Mode              byte
  Speed             sbyte
  ActualSpeed       sbyte
  RegPParameter     byte
  RegIParameter     byte
  RegDParameter     byte
  RunState          byte
  RegMode           byte
  Overloaded        byte
  SyncTurnParameter sbyte
  Options           byte
TOutput ends // 30 bytes

TButtonCounts struct
  BtnPressedCnt   byte
  BtnLongPressCnt byte
  BtnShortRelCnt  byte
  BtnLongRelCnt   byte
  BtnRelCnt       byte
TButtonCounts ends // 5 bytes

TBluetoothDevice struct
  Name          byte[]
  ClassOfDevice byte[]
  BdAddr        byte[]
  DeviceStatus  byte
TBluetoothDevice ends // 28 bytes

TBluetoothConnection struct
  Name          byte[]
  ClassOfDevice byte[]
  PinCode       byte[]
  BdAddr        byte[]
  HandleNr      byte
  StreamStatus  byte
  LinkQuality   byte
TBluetoothConnection ends // 46 bytes

TBrickData struct
  Name            byte[]
  BluecoreVersion byte[]
  BdAddr          byte[]
  BtStateStatus   byte
  BtHwStatus      byte
  TimeOutValue    byte
TBrickData ends // 28 bytes

#endif

TXGPacket struct
  AccAngle sword
  TurnRate sword
  XAxis sword
  YAxis sword
  ZAxis sword
TXGPacket ends

TVector struct
  X float
  Y float
  Z float
TVector ends

dseg	ends

// motor arrays (compiler will optimize these out if they are not used)
dseg segment
  __OUT_AB byte[] OUT_A, OUT_B
  __OUT_AC byte[] OUT_A, OUT_C
  __OUT_BC byte[] OUT_B, OUT_C
  __OUT_ABC byte[] OUT_A, OUT_B, OUT_C
  __OnRev_Tmp sbyte
  __OnRevMutex mutex
dseg ends

dseg segment
  __rotateMutex0 mutex
  __rotateMutex1 mutex
  __rotateMutex2 mutex
dseg ends

dseg segment
// variables for rotate motor subroutine (0)
  __rotate_power0 byte
  __rotate_angle0 slong
  __rotate_ports0 byte[]
  __rotate_firstPort0 byte
  __rotate_sync0 byte
  __rotate_stop0 byte
  __rotate_turnpct0 sbyte
  __rotate_theUF0 byte
  __rotate_theOM0 byte
  __rotate_theRM0 byte
  __rotate_theRS0 byte
  __rotate_theRVP0 byte
  __rotate_theRVI0 byte
  __rotate_theRVD0 byte
  __rotate_rs0 byte
  __rotate_OldRotCount0 sword
  __rotate_RotCount0 sword
  __rotate_thePower0 sbyte
  __rotate_theAngle0 ulong
  __rotate_theTurnPct0 sbyte
  __rotate_then0 dword
  __rotate_now0 dword
dseg ends

dseg segment
// variables for rotate motor subroutine (1)
  __rotate_power1 byte
  __rotate_angle1 slong
  __rotate_ports1 byte[]
  __rotate_firstPort1 byte
  __rotate_sync1 byte
  __rotate_stop1 byte
  __rotate_turnpct1 sbyte
  __rotate_theUF1 byte
  __rotate_theOM1 byte
  __rotate_theRM1 byte
  __rotate_theRS1 byte
  __rotate_theRVP1 byte
  __rotate_theRVI1 byte
  __rotate_theRVD1 byte
  __rotate_rs1 byte
  __rotate_OldRotCount1 sword
  __rotate_RotCount1 sword
  __rotate_thePower1 sbyte
  __rotate_theAngle1 ulong
  __rotate_theTurnPct1 sbyte
  __rotate_then1 dword
  __rotate_now1 dword
dseg ends

dseg segment
// variables for rotate motor subroutine (2)
  __rotate_power2 byte
  __rotate_angle2 slong
  __rotate_ports2 byte[]
  __rotate_firstPort2 byte
  __rotate_sync2 byte
  __rotate_stop2 byte
  __rotate_turnpct2 sbyte
  __rotate_theUF2 byte
  __rotate_theOM2 byte
  __rotate_theRM2 byte
  __rotate_theRS2 byte
  __rotate_theRVP2 byte
  __rotate_theRVI2 byte
  __rotate_theRVD2 byte
  __rotate_rs2 byte
  __rotate_OldRotCount2 sword
  __rotate_RotCount2 sword
  __rotate_thePower2 sbyte
  __rotate_theAngle2 ulong
  __rotate_theTurnPct2 sbyte
  __rotate_then2 dword
  __rotate_now2 dword
dseg ends

dseg segment
// variables for rotate motor subroutine (3)
  __rotate_power3 byte
  __rotate_angle3 slong
  __rotate_ports3 byte[]
  __rotate_firstPort3 byte
  __rotate_sync3 byte
  __rotate_stop3 byte
  __rotate_turnpct3 sbyte
  __rotate_theUF3 byte
  __rotate_theOM3 byte
  __rotate_theRM3 byte
  __rotate_theRS3 byte
  __rotate_theRVP3 byte
  __rotate_theRVI3 byte
  __rotate_theRVD3 byte
  __rotate_rs3 byte
  __rotate_OldRotCount3 sword
  __rotate_RotCount3 sword
  __rotate_thePower3 sbyte
  __rotate_theAngle3 ulong
  __rotate_theTurnPct3 sbyte
  __rotate_then3 dword
  __rotate_now3 dword
dseg ends

dseg segment
// variables for rotate motor subroutine (4)
  __rotate_power4 byte
  __rotate_angle4 slong
  __rotate_ports4 byte[]
  __rotate_firstPort4 byte
  __rotate_sync4 byte
  __rotate_stop4 byte
  __rotate_turnpct4 sbyte
  __rotate_theUF4 byte
  __rotate_theOM4 byte
  __rotate_theRM4 byte
  __rotate_theRS4 byte
  __rotate_theRVP4 byte
  __rotate_theRVI4 byte
  __rotate_theRVD4 byte
  __rotate_rs4 byte
  __rotate_OldRotCount4 sword
  __rotate_RotCount4 sword
  __rotate_thePower4 sbyte
  __rotate_theAngle4 ulong
  __rotate_theTurnPct4 sbyte
  __rotate_then4 dword
  __rotate_now4 dword
dseg ends

dseg segment
// variables for rotate motor subroutine (5)
  __rotate_power5 byte
  __rotate_angle5 slong
  __rotate_ports5 byte[]
  __rotate_firstPort5 byte
  __rotate_sync5 byte
  __rotate_stop5 byte
  __rotate_turnpct5 sbyte
  __rotate_theUF5 byte
  __rotate_theOM5 byte
  __rotate_theRM5 byte
  __rotate_theRS5 byte
  __rotate_theRVP5 byte
  __rotate_theRVI5 byte
  __rotate_theRVD5 byte
  __rotate_rs5 byte
  __rotate_OldRotCount5 sword
  __rotate_RotCount5 sword
  __rotate_thePower5 sbyte
  __rotate_theAngle5 ulong
  __rotate_theTurnPct5 sbyte
  __rotate_then5 dword
  __rotate_now5 dword
dseg ends

dseg segment
// variables for rotate motor subroutine (6)
  __rotate_power6 byte
  __rotate_angle6 slong
  __rotate_ports6 byte[]
  __rotate_firstPort6 byte
  __rotate_sync6 byte
  __rotate_stop6 byte
  __rotate_turnpct6 sbyte
  __rotate_theUF6 byte
  __rotate_theOM6 byte
  __rotate_theRM6 byte
  __rotate_theRS6 byte
  __rotate_theRVP6 byte
  __rotate_theRVI6 byte
  __rotate_theRVD6 byte
  __rotate_rs6 byte
  __rotate_OldRotCount6 sword
  __rotate_RotCount6 sword
  __rotate_thePower6 sbyte
  __rotate_theAngle6 ulong
  __rotate_theTurnPct6 sbyte
  __rotate_then6 dword
  __rotate_now6 dword
dseg ends

#define UF_UPDATE_ONFWD 0x28

// API macros
#define __resetMotorCounter0(_val) setout OUT_A, UpdateFlagsField, _val
#define __resetMotorCounter1(_val) setout OUT_B, UpdateFlagsField, _val
#define __resetMotorCounter2(_val) setout OUT_C, UpdateFlagsField, _val
#define __resetMotorCounter3(_val) setout __OUT_AB, UpdateFlagsField, _val
#define __resetMotorCounter4(_val) setout __OUT_AC, UpdateFlagsField, _val
#define __resetMotorCounter5(_val) setout __OUT_BC, UpdateFlagsField, _val
#define __resetMotorCounter6(_val) setout __OUT_ABC, UpdateFlagsField, _val

#define __resetTachoCount(_p) \
  compif EQ, isconst(_p), FALSE \
  setout _p, UpdateFlagsField, RESET_COUNT \
  compelse \
  compchk LT, _p, 0x07 \
  compchk GTEQ, _p, 0x00 \
  __resetMotorCounter##_p(RESET_COUNT) \
  compend

#define __resetBlockTachoCount(_p) \
  compif EQ, isconst(_p), FALSE \
  setout _p, UpdateFlagsField, RESET_BLOCK_COUNT \
  compelse \
  compchk LT, _p, 0x07 \
  compchk GTEQ, _p, 0x00 \
  __resetMotorCounter##_p(RESET_BLOCK_COUNT) \
  compend

#define __resetRotationCount(_p) \
  compif EQ, isconst(_p), FALSE \
  setout _p, UpdateFlagsField, RESET_ROTATION_COUNT \
  compelse \
  compchk LT, _p, 0x07 \
  compchk GTEQ, _p, 0x00 \
  __resetMotorCounter##_p(RESET_ROTATION_COUNT) \
  compend

#define __resetAllTachoCounts(_p) \
  compif EQ, isconst(_p), FALSE \
  setout _p, UpdateFlagsField, RESET_ALL \
  compelse \
  compchk LT, _p, 0x07 \
  compchk GTEQ, _p, 0x00 \
  __resetMotorCounter##_p(RESET_ALL) \
  compend

#define __onFwdExPIDAll(_ports, _pwr, _reset, _p, _i, _d) setout _ports, PowerField, _pwr, OutputModeField, OUT_MODE_MOTORON+OUT_MODE_BRAKE, RegModeField, OUT_REGMODE_IDLE, RunStateField, OUT_RUNSTATE_RUNNING, TurnRatioField, 0, TachoLimitField, 0, RegPValueField, _p, RegIValueField, _i, RegDValueField, _d, UpdateFlagsField, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_MODE+UF_UPDATE_SPEED+UF_UPDATE_PID_VALUES+_reset
#define __onFwdExPID0(_pwr, _reset, _p, _i, _d) __onFwdExPIDAll(OUT_A, _pwr, _reset, _p, _i, _d)
#define __onFwdExPID1(_pwr, _reset, _p, _i, _d) __onFwdExPIDAll(OUT_B, _pwr, _reset, _p, _i, _d)
#define __onFwdExPID2(_pwr, _reset, _p, _i, _d) __onFwdExPIDAll(OUT_C, _pwr, _reset, _p, _i, _d)
#define __onFwdExPID3(_pwr, _reset, _p, _i, _d) __onFwdExPIDAll(__OUT_AB, _pwr, _reset, _p, _i, _d)
#define __onFwdExPID4(_pwr, _reset, _p, _i, _d) __onFwdExPIDAll(__OUT_AC, _pwr, _reset, _p, _i, _d)
#define __onFwdExPID5(_pwr, _reset, _p, _i, _d) __onFwdExPIDAll(__OUT_BC, _pwr, _reset, _p, _i, _d)
#define __onFwdExPID6(_pwr, _reset, _p, _i, _d) __onFwdExPIDAll(__OUT_ABC, _pwr, _reset, _p, _i, _d)

#define __coastExAll(_ports, _reset) setout _ports, PowerField, 0, OutputModeField, OUT_MODE_BRAKE, RegModeField, OUT_REGMODE_IDLE, RunStateField, OUT_RUNSTATE_IDLE, TurnRatioField, 0, TachoLimitField, 0, RegPValueField, PID_3, RegIValueField, PID_1, RegDValueField, PID_1, UpdateFlagsField, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_MODE+UF_UPDATE_SPEED+UF_UPDATE_PID_VALUES+_reset
#define __coastEx0(_reset) __coastExAll(OUT_A, _reset)
#define __coastEx1(_reset) __coastExAll(OUT_B, _reset)
#define __coastEx2(_reset) __coastExAll(OUT_C, _reset)
#define __coastEx3(_reset) __coastExAll(__OUT_AB, _reset)
#define __coastEx4(_reset) __coastExAll(__OUT_AC, _reset)
#define __coastEx5(_reset) __coastExAll(__OUT_BC, _reset)
#define __coastEx6(_reset) __coastExAll(__OUT_ABC, _reset)

#define __offExAll(_ports, _reset) setout _ports, PowerField, 0, OutputModeField, OUT_MODE_MOTORON+OUT_MODE_BRAKE, RegModeField, OUT_REGMODE_IDLE, RunStateField, OUT_RUNSTATE_RUNNING, TurnRatioField, 0, TachoLimitField, 0, RegPValueField, PID_3, RegIValueField, PID_1, RegDValueField, PID_1, UpdateFlagsField, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_MODE+UF_UPDATE_SPEED+UF_UPDATE_PID_VALUES+_reset
#define __offEx0(_reset) __offExAll(OUT_A, _reset)
#define __offEx1(_reset) __offExAll(OUT_B, _reset)
#define __offEx2(_reset) __offExAll(OUT_C, _reset)
#define __offEx3(_reset) __offExAll(__OUT_AB, _reset)
#define __offEx4(_reset) __offExAll(__OUT_AC, _reset)
#define __offEx5(_reset) __offExAll(__OUT_BC, _reset)
#define __offEx6(_reset) __offExAll(__OUT_ABC, _reset)

#define __onFwdRegExPIDAll(_ports, _pwr, _regmode, _reset, _p, _i, _d) setout _ports, PowerField, _pwr, OutputModeField, OUT_MODE_MOTORON+OUT_MODE_REGULATED+OUT_MODE_BRAKE, RegModeField, _regmode, RunStateField, OUT_RUNSTATE_RUNNING, TurnRatioField, 0, TachoLimitField, 0, RegPValueField, _p, RegIValueField, _i, RegDValueField, _d, UpdateFlagsField, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_MODE+UF_UPDATE_SPEED+UF_UPDATE_PID_VALUES+_reset
#define __onFwdRegExPID0(_pwr, _regmode, _reset, _p, _i, _d) __onFwdRegExPIDAll(OUT_A, _pwr, _regmode, _reset, _p, _i, _d)
#define __onFwdRegExPID1(_pwr, _regmode, _reset, _p, _i, _d) __onFwdRegExPIDAll(OUT_B, _pwr, _regmode, _reset, _p, _i, _d)
#define __onFwdRegExPID2(_pwr, _regmode, _reset, _p, _i, _d) __onFwdRegExPIDAll(OUT_C, _pwr, _regmode, _reset, _p, _i, _d)
#define __onFwdRegExPID3(_pwr, _regmode, _reset, _p, _i, _d) __onFwdRegExPIDAll(__OUT_AB, _pwr, _regmode, _reset, _p, _i, _d)
#define __onFwdRegExPID4(_pwr, _regmode, _reset, _p, _i, _d) __onFwdRegExPIDAll(__OUT_AC, _pwr, _regmode, _reset, _p, _i, _d)
#define __onFwdRegExPID5(_pwr, _regmode, _reset, _p, _i, _d) __onFwdRegExPIDAll(__OUT_BC, _pwr, _regmode, _reset, _p, _i, _d)
#define __onFwdRegExPID6(_pwr, _regmode, _reset, _p, _i, _d) __onFwdRegExPIDAll(__OUT_ABC, _pwr, _regmode, _reset, _p, _i, _d)

#define __onFwdSyncExPIDAll(_ports, _pwr, _turnpct, _reset, _p, _i, _d) setout _ports, PowerField, _pwr, OutputModeField, OUT_MODE_MOTORON+OUT_MODE_REGULATED+OUT_MODE_BRAKE, RegModeField, OUT_REGMODE_SYNC, TurnRatioField, _turnpct, RunStateField, OUT_RUNSTATE_RUNNING, TachoLimitField, 0, RegPValueField, _p, RegIValueField, _i, RegDValueField, _d, UpdateFlagsField, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_MODE+UF_UPDATE_SPEED+UF_UPDATE_PID_VALUES+_reset
#define __onFwdSyncExPID0(_pwr, _turnpct, _reset, _p, _i, _d) __onFwdSyncExPIDAll(OUT_A, _pwr, _turnpct, _reset, _p, _i, _d)
#define __onFwdSyncExPID1(_pwr, _turnpct, _reset, _p, _i, _d) __onFwdSyncExPIDAll(OUT_B, _pwr, _turnpct, _reset, _p, _i, _d)
#define __onFwdSyncExPID2(_pwr, _turnpct, _reset, _p, _i, _d) __onFwdSyncExPIDAll(OUT_C, _pwr, _turnpct, _reset, _p, _i, _d)
#define __onFwdSyncExPID3(_pwr, _turnpct, _reset, _p, _i, _d) __onFwdSyncExPIDAll(__OUT_AB, _pwr, _turnpct, _reset, _p, _i, _d)
#define __onFwdSyncExPID4(_pwr, _turnpct, _reset, _p, _i, _d) __onFwdSyncExPIDAll(__OUT_AC, _pwr, _turnpct, _reset, _p, _i, _d)
#define __onFwdSyncExPID5(_pwr, _turnpct, _reset, _p, _i, _d) __onFwdSyncExPIDAll(__OUT_BC, _pwr, _turnpct, _reset, _p, _i, _d)
#define __onFwdSyncExPID6(_pwr, _turnpct, _reset, _p, _i, _d) __onFwdSyncExPIDAll(__OUT_ABC, _pwr, _turnpct, _reset, _p, _i, _d)

#define __rotateMotorExPID0(_pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   acquire __rotateMutex0 \
   arrbuild __rotate_ports0, OUT_A \
   mov __rotate_power0, _pwr \
   mov __rotate_angle0, _angle \
   mov __rotate_turnpct0, _turnpct \
   mov __rotate_sync0, _bSync \
   mov __rotate_stop0, _bStop \
   mov __rotate_theRVP0, _p \
   mov __rotate_theRVI0, _i \
   mov __rotate_theRVD0, _d \
   call __RotateMotor0 \
   release __rotateMutex0

#define __rotateMotorExPID1(_pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   acquire __rotateMutex1 \
   arrbuild __rotate_ports1, OUT_B \
   mov __rotate_power1, _pwr \
   mov __rotate_angle1, _angle \
   mov __rotate_turnpct1, _turnpct \
   mov __rotate_sync1, _bSync \
   mov __rotate_stop1, _bStop \
   mov __rotate_theRVP1, _p \
   mov __rotate_theRVI1, _i \
   mov __rotate_theRVD1, _d \
   call __RotateMotor1 \
   release __rotateMutex1

#define __rotateMotorExPID2(_pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   acquire __rotateMutex2 \
   arrbuild __rotate_ports2, OUT_C \
   mov __rotate_power2, _pwr \
   mov __rotate_angle2, _angle \
   mov __rotate_turnpct2, _turnpct \
   mov __rotate_sync2, _bSync \
   mov __rotate_stop2, _bStop \
   mov __rotate_theRVP2, _p \
   mov __rotate_theRVI2, _i \
   mov __rotate_theRVD2, _d \
   call __RotateMotor2 \
   release __rotateMutex2

#define __rotateMotorExPID3(_pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   acquire __rotateMutex0 \
   acquire __rotateMutex1 \
   mov __rotate_ports3, __OUT_AB \
   mov __rotate_power3, _pwr \
   mov __rotate_angle3, _angle \
   mov __rotate_turnpct3, _turnpct \
   mov __rotate_sync3, _bSync \
   mov __rotate_stop3, _bStop \
   mov __rotate_theRVP3, _p \
   mov __rotate_theRVI3, _i \
   mov __rotate_theRVD3, _d \
   call __RotateMotor3 \
   release __rotateMutex1 \
   release __rotateMutex0

#define __rotateMotorExPID4(_pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   acquire __rotateMutex0 \
   acquire __rotateMutex2 \
   mov __rotate_ports4, __OUT_AC \
   mov __rotate_power4, _pwr \
   mov __rotate_angle4, _angle \
   mov __rotate_turnpct4, _turnpct \
   mov __rotate_sync4, _bSync \
   mov __rotate_stop4, _bStop \
   mov __rotate_theRVP4, _p \
   mov __rotate_theRVI4, _i \
   mov __rotate_theRVD4, _d \
   call __RotateMotor4 \
   release __rotateMutex2 \
   release __rotateMutex0

#define __rotateMotorExPID5(_pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   acquire __rotateMutex1 \
   acquire __rotateMutex2 \
   mov __rotate_ports5, __OUT_BC \
   mov __rotate_power5, _pwr \
   mov __rotate_angle5, _angle \
   mov __rotate_turnpct5, _turnpct \
   mov __rotate_sync5, _bSync \
   mov __rotate_stop5, _bStop \
   mov __rotate_theRVP5, _p \
   mov __rotate_theRVI5, _i \
   mov __rotate_theRVD5, _d \
   call __RotateMotor5 \
   release __rotateMutex2 \
   release __rotateMutex1

#define __rotateMotorExPID6(_pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   acquire __rotateMutex0 \
   acquire __rotateMutex1 \
   acquire __rotateMutex2 \
   mov __rotate_ports6, __OUT_ABC \
   mov __rotate_power6, _pwr \
   mov __rotate_angle6, _angle \
   mov __rotate_turnpct6, _turnpct \
   mov __rotate_sync6, _bSync \
   mov __rotate_stop6, _bStop \
   mov __rotate_theRVP6, _p \
   mov __rotate_theRVI6, _i \
   mov __rotate_theRVD6, _d \
   call __RotateMotor6 \
   release __rotateMutex2 \
   release __rotateMutex1 \
   release __rotateMutex0

#define __rotateMotorExPIDVar(_ports, _pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   acquire __rotateMutex0 \
   acquire __rotateMutex1 \
   acquire __rotateMutex2 \
   arrbuild __rotate_ports6, _ports \
   mov __rotate_power6, _pwr \
   mov __rotate_angle6, _angle \
   mov __rotate_turnpct6, _turnpct \
   mov __rotate_sync6, _bSync \
   mov __rotate_stop6, _bStop \
   mov __rotate_theRVP6, _p \
   mov __rotate_theRVI6, _i \
   mov __rotate_theRVD6, _d \
   call __RotateMotorVar \
   release __rotateMutex2 \
   release __rotateMutex1 \
   release __rotateMutex0

subroutine __RotateMotor0
  brtst EQ, __rotate_Done0, __rotate_angle0
  sign __rotate_thePower0, __rotate_angle0
  abs __rotate_theAngle0, __rotate_angle0
  mul __rotate_thePower0, __rotate_thePower0, __rotate_power0 // convert __rotate_power to negative value if __rotate_angle is negative.

  set __rotate_theUF0, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE+UF_UPDATE_PID_VALUES
  brtst EQ, __rotate_NoSync0, __rotate_sync0
  set __rotate_theOM0, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theRM0, OUT_REGMODE_SYNC
  mov __rotate_theTurnPct0, __rotate_turnpct0
  brtst EQ, __rotate_Start0, __rotate_theTurnPct0
  add __rotate_theUF0, __rotate_theUF0, UF_UPDATE_RESET_BLOCK_COUNT
  jmp __rotate_Start0
__rotate_NoSync0:
  set __rotate_theOM0, OUT_MODE_MOTORON+OUT_MODE_BRAKE
  set __rotate_theRM0, OUT_REGMODE_IDLE
  set __rotate_theTurnPct0, 0
__rotate_Start0:
  set __rotate_theRS0, OUT_RUNSTATE_RUNNING
  setout __rotate_ports0, OutputModeField, __rotate_theOM0, RegModeField, __rotate_theRM0, TachoLimitField, __rotate_theAngle0, RunStateField, __rotate_theRS0, RegPValueField, __rotate_theRVP0, RegIValueField, __rotate_theRVI0, RegDValueField, __rotate_theRVD0, PowerField, __rotate_thePower0, TurnRatioField, __rotate_turnpct0, UpdateFlagsField, __rotate_theUF0

// Waits till angle reached
  index __rotate_firstPort0, __rotate_ports0, NA
__rotate_Running0:
  getout __rotate_power0, __rotate_firstPort0, PowerField
  brtst EQ, __rotate_doneRunning0, __rotate_power0
  getout __rotate_rs0, __rotate_firstPort0, RunStateField
  brcmp EQ, __rotate_Running0, __rotate_rs0, OUT_RUNSTATE_RUNNING
__rotate_doneRunning0:
  brtst EQ, __rotate_Reset0, __rotate_stop0 // skip the speed regulation phase if __rotate_stop is false
// Regulates for speed = 0
  set __rotate_theOM0, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theUF0, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE
  setout __rotate_ports0, OutputModeField, __rotate_theOM0, RegModeField, OUT_REGMODE_SPEED, RunStateField, __rotate_theRS0, PowerField, 0, TachoLimitField, 0, UpdateFlagsField, __rotate_theUF0
// Verifies that motor doesn't rotate for 50ms, else loops
  getout __rotate_RotCount0, __rotate_firstPort0, RotationCountField
__rotate_Stabilize0:
  mov __rotate_OldRotCount0, __rotate_RotCount0
  wait 50
  // check rotation
  getout __rotate_RotCount0, __rotate_firstPort0, RotationCountField
  brcmp NEQ, __rotate_Stabilize0, __rotate_OldRotCount0, __rotate_RotCount0
  set __rotate_theOM0, OUT_MODE_COAST+OUT_MODE_REGULATED
  setout __rotate_ports0, RegModeField, __rotate_theRM0, RunStateField, OUT_RUNSTATE_IDLE, OutputModeField, __rotate_theOM0, UpdateFlagsField, UF_UPDATE_MODE
__rotate_Reset0:
  // maybe reset the block rotation count
  brtst EQ, __rotate_Done0, __rotate_theTurnPct0
  setout __rotate_ports0, UpdateFlagsField, UF_UPDATE_RESET_BLOCK_COUNT
__rotate_Done0:
  return
ends

subroutine __RotateMotor1
  brtst EQ, __rotate_Done1, __rotate_angle1
  sign __rotate_thePower1, __rotate_angle1
  abs __rotate_theAngle1, __rotate_angle1
  mul __rotate_thePower1, __rotate_thePower1, __rotate_power1 // convert __rotate_power to negative value if __rotate_angle is negative.

  set __rotate_theUF1, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE+UF_UPDATE_PID_VALUES
  brtst EQ, __rotate_NoSync1, __rotate_sync1
  set __rotate_theOM1, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theRM1, OUT_REGMODE_SYNC
  mov __rotate_theTurnPct1, __rotate_turnpct1
  brtst EQ, __rotate_Start1, __rotate_theTurnPct1
  add __rotate_theUF1, __rotate_theUF1, UF_UPDATE_RESET_BLOCK_COUNT
  jmp __rotate_Start1
__rotate_NoSync1:
  set __rotate_theOM1, OUT_MODE_MOTORON+OUT_MODE_BRAKE
  set __rotate_theRM1, OUT_REGMODE_IDLE
  set __rotate_theTurnPct1, 0
__rotate_Start1:
  set __rotate_theRS1, OUT_RUNSTATE_RUNNING
  setout __rotate_ports1, OutputModeField, __rotate_theOM1, RegModeField, __rotate_theRM1, TachoLimitField, __rotate_theAngle1, RunStateField, __rotate_theRS1, RegPValueField, __rotate_theRVP1, RegIValueField, __rotate_theRVI1, RegDValueField, __rotate_theRVD1, PowerField, __rotate_thePower1, TurnRatioField, __rotate_turnpct1, UpdateFlagsField, __rotate_theUF1

// Waits till angle reached
  index __rotate_firstPort1, __rotate_ports1, NA
__rotate_Running1:
  getout __rotate_power1, __rotate_firstPort1, PowerField
  brtst EQ, __rotate_doneRunning1, __rotate_power1
  getout __rotate_rs1, __rotate_firstPort1, RunStateField
  brcmp EQ, __rotate_Running1, __rotate_rs1, OUT_RUNSTATE_RUNNING
__rotate_doneRunning1:
  brtst EQ, __rotate_Reset1, __rotate_stop1 // skip the speed regulation phase if __rotate_stop is false
// Regulates for speed = 0
  set __rotate_theOM1, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theUF1, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE
  setout __rotate_ports1, OutputModeField, __rotate_theOM1, RegModeField, OUT_REGMODE_SPEED, RunStateField, __rotate_theRS1, PowerField, 0, TachoLimitField, 0, UpdateFlagsField, __rotate_theUF1
// Verifies that motor doesn't rotate for 50ms, else loops
  getout __rotate_RotCount1, __rotate_firstPort1, RotationCountField
__rotate_Stabilize1:
  mov __rotate_OldRotCount1, __rotate_RotCount1
  wait 50
  // check rotation
  getout __rotate_RotCount1, __rotate_firstPort1, RotationCountField
  brcmp NEQ, __rotate_Stabilize1, __rotate_OldRotCount1, __rotate_RotCount1
  set __rotate_theOM1, OUT_MODE_COAST+OUT_MODE_REGULATED
  setout __rotate_ports1, RegModeField, __rotate_theRM1, RunStateField, OUT_RUNSTATE_IDLE, OutputModeField, __rotate_theOM1, UpdateFlagsField, UF_UPDATE_MODE
__rotate_Reset1:
  // maybe reset the block rotation count
  brtst EQ, __rotate_Done1, __rotate_theTurnPct1
  setout __rotate_ports1, UpdateFlagsField, UF_UPDATE_RESET_BLOCK_COUNT
__rotate_Done1:
  return
ends

subroutine __RotateMotor2
  brtst EQ, __rotate_Done2, __rotate_angle2
  sign __rotate_thePower2, __rotate_angle2
  abs __rotate_theAngle2, __rotate_angle2
  mul __rotate_thePower2, __rotate_thePower2, __rotate_power2 // convert __rotate_power to negative value if __rotate_angle is negative.

  set __rotate_theUF2, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE+UF_UPDATE_PID_VALUES
  brtst EQ, __rotate_NoSync2, __rotate_sync2
  set __rotate_theOM2, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theRM2, OUT_REGMODE_SYNC
  mov __rotate_theTurnPct2, __rotate_turnpct2
  brtst EQ, __rotate_Start2, __rotate_theTurnPct2
  add __rotate_theUF2, __rotate_theUF2, UF_UPDATE_RESET_BLOCK_COUNT
  jmp __rotate_Start2
__rotate_NoSync2:
  set __rotate_theOM2, OUT_MODE_MOTORON+OUT_MODE_BRAKE
  set __rotate_theRM2, OUT_REGMODE_IDLE
  set __rotate_theTurnPct2, 0
__rotate_Start2:
  set __rotate_theRS2, OUT_RUNSTATE_RUNNING
  setout __rotate_ports2, OutputModeField, __rotate_theOM2, RegModeField, __rotate_theRM2, TachoLimitField, __rotate_theAngle2, RunStateField, __rotate_theRS2, RegPValueField, __rotate_theRVP2, RegIValueField, __rotate_theRVI2, RegDValueField, __rotate_theRVD2, PowerField, __rotate_thePower2, TurnRatioField, __rotate_turnpct2, UpdateFlagsField, __rotate_theUF2

// Waits till angle reached
  index __rotate_firstPort2, __rotate_ports2, NA
__rotate_Running2:
  getout __rotate_power2, __rotate_firstPort2, PowerField
  brtst EQ, __rotate_doneRunning2, __rotate_power2
  getout __rotate_rs2, __rotate_firstPort2, RunStateField
  brcmp EQ, __rotate_Running2, __rotate_rs2, OUT_RUNSTATE_RUNNING
__rotate_doneRunning2:
  brtst EQ, __rotate_Reset2, __rotate_stop2 // skip the speed regulation phase if __rotate_stop is false
// Regulates for speed = 0
  set __rotate_theOM2, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theUF2, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE
  setout __rotate_ports2, OutputModeField, __rotate_theOM2, RegModeField, OUT_REGMODE_SPEED, RunStateField, __rotate_theRS2, PowerField, 0, TachoLimitField, 0, UpdateFlagsField, __rotate_theUF2
// Verifies that motor doesn't rotate for 50ms, else loops
  getout __rotate_RotCount2, __rotate_firstPort2, RotationCountField
__rotate_Stabilize2:
  mov __rotate_OldRotCount2, __rotate_RotCount2
  wait 50
  // check rotation
  getout __rotate_RotCount2, __rotate_firstPort2, RotationCountField
  brcmp NEQ, __rotate_Stabilize2, __rotate_OldRotCount2, __rotate_RotCount2
  set __rotate_theOM2, OUT_MODE_COAST+OUT_MODE_REGULATED
  setout __rotate_ports2, RegModeField, __rotate_theRM2, RunStateField, OUT_RUNSTATE_IDLE, OutputModeField, __rotate_theOM2, UpdateFlagsField, UF_UPDATE_MODE
__rotate_Reset2:
  // maybe reset the block rotation count
  brtst EQ, __rotate_Done2, __rotate_theTurnPct2
  setout __rotate_ports2, UpdateFlagsField, UF_UPDATE_RESET_BLOCK_COUNT
__rotate_Done2:
  return
ends

subroutine __RotateMotor3
  brtst EQ, __rotate_Done3, __rotate_angle3
  sign __rotate_thePower3, __rotate_angle3
  abs __rotate_theAngle3, __rotate_angle3
  mul __rotate_thePower3, __rotate_thePower3, __rotate_power3 // convert __rotate_power to negative value if __rotate_angle is negative.

  set __rotate_theUF3, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE+UF_UPDATE_PID_VALUES
  brtst EQ, __rotate_NoSync3, __rotate_sync3
  set __rotate_theOM3, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theRM3, OUT_REGMODE_SYNC
  mov __rotate_theTurnPct3, __rotate_turnpct3
  brtst EQ, __rotate_Start3, __rotate_theTurnPct3
  add __rotate_theUF3, __rotate_theUF3, UF_UPDATE_RESET_BLOCK_COUNT
  jmp __rotate_Start3
__rotate_NoSync3:
  set __rotate_theOM3, OUT_MODE_MOTORON+OUT_MODE_BRAKE
  set __rotate_theRM3, OUT_REGMODE_IDLE
  set __rotate_theTurnPct3, 0
__rotate_Start3:
  set __rotate_theRS3, OUT_RUNSTATE_RUNNING
  setout __rotate_ports3, OutputModeField, __rotate_theOM3, RegModeField, __rotate_theRM3, TachoLimitField, __rotate_theAngle3, RunStateField, __rotate_theRS3, RegPValueField, __rotate_theRVP3, RegIValueField, __rotate_theRVI3, RegDValueField, __rotate_theRVD3, PowerField, __rotate_thePower3, TurnRatioField, __rotate_turnpct3, UpdateFlagsField, __rotate_theUF3

// Waits till angle reached
  index __rotate_firstPort3, __rotate_ports3, NA
__rotate_Running3:
  getout __rotate_power3, __rotate_firstPort3, PowerField
  brtst EQ, __rotate_doneRunning3, __rotate_power3
  getout __rotate_rs3, __rotate_firstPort3, RunStateField
  brcmp EQ, __rotate_Running3, __rotate_rs3, OUT_RUNSTATE_RUNNING
__rotate_doneRunning3:
  brtst EQ, __rotate_Reset3, __rotate_stop3 // skip the speed regulation phase if __rotate_stop is false
// Regulates for speed = 0
  set __rotate_theOM3, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theUF3, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE
  setout __rotate_ports3, OutputModeField, __rotate_theOM3, RegModeField, OUT_REGMODE_SPEED, RunStateField, __rotate_theRS3, PowerField, 0, TachoLimitField, 0, UpdateFlagsField, __rotate_theUF3
// Verifies that motor doesn't rotate for 50ms, else loops
  getout __rotate_RotCount3, __rotate_firstPort3, RotationCountField
__rotate_Stabilize3:
  mov __rotate_OldRotCount3, __rotate_RotCount3
  wait 50
  // check rotation
  getout __rotate_RotCount3, __rotate_firstPort3, RotationCountField
  brcmp NEQ, __rotate_Stabilize3, __rotate_OldRotCount3, __rotate_RotCount3
  set __rotate_theOM3, OUT_MODE_COAST+OUT_MODE_REGULATED
  setout __rotate_ports3, RegModeField, __rotate_theRM3, RunStateField, OUT_RUNSTATE_IDLE, OutputModeField, __rotate_theOM3, UpdateFlagsField, UF_UPDATE_MODE
__rotate_Reset3:
  // maybe reset the block rotation count
  brtst EQ, __rotate_Done3, __rotate_theTurnPct3
  setout __rotate_ports3, UpdateFlagsField, UF_UPDATE_RESET_BLOCK_COUNT
__rotate_Done3:
  return
ends

subroutine __RotateMotor4
  brtst EQ, __rotate_Done4, __rotate_angle4
  sign __rotate_thePower4, __rotate_angle4
  abs __rotate_theAngle4, __rotate_angle4
  mul __rotate_thePower4, __rotate_thePower4, __rotate_power4 // convert __rotate_power to negative value if __rotate_angle is negative.

  set __rotate_theUF4, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE+UF_UPDATE_PID_VALUES
  brtst EQ, __rotate_NoSync4, __rotate_sync4
  set __rotate_theOM4, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theRM4, OUT_REGMODE_SYNC
  mov __rotate_theTurnPct4, __rotate_turnpct4
  brtst EQ, __rotate_Start4, __rotate_theTurnPct4
  add __rotate_theUF4, __rotate_theUF4, UF_UPDATE_RESET_BLOCK_COUNT
  jmp __rotate_Start4
__rotate_NoSync4:
  set __rotate_theOM4, OUT_MODE_MOTORON+OUT_MODE_BRAKE
  set __rotate_theRM4, OUT_REGMODE_IDLE
  set __rotate_theTurnPct4, 0
__rotate_Start4:
  set __rotate_theRS4, OUT_RUNSTATE_RUNNING
  setout __rotate_ports4, OutputModeField, __rotate_theOM4, RegModeField, __rotate_theRM4, TachoLimitField, __rotate_theAngle4, RunStateField, __rotate_theRS4, RegPValueField, __rotate_theRVP4, RegIValueField, __rotate_theRVI4, RegDValueField, __rotate_theRVD4, PowerField, __rotate_thePower4, TurnRatioField, __rotate_turnpct4, UpdateFlagsField, __rotate_theUF4

// Waits till angle reached
  index __rotate_firstPort4, __rotate_ports4, NA
__rotate_Running4:
  getout __rotate_power4, __rotate_firstPort4, PowerField
  brtst EQ, __rotate_doneRunning4, __rotate_power4
  getout __rotate_rs4, __rotate_firstPort4, RunStateField
  brcmp EQ, __rotate_Running4, __rotate_rs4, OUT_RUNSTATE_RUNNING
__rotate_doneRunning4:
  brtst EQ, __rotate_Reset4, __rotate_stop4 // skip the speed regulation phase if __rotate_stop is false
// Regulates for speed = 0
  set __rotate_theOM4, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theUF4, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE
  setout __rotate_ports4, OutputModeField, __rotate_theOM4, RegModeField, OUT_REGMODE_SPEED, RunStateField, __rotate_theRS4, PowerField, 0, TachoLimitField, 0, UpdateFlagsField, __rotate_theUF4
// Verifies that motor doesn't rotate for 50ms, else loops
  getout __rotate_RotCount4, __rotate_firstPort4, RotationCountField
__rotate_Stabilize4:
  mov __rotate_OldRotCount4, __rotate_RotCount4
  wait 50
  // check rotation
  getout __rotate_RotCount4, __rotate_firstPort4, RotationCountField
  brcmp NEQ, __rotate_Stabilize4, __rotate_OldRotCount4, __rotate_RotCount4
  set __rotate_theOM4, OUT_MODE_COAST+OUT_MODE_REGULATED
  setout __rotate_ports4, RegModeField, __rotate_theRM4, RunStateField, OUT_RUNSTATE_IDLE, OutputModeField, __rotate_theOM4, UpdateFlagsField, UF_UPDATE_MODE
__rotate_Reset4:
  // maybe reset the block rotation count
  brtst EQ, __rotate_Done4, __rotate_theTurnPct4
  setout __rotate_ports4, UpdateFlagsField, UF_UPDATE_RESET_BLOCK_COUNT
__rotate_Done4:
  return
ends

subroutine __RotateMotor5
  brtst EQ, __rotate_Done5, __rotate_angle5
  sign __rotate_thePower5, __rotate_angle5
  abs __rotate_theAngle5, __rotate_angle5
  mul __rotate_thePower5, __rotate_thePower5, __rotate_power5 // convert __rotate_power to negative value if __rotate_angle is negative.

  set __rotate_theUF5, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE+UF_UPDATE_PID_VALUES
  brtst EQ, __rotate_NoSync5, __rotate_sync5
  set __rotate_theOM5, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theRM5, OUT_REGMODE_SYNC
  mov __rotate_theTurnPct5, __rotate_turnpct5
  brtst EQ, __rotate_Start5, __rotate_theTurnPct5
  add __rotate_theUF5, __rotate_theUF5, UF_UPDATE_RESET_BLOCK_COUNT
  jmp __rotate_Start5
__rotate_NoSync5:
  set __rotate_theOM5, OUT_MODE_MOTORON+OUT_MODE_BRAKE
  set __rotate_theRM5, OUT_REGMODE_IDLE
  set __rotate_theTurnPct5, 0
__rotate_Start5:
  set __rotate_theRS5, OUT_RUNSTATE_RUNNING
  setout __rotate_ports5, OutputModeField, __rotate_theOM5, RegModeField, __rotate_theRM5, TachoLimitField, __rotate_theAngle5, RunStateField, __rotate_theRS5, RegPValueField, __rotate_theRVP5, RegIValueField, __rotate_theRVI5, RegDValueField, __rotate_theRVD5, PowerField, __rotate_thePower5, TurnRatioField, __rotate_turnpct5, UpdateFlagsField, __rotate_theUF5

// Waits till angle reached
  index __rotate_firstPort5, __rotate_ports5, NA
__rotate_Running5:
  getout __rotate_power5, __rotate_firstPort5, PowerField
  brtst EQ, __rotate_doneRunning5, __rotate_power5
  getout __rotate_rs5, __rotate_firstPort5, RunStateField
  brcmp EQ, __rotate_Running5, __rotate_rs5, OUT_RUNSTATE_RUNNING
__rotate_doneRunning5:
  brtst EQ, __rotate_Reset5, __rotate_stop5 // skip the speed regulation phase if __rotate_stop is false
// Regulates for speed = 0
  set __rotate_theOM5, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theUF5, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE
  setout __rotate_ports5, OutputModeField, __rotate_theOM5, RegModeField, OUT_REGMODE_SPEED, RunStateField, __rotate_theRS5, PowerField, 0, TachoLimitField, 0, UpdateFlagsField, __rotate_theUF5
// Verifies that motor doesn't rotate for 50ms, else loops
  getout __rotate_RotCount5, __rotate_firstPort5, RotationCountField
__rotate_Stabilize5:
  mov __rotate_OldRotCount5, __rotate_RotCount5
  wait 50
  // check rotation
  getout __rotate_RotCount5, __rotate_firstPort5, RotationCountField
  brcmp NEQ, __rotate_Stabilize5, __rotate_OldRotCount5, __rotate_RotCount5
  set __rotate_theOM5, OUT_MODE_COAST+OUT_MODE_REGULATED
  setout __rotate_ports5, RegModeField, __rotate_theRM5, RunStateField, OUT_RUNSTATE_IDLE, OutputModeField, __rotate_theOM5, UpdateFlagsField, UF_UPDATE_MODE
__rotate_Reset5:
  // maybe reset the block rotation count
  brtst EQ, __rotate_Done5, __rotate_theTurnPct5
  setout __rotate_ports5, UpdateFlagsField, UF_UPDATE_RESET_BLOCK_COUNT
__rotate_Done5:
  return
ends

subroutine __RotateMotor6
  brtst EQ, __rotate_Done6, __rotate_angle6
  sign __rotate_thePower6, __rotate_angle6
  abs __rotate_theAngle6, __rotate_angle6
  mul __rotate_thePower6, __rotate_thePower6, __rotate_power6 // convert __rotate_power to negative value if __rotate_angle is negative.

  set __rotate_theUF6, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE+UF_UPDATE_PID_VALUES
  brtst EQ, __rotate_NoSync6, __rotate_sync6
  set __rotate_theOM6, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theRM6, OUT_REGMODE_SYNC
  mov __rotate_theTurnPct6, __rotate_turnpct6
  brtst EQ, __rotate_Start6, __rotate_theTurnPct6
  add __rotate_theUF6, __rotate_theUF6, UF_UPDATE_RESET_BLOCK_COUNT
  jmp __rotate_Start6
__rotate_NoSync6:
  set __rotate_theOM6, OUT_MODE_MOTORON+OUT_MODE_BRAKE
  set __rotate_theRM6, OUT_REGMODE_IDLE
  set __rotate_theTurnPct6, 0
__rotate_Start6:
  set __rotate_theRS6, OUT_RUNSTATE_RUNNING
  setout __rotate_ports6, OutputModeField, __rotate_theOM6, RegModeField, __rotate_theRM6, TachoLimitField, __rotate_theAngle6, RunStateField, __rotate_theRS6, RegPValueField, __rotate_theRVP6, RegIValueField, __rotate_theRVI6, RegDValueField, __rotate_theRVD6, PowerField, __rotate_thePower6, TurnRatioField, __rotate_turnpct6, UpdateFlagsField, __rotate_theUF6

// Waits till angle reached
  index __rotate_firstPort6, __rotate_ports6, NA
__rotate_Running6:
  getout __rotate_power6, __rotate_firstPort6, PowerField
  brtst EQ, __rotate_doneRunning6, __rotate_power6
  getout __rotate_rs6, __rotate_firstPort6, RunStateField
  brcmp EQ, __rotate_Running6, __rotate_rs6, OUT_RUNSTATE_RUNNING
__rotate_doneRunning6:
  brtst EQ, __rotate_Reset6, __rotate_stop6 // skip the speed regulation phase if __rotate_stop is false
// Regulates for speed = 0
  set __rotate_theOM6, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED
  set __rotate_theUF6, UF_UPDATE_TACHO_LIMIT+UF_UPDATE_SPEED+UF_UPDATE_MODE
  setout __rotate_ports6, OutputModeField, __rotate_theOM6, RegModeField, OUT_REGMODE_SPEED, RunStateField, __rotate_theRS6, PowerField, 0, TachoLimitField, 0, UpdateFlagsField, __rotate_theUF6
// Verifies that motor doesn't rotate for 50ms, else loops
  getout __rotate_RotCount6, __rotate_firstPort6, RotationCountField
__rotate_Stabilize6:
  mov __rotate_OldRotCount6, __rotate_RotCount6
  wait 50
  // check rotation
  getout __rotate_RotCount6, __rotate_firstPort6, RotationCountField
  brcmp NEQ, __rotate_Stabilize6, __rotate_OldRotCount6, __rotate_RotCount6
  set __rotate_theOM6, OUT_MODE_COAST+OUT_MODE_REGULATED
  setout __rotate_ports6, RegModeField, __rotate_theRM6, RunStateField, OUT_RUNSTATE_IDLE, OutputModeField, __rotate_theOM6, UpdateFlagsField, UF_UPDATE_MODE
__rotate_Reset6:
  // maybe reset the block rotation count
  brtst EQ, __rotate_Done6, __rotate_theTurnPct6
  setout __rotate_ports6, UpdateFlagsField, UF_UPDATE_RESET_BLOCK_COUNT
__rotate_Done6:
  return
ends

subroutine __RotateMotorVar
/*
  _ports should be an array but it might be an integer from 0..6
  (OUT_A, OUT_B, OUT_C, OUT_AB, OUT_AC, OUT_BC, OUT_ABC)
  This subroutine converts, if necessary, an array containing a single byte
  > 2 into an array containing multiple bytes and then falls through to
  the RotateMotor6 subroutine.  It uses __rotate_rs6 as a temporary variable
*/
  arrsize __rotate_rs6, __rotate_ports6 // what is the size of the array?
  brcmp GT, __rmvCallSub, __rotate_rs6, 1 // fall through if size > 1
  // only one element in the array.  What is its value?
  index __rotate_rs6, __rotate_ports6, NA // grab the first element
  brcmp LT, __rmvCallSub, __rotate_rs6, 3 // if it is less than 3 just call the subroutine
  brcmp GT, __rmvExit, __rotate_rs6, 6 // if it is greater than 6 abort
  // start with 3
  mov __rotate_ports6, __OUT_AB
  brcmp EQ, __rmvCallSub, __rotate_rs6, 3
  mov __rotate_ports6, __OUT_AC
  brcmp EQ, __rmvCallSub, __rotate_rs6, 4
  mov __rotate_ports6, __OUT_BC
  brcmp EQ, __rmvCallSub, __rotate_rs6, 5
  mov __rotate_ports6, __OUT_ABC
__rmvCallSub:
  call __RotateMotor6
__rmvExit:
  return
ends

dseg segment
  __SensorInvalidTmp byte
dseg ends

dseg segment
  __ResetSensorMutex mutex
  __ResetSensorPort byte
  __ResetSensorTmp byte
dseg ends

subroutine __ResetSensorSubroutine
  setin TRUE, __ResetSensorPort, InvalidDataField
__SensorStillInvalid:
  getin	__ResetSensorTmp, __ResetSensorPort, InvalidDataField
  brtst	NEQ, __SensorStillInvalid, __ResetSensorTmp
  return
ends

#define __ResetSensor(_port) \
  acquire __ResetSensorMutex \
  mov __ResetSensorPort, _port \
  call __ResetSensorSubroutine \
  release __ResetSensorMutex

#define __SetSensorTouch(_port) \
  setin IN_TYPE_SWITCH, _port, TypeField \
  setin IN_MODE_BOOLEAN, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorLight(_port) \
  setin IN_TYPE_LIGHT_ACTIVE, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorSound(_port) \
  setin IN_TYPE_SOUND_DB, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorLowspeed(_port) \
  setin IN_TYPE_LOWSPEED_9V, _port, TypeField \
  setin IN_MODE_RAW, _port, InputModeField \
  __ResetSensor(_port)

#if __FIRMWARE_VERSION > 107

#define __SetSensorColorFull(_port) \
  setin IN_TYPE_COLORFULL, _port, TypeField \
  setin IN_MODE_RAW, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorColorRed(_port) \
  setin IN_TYPE_COLORRED, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorColorGreen(_port) \
  setin IN_TYPE_COLORGREEN, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorColorBlue(_port) \
  setin IN_TYPE_COLORBLUE, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorColorNone(_port) \
  setin IN_TYPE_COLORNONE, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port)

#endif

dseg segment
// port 0
  __CLSCSArgs0 TCommLSCheckStatus
  __CLSCSMutex0 mutex
  __CLSWArgs0 TCommLSWrite
  __CLSWMutex0 mutex
  __CLSRArgs0 TCommLSRead
  __CLSRMutex0 mutex
// port 1
  __CLSCSArgs1 TCommLSCheckStatus
  __CLSCSMutex1 mutex
  __CLSWArgs1 TCommLSWrite
  __CLSWMutex1 mutex
  __CLSRArgs1 TCommLSRead
  __CLSRMutex1 mutex
// port 2
  __CLSCSArgs2 TCommLSCheckStatus
  __CLSCSMutex2 mutex
  __CLSWArgs2 TCommLSWrite
  __CLSWMutex2 mutex
  __CLSRArgs2 TCommLSRead
  __CLSRMutex2 mutex
// port 3
  __CLSCSArgs3 TCommLSCheckStatus
  __CLSCSMutex3 mutex
  __CLSWArgs3 TCommLSWrite
  __CLSWMutex3 mutex
  __CLSRArgs3 TCommLSRead
  __CLSRMutex3 mutex
  __LSWriteOptionsVar byte
  __LSWriteOptions0 byte
  __LSWriteOptions1 byte
  __LSWriteOptions2 byte
  __LSWriteOptions3 byte
dseg ends

#define __lowspeedStatus(_port, _bready, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __CLSCSMutex0 \
  acquire __CLSCSMutex1 \
  acquire __CLSCSMutex2 \
  acquire __CLSCSMutex3 \
  mov __CLSCSArgs0.Port, _port \
  syscall CommLSCheckStatus, __CLSCSArgs0 \
  mov _bready, __CLSCSArgs0.BytesReady \
  mov _result, __CLSCSArgs0.Result \
  release __CLSCSMutex0 \
  release __CLSCSMutex1 \
  release __CLSCSMutex2 \
  release __CLSCSMutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __CLSCSMutex##_port \
  set __CLSCSArgs##_port.Port, _port \
  syscall CommLSCheckStatus, __CLSCSArgs##_port \
  mov _bready, __CLSCSArgs##_port.BytesReady \
  mov _result, __CLSCSArgs##_port.Result \
  release __CLSCSMutex##_port \
  compend

#define __lowspeedCheckStatus(_port, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __CLSCSMutex0 \
  acquire __CLSCSMutex1 \
  acquire __CLSCSMutex2 \
  acquire __CLSCSMutex3 \
  mov __CLSCSArgs0.Port, _port \
  syscall CommLSCheckStatus, __CLSCSArgs0 \
  mov _result, __CLSCSArgs0.Result \
  release __CLSCSMutex0 \
  release __CLSCSMutex1 \
  release __CLSCSMutex2 \
  release __CLSCSMutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __CLSCSMutex##_port \
  set __CLSCSArgs##_port.Port, _port \
  syscall CommLSCheckStatus, __CLSCSArgs##_port \
  mov _result, __CLSCSArgs##_port.Result \
  release __CLSCSMutex##_port \
  compend

#define __lowspeedBytesReady(_port, _bready) \
  compif EQ, isconst(_port), FALSE \
  acquire __CLSCSMutex0 \
  acquire __CLSCSMutex1 \
  acquire __CLSCSMutex2 \
  acquire __CLSCSMutex3 \
  mov __CLSCSArgs0.Port, _port \
  syscall CommLSCheckStatus, __CLSCSArgs0 \
  mov _bready, __CLSCSArgs0.BytesReady \
  release __CLSCSMutex0 \
  release __CLSCSMutex1 \
  release __CLSCSMutex2 \
  release __CLSCSMutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __CLSCSMutex##_port \
  set __CLSCSArgs##_port.Port, _port \
  syscall CommLSCheckStatus, __CLSCSArgs##_port \
  mov _bready, __CLSCSArgs##_port.BytesReady \
  release __CLSCSMutex##_port \
  compend

#define __lowspeedWrite(_port, _retlen, _buffer, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __CLSWMutex0 \
  acquire __CLSWMutex1 \
  acquire __CLSWMutex2 \
  acquire __CLSWMutex3 \
  or __CLSWArgs0.Port, _port, __LSWriteOptionsVar \
  mov __CLSWArgs0.ReturnLen, _retlen \
  mov __CLSWArgs0.Buffer, _buffer \
  syscall CommLSWrite, __CLSWArgs0 \
  mov _result, __CLSWArgs0.Result \
  release __CLSWMutex0 \
  release __CLSWMutex1 \
  release __CLSWMutex2 \
  release __CLSWMutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __CLSWMutex##_port \
  or __CLSWArgs##_port.Port, _port, __LSWriteOptions##_port \
  mov __CLSWArgs##_port.ReturnLen, _retlen \
  mov __CLSWArgs##_port.Buffer, _buffer \
  syscall CommLSWrite, __CLSWArgs##_port \
  mov _result, __CLSWArgs##_port.Result \
  release __CLSWMutex##_port \
  compend

#define __lowspeedRead(_port, _buflen, _buffer, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __CLSRMutex0 \
  acquire __CLSRMutex1 \
  acquire __CLSRMutex2 \
  acquire __CLSRMutex3 \
  mov __CLSRArgs0.Port, _port \
  mov __CLSRArgs0.BufferLen, _buflen \
  syscall CommLSRead, __CLSRArgs0 \
  mov _buffer, __CLSRArgs0.Buffer \
  mov _result, __CLSRArgs0.Result \
  release __CLSRMutex0 \
  release __CLSRMutex1 \
  release __CLSRMutex2 \
  release __CLSRMutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __CLSRMutex##_port \
  set __CLSRArgs##_port.Port, _port \
  mov __CLSRArgs##_port.BufferLen, _buflen \
  syscall CommLSRead, __CLSRArgs##_port \
  mov _buffer, __CLSRArgs##_port.Buffer \
  mov _result, __CLSRArgs##_port.Result \
  release __CLSRMutex##_port \
  compend

#define __setI2COptions(_port, _options) \
  compif EQ, isconst(_port), FALSE \
  mov __LSWriteOptionsVar, _options \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  mov __LSWriteOptions##_port, _options \
  mov __LSWriteOptionsVar, __LSWriteOptions##_port \
  compend


dseg segment
  __TextOutMutex mutex
  __TextOutArgs TDrawText
  __BlankLine byte[] '                    '
  __NumOutMutex mutex
  __NumOutArgs TDrawText
  __PointOutArgs TDrawPoint
  __PointOutMutex mutex
  __LineOutArgs TDrawLine
  __LineOutMutex mutex
  __RectOutArgs TDrawRect
  __RectOutMutex mutex
  __CircleOutArgs TDrawCircle
  __CircleOutMutex mutex
  __GraphicOutArgs TDrawGraphic
  __GraphicOutMutex mutex
  __GraphicOutEmptyVars sdword[]
dseg ends

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)

dseg segment
  __GraphicArrayOutArgs TDrawGraphicArray
  __PolyOutArgs TDrawPolygon
  __PolyOutMutex mutex
  __EllipseOutArgs TDrawEllipse
  __EllipseOutMutex mutex
  __FontOutMutex mutex
  __FontOutArgs TDrawFont
  __MemMgrMutex mutex
  __MemMgrArgs TMemoryManager
  __ReadLastMutex mutex
  __ReadLastArgs TReadLastResponse
dseg ends

#endif

#if __FIRMWARE_VERSION > 107

dseg segment
  __ColorSensorReadArgs TColorSensorRead
  __ColorSensorReadMutex mutex
dseg ends

#define __ReadSensorColorRaw(_port, _rawVals, _result) \
  acquire __ColorSensorReadMutex \
  mov __ColorSensorReadArgs.Port,_port \
  syscall ColorSensorRead,__ColorSensorReadArgs \
  mov _rawVals, __ColorSensorReadArgs.RawArray \
  tst EQ, _result, __ColorSensorReadArgs.Result \
  release __ColorSensorReadMutex

#define __ReadSensorColorEx(_port, _colorval, _rawVals, _normVals, _scaledVals, _result) \
  acquire __ColorSensorReadMutex \
  mov __ColorSensorReadArgs.Port,_port \
  syscall ColorSensorRead,__ColorSensorReadArgs \
  mov _colorval, __ColorSensorReadArgs.ColorValue \
  mov _rawVals, __ColorSensorReadArgs.RawArray \
  mov _normVals, __ColorSensorReadArgs.NormalizedArray \
  mov _scaledVals, __ColorSensorReadArgs.ScaledArray \
  tst EQ, _result, __ColorSensorReadArgs.Result \
  release __ColorSensorReadMutex

#endif

#define __OnFwdEx(_ports, _pwr, _reset) \
  compif EQ, isconst(_ports), FALSE \
  __onFwdExPIDAll(_ports, _pwr, _reset, PID_3, PID_1, PID_1) \
  compelse \
  compchk LT, _ports, 0x07 \
  compchk GTEQ, _ports, 0x00 \
  __onFwdExPID##_ports(_pwr, _reset, PID_3, PID_1, PID_1) \
  compend

#define __OnRevEx(_ports, _pwr, _reset) \
  acquire __OnRevMutex \
  neg __OnRev_Tmp, _pwr \
  __OnFwdEx(_ports, __OnRev_Tmp, _reset) \
  release __OnRevMutex

#define __OnFwdExPID(_ports, _pwr, _reset, _p, _i, _d) \
  compif EQ, isconst(_ports), FALSE \
  __onFwdExPIDAll(_ports, _pwr, _reset, _p, _i, _d) \
  compelse \
  compchk LT, _ports, 0x07 \
  compchk GTEQ, _ports, 0x00 \
  __onFwdExPID##_ports(_pwr, _reset, _p, _i, _d) \
  compend

#define __OnRevExPID(_ports, _pwr, _reset, _p, _i, _d) \
  acquire __OnRevMutex \
  neg __OnRev_Tmp, _pwr \
  __OnFwdExPID(_ports, __OnRev_Tmp, _reset, _p, _i, _d) \
  release __OnRevMutex

#define __CoastEx(_ports, _reset) \
  compif EQ, isconst(_ports), FALSE \
  __coastExAll(_ports, _reset) \
  compelse \
  compchk LT, _ports, 0x07 \
  compchk GTEQ, _ports, 0x00 \
  __coastEx##_ports(_reset) \
  compend

#define __OffEx(_ports, _reset) \
  compif EQ, isconst(_ports), FALSE \
  __offExAll(_ports, _reset) \
  compelse \
  compchk LT, _ports, 0x07 \
  compchk GTEQ, _ports, 0x00 \
  __offEx##_ports(_reset) \
  compend

#define __OnFwdRegEx(_ports, _pwr, _regmode, _reset) \
  compif EQ, isconst(_ports), FALSE \
  __onFwdRegExPIDAll(_ports, _pwr, _regmode, _reset, PID_3, PID_1, PID_1) \
  compelse \
  compchk LT, _ports, 0x07 \
  compchk GTEQ, _ports, 0x00 \
  __onFwdRegExPID##_ports(_pwr, _regmode, _reset, PID_3, PID_1, PID_1) \
  compend

#define __OnRevRegEx(_ports, _pwr, _regmode, _reset) \
  acquire __OnRevMutex \
  neg __OnRev_Tmp, _pwr \
  __OnFwdRegEx(_ports, __OnRev_Tmp, _regmode, _reset) \
  release __OnRevMutex

#define __OnFwdRegExPID(_ports, _pwr, _regmode, _reset, _p, _i, _d) \
  compif EQ, isconst(_ports), FALSE \
  __onFwdRegExPIDAll(_ports, _pwr, _regmode, _reset, _p, _i, _d) \
  compelse \
  compchk LT, _ports, 0x07 \
  compchk GTEQ, _ports, 0x00 \
  __onFwdRegExPID##_ports(_pwr, _regmode, _reset, _p, _i, _d) \
  compend

#define __OnRevRegExPID(_ports, _pwr, _regmode, _reset, _p, _i, _d) \
  acquire __OnRevMutex \
  neg __OnRev_Tmp, _pwr \
  __OnFwdRegExPID(_ports, __OnRev_Tmp, _regmode, _reset, _p, _i, _d) \
  release __OnRevMutex

#define __OnFwdSyncEx(_ports, _pwr, _turnpct, _reset) \
  compif EQ, isconst(_ports), FALSE \
  __onFwdSyncExPIDAll(_ports, _pwr, _turnpct, _reset, PID_3, PID_1, PID_1) \
  compelse \
  compchk LT, _ports, 0x07 \
  compchk GTEQ, _ports, 0x00 \
  __onFwdSyncExPID##_ports(_pwr, _turnpct, _reset, PID_3, PID_1, PID_1) \
  compend

#define __OnRevSyncEx(_ports, _pwr, _turnpct, _reset) \
  acquire __OnRevMutex \
  neg __OnRev_Tmp, _pwr \
  __OnFwdSyncEx(_ports, __OnRev_Tmp, _turnpct, _reset) \
  release __OnRevMutex

#define __OnFwdSyncExPID(_ports, _pwr, _turnpct, _reset, _p, _i, _d) \
  compif EQ, isconst(_ports), FALSE \
  __onFwdSyncExPIDAll(_ports, _pwr, _turnpct, _reset, _p, _i, _d) \
  compelse \
  compchk LT, _ports, 0x07 \
  compchk GTEQ, _ports, 0x00 \
  __onFwdSyncExPID##_ports(_pwr, _turnpct, _reset, _p, _i, _d) \
  compend

#define __OnRevSyncExPID(_ports, _pwr, _turnpct, _reset, _p, _i, _d) \
  acquire __OnRevMutex \
  neg __OnRev_Tmp, _pwr \
  __OnFwdSyncExPID(_ports, __OnRev_Tmp, _turnpct, _reset, _p, _i, _d) \
  release __OnRevMutex

#define __RotateMotorExPID(_ports, _pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   compif EQ, isconst(_ports), FALSE \
   __rotateMotorExPIDVar(_ports, _pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   compelse \
   compchk LT, _ports, 0x07 \
   compchk GTEQ, _ports, 0x00 \
   __rotateMotorExPID##_ports(_pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   compend

#define __TextOutEx(_x,_y,_txt,_options) \
  acquire __TextOutMutex \
  mov __TextOutArgs.Location.X,_x \
  mov __TextOutArgs.Location.Y,_y \
  mov __TextOutArgs.Options,_options \
  mov __TextOutArgs.Text,_txt \
  syscall DrawText,__TextOutArgs \
  release __TextOutMutex

#define __NumOutEx(_x,_y,_num,_options) \
  acquire __NumOutMutex \
  mov __NumOutArgs.Location.X,_x \
  mov __NumOutArgs.Location.Y,_y \
  mov __NumOutArgs.Options,_options \
  numtostr __NumOutArgs.Text,_num \
  syscall DrawText,__NumOutArgs \
  release __NumOutMutex

#define __PointOutEx(_x,_y,_options) \
  acquire __PointOutMutex \
  mov __PointOutArgs.Location.X,_x \
  mov __PointOutArgs.Location.Y,_y \
  mov __PointOutArgs.Options,_options \
  syscall DrawPoint,__PointOutArgs \
  release __PointOutMutex

#define __LineOutEx(_x1,_y1,_x2,_y2,_options) \
  acquire __LineOutMutex \
  mov __LineOutArgs.StartLoc.X,_x1 \
  mov __LineOutArgs.StartLoc.Y,_y1 \
  mov __LineOutArgs.EndLoc.X,_x2 \
  mov __LineOutArgs.EndLoc.Y,_y2 \
  mov __LineOutArgs.Options,_options \
  syscall DrawLine,__LineOutArgs \
  release __LineOutMutex

#define __RectOutEx(_x,_y,_w,_h,_options) \
  acquire __RectOutMutex \
  mov __RectOutArgs.Location.X,_x \
  mov __RectOutArgs.Location.Y,_y \
  mov __RectOutArgs.Size.Width,_w \
  mov __RectOutArgs.Size.Height,_h \
  mov __RectOutArgs.Options,_options \
  syscall DrawRect,__RectOutArgs \
  release __RectOutMutex

#define __CircleOutEx(_x,_y,_r,_options) \
  acquire __CircleOutMutex \
  mov __CircleOutArgs.Center.X,_x \
  mov __CircleOutArgs.Center.Y,_y \
  mov __CircleOutArgs.Size,_r \
  mov __CircleOutArgs.Options,_options \
  syscall DrawCircle,__CircleOutArgs \
  release __CircleOutMutex

#define __GraphicOutEx(_x,_y,_file,_vars,_options) \
  acquire __GraphicOutMutex \
  mov __GraphicOutArgs.Location.X,_x \
  mov __GraphicOutArgs.Location.Y,_y \
  mov __GraphicOutArgs.Filename,_file \
  mov __GraphicOutArgs.Variables,_vars \
  mov __GraphicOutArgs.Options,_options \
  syscall DrawGraphic,__GraphicOutArgs \
  release __GraphicOutMutex

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)

#define __GraphicArrayOutEx(_x,_y,_data,_vars,_options) \
  acquire __GraphicOutMutex \
  mov __GraphicArrayOutArgs.Location.X,_x \
  mov __GraphicArrayOutArgs.Location.Y,_y \
  mov __GraphicArrayOutArgs.Data,_data \
  mov __GraphicArrayOutArgs.Variables,_vars \
  mov __GraphicArrayOutArgs.Options,_options \
  syscall DrawGraphicArray,__GraphicArrayOutArgs \
  release __GraphicOutMutex

#define __PolyOutEx(_points,_options) \
  acquire __PolyOutMutex \
  mov __PolyOutArgs.Points,_points \
  mov __PolyOutArgs.Options,_options \
  syscall DrawPolygon,__PolyOutArgs \
  release __PolyOutMutex

#define __EllipseOutEx(_x,_y,_rX,_rY,_options) \
  acquire __EllipseOutMutex \
  mov __EllipseOutArgs.Center.X,_x \
  mov __EllipseOutArgs.Center.Y,_y \
  mov __EllipseOutArgs.SizeX,_rX \
  mov __EllipseOutArgs.SizeY,_rY \
  mov __EllipseOutArgs.Options,_options \
  syscall DrawEllipse,__EllipseOutArgs \
  release __EllipseOutMutex

#define __FontTextOutEx(_x,_y,_fnt,_txt,_options) \
  acquire __FontOutMutex \
  mov __FontOutArgs.Location.X,_x \
  mov __FontOutArgs.Location.Y,_y \
  mov __FontOutArgs.Options,_options \
  mov __FontOutArgs.Filename,_fnt \
  mov __FontOutArgs.Text,_txt \
  syscall DrawFont,__FontOutArgs \
  release __FontOutMutex

#define __FontNumOutEx(_x,_y,_fnt,_num,_options) \
  acquire __FontOutMutex \
  mov __FontOutArgs.Location.X,_x \
  mov __FontOutArgs.Location.Y,_y \
  mov __FontOutArgs.Options,_options \
  mov __FontOutArgs.Filename,_fnt \
  numtostr __FontOutArgs.Text,_num \
  syscall DrawFont,__FontOutArgs \
  release __FontOutMutex

#define __GetMemoryInfo(_Compact,_PoolSize,_DataspaceSize,_Result) \
  acquire __MemMgrMutex \
  mov __MemMgrArgs.Compact,_Compact \
  syscall MemoryManager,__MemMgrArgs \
  mov _PoolSize, __MemMgrArgs.PoolSize \
  mov _DataspaceSize, __MemMgrArgs.DataspaceSize \
  mov _Result, __MemMgrArgs.Result \
  release __MemMgrMutex

#define __GetLastResponseInfo(_Clear,_Length,_Command,_Buffer,_Result) \
  acquire __ReadLastMutex \
  mov __ReadLastArgs.Clear,_Clear \
  syscall ReadLastResponse,__ReadLastArgs \
  mov _Buffer, __ReadLastArgs.Buffer \
  mov _Length, __ReadLastArgs.Length \
  mov _Command, __ReadLastArgs.Command \
  mov _Result, __ReadLastArgs.Result \
  release __ReadLastMutex


#endif

dseg segment
  __RLSBbufLSWrite1 byte[] 0x02, 0x42
  __RSEMeterLSBuf byte[] 0x04, 0x0A
  __RSTempLSBuf byte[] 0x98, 0x00
  __RSTempRaw slong
dseg ends

#define __ReadI2CBytes(_port, _inbuf, _count, _outbuf, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, _inbuf \
  mov __RLSBytesCountVar, _count \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  mov _count, __RLSBytesCountVar \
  mov _outbuf, __RLSReadBufVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, _inbuf \
  mov __RLSBytesCount##_port, _count \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  mov _count, __RLSBytesCount##_port \
  mov _outbuf, __RLSReadBuf##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorUS(_port, _value) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 1 \
  wait 15 \
  call __ReadLSBytesVar \
  index _value, __RLSReadBufVar, NA \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 1 \
  wait 15 \
  call __ReadLSBytes##_port \
  index _value, __RLSReadBuf##_port, NA \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorUSEx(_port, _values, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 8 \
  wait 15 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  mov _values, __RLSReadBufVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 8 \
  wait 15 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  mov _values, __RLSReadBuf##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorEMeter(_port, _vIn, _aIn, _vOut, _aOut, _joules, _wIn, _wOut, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RSEMeterLSBuf \
  set __RLSBytesCountVar, 14 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index __RLSBytesCountVar, __RLSReadBufVar, NA \
  index _vIn, __RLSReadBufVar, 1 \
  mul _vIn, _vIn, 256 \
  add _vIn, _vIn, __RLSBytesCountVar \
  div _vIn, _vIn, 1000 \
  index __RLSBytesCountVar, __RLSReadBufVar, 2 \
  index _aIn, __RLSReadBufVar, 3 \
  mul _aIn, _aIn, 256 \
  add _aIn, _aIn, __RLSBytesCountVar \
  div _aIn, _aIn, 1000 \
  index __RLSBytesCountVar, __RLSReadBufVar, 4 \
  index _vOut, __RLSReadBufVar, 5 \
  mul _vOut, _vOut, 256 \
  add _vOut, _vOut, __RLSBytesCountVar \
  div _vOut, _vOut, 1000 \
  index __RLSBytesCountVar, __RLSReadBufVar, 6 \
  index _aOut, __RLSReadBufVar, 7 \
  mul _aOut, _aOut, 256 \
  add _aOut, _aOut, __RLSBytesCountVar \
  div _aOut, _aOut, 1000 \
  index __RLSBytesCountVar, __RLSReadBufVar, 8 \
  index _joules, __RLSReadBufVar, 9 \
  mul _joules, _joules, 256 \
  add _joules, _joules, __RLSBytesCountVar \
  index __RLSBytesCountVar, __RLSReadBufVar, 10 \
  index _wIn, __RLSReadBufVar, 11 \
  mul _wIn, _wIn, 256 \
  add _wIn, _wIn, __RLSBytesCountVar \
  div _wIn, _wIn, 1000 \
  index __RLSBytesCountVar, __RLSReadBufVar, 12 \
  index _wOut, __RLSReadBufVar, 13 \
  mul _wOut, _wOut, 256 \
  add _wOut, _wOut, __RLSBytesCountVar \
  div _wOut, _wOut, 1000 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RSEMeterLSBuf \
  set __RLSBytesCount##_port, 14 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, NA \
  index _vIn, __RLSReadBuf##_port, 1 \
  mul _vIn, _vIn, 256 \
  add _vIn, _vIn, __RLSBytesCount##_port \
  div _vIn, _vIn, 1000 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 2 \
  index _aIn, __RLSReadBuf##_port, 3 \
  mul _aIn, _aIn, 256 \
  add _aIn, _aIn, __RLSBytesCount##_port \
  div _aIn, _aIn, 1000 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 4 \
  index _vOut, __RLSReadBuf##_port, 5 \
  mul _vOut, _vOut, 256 \
  add _vOut, _vOut, __RLSBytesCount##_port \
  div _vOut, _vOut, 1000 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 6 \
  index _aOut, __RLSReadBuf##_port, 7 \
  mul _aOut, _aOut, 256 \
  add _aOut, _aOut, __RLSBytesCount##_port \
  div _aOut, _aOut, 1000 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 8 \
  index _joules, __RLSReadBuf##_port, 9 \
  mul _joules, _joules, 256 \
  add _joules, _joules, __RLSBytesCount##_port \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 10 \
  index _wIn, __RLSReadBuf##_port, 11 \
  mul _wIn, _wIn, 256 \
  add _wIn, _wIn, __RLSBytesCount##_port \
  div _wIn, _wIn, 1000 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 12 \
  index _wOut, __RLSReadBuf##_port, 13 \
  mul _wOut, _wOut, 256 \
  add _wOut, _wOut, __RLSBytesCount##_port \
  div _wOut, _wOut, 1000 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorTemperature(_port, _temp) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RSTempLSBuf \
  set __RLSBytesCountVar, 2 \
  call __ReadLSBytesVar \
  index __RSTempRaw, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  mul __RSTempRaw, __RSTempRaw, 256 \
  add __RSTempRaw, __RSTempRaw, __RLSBytesCountVar \
  mul __RSTempRaw, __RSTempRaw, 10 \
  div __RSTempRaw, __RSTempRaw, 16 \
  div _temp, __RSTempRaw, 16 \
  brcmp LTEQ, __RRT_EndIf##__I__, __RSTempRaw, 20470 \
  sub _temp, _temp, 2560 \
  __RRT_EndIf##__I__: \
  __IncI__ \
  brcmp NEQ, __RRT_FloatEndIf##__I__, typeof(_temp), 10 \
  div _temp, _temp, 10 \
  __RRT_FloatEndIf##__I__: \
  __IncI__ \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RSTempLSBuf \
  set __RLSBytesCount##_port, 2 \
  call __ReadLSBytes##_port \
  index __RSTempRaw, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  mul __RSTempRaw, __RSTempRaw, 256 \
  add __RSTempRaw, __RSTempRaw, __RLSBytesCount##_port \
  mul __RSTempRaw, __RSTempRaw, 10 \
  div __RSTempRaw, __RSTempRaw, 16 \
  div _temp, __RSTempRaw, 16 \
  brcmp LTEQ, __RRT_EndIf##__I__, __RSTempRaw, 20470 \
  sub _temp, _temp, 2560 \
  __RRT_EndIf##__I__: \
  __IncI__ \
  brcmp NEQ, __RRT_FloatEndIf##__I__, typeof(_temp), 10 \
  div _temp, _temp, 10 \
  __RRT_FloatEndIf##__I__: \
  __IncI__ \
  release __RLSBmutex##_port \
  compend

subroutine __ReadLSBytes0
  dseg segment
    __RLSBmutex0 mutex
    __RLSLastGoodRead0 byte[] 0x00
    __RLSBResult0 sbyte
    __RLSBytesCount0 byte
    __RLSBIterations0 byte
    __RLSReadBuf0 byte[]
  dseg ends
  __lowspeedWrite(0, __RLSBytesCount0, __RLSReadBuf0, __RLSBResult0)
  brtst NEQ, __RLSBError0, __RLSBResult0 // terminate if not NO_ERR
  set __RLSBIterations0, 60
__RLSBDoCheckStatus0:
  __lowspeedStatus(0, __RLSBytesCount0, __RLSBResult0)
  sub __RLSBIterations0, __RLSBIterations0, 1
  brtst LTEQ, __RLSBError0, __RLSBIterations0
  brtst LT, __RLSBError0, __RLSBResult0 // negative results are absolute errors
  brtst EQ, __RLSBReadyToRead0, __RLSBResult0
  // if STAT_COMM_PENDING then wait a bit and then try again (up to 60 ms)
  wait 1
  jmp __RLSBDoCheckStatus0
__RLSBReadyToRead0:
  brtst EQ, __RLSBReturn0, __RLSBytesCount0 // terminate if zero bytes to read
  arrinit __RLSReadBuf0, 0, __RLSBytesCount0
  // Try reading now
  __lowspeedRead(0, __RLSBytesCount0, __RLSReadBuf0, __RLSBResult0)
  brtst NEQ, __RLSBError0, __RLSBResult0 // terminate if not NO_ERR
  mov __RLSLastGoodRead0, __RLSReadBuf0
  jmp __RLSBDone0
__RLSBError0:
  mov __RLSReadBuf0, __RLSLastGoodRead0
__RLSBDone0:
  arrsize __RLSBytesCount0, __RLSReadBuf0
__RLSBReturn0:
  return
ends

subroutine __ReadLSBytes1
  dseg segment
    __RLSBmutex1 mutex
    __RLSLastGoodRead1 byte[] 0x00
    __RLSBResult1 sbyte
    __RLSBytesCount1 byte
    __RLSBIterations1 byte
    __RLSReadBuf1 byte[]
  dseg ends
  __lowspeedWrite(1, __RLSBytesCount1, __RLSReadBuf1, __RLSBResult1)
  brtst NEQ, __RLSBError1, __RLSBResult1 // terminate if not NO_ERR
  set __RLSBIterations1, 60
__RLSBDoCheckStatus1:
  __lowspeedStatus(1, __RLSBytesCount1, __RLSBResult1)
  sub __RLSBIterations1, __RLSBIterations1, 1
  brtst LTEQ, __RLSBError1, __RLSBIterations1
  brtst LT, __RLSBError1, __RLSBResult1 // negative results are absolute errors
  brtst EQ, __RLSBReadyToRead1, __RLSBResult1
  // if STAT_COMM_PENDING then wait a bit and then try again (up to 60 ms)
  wait 1
  jmp __RLSBDoCheckStatus1
__RLSBReadyToRead1:
  brtst EQ, __RLSBReturn1, __RLSBytesCount1 // terminate if zero bytes to read
  arrinit __RLSReadBuf1, 0, __RLSBytesCount1
  // Try reading now
  __lowspeedRead(1, __RLSBytesCount1, __RLSReadBuf1, __RLSBResult1)
  brtst NEQ, __RLSBError1, __RLSBResult1 // terminate if not NO_ERR
  mov __RLSLastGoodRead1, __RLSReadBuf1
  jmp __RLSBDone1
__RLSBError1:
  mov __RLSReadBuf1, __RLSLastGoodRead1
__RLSBDone1:
  arrsize __RLSBytesCount1, __RLSReadBuf1
__RLSBReturn1:
  return
ends

subroutine __ReadLSBytes2
  dseg segment
    __RLSBmutex2 mutex
    __RLSLastGoodRead2 byte[] 0x00
    __RLSBResult2 sbyte
    __RLSBytesCount2 byte
    __RLSBIterations2 byte
    __RLSReadBuf2 byte[]
  dseg ends
  __lowspeedWrite(2, __RLSBytesCount2, __RLSReadBuf2, __RLSBResult2)
  brtst NEQ, __RLSBError2, __RLSBResult2 // terminate if not NO_ERR
  set __RLSBIterations2, 60
__RLSBDoCheckStatus2:
  __lowspeedStatus(2, __RLSBytesCount2, __RLSBResult2)
  sub __RLSBIterations2, __RLSBIterations2, 1
  brtst LTEQ, __RLSBError2, __RLSBIterations2
  brtst LT, __RLSBError2, __RLSBResult2 // negative results are absolute errors
  brtst EQ, __RLSBReadyToRead2, __RLSBResult2
  // if STAT_COMM_PENDING then wait a bit and then try again (up to 60 ms)
  wait 1
  jmp __RLSBDoCheckStatus2
__RLSBReadyToRead2:
  brtst EQ, __RLSBReturn2, __RLSBytesCount2 // terminate if zero bytes to read
  arrinit __RLSReadBuf2, 0, __RLSBytesCount2
  // Try reading now
  __lowspeedRead(2, __RLSBytesCount2, __RLSReadBuf2, __RLSBResult2)
  brtst NEQ, __RLSBError2, __RLSBResult2 // terminate if not NO_ERR
  mov __RLSLastGoodRead2, __RLSReadBuf2
  jmp __RLSBDone2
__RLSBError2:
  mov __RLSReadBuf2, __RLSLastGoodRead2
__RLSBDone2:
  arrsize __RLSBytesCount2, __RLSReadBuf2
__RLSBReturn2:
  return
ends

subroutine __ReadLSBytes3
  dseg segment
    __RLSBmutex3 mutex
    __RLSLastGoodRead3 byte[] 0x00
    __RLSBResult3 sbyte
    __RLSBytesCount3 byte
    __RLSBIterations3 byte
    __RLSReadBuf3 byte[]
  dseg ends
  __lowspeedWrite(3, __RLSBytesCount3, __RLSReadBuf3, __RLSBResult3)
  brtst NEQ, __RLSBError3, __RLSBResult3 // terminate if not NO_ERR
  set __RLSBIterations3, 60
__RLSBDoCheckStatus3:
  __lowspeedStatus(3, __RLSBytesCount3, __RLSBResult3)
  sub __RLSBIterations3, __RLSBIterations3, 1
  brtst LTEQ, __RLSBError3, __RLSBIterations3
  brtst LT, __RLSBError3, __RLSBResult3 // negative results are absolute errors
  brtst EQ, __RLSBReadyToRead3, __RLSBResult3
  // if STAT_COMM_PENDING then wait a bit and then try again (up to 60 ms)
  wait 1
  jmp __RLSBDoCheckStatus3
__RLSBReadyToRead3:
  brtst EQ, __RLSBReturn3, __RLSBytesCount3 // terminate if zero bytes to read
  arrinit __RLSReadBuf3, 0, __RLSBytesCount3
  // Try reading now
  __lowspeedRead(3, __RLSBytesCount3, __RLSReadBuf3, __RLSBResult3)
  brtst NEQ, __RLSBError3, __RLSBResult3 // terminate if not NO_ERR
  mov __RLSLastGoodRead3, __RLSReadBuf3
  jmp __RLSBDone3
__RLSBError3:
  mov __RLSReadBuf3, __RLSLastGoodRead3
__RLSBDone3:
  arrsize __RLSBytesCount3, __RLSReadBuf3
__RLSBReturn3:
  return
ends

subroutine __ReadLSBytesVar
  dseg segment
    __RLSLastGoodReadVar byte[] 0x00
    __RLSBResultVar sbyte
    __RLSBytesCountVar byte
    __RLSBIterationsVar byte
    __RLSReadBufVar byte[]
    __RLSReadPort byte
  dseg ends
  __lowspeedWrite(__RLSReadPort, __RLSBytesCountVar, __RLSReadBufVar, __RLSBResultVar)
  brtst NEQ, __RLSBErrorVar, __RLSBResultVar // terminate if not NO_ERR
  set __RLSBIterationsVar, 60
__RLSBDoCheckStatusVar:
  __lowspeedStatus(__RLSReadPort, __RLSBytesCountVar, __RLSBResultVar)
  sub __RLSBIterationsVar, __RLSBIterationsVar, 1
  brtst LTEQ, __RLSBErrorVar, __RLSBIterationsVar
  brtst LT, __RLSBErrorVar, __RLSBResultVar // negative results are absolute errors
  brtst EQ, __RLSBReadyToReadVar, __RLSBResultVar
  // if STAT_COMM_PENDING then wait a bit and then try again (up to 60 ms)
  wait 1
  jmp __RLSBDoCheckStatusVar
__RLSBReadyToReadVar:
  brtst EQ, __RLSBReturnVar, __RLSBytesCountVar // terminate if zero bytes to read
  arrinit __RLSReadBufVar, 0, __RLSBytesCountVar
  // Try reading now
  __lowspeedRead(__RLSReadPort, __RLSBytesCountVar, __RLSReadBufVar, __RLSBResultVar)
  brtst NEQ, __RLSBErrorVar, __RLSBResultVar // terminate if not NO_ERR
  mov __RLSLastGoodReadVar, __RLSReadBufVar
  jmp __RLSBDoneVar
__RLSBErrorVar:
  mov __RLSReadBufVar, __RLSLastGoodReadVar
__RLSBDoneVar:
  arrsize __RLSBytesCountVar, __RLSReadBufVar
__RLSBReturnVar:
  return
ends

dseg segment
  __PlayToneTmp TSoundPlayTone
  __PlayFileTmp TSoundPlayFile
  __PlayFileMutex mutex
  __PlayToneMutex mutex
  __SGSMutex mutex
  __SGSArgs TSoundGetState
  __SSSMutex mutex
  __SSSArgs TSoundSetState
  __RandomTmp dword
  __RandomArgs TRandomNumber
  __RandomMutex mutex
  __KeepAliveArgs TKeepAlive
  __KeepAliveMutex mutex
  __GSTArgs TGetStartTick
  __GSTMutex mutex
  __RBtnMutex mutex
  __RBtnArgs TReadButton
  __IOMRMutex mutex
  __IOMRArgs TIOMapRead
  __IOMRUnflattenErr byte
  __IOMRUnflattenBuf byte[]
#ifdef __ENHANCED_FIRMWARE
  __RandomExArgs TRandomEx
  __RandomExMutex mutex
#endif
dseg ends


#define __PlayToneEx(_freq,_dur,_vol,_loop) \
  acquire __PlayToneMutex \
  mov __PlayToneTmp.Frequency, _freq \
  mov __PlayToneTmp.Duration, _dur \
  mov __PlayToneTmp.Volume, _vol \
  mov __PlayToneTmp.Loop, _loop \
  syscall SoundPlayTone, __PlayToneTmp \
  release __PlayToneMutex

#define __PlayFileEx(_file,_vol,_loop) \
  acquire __PlayFileMutex \
  mov __PlayFileTmp.Filename, _file \
  mov __PlayFileTmp.Volume, _vol \
  mov __PlayFileTmp.Loop, _loop \
  syscall SoundPlayFile, __PlayFileTmp \
  release __PlayFileMutex

#define __setSoundState(_state, _flags, _result) \
  acquire __SSSMutex \
  mov __SSSArgs.State, _state \
  mov __SSSArgs.Flags, _flags \
  syscall SoundSetState, __SSSArgs \
  mov _result, __SSSArgs.Result \
  release __SSSMutex

#define __GetSoundState(_state, _flags) \
  acquire __SGSMutex \
  syscall SoundGetState, __SGSArgs \
  mov _state, __SGSArgs.State \
  mov _flags, __SGSArgs.Flags \
  release __SGSMutex

#define __Random(_arg,_max) \
  acquire __RandomMutex \
  syscall RandomNumber, __RandomArgs \
  add __RandomTmp, __RandomArgs.Result, 32768 \
  mul __RandomTmp, __RandomTmp, _max \
  div __RandomTmp, __RandomTmp, 65536 \
  mov _arg, __RandomTmp \
  release __RandomMutex

#define __SignedRandom(_arg) \
  acquire __RandomMutex \
  syscall RandomNumber, __RandomArgs \
  mov _arg, __RandomArgs.Result \
  release __RandomMutex

#ifdef __ENHANCED_FIRMWARE

#define __SeedRandomEx(_seedin, _out) \
  acquire __RandomExMutex \
  set __RandomExArgs.ReSeed, TRUE \
  mov __RandomExArgs.Seed, _seedin \
  syscall RandomEx, __RandomExArgs \
  set __RandomExArgs.ReSeed, FALSE \
  mov _out, __RandomExArgs.Seed \
  release __RandomExMutex

#define __RandomEx(_out) \
  acquire __RandomExMutex \
  syscall RandomEx, __RandomExArgs \
  mov _out, __RandomExArgs.Seed \
  release __RandomExMutex

#endif

#define __GetFirstTick(_value) \
  compchk EQ, sizeof(_value), 4 \
  acquire __GSTMutex \
  syscall GetStartTick, __GSTArgs \
  mov _value, __GSTArgs.Result \
  release __GSTMutex

#define __ReadButtonEx(_idx, _reset, _pressed, _count, _result) \
  acquire __RBtnMutex \
  mov __RBtnArgs.Index, _idx \
  mov __RBtnArgs.Reset, _reset \
  syscall ReadButton, __RBtnArgs \
  mov _pressed, __RBtnArgs.Pressed \
  mov _count, __RBtnArgs.Count \
  mov _result, __RBtnArgs.Result \
  release __RBtnMutex

#define __getIOMapBytes(_modName, _offset, _cnt, _arrOut) \
  acquire __IOMRMutex \
  mov __IOMRArgs.ModuleName, _modName \
  mov __IOMRArgs.Offset, _offset \
  mov __IOMRArgs.Count, _cnt \
  syscall IOMapRead, __IOMRArgs \
  mov _arrOut, __IOMRArgs.Buffer \
  release __IOMRMutex

#define __getIOMapValue(_modName, _offset, _n) \
  acquire __IOMRMutex \
  mov __IOMRArgs.ModuleName, _modName \
  mov __IOMRArgs.Offset, _offset \
  set __IOMRArgs.Count, sizeof(_n) \
  syscall IOMapRead, __IOMRArgs \
  arrtostr __IOMRUnflattenBuf, __IOMRArgs.Buffer \
  unflatten _n, __IOMRUnflattenErr, __IOMRUnflattenBuf, _n \
  release __IOMRMutex

#ifdef __ENHANCED_FIRMWARE

dseg segment
  __IOMRBIArgs TIOMapReadByID
dseg ends

#define __getIOMapBytesByID(_modID, _offset, _cnt, _arrOut) \
  acquire __IOMRMutex \
  mov __IOMRBIArgs.ModuleID, _modID \
  mov __IOMRBIArgs.Offset, _offset \
  mov __IOMRBIArgs.Count, _cnt \
  syscall IOMapReadByID, __IOMRBIArgs \
  mov _arrOut, __IOMRBIArgs.Buffer \
  release __IOMRMutex

#define __getIOMapValueByID(_modID, _offset, _n) \
  acquire __IOMRMutex \
  mov __IOMRBIArgs.ModuleID, _modID \
  mov __IOMRBIArgs.Offset, _offset \
  set __IOMRBIArgs.Count, sizeof(_n) \
  syscall IOMapReadByID, __IOMRBIArgs \
  arrtostr __IOMRUnflattenBuf, __IOMRBIArgs.Buffer \
  unflatten _n, __IOMRUnflattenErr, __IOMRUnflattenBuf, _n \
  release __IOMRMutex

#define __getLowSpeedModuleBytes(_offset, _cnt, _arrOut) __getIOMapBytesByID(LowSpeedModuleID, _offset, _cnt, _arrOut)
#define __getDisplayModuleBytes(_offset, _cnt, _arrOut) __getIOMapBytesByID(DisplayModuleID, _offset, _cnt, _arrOut)
#define __getCommModuleBytes(_offset, _cnt, _arrOut) __getIOMapBytesByID(CommModuleID, _offset, _cnt, _arrOut)
#define __getCommandModuleBytes(_offset, _cnt, _arrOut) __getIOMapBytesByID(CommandModuleID, _offset, _cnt, _arrOut)

#else

#define __getLowSpeedModuleBytes(_offset, _cnt, _arrOut) __getIOMapBytes(LowSpeedModuleName, _offset, _cnt, _arrOut)
#define __getDisplayModuleBytes(_offset, _cnt, _arrOut) __getIOMapBytes(DisplayModuleName, _offset, _cnt, _arrOut)
#define __getCommModuleBytes(_offset, _cnt, _arrOut) __getIOMapBytes(CommModuleName, _offset, _cnt, _arrOut)
#define __getCommandModuleBytes(_offset, _cnt, _arrOut) __getIOMapBytes(CommandModuleName, _offset, _cnt, _arrOut)

#endif

#define __GetFreeMemory(_value) \
  compchk EQ, sizeof(_value), 4 \
  GetLoaderModuleValue(LoaderOffsetFreeUserFlash, _value)

#define __GetSoundFrequency(_n) \
  compchk EQ, sizeof(_n), 2 \
  GetSoundModuleValue(SoundOffsetFreq, _n)

#define __GetSoundDuration(_n) \
  compchk EQ, sizeof(_n), 2 \
  GetSoundModuleValue(SoundOffsetDuration, _n)

#define __GetSoundSampleRate(_n) \
  compchk EQ, sizeof(_n), 2 \
  GetSoundModuleValue(SoundOffsetSampleRate, _n)

#define __GetSoundMode(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetSoundModuleValue(SoundOffsetMode, _n)

#define __GetSoundVolume(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetSoundModuleValue(SoundOffsetVolume, _n)

dseg segment
  __btnModuleOffsetMutex mutex
  __btnModuleOffset word
dseg ends

#define __GetButtonPressCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  GetButtonModuleValue(ButtonOffsetPressedCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  GetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __GetButtonLongPressCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  GetButtonModuleValue(ButtonOffsetLongPressCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  add __btnModuleOffset, __btnModuleOffset, 1 \
  GetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __GetButtonShortReleaseCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  GetButtonModuleValue(ButtonOffsetShortRelCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  add __btnModuleOffset, __btnModuleOffset, 2 \
  GetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __GetButtonLongReleaseCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  GetButtonModuleValue(ButtonOffsetLongRelCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  add __btnModuleOffset, __btnModuleOffset, 3 \
  GetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __GetButtonReleaseCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  GetButtonModuleValue(ButtonOffsetRelCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  add __btnModuleOffset, __btnModuleOffset, 4 \
  GetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __GetButtonState(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  GetButtonModuleValue(ButtonOffsetState(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  add __btnModuleOffset, _b, 32 \
  GetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __GetBatteryLevel(_n) \
  compchk EQ, sizeof(_n), 2 \
  GetUIModuleValue(UIOffsetBatteryVoltage, _n)

#define __GetCommandFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetFlags, _n)

#define __GetUIState(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetState, _n)

#define __GetUIButton(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetButton, _n)

#define __GetVMRunState(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetRunState, _n)

#define __GetBatteryState(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetBatteryState, _n)

#define __GetBluetoothState(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetBluetoothState, _n)

#define __GetUsbState(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetUsbState, _n)

#define __GetSleepTimeout(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetSleepTimeout, _n)

#define __GetSleepTimer(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetSleepTimer, _n)

#define __GetRechargeableBattery(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetRechargeable, _n)

#define __GetVolume(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetVolume, _n)

#define __GetOnBrickProgramPointer(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetOBPPointer, _n)

#define __GetAbortFlag(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetUIModuleValue(UIOffsetAbortFlag, _n)

dseg segment
  __inputModuleOffsetMutex mutex
  __inputModuleOffset word
  __inputModuleOffsetTmp word
dseg ends

#define __GetInCustomZeroOffset(_p, _n) \
  compchk EQ, sizeof(_n), 2 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetInputModuleValue(InputOffsetCustomZeroOffset(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInSensorBoolean(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetInputModuleValue(InputOffsetSensorBoolean(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 10 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInDigiPinsDirection(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetInputModuleValue(InputOffsetDigiPinsDir(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 11 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInDigiPinsStatus(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetInputModuleValue(InputOffsetDigiPinsIn(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 12 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInDigiPinsOutputLevel(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetInputModuleValue(InputOffsetDigiPinsOut(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 13 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInCustomPercentFullScale(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetInputModuleValue(InputOffsetCustomPctFullScale(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 14 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInCustomActiveStatus(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetInputModuleValue(InputOffsetCustomActiveStatus(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 15 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#if __FIRMWARE_VERSION > 107

#define __GetInColorCalibration(_p, _np, _nc, _n) \
  compchk EQ, sizeof(_n), 4 \
  compif EQ, isconst(_p+_np+_nc), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  compchk LT, _np, INPUT_NO_OF_POINTS \
  compchk GTEQ, _np, 0x00 \
  compchk LT, _nc, INPUT_NO_OF_COLORS \
  compchk GTEQ, _nc, 0x00 \
  GetInputModuleValue(InputOffsetColorCalibration(_p, _np, _nc), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 84 \
  mul __inputModuleOffsetTmp, _np, 16 \
  add __inputModuleOffset, __inputModuleOffset, __inputModuleOffsetTmp \
  mul __inputModuleOffsetTmp, _nc, 4 \
  add __inputModuleOffset, __inputModuleOffset, __inputModuleOffsetTmp \
  add __inputModuleOffset, __inputModuleOffset, 80 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInColorCalLimits(_p, _np, _n) \
  compchk EQ, sizeof(_n), 2 \
  compif EQ, isconst(_p+_np), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  compchk LT, _np, 0x02 \
  compchk GTEQ, _np, 0x00 \
  GetInputModuleValue(InputOffsetColorCalLimits(_p, _np), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 84 \
  mul __inputModuleOffsetTmp, _np, 2 \
  add __inputModuleOffset, __inputModuleOffset, __inputModuleOffsetTmp \
  add __inputModuleOffset, __inputModuleOffset, 128 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInColorADRaw(_p, _nc, _n) \
  compchk EQ, sizeof(_n), 2 \
  compif EQ, isconst(_p+_nc), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  compchk LT, _nc, INPUT_NO_OF_COLORS \
  compchk GTEQ, _nc, 0x00 \
  GetInputModuleValue(InputOffsetColorADRaw(_p, _nc), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 84 \
  mul __inputModuleOffsetTmp, _nc, 2 \
  add __inputModuleOffset, __inputModuleOffset, __inputModuleOffsetTmp \
  add __inputModuleOffset, __inputModuleOffset, 132 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInColorSensorRaw(_p, _nc, _n) \
  compchk EQ, sizeof(_n), 2 \
  compif EQ, isconst(_p+_nc), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  compchk LT, _nc, INPUT_NO_OF_COLORS \
  compchk GTEQ, _nc, 0x00 \
  GetInputModuleValue(InputOffsetColorSensorRaw(_p, _nc), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 84 \
  mul __inputModuleOffsetTmp, _nc, 2 \
  add __inputModuleOffset, __inputModuleOffset, __inputModuleOffsetTmp \
  add __inputModuleOffset, __inputModuleOffset, 140 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInColorSensorValue(_p, _nc, _n) \
  compchk EQ, sizeof(_n), 2 \
  compif EQ, isconst(_p+_nc), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  compchk LT, _nc, INPUT_NO_OF_COLORS \
  compchk GTEQ, _nc, 0x00 \
  GetInputModuleValue(InputOffsetColorSensorValue(_p, _nc), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 84 \
  mul __inputModuleOffsetTmp, _nc, 2 \
  add __inputModuleOffset, __inputModuleOffset, __inputModuleOffsetTmp \
  add __inputModuleOffset, __inputModuleOffset, 148 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInColorBoolean(_p, _nc, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p+_nc), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  compchk LT, _nc, INPUT_NO_OF_COLORS \
  compchk GTEQ, _nc, 0x00 \
  GetInputModuleValue(InputOffsetColorBoolean(_p, _nc), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 84 \
  mul __inputModuleOffsetTmp, _nc, 2 \
  add __inputModuleOffset, __inputModuleOffset, __inputModuleOffsetTmp \
  add __inputModuleOffset, __inputModuleOffset, 156 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __GetInColorCalibrationState(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetInputModuleValue(InputOffsetColorCalibrationState(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 84 \
  add __inputModuleOffset, __inputModuleOffset, 160 \
  GetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#endif

#define __GetOutPwnFreq(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetOutputModuleValue(OutputOffsetRegulationTime, _n)

#define __GetOutRegulationTime(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetOutputModuleValue(OutputOffsetRegulationTime, _n)

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)

#define __GetOutRegulationOptions(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetOutputModuleValue(OutputOffsetRegulationOptions, _n)

#endif

dseg segment
  __lsModuleOffsetMutex mutex
  __lsModuleOffset word
dseg ends

#define __getLSInputBuffer(_p, _offset, _cnt, _data) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleBytes(LowSpeedOffsetInBufBuf(_p)+_offset, _cnt, _data) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, _offset \
  GetLowSpeedModuleBytes(__lsModuleOffset, _cnt, _data) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSInputBufferInPtr(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetInBufInPtr(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 16 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSInputBufferOutPtr(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetInBufOutPtr(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 17 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSInputBufferBytesToRx(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetInBufBytesToRx(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 18 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __getLSOutputBuffer(_p, _offset, _cnt, _data) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleBytes(LowSpeedOffsetOutBufBuf(_p)+_offset, _cnt, _data) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 76 \
  add __lsModuleOffset, __lsModuleOffset, _offset \
  GetLowSpeedModuleBytes(__lsModuleOffset, _cnt, _data) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSOutputBufferInPtr(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetOutBufInPtr(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 92 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSOutputBufferOutPtr(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetOutBufOutPtr(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 93 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSOutputBufferBytesToRx(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetOutBufBytesToRx(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 94 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSMode(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetMode(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  add __lsModuleOffset, _p, 152 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSChannelState(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetChannelState(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  add __lsModuleOffset, _p, 156 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSErrorType(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetLowSpeedModuleValue(LowSpeedOffsetErrorType(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  add __lsModuleOffset, _p, 160 \
  GetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __GetLSState(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetLowSpeedModuleValue(LowSpeedOffsetState, _n)

#define __GetLSSpeed(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetLowSpeedModuleValue(LowSpeedOffsetSpeed, _n)

#ifdef __ENHANCED_FIRMWARE

#define __GetLSNoRestartOnRead(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetLowSpeedModuleValue(LowSpeedOffsetNoRestartOnRead, _n)

#endif

#define __GetDisplayEraseMask(_n) \
  compchk EQ, sizeof(_n), 4 \
  GetDisplayModuleValue(DisplayOffsetEraseMask, _n)

#define __GetDisplayUpdateMask(_n) \
  compchk EQ, sizeof(_n), 4 \
  GetDisplayModuleValue(DisplayOffsetUpdateMask, _n)

#define __GetDisplayFont(_n) \
  compchk EQ, sizeof(_n), 4 \
  GetDisplayModuleValue(DisplayOffsetPFont, _n)

#define __GetDisplayDisplay(_n) \
  compchk EQ, sizeof(_n), 4 \
  GetDisplayModuleValue(DisplayOffsetDisplay, _n)

#define __GetDisplayFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetDisplayModuleValue(DisplayOffsetFlags, _n)

#define __GetDisplayTextLinesCenterFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetDisplayModuleValue(DisplayOffsetTextLinesCenterFlags, _n)

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)

#define __GetDisplayContrast(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetDisplayModuleValue(DisplayOffsetContrast, _n)

#endif

dseg segment
  __displayModuleOffsetMutex mutex
  __displayModuleOffset word
dseg ends

#define __getDisplayNormal(_x, _line, _cnt, _data) \
  compif EQ, isconst(_line+_x), TRUE \
  compchk LT, _line, 0x08 \
  compchk GTEQ, _line, 0x00 \
  GetDisplayModuleBytes(DisplayOffsetNormal(_line,_x), _cnt, _data) \
  compelse \
  acquire __displayModuleOffsetMutex \
  mul __displayModuleOffset, _line, 100 \
  add __displayModuleOffset, __displayModuleOffset, _x \
  add __displayModuleOffset, __displayModuleOffset, 119 \
  GetDisplayModuleBytes(__displayModuleOffset, _cnt, _data) \
  release __displayModuleOffsetMutex \
  compend

#define __getDisplayPopup(_x, _line, _cnt, _data) \
  compif EQ, isconst(_line+_x), TRUE \
  compchk LT, _line, 0x08 \
  compchk GTEQ, _line, 0x00 \
  GetDisplayModuleBytes(DisplayOffsetPopup(_line,_x), _cnt, _data) \
  compelse \
  acquire __displayModuleOffsetMutex \
  mul __displayModuleOffset, _line, 100 \
  add __displayModuleOffset, __displayModuleOffset, _x \
  add __displayModuleOffset, __displayModuleOffset, 919 \
  GetDisplayModuleBytes(__displayModuleOffset, _cnt, _data) \
  release __displayModuleOffsetMutex \
  compend

dseg segment
  __commModuleOffsetMutex mutex
  __commModuleOffset word
dseg ends

#define __GetBTDeviceName(_p, _str) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleBytes(CommOffsetBtDeviceTableName(_p), 16, _str) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 31 \
  add __commModuleOffset, __commModuleOffset, 8 \
  GetCommModuleBytes(__commModuleOffset, 16, _str) \
  release __commModuleOffsetMutex \
  compend

#define __GetBTDeviceClass(_p, _n) \
  compchk EQ, sizeof(_n), 4 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleValue(CommOffsetBtDeviceTableClassOfDevice(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 31 \
  add __commModuleOffset, __commModuleOffset, 24 \
  GetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __getBTDeviceAddress(_p, _btaddr) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleBytes(CommOffsetBtDeviceTableBdAddr(_p), 7, _btaddr) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 31 \
  add __commModuleOffset, __commModuleOffset, 28 \
  GetCommModuleBytes(__commModuleOffset, 7, _btaddr) \
  release __commModuleOffsetMutex \
  compend

#define __GetBTDeviceStatus(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleValue(CommOffsetBtDeviceTableDeviceStatus(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 31 \
  add __commModuleOffset, __commModuleOffset, 35 \
  GetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __GetBTConnectionName(_p, _str) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleBytes(CommOffsetBtConnectTableName(_p), 16, _str) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 938 \
  GetCommModuleBytes(__commModuleOffset, 16, _str) \
  release __commModuleOffsetMutex \
  compend

#define __GetBTConnectionClass(_p, _n) \
  compchk EQ, sizeof(_n), 4 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleValue(CommOffsetBtConnectTableClassOfDevice(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 954 \
  GetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __GetBTConnectionPinCode(_p, _code) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleBytes(CommOffsetBtConnectTablePinCode(_p), 16, _code) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 958 \
  GetCommModuleBytes(__commModuleOffset, 16, _code) \
  release __commModuleOffsetMutex \
  compend

#define __getBTConnectionAddress(_p, _btaddr) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleBytes(CommOffsetBtConnectTableBdAddr(_p), 7, _btaddr) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 974 \
  GetCommModuleBytes(__commModuleOffset, 7, _btaddr) \
  release __commModuleOffsetMutex \
  compend

#define __GetBTConnectionHandleNum(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleValue(CommOffsetBtConnectTableHandleNr(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 981 \
  GetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __GetBTConnectionStreamStatus(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleValue(CommOffsetBtConnectTableStreamStatus(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 982 \
  GetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __GetBTConnectionLinkQuality(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  GetCommModuleValue(CommOffsetBtConnectTableLinkQuality(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 983 \
  GetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __getBTInputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  GetCommModuleBytes(CommOffsetBtInBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetBtInBufBuf \
  GetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __getBTOutputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  GetCommModuleBytes(CommOffsetBtOutBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetBtOutBufBuf \
  GetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __getHSInputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  GetCommModuleBytes(CommOffsetHsInBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetHsInBufBuf \
  GetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __getHSOutputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  GetCommModuleBytes(CommOffsetHsOutBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetHsOutBufBuf \
  GetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __getUSBInputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  GetCommModuleBytes(CommOffsetUsbInBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetUsbInBufBuf \
  GetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __getUSBOutputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  GetCommModuleBytes(CommOffsetUsbOutBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetUsbOutBufBuf \
  GetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __getUSBPollBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  GetCommModuleBytes(CommOffsetUsbPollBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetUsbPollBufBuf \
  GetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

dseg segment
  __IOMWArgs TIOMapWrite
  __IOMWMutex mutex
  __IOMWFlattenBuf byte[]
dseg ends

#define __SetIOMapBytes(_modName, _offset, _cnt, _arrIn) \
  acquire __IOMWMutex \
  mov __IOMWArgs.ModuleName, _modName \
  mov __IOMWArgs.Offset, _offset \
  arrsubset __IOMWArgs.Buffer, _arrIn, NA, _cnt \
  syscall IOMapWrite, __IOMWArgs \
  release __IOMWMutex

#define __SetIOMapValue(_modName, _offset, _n) \
  acquire __IOMWMutex \
  mov __IOMWArgs.ModuleName, _modName \
  mov __IOMWArgs.Offset, _offset \
  flatten __IOMWFlattenBuf, _n \
  strtoarr __IOMWArgs.Buffer, __IOMWFlattenBuf \
  syscall IOMapWrite, __IOMWArgs \
  release __IOMWMutex

#ifdef __ENHANCED_FIRMWARE

dseg segment
  __IOMWBIArgs TIOMapWriteByID
dseg ends

#define __SetIOMapBytesByID(_modID, _offset, _cnt, _arrIn) \
  acquire __IOMWMutex \
  mov __IOMWBIArgs.ModuleID, _modID \
  mov __IOMWBIArgs.Offset, _offset \
  arrsubset __IOMWBIArgs.Buffer, _arrIn, NA, _cnt \
  syscall IOMapWriteByID, __IOMWBIArgs \
  release __IOMWMutex

#define __SetIOMapValueByID(_modID, _offset, _n) \
  acquire __IOMWMutex \
  mov __IOMWBIArgs.ModuleID, _modID \
  mov __IOMWBIArgs.Offset, _offset \
  flatten __IOMWFlattenBuf, _n \
  strtoarr __IOMWBIArgs.Buffer, __IOMWFlattenBuf \
  syscall IOMapWriteByID, __IOMWBIArgs \
  release __IOMWMutex

#endif

#define __setLSInputBuffer(_p, _offset, _cnt, _data) \
  compif EQ, isconst(_p+_offset), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleBytes(LowSpeedOffsetInBufBuf(_p)+_offset, _cnt, _data) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, _offset \
  SetLowSpeedModuleBytes(__lsModuleOffset, _cnt, _data) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSOutputBuffer(_p, _offset, _cnt, _data) \
  compif EQ, isconst(_p+_offset), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleBytes(LowSpeedOffsetInBufBuf(_p)+_offset, _cnt, _data) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 76 \
  add __lsModuleOffset, __lsModuleOffset, _offset \
  SetLowSpeedModuleBytes(__lsModuleOffset, _cnt, _data) \
  release __lsModuleOffsetMutex \
  compend

#ifdef __ENHANCED_FIRMWARE

#define __spawnProgram(_fname) \
  acquire __IOMWMutex \
  mov __IOMWBIArgs.ModuleID, CommandModuleID \
  mov __IOMWBIArgs.Offset, CommandOffsetActivateFlag \
  arrsubset __IOMWFlattenBuf, _fname, NA, 20 \
  arrbuild __IOMWBIArgs.Buffer, 1, 0, __IOMWFlattenBuf \
  syscall IOMapWriteByID, __IOMWBIArgs \
  release __IOMWMutex \
  stop NA

#else

#define __spawnProgram(_fname) \
  acquire __IOMWMutex \
  mov __IOMWArgs.ModuleName, CommandModuleName \
  mov __IOMWArgs.Offset, CommandOffsetActivateFlag \
  arrsubset __IOMWFlattenBuf, _fname, NA, 20 \
  arrbuild __IOMWArgs.Buffer, 1, 0, __IOMWFlattenBuf \
  syscall IOMapWrite, __IOMWArgs \
  release __IOMWMutex \
  stop NA

#endif

#define __setDisplayNormal(_x, _line, _cnt, _data) \
  compif EQ, isconst(_line+_x), TRUE \
  compchk LT, _line, 0x08 \
  compchk GTEQ, _line, 0x00 \
  SetDisplayModuleBytes(DisplayOffsetNormal(_line,_x), _cnt, _data) \
  compelse \
  acquire __displayModuleOffsetMutex \
  mul __displayModuleOffset, _line, 100 \
  add __displayModuleOffset, __displayModuleOffset, _x \
  add __displayModuleOffset, __displayModuleOffset, 119 \
  SetDisplayModuleBytes(__displayModuleOffset, _cnt, _data) \
  release __displayModuleOffsetMutex \
  compend

#define __setDisplayPopup(_x, _line, _cnt, _data) \
  compif EQ, isconst(_line+_x), TRUE \
  compchk LT, _line, 0x08 \
  compchk GTEQ, _line, 0x00 \
  SetDisplayModuleBytes(DisplayOffsetPopup(_line,_x), _cnt, _data) \
  compelse \
  acquire __displayModuleOffsetMutex \
  mul __displayModuleOffset, _line, 100 \
  add __displayModuleOffset, __displayModuleOffset, _x \
  add __displayModuleOffset, __displayModuleOffset, 919 \
  SetDisplayModuleBytes(__displayModuleOffset, _cnt, _data) \
  release __displayModuleOffsetMutex \
  compend

#define __setBTDeviceName(_p, _str) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleBytes(CommOffsetBtDeviceTableName(_p), 16, _str) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 31 \
  add __commModuleOffset, __commModuleOffset, 8 \
  SetCommModuleBytes(__commModuleOffset, 16, _str) \
  release __commModuleOffsetMutex \
  compend

#define __setBTDeviceAddress(_p, _btaddr) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleBytes(CommOffsetBtDeviceTableBdAddr(_p), 7, _btaddr) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 31 \
  add __commModuleOffset, __commModuleOffset, 28 \
  SetCommModuleBytes(__commModuleOffset, 7, _btaddr) \
  release __commModuleOffsetMutex \
  compend

#define __setBTConnectionName(_p, _str) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleBytes(CommOffsetBtConnectTableName(_p), 16, _str) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 938 \
  SetCommModuleBytes(__commModuleOffset, 16, _str) \
  release __commModuleOffsetMutex \
  compend

#define __setBTConnectionPinCode(_p, _code) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleBytes(CommOffsetBtConnectTablePinCode(_p), 16, _code) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 958 \
  SetCommModuleBytes(__commModuleOffset, 16, _code) \
  release __commModuleOffsetMutex \
  compend

#define __setBTConnectionAddress(_p, _btaddr) \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleBytes(CommOffsetBtConnectTableBdAddr(_p), 7, _btaddr) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 974 \
  SetCommModuleBytes(__commModuleOffset, 7, _btaddr) \
  release __commModuleOffsetMutex \
  compend

#define __setBTInputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  SetCommModuleBytes(CommOffsetBtInBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetBtInBufBuf \
  SetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __setBTOutputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  SetCommModuleBytes(CommOffsetBtOutBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetBtOutBufBuf \
  SetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __setHSInputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  SetCommModuleBytes(CommOffsetHsInBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetHsInBufBuf \
  SetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __setHSOutputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  SetCommModuleBytes(CommOffsetHsOutBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetHsOutBufBuf \
  SetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __setUSBInputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  SetCommModuleBytes(CommOffsetUsbInBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetUsbInBufBuf \
  SetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __setUSBOutputBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  SetCommModuleBytes(CommOffsetUsbOutBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetUsbOutBufBuf \
  SetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __setUSBPollBuffer(_offset, _cnt, _data) \
  compif EQ, isconst(_offset), TRUE \
  SetCommModuleBytes(CommOffsetUsbPollBufBuf+_offset, _cnt, _data) \
  compelse \
  acquire __commModuleOffsetMutex \
  add __commModuleOffset, _offset, CommOffsetUsbPollBufBuf \
  SetCommModuleBytes(__commModuleOffset, _cnt, _data) \
  release __commModuleOffsetMutex \
  compend

#define __setSoundFrequency(_n) \
  compchk EQ, sizeof(_n), 2 \
  SetSoundModuleValue(SoundOffsetFreq, _n)

#define __setSoundDuration(_n) \
  compchk EQ, sizeof(_n), 2 \
  SetSoundModuleValue(SoundOffsetDuration, _n)

#define __setSoundSampleRate(_n) \
  compchk EQ, sizeof(_n), 2 \
  SetSoundModuleValue(SoundOffsetSampleRate, _n)

#define __setSoundFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetSoundModuleValue(SoundOffsetFlags, _n)

#define __setSoundModuleState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetSoundModuleValue(SoundOffsetState, _n)

#define __setSoundMode(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetSoundModuleValue(SoundOffsetMode, _n)

#define __setSoundVolume(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetSoundModuleValue(SoundOffsetVolume, _n)

#define __setButtonPressCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  SetButtonModuleValue(ButtonOffsetPressedCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  SetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __setButtonLongPressCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  SetButtonModuleValue(ButtonOffsetLongPressCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  add __btnModuleOffset, __btnModuleOffset, 1 \
  SetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __setButtonShortReleaseCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  SetButtonModuleValue(ButtonOffsetShortRelCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  add __btnModuleOffset, __btnModuleOffset, 2 \
  SetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __setButtonLongReleaseCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  SetButtonModuleValue(ButtonOffsetLongRelCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  add __btnModuleOffset, __btnModuleOffset, 3 \
  SetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __setButtonReleaseCount(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  SetButtonModuleValue(ButtonOffsetRelCnt(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  mul __btnModuleOffset, _b, 8 \
  add __btnModuleOffset, __btnModuleOffset, 4 \
  SetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  compend

#define __setButtonState(_b, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_b), TRUE \
  compchk LT, _b, 0x04 \
  compchk GTEQ, _b, 0x00 \
  SetButtonModuleValue(ButtonOffsetState(_b), _n) \
  compelse \
  acquire __btnModuleOffsetMutex \
  add __btnModuleOffset, _b, 32 \
  SetButtonModuleValue(__btnModuleOffset, _n) \
  release __btnModuleOffsetMutex \
  Compend

#define __setCommandFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetFlags, _n)

#define __setUIState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetState, _n)

#define __setUIButton(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetButton, _n)

#define __setVMRunState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetRunState, _n)

#define __setBatteryState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetBatteryState, _n)

#define __setBluetoothState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetBluetoothState, _n)

#define __setUsbState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetUsbState, _n)

#define __setSleepTimeout(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetSleepTimeout, _n)

#define __setSleepTimer(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetSleepTimer, _n)

#define __setVolume(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetVolume, _n)

#define __setOnBrickProgramPointer(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetOBPPointer, _n)

#define __forceOff(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetForceOff, _n)

#define __setAbortFlag(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetUIModuleValue(UIOffsetAbortFlag, _n)

#define __setInCustomZeroOffset(_p, _n) \
  compchk EQ, sizeof(_n), 2 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetInputModuleValue(InputOffsetCustomZeroOffset(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  SetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __setInSensorBoolean(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetInputModuleValue(InputOffsetSensorBoolean(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 10 \
  SetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __setInDigiPinsDirection(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetInputModuleValue(InputOffsetDigiPinsDir(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 11 \
  SetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __setInDigiPinsStatus(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetInputModuleValue(InputOffsetDigiPinsIn(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 12 \
  SetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __setInDigiPinsOutputLevel(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetInputModuleValue(InputOffsetDigiPinsOut(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 13 \
  SetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __setInCustomPercentFullScale(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetInputModuleValue(InputOffsetCustomPctFullScale(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 14 \
  SetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __setInCustomActiveStatus(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetInputModuleValue(InputOffsetCustomActiveStatus(_p), _n) \
  compelse \
  acquire __inputModuleOffsetMutex \
  mul __inputModuleOffset, _p, 20 \
  add __inputModuleOffset, __inputModuleOffset, 15 \
  SetInputModuleValue(__inputModuleOffset, _n) \
  release __inputModuleOffsetMutex \
  compend

#define __setOutPwnFreq(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetOutputModuleValue(OutputOffsetRegulationTime, _n)

#define __setOutRegulationTime(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetOutputModuleValue(OutputOffsetRegulationTime, _n)

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)

#define __setOutRegulationOptions(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetOutputModuleValue(OutputOffsetRegulationOptions, _n)

#endif

#define __setLSInputBufferInPtr(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetInBufInPtr(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 16 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSInputBufferOutPtr(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetInBufOutPtr(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 17 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSInputBufferBytesToRx(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetInBufBytesToRx(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 18 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSOutputBufferInPtr(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetOutBufInPtr(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 92 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSOutputBufferOutPtr(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetOutBufOutPtr(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 93 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSOutputBufferBytesToRx(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetOutBufBytesToRx(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  mul __lsModuleOffset, _p, 19 \
  add __lsModuleOffset, __lsModuleOffset, 94 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSMode(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetMode(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  add __lsModuleOffset, _p, 152 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSChannelState(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetChannelState(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  add __lsModuleOffset, _p, 156 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSErrorType(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetLowSpeedModuleValue(LowSpeedOffsetErrorType(_p), _n) \
  compelse \
  acquire __lsModuleOffsetMutex \
  add __lsModuleOffset, _p, 160 \
  SetLowSpeedModuleValue(__lsModuleOffset, _n) \
  release __lsModuleOffsetMutex \
  compend

#define __setLSState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetLowSpeedModuleValue(LowSpeedOffsetState, _n)

#define __setLSSpeed(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetLowSpeedModuleValue(LowSpeedOffsetSpeed, _n)

#ifdef __ENHANCED_FIRMWARE
#define __setLSNoRestartOnRead(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetLowSpeedModuleValue(LowSpeedOffsetNoRestartOnRead, _n)
#endif

#define __setDisplayEraseMask(_n) \
  compchk EQ, sizeof(_n), 4 \
  SetDisplayModuleValue(DisplayOffsetEraseMask, _n)

#define __setDisplayUpdateMask(_n) \
  compchk EQ, sizeof(_n), 4 \
  SetDisplayModuleValue(DisplayOffsetUpdateMask, _n)

#define __setDisplayFont(_n) \
  compchk EQ, sizeof(_n), 4 \
  SetDisplayModuleValue(DisplayOffsetPFont, _n)

#define __setDisplayDisplay(_n) \
  compchk EQ, sizeof(_n), 4 \
  SetDisplayModuleValue(DisplayOffsetDisplay, _n)

#define __setDisplayFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetDisplayModuleValue(DisplayOffsetFlags, _n)

#define __setDisplayTextLinesCenterFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetDisplayModuleValue(DisplayOffsetTextLinesCenterFlags, _n)

#define __setDisplayContrast(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetDisplayModuleValue(DisplayOffsetContrast, _n)

#define __setBTDeviceClass(_p, _n) \
  compchk EQ, sizeof(_n), 4 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleValue(CommOffsetBtDeviceTableClassOfDevice(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 31 \
  add __commModuleOffset, __commModuleOffset, 24 \
  SetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __setBTDeviceStatus(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleValue(CommOffsetBtDeviceTableDeviceStatus(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 31 \
  add __commModuleOffset, __commModuleOffset, 35 \
  SetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __setBTConnectionClass(_p, _n) \
  compchk EQ, sizeof(_n), 4 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleValue(CommOffsetBtConnectTableClassOfDevice(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 954 \
  SetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __setBTConnectionHandleNum(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleValue(CommOffsetBtConnectTableHandleNr(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 981 \
  SetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __setBTConnectionStreamStatus(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleValue(CommOffsetBtConnectTableStreamStatus(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 982 \
  SetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __setBTConnectionLinkQuality(_p, _n) \
  compchk EQ, sizeof(_n), 1 \
  compif EQ, isconst(_p), TRUE \
  compchk LT, _p, 0x04 \
  compchk GTEQ, _p, 0x00 \
  SetCommModuleValue(CommOffsetBtConnectTableLinkQuality(_p), _n) \
  compelse \
  acquire __commModuleOffsetMutex \
  mul __commModuleOffset, _p, 47 \
  add __commModuleOffset, __commModuleOffset, 983 \
  SetCommModuleValue(__commModuleOffset, _n) \
  release __commModuleOffsetMutex \
  compend

#define __setBrickDataBluecoreVersion(_n) \
  compchk EQ, sizeof(_n), 2 \
  SetCommModuleValue(CommOffsetBrickDataBluecoreVersion, _n)

#define __setBrickDataBtStateStatus(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBrickDataBtStateStatus, _n)

#define __setBrickDataBtHardwareStatus(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBrickDataBtHwStatus, _n)

#define __setBrickDataTimeoutValue(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBrickDataTimeOutValue, _n)

#define __setBTInputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBtInBufInPtr, _n)

#define __setBTInputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBtInBufOutPtr, _n)

#define __setBTOutputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBtOutBufInPtr, _n)

#define __setBTOutputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBtOutBufOutPtr, _n)

#define __setHSInputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetHsInBufInPtr, _n)

#define __setHSInputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetHsInBufOutPtr, _n)

#define __setHSOutputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetHsOutBufInPtr, _n)

#define __setHSOutputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetHsOutBufOutPtr, _n)

#define __setUSBInputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetUsbInBufInPtr, _n)

#define __setUSBInputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetUsbInBufOutPtr, _n)

#define __setUSBOutputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetUsbOutBufInPtr, _n)

#define __setUSBOutputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetUsbOutBufOutPtr, _n)

#define __setUSBPollBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetUsbPollBufInPtr, _n)

#define __setUSBPollBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetUsbPollBufOutPtr, _n)

#define __setBTDeviceCount(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBtDeviceCnt, _n)

#define __setBTDeviceNameCount(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetBtDeviceNameCnt, _n)

#define __setHSFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetHsFlags, _n)

#define __setHSSpeed(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetHsSpeed, _n)

#define __setHSState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetHsState, _n)

#define __setUSBState(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetUsbState, _n)

#define __setHSAddress(_n) \
  compchk EQ, sizeof(_n), 1 \
  SetCommModuleValue(CommOffsetHsAddress, _n)

#if (__FIRMWARE_VERSION > 107) && defined(__ENHANCED_FIRMWARE)

#define __setHSMode(_n) \
  compchk EQ, sizeof(_n), 2 \
  SetCommModuleValue(CommOffsetHsMode, _n)

#define __setBTDataMode(_n) \
  compchk EQ, sizeof(_n), 1 \
  compchk EQ, isconst(_n), 1 \
  SetCommModuleValue(CommOffsetBtDataMode, _n|DATA_MODE_UPDATE) \
  wait 1

#define __setHSDataMode(_n) \
  compchk EQ, sizeof(_n), 1 \
  compchk EQ, isconst(_n), 1 \
  SetCommModuleValue(CommOffsetHsDataMode, _n|DATA_MODE_UPDATE) \
  wait 1

#endif

dseg segment
  __FOMutex mutex
  __FOArgs TFileOpen
  __FCMutex mutex
  __FCArgs TFileClose
  __FRHMutex mutex
  __FRHArgs TFileResolveHandle
  __FRMutex mutex
  __FRArgs TFileRename
  __FDMutex mutex
  __FDArgs TFileDelete
  __FFMutex mutex
dseg ends

#ifdef __ENHANCED_FIRMWARE
dseg segment
  __FFArgs TFileFind
dseg ends
#endif

subroutine __fileResizeSub
  dseg segment
    __frsMutex mutex
    __frsNewSize dword
    __frsOldName byte[]
    __frsTmpName byte[]
    __frsFOReadArgs TFileOpen
    __frsFOWriteArgs TFileOpen
    __frsFReadArgs TFileReadWrite
    __frsFWriteArgs TFileReadWrite
    __frsFRArgs TFileRename
    __frsFCArgs TFileClose
    __frsFDArgs TFileDelete
    __frsResult word
  dseg ends
  strcat __frsFRArgs.NewFilename, '_tmp', __frsOldName
  mov __frsFRArgs.OldFilename, __frsOldName
  syscall FileRename, __frsFRArgs
  mov __frsResult, __frsFRArgs.Result
  brtst NEQ, __frsEnd, __frsResult
  // old file has been renamed successfully
  mov __frsFOReadArgs.Filename, __frsFRArgs.NewFilename
  syscall FileOpenRead, __frsFOReadArgs
  mov __frsResult, __frsFOReadArgs.Result
  brtst NEQ, __frsOpenReadFailed, __frsResult
  // renamed file is open for reading
  mov __frsFOWriteArgs.Filename, __frsOldName
  mov __frsFOWriteArgs.Length, __frsNewSize
  syscall FileOpenWrite, __frsFOWriteArgs
  mov __frsResult, __frsFOWriteArgs.Result
  brtst NEQ, __frsOpenWriteFailed, __frsResult
  // both files are open
  mov __frsFReadArgs.FileHandle, __frsFOReadArgs.FileHandle
  mov __frsFWriteArgs.FileHandle, __frsFOWriteArgs.FileHandle
__frsCopyLoop:
  set __frsFReadArgs.Length, 1024
  syscall FileRead, __frsFReadArgs
  brtst LTEQ, __frsEndLoop, __frsFReadArgs.Length
  mov __frsFWriteArgs.Buffer, __frsFReadArgs.Buffer
  mov __frsFWriteArgs.Length, __frsFReadArgs.Length
  syscall FileWrite, __frsFWriteArgs
  brtst NEQ, __frsEndLoop, __frsFWriteArgs.Result
  brtst NEQ, __frsEndLoop, __frsFReadArgs.Result
  jmp __frsCopyLoop
__frsEndLoop:
  // close read file
  mov __frsFCArgs.FileHandle, __frsFOReadArgs.FileHandle
  syscall FileClose, __frsFCArgs
  // close write file
  mov __frsFCArgs.FileHandle, __frsFOWriteArgs.FileHandle
  syscall FileClose, __frsFCArgs
  // delete read file
  mov __frsFDArgs.Filename, __frsFOReadArgs.Filename
  syscall FileDelete, __frsFDArgs
  jmp __frsEnd
__frsOpenWriteFailed:
  // close read file
  mov __frsFCArgs.FileHandle, __frsFOReadArgs.FileHandle
  syscall FileClose, __frsFCArgs
  jmp __frsEnd
__frsOpenReadFailed:
  // if the open read failed rename tmp back to original and exit
  mov __frsFRArgs.OldFilename, __frsFRArgs.NewFilename
  mov __frsFRArgs.NewFilename, __frsOldName
  syscall FileRename, __frsFRArgs
__frsEnd:
  return
ends

#define __fileResize(_fname, _newsize, _result) \
  acquire __frsMutex \
  mov __frsOldName, _fname \
  mov __frsNewSize, _newsize \
  call __fileResizeSub \
  mov _result, __frsResult \
  release __frsMutex 

#define __createFile(_fname, _fsize, _handle, _result) \
  acquire __FOMutex \
  mov __FOArgs.Filename, _fname \
  mov __FOArgs.Length, _fsize \
  syscall FileOpenWrite, __FOArgs \
  mov _handle, __FOArgs.FileHandle \
  mov _result, __FOArgs.Result \
  release __FOMutex

#define __createFileLinear(_fname, _fsize, _handle, _result) \
  acquire __FOMutex \
  mov __FOArgs.Filename, _fname \
  mov __FOArgs.Length, _fsize \
  syscall FileOpenWriteLinear, __FOArgs \
  mov _handle, __FOArgs.FileHandle \
  mov _result, __FOArgs.Result \
  release __FOMutex

#define __createFileNonLinear(_fname, _fsize, _handle, _result) \
  acquire __FOMutex \
  mov __FOArgs.Filename, _fname \
  mov __FOArgs.Length, _fsize \
  syscall FileOpenWriteNonLinear, __FOArgs \
  mov _handle, __FOArgs.FileHandle \
  mov _result, __FOArgs.Result \
  release __FOMutex

#define __openFileAppend(_fname, _fsize, _handle, _result) \
  acquire __FOMutex \
  mov __FOArgs.Filename, _fname \
  syscall FileOpenAppend, __FOArgs \
  mov _fsize, __FOArgs.Length \
  mov _handle, __FOArgs.FileHandle \
  mov _result, __FOArgs.Result \
  release __FOMutex

#define __openFileRead(_fname, _fsize, _handle, _result) \
  acquire __FOMutex \
  mov __FOArgs.Filename, _fname \
  syscall FileOpenRead, __FOArgs \
  mov _fsize, __FOArgs.Length \
  mov _handle, __FOArgs.FileHandle \
  mov _result, __FOArgs.Result \
  release __FOMutex

#define __openFileReadLinear(_fname, _fsize, _handle, _result) \
  acquire __FOMutex \
  mov __FOArgs.Filename, _fname \
  syscall FileOpenReadLinear, __FOArgs \
  mov _fsize, __FOArgs.Length \
  mov _handle, __FOArgs.FileHandle \
  mov _result, __FOArgs.Result \
  release __FOMutex

#define __closeFile(_handle, _result) \
  acquire __FCMutex \
  mov __FCArgs.FileHandle, _handle \
  syscall FileClose, __FCArgs \
  mov _result, __FCArgs.Result \
  release __FCMutex

#define __resolveHandle(_fname, _handle, _writable, _result) \
  acquire __FRHMutex \
  mov __FRHArgs.Filename, _fname \
  syscall FileResolveHandle, __FRHArgs \
  mov _handle, __FRHArgs.FileHandle \
  mov _writable, __FRHArgs.WriteHandle \
  mov _result, __FRHArgs.Result \
  release __FRHMutex

#define __renameFile(_oldname, _newname, _result) \
  acquire __FRMutex \
  mov __FRArgs.OldFilename, _oldname \
  mov __FRArgs.NewFilename, _newname \
  syscall FileRename, __FRArgs \
  mov _result, __FRArgs.Result \
  release __FRMutex

#define __deleteFile(_fname, _result) \
  acquire __FDMutex \
  mov __FDArgs.Filename, _fname \
  syscall FileDelete, __FDArgs \
  mov _result, __FDArgs.Result \
  release __FDMutex

#ifdef __ENHANCED_FIRMWARE

#define __findFirstFile(_fname, _handle, _result) \
  acquire __FFMutex \
  mov __FFArgs.Filename, _fname \
  syscall FileFindFirst, __FFArgs \
  mov _result, __FFArgs.Result \
  mov _handle, __FFArgs.FileHandle \
  mov _fname, __FFArgs.Filename \
  release __FFMutex

#define __findNextFile(_fname, _handle, _result) \
  acquire __FFMutex \
  mov __FFArgs.FileHandle, _handle \
  syscall FileFindNext, __FFArgs \
  mov _result, __FFArgs.Result \
  mov _handle, __FFArgs.FileHandle \
  mov _fname, __FFArgs.Filename \
  release __FFMutex

#endif

dseg segment
  __FReadArgs TFileReadWrite
  __FReadTmpByte byte
  __FReadMutex mutex
  __RLSBuffer byte[]
  __RLSOutput byte[]
  __RLSReturn word
  __RLSReturnAddress byte
  __RLSMaxBytes word
  __RLSByteCount word
  __soTmpBuf byte[]
  __soMutex mutex
dseg ends

#define __sizeOF(_n, _result) \
  compif EQ, ((typeof(_n)>=1)&&(typeof(_n)<=6))||(typeof(_n)==10), TRUE \
  set _result, sizeof(_n) \
  compelse \
  acquire __soMutex \
  flatten __soTmpBuf, _n \
  arrsize _result, __soTmpBuf \
  sub _result, _result, 1 \
  release __soMutex \
  compend

#define __readBytes(_handle, _len, _buf, _result) \
  acquire __FReadMutex \
  mov __FReadArgs.FileHandle, _handle \
  mov __FReadArgs.Length, _len \
  syscall FileRead, __FReadArgs \
  mov _result, __FReadArgs.Result \
  strtoarr _buf, __FReadArgs.Buffer \
  mov _len, __FReadArgs.Length \
  release __FReadMutex

#define __readValue(_handle, _n, _result) \
  acquire __FReadMutex \
  mov __FReadArgs.FileHandle, _handle \
  __sizeOF(_n, __FReadArgs.Length) \
  syscall FileRead, __FReadArgs \
  mov _result, __FReadArgs.Result \
  unflatten _n, __FReadTmpByte, __FReadArgs.Buffer, _n \
  release __FReadMutex

#define __readLnValue(_handle, _n, _result) \
  acquire __FReadMutex \
  mov __FReadArgs.FileHandle, _handle \
  __sizeOF(_n, __FReadArgs.Length) \
  syscall FileRead, __FReadArgs \
  unflatten _n, __FReadTmpByte, __FReadArgs.Buffer, _n \
  set __FReadArgs.Length, 2 \
  syscall FileRead, __FReadArgs \
  mov _result, __FReadArgs.Result \
  release __FReadMutex

#define __readLnStringEx(_handle, _output, _max, _result) \
  acquire __FReadMutex \
  mov __FReadArgs.FileHandle, _handle \
  mov __RLSMaxBytes, _max \
  subcall __readStringLine, __RLSReturnAddress \
  mov _result, __RLSReturn \
  mov _output, __RLSOutput \
  release __FReadMutex \

#define __readLnString(_handle, _output, _result) __readLnStringEx(_handle, _output, 0xFFFF, _result)

subroutine __readStringLine
  arrinit __RLSOutput, 0, 1
  set __RLSByteCount, 0
  __RLSStringLoop:
  set __FReadArgs.Length, 1
  mov __RLSBuffer, __RLSOutput
  syscall FileRead, __FReadArgs
  mov __RLSReturn, __FReadArgs.Result
  brtst NEQ, __RLSStringDone, __RLSReturn
  index __FReadTmpByte, __FReadArgs.Buffer, NA
  brcmp EQ, __RLSStringDone, __FReadTmpByte, 0x0A
  brcmp EQ, __RLSStringSkip, __FReadTmpByte, 0x0D
  strcat __RLSOutput, __RLSBuffer, __FReadArgs.Buffer
  add __RLSByteCount, __RLSByteCount, 1
  brcmp GTEQ, __RLSStringDone, __RLSByteCount, __RLSMaxBytes
  __RLSStringSkip:
  jmp __RLSStringLoop
  __RLSStringDone:
  subret __RLSReturnAddress
ends

dseg segment
  __FWriteArgs TFileReadWrite
  __FWriteFlattenBuf byte[]
  __FWriteMutex mutex
  __FWriteLn byte[] {0x0D, 0x0A}
dseg ends

#define __writeBytes(_handle, _buf, _len, _result) \
  acquire __FWriteMutex \
  mov __FWriteArgs.FileHandle, _handle \
  mov __FWriteArgs.Buffer, _buf \
  arrsize __FWriteArgs.Length, __FWriteArgs.Buffer \
  syscall FileWrite, __FWriteArgs \
  mov _result, __FWriteArgs.Result \
  mov _len, __FWriteArgs.Length \
  release __FWriteMutex

#define __writeString(_handle, _str, _len, _result) \
  acquire __FWriteMutex \
  mov __FWriteArgs.FileHandle, _handle \
  strtoarr __FWriteArgs.Buffer, _str \
  arrsize __FWriteArgs.Length, __FWriteArgs.Buffer \
  syscall FileWrite, __FWriteArgs \
  mov _result, __FWriteArgs.Result \
  mov _len, __FWriteArgs.Length \
  release __FWriteMutex

#define __writeLnString(_handle, _str, _len, _result) \
  acquire __FWriteMutex \
  mov __FWriteArgs.FileHandle, _handle \
  strtoarr __FWriteFlattenBuf, _str \
  arrbuild __FWriteArgs.Buffer, __FWriteFlattenBuf, __FWriteLn \
  arrsize __FWriteArgs.Length, __FWriteArgs.Buffer \
  syscall FileWrite, __FWriteArgs \
  mov _result, __FWriteArgs.Result \
  mov _len, __FWriteArgs.Length \
  release __FWriteMutex

#define __writeBytesEx(_handle, _len, _buf, _result) \
  acquire __FWriteMutex \
  mov __FWriteArgs.FileHandle, _handle \
  mov __FWriteArgs.Length, _len \
  mov __FWriteArgs.Buffer, _buf \
  syscall FileWrite, __FWriteArgs \
  mov _result, __FWriteArgs.Result \
  mov _len, __FWriteArgs.Length \
  release __FWriteMutex

#define __writeValue(_handle, _n, _result) \
  acquire __FWriteMutex \
  mov __FWriteArgs.FileHandle, _handle \
  flatten __FWriteFlattenBuf, _n \
  strtoarr __FWriteArgs.Buffer, __FWriteFlattenBuf \
  arrsize __FWriteArgs.Length, __FWriteArgs.Buffer \
  syscall FileWrite, __FWriteArgs \
  mov _result, __FWriteArgs.Result \
  release __FWriteMutex

#define __writeLnValue(_handle, _n, _result) \
  acquire __FWriteMutex \
  mov __FWriteArgs.FileHandle, _handle \
  flatten __FWriteFlattenBuf, _n \
  strtoarr __FWriteArgs.Buffer, __FWriteFlattenBuf \
  arrbuild __FWriteFlattenBuf, __FWriteArgs.Buffer, __FWriteLn \
  mov __FWriteArgs.Buffer, __FWriteFlattenBuf \
  arrsize __FWriteArgs.Length, __FWriteArgs.Buffer \
  syscall FileWrite, __FWriteArgs \
  mov _result, __FWriteArgs.Result \
  release __FWriteMutex

dseg segment
  __MWMutex mutex
  __MWArgs TMessageWrite
  __MRMutex mutex
  __MRArgs TMessageRead
  __SRNTmpVal sdword
  __RRNTmpVal sdword
  __RRNErr byte
dseg ends

#define __sendMessage(_queue, _msg, _result) \
  acquire __MWMutex \
  mov __MWArgs.QueueID, _queue \
  mov __MWArgs.Message, _msg \
  syscall MessageWrite, __MWArgs \
  mov _result, __MWArgs.Result \
  release __MWMutex

#define __receiveMessage(_queue, _clear, _msg, _result) \
  acquire __MRMutex \
  mov __MRArgs.QueueID, _queue \
  mov __MRArgs.Remove, _clear \
  syscall MessageRead, __MRArgs \
  mov _msg, __MRArgs.Message \
  mov _result, __MRArgs.Result \
  release __MRMutex

#define __receiveRemoteBool(_queue, _clear, _bval, _result) \
  acquire __MRMutex \
  mov __MRArgs.QueueID, _queue \
  mov __MRArgs.Remove, _clear \
  set _bval, 0 \
  syscall MessageRead, __MRArgs \
  brtst NEQ, __RRB_Err##__I__, __MRArgs.Result \
  index _bval, __MRArgs.Message, NA \
  __RRB_Err##__I__: \
  __IncI__ \
  mov _result, __MRArgs.Result \
  release __MRMutex

#define __receiveRemoteNumber(_queue, _clear, _val, _result) \
  acquire __MRMutex \
  mov __MRArgs.QueueID, _queue \
  mov __MRArgs.Remove, _clear \
  set __RRNTmpVal, 0 \
  syscall MessageRead, __MRArgs \
  unflatten __RRNTmpVal, __RRNErr, __MRArgs.Message, __RRNTmpVal \
  mov _val, __RRNTmpVal \
  mov _result, __MRArgs.Result \
  release __MRMutex

#define __receiveRemoteMessageEx(_queue, _clear, _str, _val, _bval, _result) \
  acquire __MRMutex \
  mov __MRArgs.QueueID, _queue \
  mov __MRArgs.Remove, _clear \
  set __RRNTmpVal, 0 \
  set _bval, 0 \
  syscall MessageRead, __MRArgs \
  brtst NEQ, __RRM_Err##__I__, __MRArgs.Result \
  index _bval, __MRArgs.Message, NA \
  unflatten __RRNTmpVal, __RRNErr, __MRArgs.Message, __RRNTmpVal \
  __RRM_Err##__I__: \
  __IncI__ \
  mov _val, __RRNTmpVal \
  mov _str, __MRArgs.Message \
  mov _result, __MRArgs.Result \
  release __MRMutex

#define __sendResponseBool(_queue, _bval, _result) \
  acquire __MWMutex \
  add __MWArgs.QueueID, _queue, 10 \
  arrbuild __MWArgs.Message, _bval, 0 \
  syscall MessageWrite, __MWArgs \
  mov _result, __MWArgs.Result \
  release __MWMutex

#define __sendResponseNumber(_queue, _val, _result) \
  acquire __MWMutex \
  add __MWArgs.QueueID, _queue, 10 \
  mov __SRNTmpVal, _val \
  flatten __MWArgs.Message, __SRNTmpVal \
  syscall MessageWrite, __MWArgs \
  mov _result, __MWArgs.Result \
  release __MWMutex

#define __sendResponseString(_queue, _msg, _result) \
  acquire __MWMutex \
  add __MWArgs.QueueID, _queue, 10 \
  mov __MWArgs.Message, _msg \
  syscall MessageWrite, __MWArgs \
  mov _result, __MWArgs.Result \
  release __MWMutex


dseg segment
  __CBTCSArgs TCommBTCheckStatus
  __CBTCSMutex mutex
  __CBTWArgs TCommBTWrite
  __CBTWMutex mutex
  __SRSTmpBuf byte[]
  __SRSSendBuf byte[]
  __SRSTmpLongVal sdword
  __SRSTmpWordVal sword
  __SRSTmpByteVal sbyte
  __SRSFlattenBuf byte[]
  __RemoteMutex mutex
dseg ends

dseg segment
  __GenericCmdFilenamePacket byte[] {0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  __GenericCreateFilePacket byte[]  {0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0xFF, 0xFF}
  __GenericIOMapPacket byte[]       {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}
// direct commands
  __DCStartProgramPacket byte[]     {0x80, 0x00}
  __DCStopProgramPacket byte[]      {0x80, 0x01}
  __DCPlaySoundFilePacket byte[]    {0x80, 0x02, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  __DCPlayTonePacket byte[]         {0x80, 0x03, 0xFF, 0xFF, 0xFF, 0xFF}
  __DCSetOutputStatePacket byte[]   {0x80, 0x04}
  __DCSetInputModePacket byte[]     {0x80, 0x05}
  __DCGetOutputStatePacket byte[]   {0x00, 0x06}
  __DCGetInputValuesPacket byte[]   {0x00, 0x07}
  __DCResetScaledValuePacket byte[] {0x80, 0x08}
  __DCMessageWritePacket byte[]     {0x80, 0x09, 0xFF, 0xFF}
  __DCResetMotorPosPacket byte[]    {0x80, 0x0a}
  __DCGetBatteryLevelPacket byte[]  {0x00, 0x0b}
  __DCStopSoundPacket byte[]        {0x80, 0x0c}
  __DCKeepAlivePacket byte[]        {0x80, 0x0d}
  __DCLSGetStatusPacket byte[]      {0x00, 0x0e}
  __DCLSWritePacket byte[]          {0x80, 0x0f}
  __DCLSReadPacket byte[]           {0x00, 0x10}
  __DCGetCurProgNamePacket byte[]   {0x00, 0x11}
  __DCMessageReadPacket byte[]      {0x00, 0x13}
  __DCDatalogReadPacket byte[]      {0x00, 0x19}
  __DCDatalogSetTimesPacket byte[]  {0x80, 0x1a}
  __DCBTGetContactCntPacket byte[]  {0x00, 0x1b}
  __DCBTGetContactNamePacket byte[] {0x00, 0x1c}
  __DCBTGetConnectCntPacket byte[]  {0x00, 0x1d}
  __DCBTGetConnectNamePacket byte[] {0x00, 0x1e}
  __DCSetPropertyPacket byte[]      {0x80, 0x1f}
  __DCGetPropertyPacket byte[]      {0x00, 0x20}
  __DCUpdateResetCountPacket byte[] {0x80, 0x21}
// system commands
  __SCOpenReadPacket byte[]         {0x01, 0x80}
  __SCOpenWritePacket byte[]        {0x01, 0x81}
  __SCReadPacket byte[]             {0x01, 0x82}
  __SCWritePacket byte[]            {0x01, 0x83}
  __SCClosePacket byte[]            {0x01, 0x84}
  __SCDeletePacket byte[]           {0x01, 0x85}
  __SCFindFirstPacket byte[]        {0x01, 0x86}
  __SCFindNextPacket byte[]         {0x01, 0x87}
  __SCGetFirmwareVerPacket byte[]   {0x01, 0x88}
  __SCOpenWriteLinearPacket byte[]  {0x01, 0x89}
  __SCOpenWriteDataPacket byte[]    {0x01, 0x8b}
  __SCOpenAppendDataPacket byte[]   {0x01, 0x8c}
  __SCIOMapReadPacket byte[]        {0x01, 0x94}
  __SCIOMapWritePacket byte[]       {0x81, 0x95}
  __SCSetBrickNamePacket byte[]     {0x81, 0x98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  __SCBTGetAddressPacket byte[]     {0x01, 0x9a}
  __SCGetDeviceInfoPacket byte[]    {0x01, 0x9b}
  __SCDeleteUserFlashPacket byte[]  {0x01, 0xA0}
  __SCPollCommandLenPacket byte[]   {0x01, 0xA1}
  __SCPollCommandPacket byte[]      {0x01, 0xA2} // append buffer number, cmd len,
  __SCRenameFilePacket byte[]       {0x81, 0xA3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  __SCBTFactoryResetPacket byte[]   {0x81, 0xA4}
dseg ends

#define __bluetoothStatus(_conn, _result) \
  acquire __CBTCSMutex \
  mov __CBTCSArgs.Connection, _conn \
  syscall CommBTCheckStatus, __CBTCSArgs \
  mov _result, __CBTCSArgs.Result \
  release __CBTCSMutex

#define __bluetoothWrite(_conn, _buffer, _result) \
  acquire __CBTWMutex \
  mov __CBTWArgs.Connection, _conn \
  mov __CBTWArgs.Buffer, _buffer \
  syscall CommBTWrite, __CBTWArgs \
  mov _result, __CBTWArgs.Result \
  release __CBTWMutex

#define __UseRS485() \
  setin IN_TYPE_HISPEED, IN_4, TypeField \
  wait 1

#ifdef __ENHANCED_FIRMWARE

dseg segment
  __CHSCSArgs TCommHSCheckStatus
  __CHSCSMutex mutex
  __CHSWArgs TCommHSReadWrite
  __CHSWMutex mutex
  __CHSRArgs TCommHSReadWrite
  __CHSRMutex mutex
  __CHSCArgs TCommHSControl
  __CHSCMutex mutex
  __SHSTmpVal sdword
  __WFRRMutex mutex
  __WFRRAvail byte
  __WFRR_I byte
  __WFRRCmd byte
  __WFRRBuffer byte[]
  __WFRRTmpBuffer byte[]
  __WFRRUnflattenBuf byte[]
  __WFRRUnflattenErr byte
  __WFRRTmpByte byte
  __WFRRTmpSWord sword
  __WFRRTmpSDWord sdword
  __WFRRStatus sbyte
dseg ends

#define __RS485Status(_sendingData, _dataAvail) \
  acquire __CHSCSMutex \
  syscall CommHSCheckStatus, __CHSCSArgs \
  mov _sendingData, __CHSCSArgs.SendingData \
  mov _dataAvail, __CHSCSArgs.DataAvailable \
  release __CHSCSMutex

#define __RS485WriteSCDC(_conn, _buffer, _status) \
  acquire __CHSWMutex \
  sub __WFRRTmpByte, _conn, CONN_HS_ALL \
  arrbuild __CHSWArgs.Buffer, __WFRRTmpByte, _buffer \
  syscall CommHSWrite, __CHSWArgs \
  mov _status, __CHSWArgs.Status \
  release __CHSWMutex

#define __RS485Write(_buffer, _status) \
  acquire __CHSWMutex \
  mov __CHSWArgs.Buffer, _buffer \
  syscall CommHSWrite, __CHSWArgs \
  mov _status, __CHSWArgs.Status \
  release __CHSWMutex

#if __FIRMWARE_VERSION > 107

#define __RS485Read(_buffer, _status) \
  acquire __CHSRMutex \
  set __CHSRArgs.BufferLen, 0xFF \
  syscall CommHSRead, __CHSRArgs \
  mov _buffer, __CHSRArgs.Buffer \
  mov _status, __CHSRArgs.Status \
  release __CHSRMutex

#define __RS485ReadEx(_buffer, _buflen, _status) \
  acquire __CHSRMutex \
  mov __CHSRArgs.BufferLen, _buflen \
  syscall CommHSRead, __CHSRArgs \
  mov _buffer, __CHSRArgs.Buffer \
  mov _status, __CHSRArgs.Status \
  release __CHSRMutex

#define __RS485Control(_cmd, _baud, _mode, _result) \
  acquire __CHSCMutex \
  mov __CHSCArgs.Command, _cmd \
  mov __CHSCArgs.BaudRate, _baud \
  mov __CHSCArgs.Mode, _mode \
  syscall CommHSControl, __CHSCArgs \
  mov _result, __CHSCArgs.Result \
  release __CHSCMutex \
  wait 1

#else

#define __RS485Read(_buffer, _status) \
  acquire __CHSRMutex \
  syscall CommHSRead, __CHSRArgs \
  mov _buffer, __CHSRArgs.Buffer \
  mov _status, __CHSRArgs.Status \
  release __CHSRMutex

#define __RS485Control(_cmd, _baud, _result) \
  acquire __CHSCMutex \
  mov __CHSCArgs.Command, _cmd \
  mov __CHSCArgs.BaudRate, _baud \
  syscall CommHSControl, __CHSCArgs \
  mov _result, __CHSCArgs.Result \
  release __CHSCMutex \
  wait 1

#endif

#define __sendRS485Bool(_bval, _status) \
  acquire __CHSWMutex \
  arrbuild __CHSWArgs.Buffer, _bval, 0 \
  syscall CommHSWrite, __CHSWArgs \
  mov _status, __CHSWArgs.Status \
  release __CHSWMutex

#define __sendRS485Number(_val, _status) \
  acquire __CHSWMutex \
  mov __SHSTmpVal, _val \
  flatten __CHSWArgs.Buffer, __SHSTmpVal \
  syscall CommHSWrite, __CHSWArgs \
  mov _status, __CHSWArgs.Status \
  release __CHSWMutex

#define __sendRS485String(_str, _status) __RS485Write(_str, _status)

#endif

#ifdef __ENHANCED_FIRMWARE

#define __connectionSCDCWrite(_conn, _buffer, _result) \
  brcmp LT, __ConnWrite_Else##__I__, _conn, 4 \
  __RS485WriteSCDC(_conn, _buffer, _result) \
  jmp __ConnWrite_EndIf##__I__ \
  __ConnWrite_Else##__I__: \
  __bluetoothWrite(_conn, _buffer, _result) \
  __ConnWrite_EndIf##__I__: \
  __IncI__

#define __connectionRawWrite(_conn, _buffer, _result) \
  brcmp LT, __ConnWrite_Else##__I__, _conn, 4 \
  __RS485Write(_buffer, _result) \
  jmp __ConnWrite_EndIf##__I__ \
  __ConnWrite_Else##__I__: \
  __bluetoothWrite(_conn, _buffer, _result) \
  __ConnWrite_EndIf##__I__: \
  __IncI__

#define __remoteConnectionIdle(_conn, _result) \
  brcmp NEQ, __ConnIdle_Else##__I__, _conn, 4 \
  __RS485Status(_result, __SHSTmpVal) \
  jmp __ConnIdle_EndIf##__I__ \
  __ConnIdle_Else##__I__: \
  __bluetoothStatus(_conn, _result) \
  __ConnIdle_EndIf##__I__: \
  tst EQ, _result, _result \
  __IncI__

subroutine __DoWaitForRemoteResponse
  set __WFRR_I, 0
  __wFRR_Repeat:
  __GetLastResponseInfo(FALSE, __WFRRAvail, __WFRRCmd, __WFRRBuffer, __WFRRStatus)
  wait 2
  add __WFRR_I, __WFRR_I, 1
  // if it rolls back around to 0 then break out of loop
  brtst EQ, __wFRR_Break, __WFRR_I
  brtst EQ, __wFRR_Repeat, __WFRRAvail
  // > 0 bytes in last response so read it one more time and clear it
  __GetLastResponseInfo(TRUE, __WFRRAvail, __WFRRCmd, __WFRRBuffer, __WFRRStatus)
  jmp __wFRR_End
  __wFRR_Break:
  set __WFRRStatus, TRUE // timeout error occurred
  __wFRR_End:
  return
ends

#else

#define __connectionSCDCWrite(_conn, _buffer, _result) __bluetoothWrite(_conn, _buffer, _result)
#define __connectionRawWrite(_conn, _buffer, _result) __bluetoothWrite(_conn, _buffer, _result)

#define __remoteConnectionIdle(_conn, _result) \
  __bluetoothStatus(_conn, _result) \
  tst EQ, _result, _result

#endif

#define __sendRemoteBool(_conn, _queue, _bval, _result) \
  acquire __RemoteMutex \
  mov __SRSTmpBuf, __DCMessageWritePacket \
  replace __SRSTmpBuf, __SRSTmpBuf, 2, _queue \
  replace __SRSTmpBuf, __SRSTmpBuf, 3, 2 \
  arrbuild __SRSSendBuf, __SRSTmpBuf, _bval, 0 \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __sendRemoteNumber(_conn, _queue, _val, _result) \
  acquire __RemoteMutex \
  mov __SRSTmpBuf, __DCMessageWritePacket \
  replace __SRSTmpBuf, __SRSTmpBuf, 2, _queue \
  replace __SRSTmpBuf, __SRSTmpBuf, 3, 5 \
  mov __SRSTmpLongVal, _val \
  flatten __SRSFlattenBuf, __SRSTmpLongVal \
  arrbuild __SRSSendBuf, __SRSTmpBuf, __SRSFlattenBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __sendRemoteString(_conn, _queue, _str, _result) \
  acquire __RemoteMutex \
  mov __SRSTmpBuf, __DCMessageWritePacket \
  replace __SRSTmpBuf, __SRSTmpBuf, 2, _queue \
  arrsize __SRSTmpLongVal, _str \
  replace __SRSTmpBuf, __SRSTmpBuf, 3, __SRSTmpLongVal \
  arrbuild __SRSSendBuf, __SRSTmpBuf, _str \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteMessageRead(_conn, _queue, _result) \
  acquire __RemoteMutex \
  add __SRSTmpLongVal, _queue, 10 \
  arrbuild __SRSSendBuf, __DCMessageReadPacket, __SRSTmpLongVal, _queue, 0x01 \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteResetScaledValue(_conn, _port, _result) \
  acquire __RemoteMutex \
  arrbuild __SRSSendBuf, __DCResetScaledValuePacket, _port \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteResetMotorPosition(_conn, _port, _brelative, _result) \
  acquire __RemoteMutex \
  arrbuild __SRSSendBuf, __DCResetMotorPosPacket, _port, _brelative \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteSetInputMode(_conn, _port, _type, _mode, _result) \
  acquire __RemoteMutex \
  arrbuild __SRSSendBuf, __DCSetInputModePacket, _port, _type, _mode \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteSetOutputState(_conn, _port, _speed, _mode, _regmode, _turnpct, _runstate, _tacholimit, _result) \
  acquire __RemoteMutex \
  mov __SRSTmpLongVal, _tacholimit \
  flatten __SRSFlattenBuf, __SRSTmpLongVal \
  arrbuild __SRSTmpBuf, __DCSetOutputStatePacket, _port, _speed, _mode, _regmode, _turnpct, _runstate, __SRSFlattenBuf \
  strtoarr __SRSSendBuf, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remotePlaySoundFile(_conn, _filename, _bloop, _result) \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __DCPlaySoundFilePacket \
  strsubset __SRSTmpBuf, _filename, NA, 19 \
  replace __SRSSendBuf, __SRSSendBuf, 2, _bloop \
  replace __SRSSendBuf, __SRSSendBuf, 3, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remotePlayTone(_conn, _frequency, _duration, _result) \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __DCPlayTonePacket \
  and __SRSTmpLongVal, _frequency, 0xff \
  replace __SRSSendBuf, __SRSSendBuf, 2, __SRSTmpLongVal \
  div __SRSTmpLongVal, _frequency, 0xff \
  replace __SRSSendBuf, __SRSSendBuf, 3, __SRSTmpLongVal \
  and __SRSTmpLongVal, _duration, 0xff \
  replace __SRSSendBuf, __SRSSendBuf, 4, __SRSTmpLongVal \
  div __SRSTmpLongVal, _duration, 0xff \
  replace __SRSSendBuf, __SRSSendBuf, 5, __SRSTmpLongVal \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteGenericFilenameCommand(_conn, _cmdBuf, _filename, _result) \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __GenericCmdFilenamePacket \
  strsubset __SRSTmpBuf, _filename, NA, 19 \
  replace __SRSSendBuf, __SRSSendBuf, NA, _cmdBuf \
  replace __SRSSendBuf, __SRSSendBuf, 2, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteStartProgram(_conn, _filename, _result) __remoteGenericFilenameCommand(_conn, __DCStartProgramPacket, _filename, _result)

#define __remoteGenericCreateFileCommand(_conn, _cmdBuf, _filename, _size, _result) \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __GenericCreateFilePacket \
  strsubset __SRSTmpBuf, _filename, NA, 19 \
  replace __SRSSendBuf, __SRSSendBuf, NA, _cmdBuf \
  replace __SRSSendBuf, __SRSSendBuf, 2, __SRSTmpBuf \
  mov __SRSTmpLongVal, _size \
  flatten __SRSFlattenBuf, __SRSTmpLongVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 22, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteGenericByteCommand(_conn, _cmdBuf, _val, _result) \
  compchk EQ, sizeof(_val), 1 \
  acquire __RemoteMutex \
  arrbuild __SRSSendBuf, _cmdBuf, _val \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteResetTachoCount(_conn, _port, _result) __remoteGenericByteCommand(_conn, __DCUpdateResetCountPacket, _port, _result)

#define __remoteDoWrite(_conn, _handle, _data, _result) \
  compchk EQ, sizeof(_handle), 1 \
  acquire __RemoteMutex \
  arrbuild __SRSSendBuf, __SCWritePacket, _handle, _data \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteDoRead(_conn, _handle, _numbytes, _result) \
  compchk EQ, sizeof(_handle), 1 \
  acquire __RemoteMutex \
  mov __SRSTmpWordVal, _numbytes \
  flatten __SRSFlattenBuf, __SRSTmpWordVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  arrbuild __SRSSendBuf, __SCReadPacket, _handle, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteDoPollCommand(_conn, _bufnum, _len, _result) \
  compchk EQ, sizeof(_bufnum), 1 \
  compchk EQ, sizeof(_len), 1 \
  acquire __RemoteMutex \
  arrbuild __SRSSendBuf, __SCPollCommandPacket, _bufnum, _len \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteDoIOMapRead(_conn, _id, _offset, _numbytes, _result) \
  compchk EQ, sizeof(_handle), 1 \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __GenericIOMapPacket \
  replace __SRSSendBuf, __SRSSendBuf, NA, __SCIOMapReadPacket \
  mov __SRSTmpLongVal, _offset \
  flatten __SRSFlattenBuf, __SRSTmpLongVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 2, __SRSTmpBuf \
  mov __SRSTmpWordVal, _offset \
  flatten __SRSFlattenBuf, __SRSTmpWordVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 6, __SRSTmpBuf \
  mov __SRSTmpWordVal, _numbytes \
  flatten __SRSFlattenBuf, __SRSTmpWordVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 8, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex


#ifdef __ENHANCED_FIRMWARE

#define __remoteGetOutputState(_conn, _params, _result) \
  __remoteGenericByteCommand(_conn, __DCGetOutputStatePacket, _params.Port, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGOSR_End##__I__, _result \
  brcmp NEQ, __RRGOSR_End##__I__, __WFRRAvail, 23 \
  unflatten _params, __WFRRUnflattenErr, __WFRRBuffer, _params \
  __RRGOSR_End##__I__: \
  __IncI__

#define __remoteGetInputValues(_conn, _params, _result) \
  __remoteGenericByteCommand(_conn, __DCGetInputValuesPacket, _params.Port, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGIVR_End##__I__, _result \
  brcmp NEQ, __RRGIVR_End##__I__, __WFRRAvail, 14 \
  unflatten _params, __WFRRUnflattenErr, __WFRRBuffer, _params \
  __RRGIVR_End##__I__: \
  __IncI__

#define __remoteGetBatteryLevel(_conn, _value, _result) \
  compchk EQ, sizeof(_value), 2 \
  __connectionSCDCWrite(_conn, __DCGetBatteryLevelPacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGBL_End##__I__, _result \
  brcmp NEQ, __RRGBL_End##__I__, __WFRRAvail, 3 \
  unflatten _value, __WFRRUnflattenErr, __WFRRBuffer, _value \
  __RRGBL_End##__I__: \
  __IncI__

#define __remoteLowspeedGetStatus(_conn, _value, _result) \
  __connectionSCDCWrite(_conn, __DCLSGetStatusPacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRLGS_End##__I__, _result \
  brcmp NEQ, __RRLGS_End##__I__, __WFRRAvail, 2 \
  index _value, __WFRRBuffer, NA \
  __RRLGS_End##__I__: \
  __IncI__

#define __remoteLowspeedRead(_conn, _port, _bread, _data, _result) \
  __remoteGenericByteCommand(_conn, __DCLSReadPacket, _port, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRLR_End##__I__, _result \
  brcmp NEQ, __RRLR_End##__I__, __WFRRAvail, 18 \
  index _bread, __WFRRBuffer, NA \
  arrsubset _data, __WFRRBuffer, 1, _bread \
  __RRLR_End##__I__: \
  __IncI__

#define __remoteGetCurrentProgramName(_conn, _name, _result) \
  __connectionSCDCWrite(_conn, __DCGetCurProgNamePacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGCPN_End##__I__, _result \
  brcmp NEQ, __RRGCPN_End##__I__, __WFRRAvail, 21 \
  mov _name, __WFRRBuffer \
  __RRGCPN_End##__I__: \
  __IncI__

#define __remoteDatalogRead(_conn, _remove, _cnt, _log, _result) \
  __remoteGenericByteCommand(_conn, __DCDatalogReadPacket, _remove, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRDR_End##__I__, _result \
  brcmp NEQ, __RRDR_End##__I__, __WFRRAvail, 62 \
  index _cnt, __WFRRBuffer, NA \
  arrsubset _log, __WFRRBuffer, 1, _cnt \
  __RRDR_End##__I__: \
  __IncI__

#define __remoteGetContactCount(_conn, _cnt, _result) \
  __connectionSCDCWrite(_conn, __DCBTGetContactCntPacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGCTC_End##__I__, _result \
  brcmp NEQ, __RRGCTC_End##__I__, __WFRRAvail, 2 \
  index _cnt, __WFRRBuffer, NA \
  __RRGCTC_End##__I__: \
  __IncI__

#define __remoteGetContactName(_conn, _idx, _name, _result) \
  __remoteGenericByteCommand(_conn, __DCBTGetContactNamePacket, _idx, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGCTN_End##__I__, _result \
  brcmp NEQ, __RRGCTN_End##__I__, __WFRRAvail, 19 \
  mov _name, __WFRRBuffer \
  __RRGCTN_End##__I__: \
  __IncI__

#define __remoteGetConnectionCount(_conn, _cnt, _result) \
  __connectionSCDCWrite(_conn, __DCBTGetConnectCntPacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGCNC_End##__I__, _result \
  brcmp NEQ, __RRGCNC_End##__I__, __WFRRAvail, 2 \
  index _cnt, __WFRRBuffer, NA \
  __RRGCNC_End##__I__: \
  __IncI__

#define __remoteGetConnectionName(_conn, _idx, _name, _result) \
  __remoteGenericByteCommand(_conn, __DCBTGetConnectNamePacket, _idx, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGCNN_End##__I__, _result \
  brcmp NEQ, __RRGCNN_End##__I__, __WFRRAvail, 19 \
  mov _name, __WFRRBuffer \
  __RRGCNN_End##__I__: \
  __IncI__

#define __remoteGetProperty(_conn, _property, _value, _result) \
  mov _value, 0 \
  __remoteGenericByteCommand(_conn, __DCGetPropertyPacket, _property, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGP_End##__I__, _result \
  unflatten _value, __WFRRUnflattenErr, __WFRRBuffer, _value \
  __RRGP_End##__I__: \
  __IncI__

#define __remoteOpenRead(_conn, _filename, _handle, _size, _result) \
  __remoteGenericFilenameCommand(_conn, __SCOpenReadPacket, _filename, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RROR_End##__I__, _result \
  brcmp NEQ, __RROR_End##__I__, __WFRRAvail, 6 \
  index _handle, __WFRRBuffer, NA \
  arrsubset __WFRRTmpBuffer, __WFRRBuffer, 1, 5 \
  unflatten __WFRRTmpSDWord, __WFRRUnflattenErr, __WFRRTmpBuffer, __WFRRTmpSDWord \
  mov _size, __WFRRTmpSDWord \
  __RROR_End##__I__: \
  __IncI__

#define __remoteOpenWrite(_conn, _filename, _size, _handle, _result) \
  __remoteGenericCreateFileCommand(_conn, __SCOpenWritePacket, _filename, _size, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RROW_End##__I__, _result \
  brcmp NEQ, __RROW_End##__I__, __WFRRAvail, 2 \
  index _handle, __WFRRBuffer, NA \
  __RROW_End##__I__: \
  __IncI__

#define __remoteRead(_conn, _handle, _numbytes, _data, _result) \
  mov _result, 1 \
  brcmp GT, __RRRead_End##__J__, _numbytes, 58 \
  __remoteDoRead(_conn, _handle, _numbytes, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  add __WFRRTmpByte, _numbytes, 4 \
  brtst NEQ, __RRRead_End##__J__, _result \
  brcmp NEQ, __RRRead_End##__J__, __WFRRAvail, __WFRRTmpByte \
  index _handle, __WFRRBuffer, NA \
  arrsubset __WFRRTmpBuffer, __WFRRBuffer, 1, 2 \
  arrtostr __WFRRUnflattenBuf, __WFRRTmpBuffer \
  unflatten __WFRRTmpSWord, __WFRRUnflattenErr, __WFRRUnflattenBuf, __WFRRTmpSWord \
  mov _numbytes, __WFRRTmpSWord \
  arrsubset _data, __WFRRBuffer, 2, _numbytes \
  __RRRead_End##__J__: \
  __IncJ__

#define __remoteWrite(_conn, _handle, _numbytes, _data, _result) \
  mov _result, 1 \
  brcmp GT, __RRWrite_End##__J__, _numbytes, 58 \
  __remoteDoWrite(_conn, _handle, _data, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRWrite_End##__J__, _result \
  brcmp NEQ, __RRWrite_End##__J__, __WFRRAvail, 4 \
  index _handle, __WFRRBuffer, NA \
  arrsubset __WFRRTmpBuffer, __WFRRBuffer, 1, 3 \
  unflatten __WFRRTmpSWord, __WFRRUnflattenErr, __WFRRTmpBuffer, __WFRRTmpSWord \
  mov _numbytes, __WFRRTmpSWord \
  __RRWrite_End##__J__: \
  __IncJ__

#define __remoteCloseFile(_conn, _handle, _result) \
  __remoteGenericByteCommand(_conn, __SCClosePacket, _handle, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus

#define __remoteDeleteFile(_conn, _filename, _result) \
  __remoteGenericFilenameCommand(_conn, __SCDeletePacket, _filename, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus

#define __remoteDeleteUserFlash(_conn, _result) \
  __connectionSCDCWrite(_conn, __SCDeleteUserFlashPacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus

#define __remoteFindFirstFile(_conn, _mask, _handle, _name, _size, _result) \
  __remoteGenericFilenameCommand(_conn, __SCFindFirstPacket, _mask, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRFindFirstFile_End##__I__, _result \
  brcmp NEQ, __RRFindFirstFile_End##__I__, __WFRRAvail, 26 \
  index _handle, __WFRRBuffer, NA \
  arrsubset _name, __WFRRBuffer, 1, 20 \
  arrsubset __WFRRTmpBuffer, __WFRRBuffer, 21, 5 \
  unflatten __WFRRTmpSDWord, __WFRRUnflattenErr, __WFRRTmpBuffer, __WFRRTmpSDWord \
  mov _size, __WFRRTmpSDWord \
  __RRFindFirstFile_End##__I__: \
  __IncI__

#define __remoteFindNextFile(_conn, _handle, _name, _size, _result) \
  __remoteGenericByteCommand(_conn, __SCFindNextPacket, _handle, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRFindNextFile_End##__I__, _result \
  brcmp NEQ, __RRFindNextFile_End##__I__, __WFRRAvail, 26 \
  index _handle, __WFRRBuffer, NA \
  arrsubset _name, __WFRRBuffer, 1, 20 \
  arrsubset __WFRRTmpBuffer, __WFRRBuffer, 21, 5 \
  unflatten __WFRRTmpSDWord, __WFRRUnflattenErr, __WFRRTmpBuffer, __WFRRTmpSDWord \
  mov _size, __WFRRTmpSDWord \
  __RRFindNextFile_End##__I__: \
  __IncI__

#define __remoteGetFirmwareVersion(_conn, _pmin, _pmaj, _fmin, _fmaj, _result) \
  __connectionSCDCWrite(_conn, __SCGetFirmwareVerPacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGetFirmwareVersion_End##__I__, _result \
  brcmp NEQ, __RRGetFirmwareVersion_End##__I__, __WFRRAvail, 5 \
  index _pmin, __WFRRBuffer, NA \
  index _pmaj, __WFRRBuffer, 1 \
  index _fmin, __WFRRBuffer, 2 \
  index _fmaj, __WFRRBuffer, 3 \
  __RRGetFirmwareVersion_End##__I__: \
  __IncI__

#define __remoteOpenWriteLinear(_conn, _filename, _size, _handle, _result) \
  __remoteGenericCreateFileCommand(_conn, __SCOpenWriteLinearPacket, _filename, _size, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RROWL_End##__I__, _result \
  brcmp NEQ, __RROWL_End##__I__, __WFRRAvail, 2 \
  index _handle, __WFRRBuffer, NA \
  __RROWL_End##__I__: \
  __IncI__

#define __remoteOpenWriteData(_conn, _filename, _size, _handle, _result) \
  __remoteGenericCreateFileCommand(_conn, __SCOpenWriteDataPacket, _filename, _size, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RROWD_End##__I__, _result \
  brcmp NEQ, __RROWD_End##__I__, __WFRRAvail, 2 \
  index _handle, __WFRRBuffer, NA \
  __RROWD_End##__I__: \
  __IncI__

#define __remoteOpenAppendData(_conn, _filename, _handle, _size, _result) \
  __remoteGenericFilenameCommand(_conn, __SCOpenAppendDataPacket, _filename, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RROAD_End##__I__, _result \
  brcmp NEQ, __RROAD_End##__I__, __WFRRAvail, 6 \
  index _handle, __WFRRBuffer, NA \
  arrsubset __WFRRTmpBuffer, __WFRRBuffer, 1, 5 \
  unflatten __WFRRTmpSDWord, __WFRRUnflattenErr, __WFRRTmpBuffer, __WFRRTmpSDWord \
  mov _size, __WFRRTmpSDWord \
  __RROAD_End##__I__: \
  __IncI__

#define __remoteGetDeviceInfo(_conn, _name, _btaddr, _btsignal, _freemem, _result) \
  __connectionSCDCWrite(_conn, __SCGetDeviceInfoPacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGetDeviceInfo_End##__I__, _result \
  brcmp NEQ, __RRGetDeviceInfo_End##__I__, __WFRRAvail, 31 \
  arrsubset _name, __WFRRBuffer, NA, 15 \
  arrsubset _btaddr, __WFRRBuffer, 15, 7 \
  arrsubset _btsignal, __WFRRBuffer, 22, 4 \
  arrsubset __WFRRTmpBuffer, __WFRRBuffer, 26, 5 \
  unflatten __WFRRTmpSDWord, __WFRRUnflattenErr, __WFRRTmpBuffer, __WFRRTmpSDWord \
  mov _freemem, __WFRRTmpSDWord \
  __RRGetDeviceInfo_End##__I__: \
  __IncI__

#define __remotePollCommandLength(_conn, _bufnum, _length, _result) \
  __remoteGenericByteCommand(_conn, __SCPollCommandLenPacket, _bufnum, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRPollCommandLength_End##__I__, _result \
  brcmp NEQ, __RRPollCommandLength_End##__I__, __WFRRAvail, 3 \
  index _length, __WFRRBuffer, 1 \
  __RRPollCommandLength_End##__I__: \
  __IncI__

#define __remotePollCommand(_conn, _bufnum, _len, _data, _result) \
  mov _result, 1 \
  brcmp GT, __RRPollCommand_End##__J__, _len, 58 \
  __remoteDoPollCommand(_conn, _bufnum, _len, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  add __WFRRTmpByte, _len, 3 \
  brtst NEQ, __RRPollCommand_End##__J__, _result \
  brcmp NEQ, __RRPollCommand_End##__J__, __WFRRAvail, __WFRRTmpByte \
  index _len, __WFRRBuffer, 1 \
  arrsubset _data, __WFRRBuffer, 2, _len \
  __RRPollCommand_End##__J__: \
  __IncJ__

#define __remoteIOMapRead(_conn, _id, _offset, _numbytes, _data, _result) \
  mov _result, 1 \
  brcmp GT, __RRIOMapRead_End##__J__, _numbytes, 58 \
  __remoteDoIOMapRead(_conn, _id, _offset, _numbytes, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  add __WFRRTmpByte, _numbytes, 7 \
  brtst NEQ, __RRIOMapRead_End##__J__, _result \
  brcmp NEQ, __RRIOMapRead_End##__J__, __WFRRAvail, __WFRRTmpByte \
  arrsubset __WFRRTmpBuffer, __WFRRBuffer, 4, 2 \
  arrtostr __WFRRUnflattenBuf, __WFRRTmpBuffer \
  unflatten __WFRRTmpSWord, __WFRRUnflattenErr, __WFRRUnflattenBuf, __WFRRTmpSWord \
  mov _numbytes, __WFRRTmpSWord \
  arrsubset _data, __WFRRBuffer, 6, _numbytes \
  __RRIOMapRead_End##__J__: \
  __IncJ__

#define __remoteGetBluetoothAddress(_conn, _btaddr, _result) \
  __connectionSCDCWrite(_conn, __SCBTGetAddressPacket, _result) \
  call __DoWaitForRemoteResponse \
  mov _result, __WFRRStatus \
  brtst NEQ, __RRGetBluetoothAddress_End##__I__, _result \
  brcmp NEQ, __RRGetBluetoothAddress_End##__I__, __WFRRAvail, 8 \
  arrsubset _btaddr, __WFRRBuffer, NA, 7 \
  __RRGetBluetoothAddress_End##__I__: \
  __IncI__

#define __remoteRenameFile(_conn, _oldname, _newname, _result) \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __SCRenameFilePacket \
  strsubset __SRSTmpBuf, _oldname, NA, 19 \
  replace __SRSSendBuf, __SRSSendBuf, 2, __SRSTmpBuf \
  strsubset __SRSTmpBuf, _newname, NA, 19 \
  replace __SRSSendBuf, __SRSSendBuf, 22, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#else

#define __remoteGetOutputState(_conn, _port, _result) __remoteGenericByteCommand(_conn, __DCGetOutputStatePacket, _port, _result)
#define __remoteGetInputValues(_conn, _port, _result) __remoteGenericByteCommand(_conn, __DCGetInputValuesPacket, _port, _result)
#define __remoteGetBatteryLevel(_conn, _result) __connectionSCDCWrite(_conn, __DCGetBatteryLevelPacket, _result)
#define __remoteLowspeedGetStatus(_conn, _result) __connectionSCDCWrite(_conn, __DCLSGetStatusPacket, _result)
#define __remoteLowspeedRead(_conn, _port, _result) __remoteGenericByteCommand(_conn, __DCLSReadPacket, _port, _result)
#define __remoteGetCurrentProgramName(_conn, _result) __connectionSCDCWrite(_conn, __DCGetCurProgNamePacket, _result)
#define __remoteDatalogRead(_conn, _remove, _result) __remoteGenericByteCommand(_conn, __DCDatalogReadPacket, _remove, _result)
#define __remoteGetContactCount(_conn, _result) __connectionSCDCWrite(_conn, __DCBTGetContactCntPacket, _result)
#define __remoteGetContactName(_conn, _idx, _result) __remoteGenericByteCommand(_conn, __DCBTGetContactNamePacket, _idx, _result)
#define __remoteGetConnectionCount(_conn, _result) __connectionSCDCWrite(_conn, __DCBTGetConnectCntPacket, _result)
#define __remoteGetConnectionName(_conn, _idx, _result) __remoteGenericByteCommand(_conn, __DCBTGetConnectNamePacket, _idx, _result)
#define __remoteGetProperty(_conn, _property, _result) __remoteGenericByteCommand(_conn, __DCGetPropertyPacket, _property, _result)


#define __remoteOpenRead(_conn, _filename, _result) __remoteGenericFilenameCommand(_conn, __SCOpenReadPacket, _filename, _result)
#define __remoteOpenWrite(_conn, _filename, _size, _result) __remoteGenericCreateFileCommand(_conn, __SCOpenWritePacket, _filename, _size, _result)
#define __remoteRead(_conn, _handle, _numbytes, _result) __remoteDoRead(_conn, _handle, _numbytes, _result)
#define __remoteWrite(_conn, _handle, _data, _result) __remoteDoWrite(_conn, _handle, _data, _result)
#define __remoteCloseFile(_conn, _handle, _result) __remoteGenericByteCommand(_conn, __SCClosePacket, _handle, _result)
#define __remoteDeleteFile(_conn, _filename, _result) __remoteGenericFilenameCommand(_conn, __SCDeletePacket, _filename, _result)
#define __remoteFindFirstFile(_conn, _mask, _result) __remoteGenericFilenameCommand(_conn, __SCFindFirstPacket, _mask, _result)
#define __remoteFindNextFile(_conn, _handle, _result) __remoteGenericByteCommand(_conn, __SCFindNextPacket, _handle, _result)
#define __remoteOpenWriteLinear(_conn, _filename, _size, _result) __remoteGenericCreateFileCommand(_conn, __SCOpenWriteLinearPacket, _filename, _size, _result)
#define __remoteOpenWriteData(_conn, _filename, _size, _result) __remoteGenericCreateFileCommand(_conn, __SCOpenWriteDataPacket, _filename, _size, _result)
#define __remoteOpenAppendData(_conn, _filename, _result) __remoteGenericFilenameCommand(_conn, __SCOpenAppendDataPacket, _filename, _result)
#define __remotePollCommandLength(_conn, _bufnum, _result) __remoteGenericByteCommand(_conn, __SCPollCommandLenPacket, _bufnum, _result)
#define __remotePollCommand(_conn, _bufnum, _len, _result) __remoteDoPollCommand(_conn, _bufnum, _len, _result)
#define __remoteIOMapRead(_conn, _id, _offset, _numbytes, _result) __remoteDoIOMapRead(_conn, _id, _offset, _numbytes, _result)

#endif

#define __remoteDatalogSetTimes(_conn, _synctime, _result) \
  acquire __RemoteMutex \
  mov __SRSTmpLongVal, _synctime \
  flatten __SRSFlattenBuf, __SRSTmpLongVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  arrbuild __SRSSendBuf, __DCDatalogSetTimesPacket, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteSetProperty(_conn, _prop, _value, _result) \
  compchk EQ, sizeof(_prop), 1 \
  acquire __RemoteMutex \
  flatten __SRSFlattenBuf, _value \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  arrbuild __SRSSendBuf, __DCSetPropertyPacket, _prop, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteLowspeedWrite(_conn, _port, _txlen, _rxlen, _data, _result) \
  compchk EQ, sizeof(_port), 1 \
  compchk EQ, sizeof(_txlen), 1 \
  compchk EQ, sizeof(_rxlen), 1 \
  acquire __RemoteMutex \
  arrbuild __SRSSendBuf, __DCLSWritePacket, _port, _txlen, _rxlen, _data \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteIOMapWriteValue(_conn, _id, _offset, _value, _result) \
  compchk EQ, sizeof(_handle), 1 \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __GenericIOMapPacket \
  replace __SRSSendBuf, __SRSSendBuf, NA, __SCIOMapWritePacket \
  mov __SRSTmpLongVal, _offset \
  flatten __SRSFlattenBuf, __SRSTmpLongVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 2, __SRSTmpBuf \
  mov __SRSTmpWordVal, _offset \
  flatten __SRSFlattenBuf, __SRSTmpWordVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 6, __SRSTmpBuf \
  set __SRSTmpWordVal, sizeof(_value) \
  flatten __SRSFlattenBuf, __SRSTmpWordVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 8, __SRSTmpBuf \
  flatten __SRSFlattenBuf, _value \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  mov __SRSFlattenBuf, __SRSSendBuf \
  arrbuild __SRSSendBuf, __SRSFlattenBuf, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteIOMapWriteBytes(_conn, _id, _offset, _data, _result) \
  compchk EQ, sizeof(_handle), 1 \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __GenericIOMapPacket \
  replace __SRSSendBuf, __SRSSendBuf, NA, __SCIOMapWritePacket \
  mov __SRSTmpLongVal, _offset \
  flatten __SRSFlattenBuf, __SRSTmpLongVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 2, __SRSTmpBuf \
  mov __SRSTmpWordVal, _offset \
  flatten __SRSFlattenBuf, __SRSTmpWordVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 6, __SRSTmpBuf \
  arrsize __SRSTmpWordVal, _data \
  flatten __SRSFlattenBuf, __SRSTmpWordVal \
  strtoarr __SRSTmpBuf, __SRSFlattenBuf \
  replace __SRSSendBuf, __SRSSendBuf, 8, __SRSTmpBuf \
  mov __SRSFlattenBuf, __SRSSendBuf \
  arrbuild __SRSSendBuf, __SRSFlattenBuf, _data \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#define __remoteSetBrickName(_conn, _name, _result) \
  acquire __RemoteMutex \
  mov __SRSSendBuf, __SCSetBrickNamePacket \
  strsubset __SRSTmpBuf, _name, NA, 15 \
  replace __SRSSendBuf, __SRSSendBuf, 2, __SRSTmpBuf \
  __connectionSCDCWrite(_conn, __SRSSendBuf, _result) \
  release __RemoteMutex

#if defined(__ENHANCED_FIRMWARE)

#define __SQRT(_X,_R) sqrt _R, _X
#define __SIN(_X,_R) sin _R, _X
#define __COS(_X,_R) cos _R, _X
#define __ASIN(_X,_R) asin _R, _X
#define __ACOS(_X,_R) acos _R, _X

#else

#if (__FIRMWARE_VERSION > 107)
#define __SQRT(_X,_R) sqrt _R, _X
#else
#define __SQRT(_X,_R) \
  acquire __sqrtMutex \
  mov __sqrtValue, _X \
  call __sqrtSub \
  mov _R, __sqrtResult \
  release __sqrtMutex
#endif

#define __SIN(_X,_R) \
  acquire __sinMutex \
  mov __sinValue, _X \
  call __sinSub \
  mov _R, __sinResult \
  release __sinMutex

#define __COS(_X,_R) \
  acquire __sinMutex \
  mov __sinValue, _X \
  add __sinValue, __sinValue, 90 \
  call __sinSub \
  mov _R, __sinResult \
  release __sinMutex

#define __ASIN(_X,_R) \
  acquire __asinMutex \
  mov __asinValue, _X \
  call __asinSub \
  mov _R, __asinResult \
  release __asinMutex

#define __ACOS(_X,_R) \
  acquire __asinMutex \
  mov __asinValue, _X \
  call __asinSub \
  sub _R, 90, __asinResult \
  release __asinMutex

#endif

// data segment
dseg segment

  // sin/cos related tables
  __sin_table sword[] 0,2,3,5,7,9,10,12,14,16,17,19,21,22,24,26,28,29,31,33,34,36,37,39,41,42,44,45,47,48,50,52,53,54,56,57,59,60,62,63,64,66,67,68,69,71,72,73,74,75,77,78,79,80,81,82,83,84,85,86,87,87,88,89,90,91,91,92,93,93,94,95,95,96,96,97,97,97,98,98,98,99,99,99,99,100,100,100,100,100,100
  __asin_table sdword[] 0,1,1,2,2,3,3,4,5,5,6,6,7,7,8,9,9,10,10,11,12,12,13,13,14,14,15,16,16,17,17,18,19,19,20,20,21,22,22,23,24,24,25,25,26,27,27,28,29,29,30,31,31,32,33,33,34,35,35,36,37,38,38,39,40,41,41,42,43,44,44,45,46,47,48,49,49,50,51,52,53,54,55,56,57,58,59,60,62,63,64,66,67,68,70,72,74,76,79,82,90

  // mutexes
  __sqrtMutex mutex
  __sinMutex mutex
  __asinMutex mutex

  // sqrt variables
  __sqrtPairs byte[]  0, 0, 0, 0, 0, 0
  __sqrtPaircount sbyte
  __sqrtValue dword
  __sqrtResult dword
  __sqrtP dword
  __sqrtR dword
  __sqrtM dword
  __sqrtN dword

  // sin variables
  __sinValue sdword
  __sinResult sdword
  __sinValueNeg byte

  // asin variables
  __asinValue sdword
  __asinResult sdword
dseg ends

subroutine __sinSub
  // move the sin to + angle
  set __sinValueNeg, FALSE
  brtst GTEQ, __sinValuePos, __sinValue

  neg __sinValue, __sinValue
  set __sinValueNeg, TRUE

__sinValuePos:
  // get the 360 mod and check which quarter the sin falls into
  mod __sinValue, __sinValue, 360
  brcmp GT, __sinQ4, __sinValue, 270
  brcmp GT, __sinQ3, __sinValue, 180
  brcmp GT, __sinQ2, __sinValue, 90

  // 1st quarter
  index __sinResult, __sin_table, __sinValue
  jmp __sinAlmostDone

__sinQ2:
  // 2nd quarter
  sub __sinValue, 180, __sinValue
  index __sinResult, __sin_table, __sinValue
  jmp __sinAlmostDone

__sinQ3:
  // 3rd quarter
  sub __sinValue, __sinValue, 180
  index __sinResult, __sin_table, __sinValue
  neg __sinResult, __sinResult
  jmp __sinAlmostDone

__sinQ4:
  // 4th quarter
  sub __sinValue, 360, __sinValue
  index __sinResult, __sin_table, __sinValue
  neg __sinResult, __sinResult
  jmp __sinAlmostDone

__sinAlmostDone:

  // if the incoming angle was <0, need to negate the result because sin(-x)=-sin(x)
  brcmp EQ, __sinDone, __sinValueNeg, FALSE
  neg __sinResult, __sinResult

__sinDone:
  return
ends


subroutine __asinSub
  // input sin value should be -1 -> 1
  brcmp GT, __asinValueBad, __asinValue, 100
  brcmp LT, __asinValueBad, __asinValue, -100

  // check if it's 0->-1
  brtst LT, __asinValueNeg, __asinValue

  // value 0->1
  index __asinResult, __asin_table, __asinValue
  jmp __asinDone

__asinValueNeg:
  // value 0->-1
  neg __asinValue, __asinValue
  index __asinResult, __asin_table, __asinValue
  neg __asinResult, __asinResult
  jmp __asinDone

__asinValueBad:
  set __asinResult, 101

__asinDone:
  return
ends

subroutine __sqrtSub
  // if the input value is 0, we're done
  set __sqrtResult, 0
  brtst EQ, __sqrtDone, __sqrtValue

  // init the paircount array
  mov __sqrtPaircount, 0
  replace __sqrtPairs, __sqrtPairs, 0, 0
  replace __sqrtPairs, __sqrtPairs, 1, 0
  replace __sqrtPairs, __sqrtPairs, 2, 0
  replace __sqrtPairs, __sqrtPairs, 3, 0
  replace __sqrtPairs, __sqrtPairs, 4, 0

__sqrtPairsLoop:
  brtst EQ, __sqrtPairsOK, __sqrtValue
  mod __sqrtN, __sqrtValue, 100
  replace __sqrtPairs, __sqrtPairs, __sqrtPaircount, __sqrtN
  div __sqrtValue, __sqrtValue, 100
  add __sqrtPaircount, __sqrtPaircount, 1

  jmp __sqrtPairsLoop

__sqrtPairsOK:
  // get the leftmost pair
  index __sqrtP, __sqrtPairs, __sqrtPaircount
  set __sqrtResult, 1

  // find the sqrt for the leftmost pair (1-9), if 0 we're not here!
__sqrtFirstLoop:
  mul __sqrtN, __sqrtResult, __sqrtResult
  brcmp GT, __sqrtFirstOK, __sqrtN, __sqrtP
  add __sqrtResult, __sqrtResult, 1
  jmp __sqrtFirstLoop

__sqrtFirstOK:
  sub __sqrtResult, __sqrtResult, 1
  // got the sqrt of the first pair in sqrtResult

  mul __sqrtN, __sqrtResult, __sqrtResult
  sub __sqrtM, __sqrtP, __sqrtN

  // in loop we get 1 new digit in sqrtResult for each pair
__sqrtBigLoop:
  sub __sqrtPaircount, __sqrtPaircount, 1

  brtst LT, __sqrtDone, __sqrtPaircount

  mul __sqrtM, __sqrtM, 100
  index __sqrtP, __sqrtPairs, __sqrtPaircount
  add __sqrtM, __sqrtM, __sqrtP

  // find the next digit
  set __sqrtN, 1

__sqrtDigitLoop:
  mul __sqrtR, __sqrtResult, 20
  add __sqrtR, __sqrtR, __sqrtN
  mul __sqrtR, __sqrtR, __sqrtN

  brcmp GT, __sqrtDigitDone, __sqrtR, __sqrtM

  add __sqrtN, __sqrtN, 1
  jmp __sqrtDigitLoop

__sqrtDigitDone:
  sub __sqrtN, __sqrtN, 1
  // got the next digit

  // calculate the new value to continue with
  mul __sqrtR, __sqrtResult, 20
  add __sqrtR, __sqrtR, __sqrtN
  mul __sqrtR, __sqrtR, __sqrtN
  sub __sqrtM, __sqrtM, __sqrtR

  // add the new digit to the end of the result in sqrtResult
  mul __sqrtResult, __sqrtResult, 10
  add __sqrtResult, __sqrtResult, __sqrtN

  jmp __sqrtBigLoop

__sqrtDone:
  return
ends

dseg segment
  __bcd2DecTens byte
  __bcd2DecOnes byte
  __bcd2DecMutex mutex
dseg ends

#define __bcd2dec(_bcd, _result) \
  acquire __bcd2DecMutex \
  div __bcd2DecTens, _bcd, 16 \
  mod __bcd2DecOnes, _bcd, 16 \
  mul _result, __bcd2DecTens, 10 \
  add _result, _result, __bcd2DecOnes \
  release __bcd2DecMutex

#define __SetSensorHTEOPD(_port, _bStd) \
  setin IN_TYPE_LIGHT_ACTIVE+_bStd, _port, TypeField \
  setin IN_MODE_RAW, _port, InputModeField \
  __ResetSensor(_port)

#define __ReadSensorHTEOPD(_port, _val) \
  getin _val, _port, RawValueField \
  sub _val, 1023, _val

#define __SetSensorHTGyro(_port) \
  setin IN_TYPE_LIGHT_INACTIVE, _port, TypeField \
  setin IN_MODE_RAW, _port, InputModeField \
  __ResetSensor(_port)

#define __ReadSensorHTGyro(_port, _offset, _val) \
  getin _val, _port, RawValueField \
  sub _val, _val, 600 \
  sub _val, _val, _offset

#define __ReadSensorHTMagnet(_port, _offset, _val) __ReadSensorHTGyro(_port, _offset, _val)
#define __SetSensorHTMagnet(_port) __SetSensorHTGyro(_port)

dseg segment
  __HTMplexRaw word
  __HTMplexScaled dword
  __HTMplexMutex mutex
dseg ends

#define __ReadSensorHTTouchMultiplexer(_p, _t1, _t2, _t3, _t4) \
  acquire __HTMplexMutex \
  getin __HTMplexRaw, _p, RawValueField \
  mul __HTMplexScaled, __HTMplexRaw, 339 \
  sub __HTMplexScaled, 346797, __HTMplexScaled \
  div __HTMplexScaled, __HTMplexScaled, __HTMplexRaw \
  add __HTMplexScaled, __HTMplexScaled, 5 \
  div __HTMplexScaled, __HTMplexScaled, 10 \
  and _t4, __HTMplexScaled, 8 \
  and _t3, __HTMplexScaled, 4 \
  and _t2, __HTMplexScaled, 2 \
  and _t1, __HTMplexScaled, 1 \
  release __HTMplexMutex

dseg segment
  __HTPFStartIRLink  byte[] 0x02, 0x42
  __HTPFCommitIRLink byte[] 0x0B, 0x02, 0x01
  __HTPFBits byte[]
  __HTPFI2CBuf byte[]
  __HTPFI sword
  __HTPFJ sword
  __HTPFValue byte
  __HTPFDx byte
  __PFBytes byte[]
  __PFMutex mutex
  __PFNx byte
  __PFPowerFuncMode byte
  __PFTmp byte
  __PFNibbles byte[] 0x00, 0x00, 0x00, 0x00
  __PF_p1 byte
  __PF_p2 byte
  __PF_p3 byte
  __PF_p4 byte
  __PF_p5 byte
  __PFIdx byte
  __PFChToggle byte
  __PFToggles byte[] 0x00, 0x00, 0x00, 0x00
  __RCToggles byte[] 0x00, 0x00, 0x00, 0x00
dseg ends

subroutine __PFApplyToggle
  mov __PFIdx, __PF_p1
  index __PFChToggle, __PFToggles, __PFIdx
  add __PF_p1, __PF_p1, __PFChToggle
  return
ends

subroutine __PFUpdateToggle
  xor __PFChToggle, __PFChToggle, 8
  replace __PFToggles, __PFToggles, __PFIdx, __PFChToggle
  return
ends

subroutine __RCApplyToggle
  mov __PFIdx, __PF_p1
  index __PFChToggle, __RCToggles, __PFIdx
  add __PF_p1, __PF_p1, __PFChToggle
  return
ends

subroutine __RCUpdateToggle
  xor __PFChToggle, __PFChToggle, 8
  replace __RCToggles, __RCToggles, __PFIdx, __PFChToggle
  return
ends

subroutine __PFCalcChecksum
  // RCTrain or Power Function
  brtst EQ, __PFUseIRTrainMode, __PFPowerFuncMode
  index __PFNx, __PFNibbles, NA
  xor __PFTmp, 0xF, __PFNx
  index __PFNx, __PFNibbles, 1
  xor __PFTmp, __PFTmp, __PFNx
  index __PFNx, __PFNibbles, 2
  xor __PFTmp, __PFTmp, __PFNx
  jmp __PFEndPowerFuncModeCheck
__PFUseIRTrainMode:
  index __PFNx, __PFNibbles, NA
  sub __PFTmp, 0xF, __PFNx
  index __PFNx, __PFNibbles, 1
  sub __PFTmp, __PFTmp, __PFNx
  index __PFNx, __PFNibbles, 2
  sub __PFTmp, __PFTmp, __PFNx
__PFEndPowerFuncModeCheck:
  replace __PFNibbles, __PFNibbles, 3, __PFTmp
  return
ends

subroutine __PFComboDirectSub
  replace __PFNibbles, __PFNibbles, NA, __PF_p1
  replace __PFNibbles, __PFNibbles, 1, PF_MODE_COMBO_DIRECT
  mul __PF_p3, __PF_p3, 4
  add __PF_p3, __PF_p3, __PF_p2
  replace __PFNibbles, __PFNibbles, 2, __PF_p3
  return
ends

subroutine __PFSinglePinSub
  call __PFApplyToggle
  replace __PFNibbles, __PFNibbles, NA, __PF_p1
  set __PF_p1, PF_MODE_SINGLE_PIN_TIME
  brtst EQ, __PFEndIfSPContinuous, __PF_p5
  set __PF_p1, PF_MODE_SINGLE_PIN_CONT
__PFEndIfSPContinuous:
  replace __PFNibbles, __PFNibbles, 1, __PF_p1
  mul __PF_p2, __PF_p2, 8
  mul __PF_p3, __PF_p3, 4
  add __PF_p2, __PF_p2, __PF_p3
  add __PF_p2, __PF_p2, __PF_p4
  replace __PFNibbles, __PFNibbles, 2, __PF_p2
  call __PFUpdateToggle
  return
ends

subroutine __PFSingleOutputSub
  call __PFApplyToggle
  replace __PFNibbles, __PFNibbles, NA, __PF_p1
  set __PF_p1, PF_MODE_SINGLE_OUTPUT_PWM
  brtst EQ, __PFEndIfSOCst, __PF_p4
  set __PF_p1, PF_MODE_SINGLE_OUTPUT_CST
__PFEndIfSOCst:
  add __PF_p1, __PF_p1, __PF_p2
  replace __PFNibbles, __PFNibbles, 1, __PF_p1
  replace __PFNibbles, __PFNibbles, 2, __PF_p3
  call __PFUpdateToggle
  return
ends

subroutine __PFComboPWMSub
  add __PF_p1, __PF_p1, PF_MODE_COMBO_PWM
  replace __PFNibbles, __PFNibbles, NA, __PF_p1
  replace __PFNibbles, __PFNibbles, 1, __PF_p3
  replace __PFNibbles, __PFNibbles, 2, __PF_p2
  return
ends

subroutine __PFTrainSub
  call __PFApplyToggle
  replace __PFNibbles, __PFNibbles, NA, __PF_p1
  replace __PFNibbles, __PFNibbles, 1, PF_MODE_TRAIN
  replace __PFNibbles, __PFNibbles, 2, __PF_p2
  call __PFUpdateToggle
  return
ends

subroutine __RCTrainSub
  call __RCApplyToggle
  replace __PFNibbles, __PFNibbles, NA, __PF_p1
  replace __PFNibbles, __PFNibbles, 1, PF_MODE_TRAIN
  replace __PFNibbles, __PFNibbles, 2, __PF_p2
  call __RCUpdateToggle
  return
ends

subroutine __PFRawOutputSub
  replace __PFNibbles, __PFNibbles, NA, __PF_p1
  replace __PFNibbles, __PFNibbles, 1, __PF_p2
  replace __PFNibbles, __PFNibbles, 2, __PF_p3
  return
ends

subroutine __HTPowerFunctionCalcBits
  call __PFCalcChecksum
  brtst EQ, __HTPFUseIRTrainMode, __PFPowerFuncMode
  set __HTPFDx, 3
  jmp __HTPFEndPowerFuncModeCheck
__HTPFUseIRTrainMode:
  set __HTPFDx, 2
__HTPFEndPowerFuncModeCheck:
  arrinit __HTPFBits, 0, 88
  arrinit __PFBytes, 0, 11
  // fill in the bits
  set __PFIdx, 0
  replace __HTPFBits, __HTPFBits, __PFIdx, 1
  add __PFIdx, __PFIdx, 8
  // check bits in n0..n3
  set __HTPFI, 0
__lblCalcBitsForIBitSet:
  index __PFNx, __PFNibbles, __HTPFI
  set __HTPFJ, 3
__lblCalcBitsForJBitSet:
  replace __HTPFBits, __HTPFBits, __PFIdx, 1
  shl __PFTmp, 1, __HTPFJ
  and __HTPFValue, __PFNx, __PFTmp
  add __PFIdx, __PFIdx, __HTPFDx
  brcmp NEQ, __lblCalcBitsFoundZero, __HTPFValue, __PFTmp
  add __PFIdx, __PFIdx, 2
__lblCalcBitsFoundZero:
  sub __HTPFJ, __HTPFJ, 1
  brtst GTEQ, __lblCalcBitsForJBitSet, __HTPFJ
  add __HTPFI, __HTPFI, 1
  brcmp LTEQ, __lblCalcBitsForIBitSet, __HTPFI, 3
  replace __HTPFBits, __HTPFBits, __PFIdx, 1
  // now calculate bytes
  set __HTPFI, 0
__lblCalcBitsWhileIByteCalc:
  set __HTPFValue, 0
  set __HTPFJ, 0
__lblCalcBitsForJByteCalc:
  index __PFTmp, __HTPFBits, __HTPFI
  add __HTPFValue, __HTPFValue, __PFTmp
  brcmp GTEQ, __lblCalcBitsByteCalcLastBit, __HTPFJ, 7
  mul __HTPFValue, __HTPFValue, 2
__lblCalcBitsByteCalcLastBit:
  add __HTPFI, __HTPFI, 1
  add __HTPFJ, __HTPFJ, 1
  brcmp LTEQ, __lblCalcBitsForJByteCalc, __HTPFJ, 7
  div __PFIdx, __HTPFI, 8
  sub __PFIdx, __PFIdx, 1
  replace __PFBytes, __PFBytes, __PFIdx, __HTPFValue
  brcmp LT, __lblCalcBitsWhileIByteCalc, __HTPFI, 88
  // set IRLink mode to either PF or IRTrain
  sub __HTPFDx, __HTPFDx, 1
  replace __HTPFCommitIRLink, __HTPFCommitIRLink, 1, __HTPFDx
  // build i2c buffer
  arrbuild __HTPFI2CBuf, __HTPFStartIRLink, __PFBytes, __HTPFCommitIRLink
  return
ends

#define __HTPFComboDirect(_port, _channel, _outa, _outb, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _outa, 4 \
  mod __PF_p3, _outb, 4 \
  call __PFComboDirectSub \
  set __PFPowerFuncMode, TRUE \
  call __HTPowerFunctionCalcBits \
  __lowspeedWrite(_port, 0, __HTPFI2CBuf, _result) \
  release __PFMutex

#define __HTPFSinglePin(_port, _channel, _out, _pin, _func, _cont, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _out, 2 \
  mod __PF_p3, _pin, 2 \
  mod __PF_p4, _func, 4 \
  set __PF_p5, _cont \
  call __PFSinglePinSub \
  set __PFPowerFuncMode, TRUE \
  call __HTPowerFunctionCalcBits \
  __lowspeedWrite(_port, 0, __HTPFI2CBuf, _result) \
  release __PFMutex

#define __HTPFSingleOutput(_port, _channel, _out, _func, _cst, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _out, 2 \
  mod __PF_p3, _func, 16 \
  set __PF_p4, _cst \
  call __PFSingleOutputSub \
  set __PFPowerFuncMode, TRUE \
  call __HTPowerFunctionCalcBits \
  __lowspeedWrite(_port, 0, __HTPFI2CBuf, _result) \
  release __PFMutex

#define __HTPFComboPWM(_port, _channel, _outa, _outb, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _outa, 16 \
  mod __PF_p3, _outb, 16 \
  call __PFComboPWMSub \
  set __PFPowerFuncMode, TRUE \
  call __HTPowerFunctionCalcBits \
  __lowspeedWrite(_port, 0, __HTPFI2CBuf, _result) \
  release __PFMutex

#define __HTIRTrain(_port, _channel, _func, _PFMode, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _func, 5 \
  compif EQ, _PFMode, TRUE \
  call __PFTrainSub \
  compelse \
  call __RCTrainSub \
  compend \
  set __PFPowerFuncMode, _PFMode \
  call __HTPowerFunctionCalcBits \
  __lowspeedWrite(_port, 0, __HTPFI2CBuf, _result) \
  release __PFMutex

#define __HTPFRawOutput(_port, _nibble0, _nibble1, _nibble2, _result) \
  acquire __PFMutex \
  mod __PF_p1, _nibble0, 16 \
  mod __PF_p2, _nibble1, 16 \
  mod __PF_p3, _nibble2, 16 \
  call __PFRawOutputSub \
  set __PFPowerFuncMode, TRUE \
  call __HTPowerFunctionCalcBits \
  __lowspeedWrite(_port, 0, __HTPFI2CBuf, _result) \
  release __PFMutex

#define __HTPFRepeatLastCommand(_port, _count, _delay, _result) \
  acquire __PFMutex \
  mov __PF_p1, _count \
  compif EQ, isconst(_port), FALSE \
  acquire __CLSWMutex0 \
  acquire __CLSWMutex1 \
  acquire __CLSWMutex2 \
  acquire __CLSWMutex3 \
  mov __CLSWArgs0.Buffer, __HTPFI2CBuf \
  release __PFMutex \
  or __CLSWArgs0.Port, _port, __LSWriteOptionsVar \
  mov __CLSWArgs0.ReturnLen, 0 \
  __HTPFRepeatLoop##__I__: \
  syscall CommLSWrite, __CLSWArgs0 \
  waitv _delay \
  sub __PF_p1, __PF_p1, 1 \
  brtst GT, __HTPFRepeatLoop##__I__, __PF_p1 \
  mov _result, __CLSWArgs0.Result \
  release __CLSWMutex0 \
  release __CLSWMutex1 \
  release __CLSWMutex2 \
  release __CLSWMutex3 \
  __IncI__ \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __CLSWMutex##_port \
  mov __CLSWArgs##_port.Buffer, __HTPFI2CBuf \
  release __PFMutex \
  or __CLSWArgs##_port.Port, _port, __LSWriteOptions##_port \
  mov __CLSWArgs##_port.ReturnLen, 0 \
  __HTPFRepeatLoop##__I__: \
  syscall CommLSWrite, __CLSWArgs##_port \
  waitv _delay \
  sub __PF_p1, __PF_p1, 1 \
  brtst GT, __HTPFRepeatLoop##__I__, __PF_p1 \
  mov _result, __CLSWArgs##_port.Result \
  release __CLSWMutex##_port \
  __IncI__ \
  compend

dseg segment

TRCXCommand struct
 Port byte
 Address byte
 ResponseBytes byte
 Command byte[]
 Response byte[]
TRCXCommand ends

  __gRCXCmd TRCXCommand
  __RCXCmdMutex mutex

dseg ends

subroutine __HTRCXCommandSub
  dseg segment
    __RCSToggle byte
    __RCSI byte
    __RCSInCmd byte[]
    __RCSCmdBytes sbyte
    __RCSCmd byte
    __RCSCSum byte
    __RCSMsgBufSize byte
    __RCSTotalBytes byte
    __RCSTmpByte byte
    __RCSTmpByte2 byte
    __RCSResult byte
    __RCSHeaderMsg byte[] 0x02, 0x4a, 0x55, 0xff, 0x00, 0x03, 0x00, 0x01
  dseg ends
  arrsize __RCSCmdBytes, __gRCXCmd.Command
  index __RCSCmd, __gRCXCmd.Command, NA
  set __RCSCSum, 0

  replace __RCSHeaderMsg, __RCSHeaderMsg, NA, __gRCXCmd.Address
  // send the IR message
  __lowspeedWrite(__gRCXCmd.Port, 0, __RCSHeaderMsg, __RCSTmpByte)
  wait 12

  // build rest of the message
  set __RCSMsgBufSize, 2
  mul __RCSMsgBufSize, __RCSMsgBufSize, __RCSCmdBytes
  add __RCSMsgBufSize, __RCSMsgBufSize, 7
  add __RCSTotalBytes, __RCSMsgBufSize, __gRCXCmd.ResponseBytes

  arrinit __RCSInCmd, 0, __RCSMsgBufSize
  replace __RCSInCmd, __RCSInCmd, NA, __gRCXCmd.Address
  set __RCSTmpByte, 2
  mul __RCSTmpByte, __RCSTmpByte, __RCSCmdBytes
  sub __RCSTmpByte, 0x4b, __RCSTmpByte
  replace __RCSInCmd, __RCSInCmd, 1, __RCSTmpByte

  // put cmd and ~cmd into msg
  or __RCSTmpByte, __RCSCmd, __RCSToggle
  replace __RCSInCmd, __RCSInCmd, 2, __RCSTmpByte
  mov __RCSCSum, __RCSTmpByte
  sub __RCSTmpByte, 0xFF, __RCSTmpByte
  replace __RCSInCmd, __RCSInCmd, 3, __RCSTmpByte

  set __RCSI, 0
  xor __RCSToggle, __RCSToggle, 8

  brcmp LTEQ, __RCSEndWhileILTCmdBytes, __RCSCmdBytes, 1

__RCSWhileILTCmdBytes:
  sub __RCSTmpByte, __RCSCmdBytes, 1
  brcmp GTEQ, __RCSEndWhileILTCmdBytes, __RCSI, __RCSTmpByte
  add __RCSTmpByte, __RCSI, 1
  index __RCSTmpByte2, __gRCXCmd.Command, __RCSTmpByte
  mul __RCSTmpByte, __RCSI, 2
  add __RCSTmpByte, __RCSTmpByte, 4
  replace __RCSInCmd, __RCSInCmd, __RCSTmpByte, __RCSTmpByte2
  add __RCSCSum, __RCSCSum, __RCSTmpByte2
  add __RCSTmpByte, __RCSTmpByte, 1
  sub __RCSTmpByte2, 0xFF, __RCSTmpByte2
  replace __RCSInCmd, __RCSInCmd, __RCSTmpByte, __RCSTmpByte2
  add __RCSI, __RCSI, 1
  jmp __RCSWhileILTCmdBytes
__RCSEndWhileILTCmdBytes:

  mul __RCSTmpByte, __RCSI, 2
  add __RCSTmpByte, __RCSTmpByte, 4
  replace __RCSInCmd, __RCSInCmd, __RCSTmpByte, __RCSCSum
  sub __RCSTmpByte2, 0xFF, __RCSCSum
  add __RCSTmpByte, __RCSTmpByte, 1
  replace __RCSInCmd, __RCSInCmd, __RCSTmpByte, __RCSTmpByte2
  // fill in the last three bytes
  add __RCSTmpByte, __RCSTmpByte, 1
  mul __RCSTmpByte2, __RCSCmdBytes, 2
  add __RCSTmpByte2, __RCSTmpByte2, 2
  replace __RCSInCmd, __RCSInCmd, __RCSTmpByte, __RCSTmpByte2
  add __RCSTmpByte, __RCSTmpByte, 1
  replace __RCSInCmd, __RCSInCmd, __RCSTmpByte, 0x00
  add __RCSTmpByte, __RCSTmpByte, 1
  replace __RCSInCmd, __RCSInCmd, __RCSTmpByte, 0x01

  // send the IR message
  __lowspeedWrite(__gRCXCmd.Port, 0, __RCSInCmd, __RCSTmpByte)

  // give the message time to be transferred
  mul __RCSTmpByte, __RCSTotalBytes, 5
  add __RCSTmpByte, __RCSTmpByte, 10
  waitv __RCSTmpByte

  // do we need to read a response?
  brtst EQ, __RCSNoResponse, __gRCXCmd.ResponseBytes

  arrbuild __RCSInCmd, __gRCXCmd.Address, 0x51
  mov __RCSTmpByte, __gRCXCmd.ResponseBytes
  __ReadI2CBytes(__gRCXCmd.Port, __RCSInCmd, __RCSTmpByte, __gRCXCmd.Response, __RCSResult)
__RCSNoResponse:
  return
ends

#define __HTRCXSetIRLinkPort(_port) \
  set __gRCXCmd.Port, _port \
  set __gRCXCmd.Address, 0x02

#define __HTRCXPoll(_src, _value, _result) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_PollOp, _src, _value \
  set __gRCXCmd.ResponseBytes, 12 \
  call __HTRCXCommandSub \
  index _result, __gRCXCmd.Response, 7 \
  index __RCSTmpByte, __gRCXCmd.Response, 5 \
  mul _result, _result, 256 \
  add _result, _result, __RCSTmpByte \
  release __RCXCmdMutex

#define __HTRCXBatteryLevel(_result) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_BatteryLevelOp \
  set __gRCXCmd.ResponseBytes, 12 \
  call __HTRCXCommandSub \
  index _result, __gRCXCmd.Response, 7 \
  index __RCSTmpByte, __gRCXCmd.Response, 5 \
  mul _result, _result, 256 \
  add _result, _result, __RCSTmpByte \
  release __RCXCmdMutex

#define __HTRCXOpNoArgs(_op) \
  acquire __RCXCmdMutex \
  arrinit __gRCXCmd.Command, _op, 1 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetOutput(_outputs, _mode) \
  acquire __RCXCmdMutex \
  add __RCSTmpByte, _outputs, _mode \
  arrbuild __gRCXCmd.Command, RCX_OnOffFloatOp, __RCSTmpByte \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetDirection(_outputs, _dir) \
  acquire __RCXCmdMutex \
  add __RCSTmpByte, _outputs, _dir \
  arrbuild __gRCXCmd.Command, RCX_OutputDirOp, __RCSTmpByte \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetPower(_outputs, _pwrsrc, _pwrval) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_OutputPowerOp, _outputs, _pwrsrc, _pwrval \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXOnFwd(_outputs) \
  __HTRCXSetDirection(_outputs, RCX_OUT_FWD) \
  __HTRCXSetOutput(_outputs, RCX_OUT_ON)

#define __HTRCXOnRev(_outputs) \
  __HTRCXSetDirection(_outputs, RCX_OUT_REV) \
  __HTRCXSetOutput(_outputs, RCX_OUT_ON)

#define __HTRCXOnFor(_outputs, _ms) \
  __HTRCXSetOutput(_outputs, RCX_OUT_ON) \
  waitv _ms \
  __HTRCXSetOutput(_outputs, RCX_OUT_OFF)

#define __HTRCXSetTxPower(_pwr) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_IRModeOp, _pwr \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXPlaySound(_snd) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_PlaySoundOp, _snd \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXDeleteTask(_t) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_DeleteTaskOp, _t \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXStartTask(_t) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_StartTaskOp, _t \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXStopTask(_t) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_StopTaskOp, _t \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSelectProgram(_prog) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SelectProgramOp, _prog \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXClearTimer(_timer) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ClearTimerOp, _timer \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetSleepTime(_t) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_AutoOffOp, _t \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXDeleteSub(_s) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_DeleteSubOp, _s \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXClearSensor(_port) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ClearSensorOp, _port \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXPlayToneVar(_varnum, _duration) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_PlayToneVarOp, _varnum, _duration \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetWatch(_hours, _minutes) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SetWatchOp, _hours, _minutes \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetSensorType(_port, _type) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_InputTypeOp, _port, _type \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetSensorMode(_port, _mode) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_InputModeOp, _port, _mode \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXCreateDatalog(_size) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _size, 0xFF \
  div __RCSTmpByte2, _size, 256 \
  arrbuild __gRCXCmd.Command, RCX_SetDatalogOp, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXAddToDatalog(_src, _value) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_DatalogOp, _src, _value \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSendSerial(_first, _count) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SendUARTDataOp, _first, _count \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXRemote(_cmd) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _cmd, 0xFF \
  div __RCSTmpByte2, _cmd, 256 \
  arrbuild __gRCXCmd.Command, RCX_RemoteOp, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXEvent(_src, _value) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _value, 0xFF \
  div __RCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_DirectEventOp, _src, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXPlayTone(_freq, _duration) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _freq, 0xFF \
  div __RCSTmpByte2, _freq, 256 \
  arrbuild __gRCXCmd.Command, RCX_PlayToneOp, __RCSTmpByte, __RCSTmpByte2, _duration \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSelectDisplay(_src, _value) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _value, 0xFF \
  div __RCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_DisplayOp, _src, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXPollMemory(_memaddress, _result) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _memaddress, 0xFF \
  div __RCSTmpByte2, _memaddress, 256 \
  arrbuild __gRCXCmd.Command, RCX_PollMemoryOp, __RCSTmpByte, __RCSTmpByte2, 1 \
  set __gRCXCmd.ResponseBytes, 16 \
  call __HTRCXCommandSub \
  index _result, __gRCXCmd.Response, 7 \
  index __RCSTmpByte, __gRCXCmd.Response, 5 \
  mul _result, _result, 256 \
  add _result, _result, __RCSTmpByte \
  release __RCXCmdMutex

#define __HTRCXSetEvent(_evt, _src, _type) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SetEventOp, _evt, _src, _type \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetGlobalOutput(_outputs, _mode) \
  acquire __RCXCmdMutex \
  add __RCSTmpByte, _outputs, _mode \
  arrbuild __gRCXCmd.Command, RCX_GOutputModeOp, __RCSTmpByte \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetGlobalDirection(_outputs, _dir) \
  acquire __RCXCmdMutex \
  add __RCSTmpByte, _outputs, _dir \
  arrbuild __gRCXCmd.Command, RCX_GOutputDirOp, __RCSTmpByte \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetMaxPower(_outputs, _pwrsrc, _pwrval) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_GOutputPowerOp, _outputs, _pwrsrc, _pwrval \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXIncCounter(_counter) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_IncCounterOp, _counter \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXDecCounter(_counter) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_DecCounterOp, _counter \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXClearCounter(_counter) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ClearCounterOp, _counter \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetPriority(_p) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SetPriorityOp, _p \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTRCXSetMessage(_msg) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_MessageOp, _msg \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSetScoutMode(_mode) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ScoutOp, _mode \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSendVLL(_src, _value) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_VLLOp, _src, _value \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSetSensorClickTime(_src, _value) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _value, 0xFF \
  div __RCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_LSBlinkTimeOp, _src, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSetSensorHysteresis(_src, _value) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _value, 0xFF \
  div __RCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_LSHysteresisOp, _src, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSetSensorLowerLimit(_src, _value) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _value, 0xFF \
  div __RCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_LSLowerThreshOp, _src, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSetSensorUpperLimit(_src, _value) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _value, 0xFF \
  div __RCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_LSUpperThreshOp, _src, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSetEventFeedback(_src, _value) \
  acquire __RCXCmdMutex \
  and __RCSTmpByte, _value, 0xFF \
  div __RCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_SetFeedbackOp, _src, __RCSTmpByte, __RCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutMuteSound() \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SoundOp, 0x80 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutUnmuteSound() \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SoundOp, 0xc0 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSelectSounds(_grp) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SoundOp, _grp \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __HTScoutSetLight(_x) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_LightOp, _x \
  set __gRCXCmd.ResponseBytes, 0 \
  call __HTRCXCommandSub \
  release __RCXCmdMutex

#define __ReadSensorHTCompass(_port, _value) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 2 \
  call __ReadLSBytesVar \
  index _value, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  add _value, _value, _value \
  add _value, _value, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 2 \
  call __ReadLSBytes##_port \
  index _value, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  add _value, _value, _value \
  add _value, _value, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTAccel(_port, _x, _y, _z, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 6 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _x, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 3 \
  brcmp LTEQ, __RSHTAX##__I__, _x, 127 \
  sub _x, _x, 256 \
  __RSHTAX##__I__: \
  __IncI__ \
  mul _x, _x, 4 \
  add _x, _x, __RLSBytesCountVar \
  index _y, __RLSReadBufVar, 1 \
  index __RLSBytesCountVar, __RLSReadBufVar, 4 \
  brcmp LTEQ, __RSHTAY##__I__, _y, 127 \
  sub _y, _y, 256 \
  __RSHTAY##__I__: \
  __IncI__ \
  mul _y, _y, 4 \
  add _y, _y, __RLSBytesCountVar \
  index _z, __RLSReadBufVar, 2 \
  index __RLSBytesCountVar, __RLSReadBufVar, 5 \
  brcmp LTEQ, __RSHTAZ##__I__, _z, 127 \
  sub _z, _z, 256 \
  __RSHTAZ##__I__: \
  __IncI__ \
  mul _z, _z, 4 \
  add _z, _z, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _x, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 3 \
  brcmp LTEQ, __RSHTAX##__I__, _x, 127 \
  sub _x, _x, 256 \
  __RSHTAX##__I__: \
  __IncI__ \
  mul _x, _x, 4 \
  add _x, _x, __RLSBytesCount##_port \
  index _y, __RLSReadBuf##_port, 1 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 4 \
  brcmp LTEQ, __RSHTAY##__I__, _y, 127 \
  sub _y, _y, 256 \
  __RSHTAY##__I__: \
  __IncI__ \
  mul _y, _y, 4 \
  add _y, _y, __RLSBytesCount##_port \
  index _z, __RLSReadBuf##_port, 2 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 5 \
  brcmp LTEQ, __RSHTAZ##__I__, _z, 127 \
  sub _z, _z, 256 \
  __RSHTAZ##__I__: \
  __IncI__ \
  mul _z, _z, 4 \
  add _z, _z, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

dseg segment
  __RSHTColorRawBuf byte[] 0x02, 0x46
  __RSHTColorNormBuf byte[] 0x02, 0x4C
  __RSHTColor2NormBuf byte[] 0x02, 0x47
dseg ends

#define __ReadSensorHTRawColor(_port, _Red, _Green, _Blue, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RSHTColorRawBuf \
  set __RLSBytesCountVar, 6 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _Red, __RLSReadBufVar, 1 \
  index __RLSBytesCountVar, __RLSReadBufVar, NA \
  mul _Red, _Red, 256 \
  add _Red, _Red, __RLSBytesCountVar \
  index _Green, __RLSReadBufVar, 3 \
  index __RLSBytesCountVar, __RLSReadBufVar, 2 \
  mul _Green, _Green, 256 \
  add _Green, _Green, __RLSBytesCountVar \
  index _Blue, __RLSReadBufVar, 5 \
  index __RLSBytesCountVar, __RLSReadBufVar, 4 \
  mul _Blue, _Blue, 256 \
  add _Blue, _Blue, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RSHTColorRawBuf \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _Red, __RLSReadBuf##_port, 1 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, NA \
  mul _Red, _Red, 256 \
  add _Red, _Red, __RLSBytesCount##_port \
  index _Green, __RLSReadBuf##_port, 3 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 2 \
  mul _Green, _Green, 256 \
  add _Green, _Green, __RLSBytesCount##_port \
  index _Blue, __RLSReadBuf##_port, 5 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 4 \
  mul _Blue, _Blue, 256 \
  add _Blue, _Blue, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTColor(_port, _ColorNum, _Red, _Green, _Blue, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 4 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _ColorNum, __RLSReadBufVar, NA \
  index _Red, __RLSReadBufVar, 1 \
  index _Green, __RLSReadBufVar, 2 \
  index _Blue, __RLSReadBufVar, 3 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 4 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _ColorNum, __RLSReadBuf##_port, NA \
  index _Red, __RLSReadBuf##_port, 1 \
  index _Green, __RLSReadBuf##_port, 2 \
  index _Blue, __RLSReadBuf##_port, 3 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTNormalizedColor(_port, _ColorIdx, _Red, _Green, _Blue, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RSHTColorNormBuf \
  set __RLSBytesCountVar, 4 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _ColorIdx, __RLSReadBufVar, NA \
  index _Red, __RLSReadBufVar, 1 \
  index _Green, __RLSReadBufVar, 2 \
  index _Blue, __RLSReadBufVar, 3 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RSHTColorNormBuf \
  set __RLSBytesCount##_port, 4 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _ColorIdx, __RLSReadBuf##_port, NA \
  index _Red, __RLSReadBuf##_port, 1 \
  index _Green, __RLSReadBuf##_port, 2 \
  index _Blue, __RLSReadBuf##_port, 3 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTColor2Active(_port, _ColorNum, _Red, _Green, _Blue, _White, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 5 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _ColorNum, __RLSReadBufVar, NA \
  index _Red, __RLSReadBufVar, 1 \
  index _Green, __RLSReadBufVar, 2 \
  index _Blue, __RLSReadBufVar, 3 \
  index _White, __RLSReadBufVar, 4 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 5 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _ColorNum, __RLSReadBuf##_port, NA \
  index _Red, __RLSReadBuf##_port, 1 \
  index _Green, __RLSReadBuf##_port, 2 \
  index _Blue, __RLSReadBuf##_port, 3 \
  index _White, __RLSReadBuf##_port, 4 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTNormalizedColor2Active(_port, _ColorIdx, _Red, _Green, _Blue, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RSHTColor2NormBuf \
  set __RLSBytesCountVar, 4 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _ColorIdx, __RLSReadBufVar, NA \
  index _Red, __RLSReadBufVar, 1 \
  index _Green, __RLSReadBufVar, 2 \
  index _Blue, __RLSReadBufVar, 3 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RSHTColor2NormBuf \
  set __RLSBytesCount##_port, 5 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _ColorIdx, __RLSReadBuf##_port, NA \
  index _Red, __RLSReadBuf##_port, 1 \
  index _Green, __RLSReadBuf##_port, 2 \
  index _Blue, __RLSReadBuf##_port, 3 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTRawColor2(_port, _Red, _Green, _Blue, _White, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 8 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _Red, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  mul _Red, _Red, 256 \
  add _Red, _Red, __RLSBytesCountVar \
  index _Green, __RLSReadBufVar, 2 \
  index __RLSBytesCountVar, __RLSReadBufVar, 3 \
  mul _Green, _Green, 256 \
  add _Green, _Green, __RLSBytesCountVar \
  index _Blue, __RLSReadBufVar, 4 \
  index __RLSBytesCountVar, __RLSReadBufVar, 5 \
  mul _Blue, _Blue, 256 \
  add _Blue, _Blue, __RLSBytesCountVar \
  index _White, __RLSReadBufVar, 6 \
  index __RLSBytesCountVar, __RLSReadBufVar, 7 \
  mul _White, _White, 256 \
  add _White, _White, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 8 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _Red, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  mul _Red, _Red, 256 \
  add _Red, _Red, __RLSBytesCount##_port \
  index _Green, __RLSReadBuf##_port, 2 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 3 \
  mul _Green, _Green, 256 \
  add _Green, _Green, __RLSBytesCount##_port \
  index _Blue, __RLSReadBuf##_port, 4 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 5 \
  mul _Blue, _Blue, 256 \
  add _Blue, _Blue, __RLSBytesCount##_port \
  index _White, __RLSReadBuf##_port, 6 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 7 \
  mul _White, _White, 256 \
  add _White, _White, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTIRSeeker(_port, _dir, _s1, _s3, _s5, _s7, _s9, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 6 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _dir, __RLSReadBufVar, NA \
  index _s1, __RLSReadBufVar, 1 \
  index _s3, __RLSReadBufVar, 2 \
  index _s5, __RLSReadBufVar, 3 \
  index _s7, __RLSReadBufVar, 4 \
  index _s9, __RLSReadBufVar, 5 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _dir, __RLSReadBuf##_port, NA \
  index _s1, __RLSReadBuf##_port, 1 \
  index _s3, __RLSReadBuf##_port, 2 \
  index _s5, __RLSReadBuf##_port, 3 \
  index _s7, __RLSReadBuf##_port, 4 \
  index _s9, __RLSReadBuf##_port, 5 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTIRSeeker2DC(_port, _dir, _s1, _s3, _s5, _s7, _s9, _avg, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, 0x10, 0x42 \
  set __RLSBytesCountVar, 7 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _dir, __RLSReadBufVar, NA \
  index _s1, __RLSReadBufVar, 1 \
  index _s3, __RLSReadBufVar, 2 \
  index _s5, __RLSReadBufVar, 3 \
  index _s7, __RLSReadBufVar, 4 \
  index _s9, __RLSReadBufVar, 5 \
  index _avg, __RLSReadBufVar, 6 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, 0x10, 0x42 \
  set __RLSBytesCount##_port, 7 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _dir, __RLSReadBuf##_port, NA \
  index _s1, __RLSReadBuf##_port, 1 \
  index _s3, __RLSReadBuf##_port, 2 \
  index _s5, __RLSReadBuf##_port, 3 \
  index _s7, __RLSReadBuf##_port, 4 \
  index _s9, __RLSReadBuf##_port, 5 \
  index _avg, __RLSReadBuf##_port, 6 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTIRSeeker2AC(_port, _dir, _s1, _s3, _s5, _s7, _s9, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, 0x10, 0x49 \
  set __RLSBytesCountVar, 6 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _dir, __RLSReadBufVar, NA \
  index _s1, __RLSReadBufVar, 1 \
  index _s3, __RLSReadBufVar, 2 \
  index _s5, __RLSReadBufVar, 3 \
  index _s7, __RLSReadBufVar, 4 \
  index _s9, __RLSReadBufVar, 5 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, 0x10, 0x49 \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _dir, __RLSReadBuf##_port, NA \
  index _s1, __RLSReadBuf##_port, 1 \
  index _s3, __RLSReadBuf##_port, 2 \
  index _s5, __RLSReadBuf##_port, 3 \
  index _s7, __RLSReadBuf##_port, 4 \
  index _s9, __RLSReadBuf##_port, 5 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTIRSeeker2Addr(_port, _reg, _value) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, 0x10, _reg \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  index _value, __RLSReadBufVar, NA \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, 0x10, _reg \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  index _value, __RLSReadBuf##_port, NA \
  release __RLSBmutex##_port \
  compend

#define __SetHTIRSeeker2Mode(_port, _mode, _result) __I2CSendCmd(_port, 0x10, _mode, _result)

#define __ReadSensorHTIRReceiver(_port, _pfdata, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 8 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  mov _pfdata, __RLSReadBufVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 8 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  mov _pfdata, __RLSReadBuf##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTIRReceiverEx(_port, _reg, _pfchar, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  add __RLSBytesCountVar, 0x42, _reg \
  arrbuild __RLSReadBufVar, 0x02, __RLSBytesCountVar \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _pfchar, __RLSReadBufVar, NA \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  add __RLSBytesCount##_port, 0x42, _reg \
  arrbuild __RLSReadBuf##_port, 0x02, __RLSBytesCount##_port \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _pfchar, __RLSReadBuf##_port, NA \
  release __RLSBmutex##_port \
  compend

#define __SetHTColor2Mode(_port, _mode, _result) __I2CSendCmd(_port, 0x02, _mode, _result)

#define __ReadSensorHTColorNum(_port, _value) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  index _value, __RLSReadBufVar, NA \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  index _value, __RLSReadBuf##_port, NA \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTIRSeekerDir(_port, _value) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  index _value, __RLSReadBufVar, NA \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  index _value, __RLSReadBuf##_port, NA \
  release __RLSBmutex##_port \
  compend

#define __ResetSensorHTAngle(_port, _mode, _result) \
  compchk EQ, isconst(_mode), TRUE \
  __I2CSendCmd(_port, 0x02, _mode, _result) \
  compif EQ, _mode, HTANGLE_MODE_CALIBRATE \
  wait 30 \
  compend

#define __ReadSensorHTAngle(_port, _Angle, _AccAngle, _RPM, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 8 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _Angle, __RLSReadBufVar, NA \
  add _Angle, _Angle, _Angle \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  add _Angle, _Angle, __RLSBytesCountVar \
  index _AccAngle, __RLSReadBufVar, 2 \
  mul _AccAngle, _AccAngle, 256 \
  index __RLSBytesCountVar, __RLSReadBufVar, 3 \
  add _AccAngle, _AccAngle, __RLSBytesCountVar \
  mul _AccAngle, _AccAngle, 256 \
  index __RLSBytesCountVar, __RLSReadBufVar, 4 \
  add _AccAngle, _AccAngle, __RLSBytesCountVar \
  mul _AccAngle, _AccAngle, 256 \
  index __RLSBytesCountVar, __RLSReadBufVar, 5 \
  add _AccAngle, _AccAngle, __RLSBytesCountVar \
  index _RPM, __RLSReadBufVar, 6 \
  mul _RPM, _RPM, 256 \
  index __RLSBytesCountVar, __RLSReadBufVar, 7 \
  add _RPM, _RPM, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 8 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _Angle, __RLSReadBuf##_port, NA \
  add _Angle, _Angle, _Angle \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  add _Angle, _Angle, __RLSBytesCount##_port \
  index _AccAngle, __RLSReadBuf##_port, 2 \
  mul _AccAngle, _AccAngle, 256 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 3 \
  add _AccAngle, _AccAngle, __RLSBytesCount##_port \
  mul _AccAngle, _AccAngle, 256 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 4 \
  add _AccAngle, _AccAngle, __RLSBytesCount##_port \
  mul _AccAngle, _AccAngle, 256 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 5 \
  add _AccAngle, _AccAngle, __RLSBytesCount##_port \
  index _RPM, __RLSReadBuf##_port, 6 \
  mul _RPM, _RPM, 256 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 7 \
  add _RPM, _RPM, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

dseg segment
  __ResetHTBCal byte[] 0xaa, 0x55
  __SetHTBCal byte[] 0x55, 0xaa
  __SetHTBCalByte1Var byte
  __SetHTBCalByte2Var byte
  __SetHTBCalByte10 byte
  __SetHTBCalByte20 byte
  __SetHTBCalByte11 byte
  __SetHTBCalByte21 byte
  __SetHTBCalByte12 byte
  __SetHTBCalByte22 byte
  __SetHTBCalByte13 byte
  __SetHTBCalByte23 byte
dseg ends

#define __ResetHTBarometricCalibration(_port, _result) \
  __MSWriteToRegister(_port, HT_ADDR_BAROMETRIC, HTBAR_REG_COMMAND, __ResetHTBCal, _result) \
  tst EQ, _result, _result

#define __SetHTBarometricCalibration(_port, _cal, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  div __SetHTBCalByte1Var, _cal, 256 \
  and __SetHTBCalByte2Var, _cal, 0xFF \
  arrbuild __RLSReadBufVar, HT_ADDR_BAROMETRIC, HTBAR_REG_CALIBRATION, __SetHTBCalByte1Var, __SetHTBCalByte2Var \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  div __SetHTBCalByte1##_port, _cal, 256 \
  and __SetHTBCalByte2##_port, _cal, 0xFF \
  arrbuild __RLSReadBuf##_port, HT_ADDR_BAROMETRIC, HTBAR_REG_CALIBRATION, __SetHTBCalByte1##_port, __SetHTBCalByte2##_port \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend \
  brtst EQ, __SHTBCal_EndIf##__I__, _result \
  wait 15 \
  __MSWriteToRegister(_port, HT_ADDR_BAROMETRIC, HTBAR_REG_COMMAND, __SetHTBCal, _result) \
  tst EQ, _result, _result \
  __SHTBCal_EndIf##__I__: \
  __IncI__

#define __ReadSensorHTBarometric(_port, _t, _p, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 4 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _t, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  mul _t, _t, 256 \
  add _t, _t, __RLSBytesCountVar \
  index _p, __RLSReadBufVar, 2 \
  index __RLSBytesCountVar, __RLSReadBufVar, 3 \
  mul _p, _p, 256 \
  add _p, _p, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 4 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _t, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  mul _t, _t, 256 \
  add _t, _t, __RLSBytesCount##_port \
  index _p, __RLSReadBuf##_port, 2 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 3 \
  mul _p, _p, 256 \
  add _p, _p, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTProtoAnalog(_port, _i2caddr, _idx, _a, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, _idx \
  set __RLSBytesCountVar, 2 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _a, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  mul _a, _a, 4 \
  add _a, _a, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, _idx \
  set __RLSBytesCount##_port, 2 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _a, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  mul _a, _a, 4 \
  add _a, _a, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTProtoAllAnalog(_port, _a0, _a1, _a2, _a3, _a4, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, HT_ADDR_PROTOBOARD, HTPROTO_REG_A0 \
  set __RLSBytesCountVar, 10 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _a0, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  mul _a0, _a0, 4 \
  add _a0, _a0, __RLSBytesCountVar \
  index _a1, __RLSReadBufVar, 2 \
  index __RLSBytesCountVar, __RLSReadBufVar, 3 \
  mul _a1, _a1, 4 \
  add _a1, _a1, __RLSBytesCountVar \
  index _a2, __RLSReadBufVar, 4 \
  index __RLSBytesCountVar, __RLSReadBufVar, 5 \
  mul _a2, _a2, 4 \
  add _a2, _a2, __RLSBytesCountVar \
  index _a3, __RLSReadBufVar, 6 \
  index __RLSBytesCountVar, __RLSReadBufVar, 7 \
  mul _a3, _a3, 4 \
  add _a3, _a3, __RLSBytesCountVar \
  index _a4, __RLSReadBufVar, 8 \
  index __RLSBytesCountVar, __RLSReadBufVar, 9 \
  mul _a4, _a4, 4 \
  add _a4, _a4, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, HT_ADDR_PROTOBOARD, HTPROTO_REG_A0 \
  set __RLSBytesCount##_port, 10 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _a0, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  mul _a0, _a0, 4 \
  add _a0, _a0, __RLSBytesCount##_port \
  index _a1, __RLSReadBuf##_port, 2 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 3 \
  mul _a1, _a1, 4 \
  add _a1, _a1, __RLSBytesCount##_port \
  index _a2, __RLSReadBuf##_port, 4 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 5 \
  mul _a2, _a2, 4 \
  add _a2, _a2, __RLSBytesCount##_port \
  index _a3, __RLSReadBuf##_port, 6 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 7 \
  mul _a3, _a3, 4 \
  add _a3, _a3, __RLSBytesCount##_port \
  index _a4, __RLSReadBuf##_port, 8 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 9 \
  mul _a4, _a4, 4 \
  add _a4, _a4, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

#define __SetSensorHTProtoDigitalControl(_port, _i2caddr, _value, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, 0x4E, _value \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, 0x4E, _value \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend

#define __SetSensorHTProtoDigital(_port, _i2caddr, _value, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, 0x4D, _value \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, 0x4D, _value \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTProtoDigital(_port, _i2caddr, _pins, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, 0x4C \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _pins, __RLSReadBufVar, NA \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, 0x4C \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _pins, __RLSReadBuf##_port, NA \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorHTSuperProAllAnalog(_port, _a0, _a1, _a2, _a3, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, HT_ADDR_SUPERPRO, HTSPRO_REG_A0 \
  set __RLSBytesCountVar, 10 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _a0, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  mul _a0, _a0, 4 \
  add _a0, _a0, __RLSBytesCountVar \
  index _a1, __RLSReadBufVar, 2 \
  index __RLSBytesCountVar, __RLSReadBufVar, 3 \
  mul _a1, _a1, 4 \
  add _a1, _a1, __RLSBytesCountVar \
  index _a2, __RLSReadBufVar, 4 \
  index __RLSBytesCountVar, __RLSReadBufVar, 5 \
  mul _a2, _a2, 4 \
  add _a2, _a2, __RLSBytesCountVar \
  index _a3, __RLSReadBufVar, 6 \
  index __RLSBytesCountVar, __RLSReadBufVar, 7 \
  mul _a3, _a3, 4 \
  add _a3, _a3, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, HT_ADDR_SUPERPRO, HTSPRO_REG_A0 \
  set __RLSBytesCount##_port, 10 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _a0, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  mul _a0, _a0, 4 \
  add _a0, _a0, __RLSBytesCount##_port \
  index _a1, __RLSReadBuf##_port, 2 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 3 \
  mul _a1, _a1, 4 \
  add _a1, _a1, __RLSBytesCount##_port \
  index _a2, __RLSReadBuf##_port, 4 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 5 \
  mul _a2, _a2, 4 \
  add _a2, _a2, __RLSBytesCount##_port \
  index _a3, __RLSReadBuf##_port, 6 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 7 \
  mul _a3, _a3, 4 \
  add _a3, _a3, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

dseg segment
  __HTSPAOB1Var byte
  __HTSPAOB2Var byte
  __HTSPAOB3Var byte
  __HTSPAOB4Var byte
  __HTSPAOB10 byte
  __HTSPAOB20 byte
  __HTSPAOB30 byte
  __HTSPAOB40 byte
  __HTSPAOB11 byte
  __HTSPAOB21 byte
  __HTSPAOB31 byte
  __HTSPAOB41 byte
  __HTSPAOB12 byte
  __HTSPAOB22 byte
  __HTSPAOB32 byte
  __HTSPAOB42 byte
  __HTSPAOB13 byte
  __HTSPAOB23 byte
  __HTSPAOB33 byte
  __HTSPAOB43 byte
dseg ends

#define __SetSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  div __HTSPAOB1Var, _freq, 256 \
  and __HTSPAOB2Var, _freq, 0xFF \
  div __HTSPAOB3Var, _volt, 4 \
  and __HTSPAOB4Var, _volt, 0x03 \
  arrbuild __RLSReadBufVar, HT_ADDR_SUPERPRO, _dac, _mode, __HTSPAOB1Var, __HTSPAOB2Var, __HTSPAOB3Var, __HTSPAOB4Var \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  div __HTSPAOB1##_port, _freq, 256 \
  and __HTSPAOB2##_port, _freq, 0xFF \
  div __HTSPAOB3##_port, _volt, 4 \
  and __HTSPAOB4##_port, _volt, 0x03 \
  arrbuild __RLSReadBuf##_port, HT_ADDR_SUPERPRO, _dac, _mode, __HTSPAOB1##_port, __HTSPAOB2##_port, __HTSPAOB3##_port, __HTSPAOB4##_port \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend

#define __SetSensorHTSuperProStrobe(_port, _value, _result) \
  __MSWriteToRegister(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_STROBE, _value, _result) \
  tst EQ, _result, _result

#define __SetSensorHTSuperProLED(_port, _value, _result) \
  __MSWriteToRegister(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_LED, _value, _result) \
  tst EQ, _result, _result

#define __SetSensorHTSuperProProgramControl(_port, _value, _result) \
  __MSWriteToRegister(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_CTRL, _value, _result) \
  tst EQ, _result, _result

#define __ReadSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, HT_ADDR_SUPERPRO, _dac \
  set __RLSBytesCountVar, 5 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _mode, __RLSReadBufVar, NA \
  index _freq, __RLSReadBufVar, 1 \
  index __RLSBytesCountVar, __RLSReadBufVar, 2 \
  mul _freq, _freq, 256 \
  add _freq, _freq, __RLSBytesCountVar \
  index _volt, __RLSReadBufVar, 3 \
  index __RLSBytesCountVar, __RLSReadBufVar, 4 \
  mul _volt, _volt, 4 \
  add _volt, _volt, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, HT_ADDR_SUPERPRO, _dac \
  set __RLSBytesCount##_port, 5 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _mode, __RLSReadBuf##_port, NA \
  index _freq, __RLSReadBuf##_port, 1 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 2 \
  mul _freq, _freq, 256 \
  add _freq, _freq, __RLSBytesCount##_port \
  index _volt, __RLSReadBuf##_port, 3 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 4 \
  mul _volt, _volt, 4 \
  add _volt, _volt, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend


#define __ReadI2CDeviceInfo(_port, _i2caddr, _info, _strVal) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, _info \
  set __RLSBytesCountVar, 8 \
  call __ReadLSBytesVar \
  arrtostr _strVal, __RLSReadBufVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, _info \
  set __RLSBytesCount##_port, 8 \
  call __ReadLSBytes##_port \
  arrtostr _strVal, __RLSReadBuf##_port \
  release __RLSBmutex##_port \
  compend

#define __SetSensorMSPressure(_port) \
  setin IN_TYPE_REFLECTION, _port, TypeField \
  setin IN_MODE_RAW, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorMSDRODActive(_port) \
  setin IN_TYPE_LIGHT_ACTIVE, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorMSDRODInactive(_port) \
  setin IN_TYPE_LIGHT_INACTIVE, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port)

#define __SetSensorNXTSumoEyesLong(_port) \
  setin IN_TYPE_LIGHT_INACTIVE, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port) \
  wait 275

#define __SetSensorNXTSumoEyesShort(_port) \
  setin IN_TYPE_LIGHT_ACTIVE, _port, TypeField \
  setin IN_MODE_PCTFULLSCALE, _port, InputModeField \
  __ResetSensor(_port) \
  wait 275

#define __SetSensorMSTouchMux(_port) \
  setin IN_TYPE_LIGHT_INACTIVE, _port, TypeField \
  setin IN_MODE_RAW, _port, InputModeField \
  __ResetSensor(_port)

#define __ReadSensorMSPressure(_port, _value) \
  getin _value, _port, RawValueField \
  sub _value, 1024, _value \
  div _value, _value, 25

#define __ReadSensorMSPressureRaw(_port, _value) \
  getin _value, _port, RawValueField

#define __ReadSensorMSDROD(_port, _value) \
  getin _value, _port, NormalizedValueField

#define __ReadSensorNXTSumoEyes(_port, _value) \
  getin _value, _port, NormalizedValueField \
  mul _value, _value, 100 \
  div _value, _value, 1023

#define __ReadSensorMSCompass(_port, _i2caddr, _value) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, 0x42 \
  set __RLSBytesCountVar, 2 \
  call __ReadLSBytesVar \
  index _value, __RLSReadBufVar, 1 \
  index __RLSBytesCountVar, __RLSReadBufVar, NA \
  mul _value, _value, 256 \
  add _value, _value, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, 0x42 \
  set __RLSBytesCount##_port, 2 \
  call __ReadLSBytes##_port \
  index _value, __RLSReadBuf##_port, 1 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, NA \
  mul _value, _value, 256 \
  add _value, _value, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorMSRTClock(_port, _sec, _min, _hrs, _dow, _date, _month, _year, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, 0xD0, 0x00 \
  set __RLSBytesCountVar, 8 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _sec, __RLSReadBufVar, NA \
  index _min, __RLSReadBufVar, 1 \
  index _hrs, __RLSReadBufVar, 2 \
  index _dow, __RLSReadBufVar, 3 \
  index _date, __RLSReadBufVar, 4 \
  index _month, __RLSReadBufVar, 5 \
  index _year, __RLSReadBufVar, 6 \
  bcd2dec(_sec, _sec) \
  bcd2dec(_min, _min) \
  bcd2dec(_hrs, _hrs) \
  bcd2dec(_dow, _dow) \
  bcd2dec(_date, _date) \
  bcd2dec(_month, _month) \
  bcd2dec(_year, _year) \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, 0xD0, 0x00 \
  set __RLSBytesCount##_port, 8 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _sec, __RLSReadBuf##_port, NA \
  index _min, __RLSReadBuf##_port, 1 \
  index _hrs, __RLSReadBuf##_port, 2 \
  index _dow, __RLSReadBuf##_port, 3 \
  index _date, __RLSReadBuf##_port, 4 \
  index _month, __RLSReadBuf##_port, 5 \
  index _year, __RLSReadBuf##_port, 6 \
  bcd2dec(_sec, _sec) \
  bcd2dec(_min, _min) \
  bcd2dec(_hrs, _hrs) \
  bcd2dec(_dow, _dow) \
  bcd2dec(_date, _date) \
  bcd2dec(_month, _month) \
  bcd2dec(_year, _year) \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorMSTilt(_port, _i2caddr, _x, _y, _z, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, 0x42  \
  set __RLSBytesCountVar, 3 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _x, __RLSReadBufVar, NA \
  index _y, __RLSReadBufVar, 1 \
  index _z, __RLSReadBufVar, 2 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, 0x42 \
  set __RLSBytesCount##_port, 3 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _x, __RLSReadBuf##_port, NA \
  index _y, __RLSReadBuf##_port, 1 \
  index _z, __RLSReadBuf##_port, 2 \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorMSAccel(_port, _i2caddr, _x, _y, _z, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, 0x45 \
  set __RLSBytesCountVar, 6 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _x, __RLSReadBufVar, NA \
  index __RLSBytesCountVar, __RLSReadBufVar, 1 \
  mul __RLSBytesCountVar, __RLSBytesCountVar, 256 \
  add _x, _x, __RLSBytesCountVar \
  index _y, __RLSReadBufVar, 2 \
  index __RLSBytesCountVar, __RLSReadBufVar, 3 \
  mul __RLSBytesCountVar, __RLSBytesCountVar, 256 \
  add _y, _y, __RLSBytesCountVar \
  index _z, __RLSReadBufVar, 4 \
  index __RLSBytesCountVar, __RLSReadBufVar, 5 \
  mul __RLSBytesCountVar, __RLSBytesCountVar, 256 \
  add _z, _z, __RLSBytesCountVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, 0x45 \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _x, __RLSReadBuf##_port, NA \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 1 \
  mul __RLSBytesCount##_port, __RLSBytesCount##_port, 256 \
  add _x, _x, __RLSBytesCount##_port \
  index _y, __RLSReadBuf##_port, 2 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 3 \
  mul __RLSBytesCount##_port, __RLSBytesCount##_port, 256 \
  add _y, _y, __RLSBytesCount##_port \
  index _z, __RLSReadBuf##_port, 4 \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 5 \
  mul __RLSBytesCount##_port, __RLSBytesCount##_port, 256 \
  add _z, _z, __RLSBytesCount##_port \
  release __RLSBmutex##_port \
  compend

#define __PFMateSend(_port, _i2caddr, _channel, _motors, _cmdA, _spdA, _cmdB, _spdB, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, PFMATE_REG_CHANNEL, _channel, _motors, _cmdA, _spdA, _cmdB, _spdB  \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  arrbuild __RLSReadBufVar, _i2caddr, PFMATE_REG_CMD, PFMATE_CMD_GO  \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, PFMATE_REG_CHANNEL, _channel, _motors, _cmdA, _spdA, _cmdB, _spdB  \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, PFMATE_REG_CMD, PFMATE_CMD_GO  \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend

#define __PFMateSendRaw(_port, _i2caddr, _channel, _b1, _b2, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, PFMATE_REG_CHANNEL, _channel, 0x00, _b1, _b2  \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  arrbuild __RLSReadBufVar, _i2caddr, PFMATE_REG_CMD, PFMATE_CMD_RAW  \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, PFMATE_REG_CHANNEL, _channel, 0x00, _b1, _b2  \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, PFMATE_REG_CMD, PFMATE_CMD_RAW  \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend


dseg segment
  __RLSBbufRFIDInit byte[] 0x04, 0x32
  __RLSBbufRFIDData byte[] 0x04, 0x42
  __RFIDCount byte
  __RFIDCont_Port byte
  __RFIDCont_Result byte
  __RFIDCont_Output byte[]
  __RFIDmutex mutex
dseg ends

#define __RFIDInit(_port, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufRFIDInit \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufRFIDInit \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend

#define __RFIDMode(_port, _mode, _result) __I2CSendCmd(_port, 0x04, _mode, _result)
#define __RFIDStatus(_port, _result) __MSReadValue(_port, 0x04, 0x32, 1, _result, __RDSD_LSStatus)
#define __RFIDRead(_port, _output, _result) \
  set __RFIDCount, 5 \
  __ReadI2CBytes(_port, __RLSBbufRFIDData, __RFIDCount, _output, _result)

#define __RFIDStop(_port, _result) \
  __RFIDInit(_port, _result) \
  wait 10 \
  __RFIDMode(_port, RFID_MODE_STOP, _result)

#define __RFIDReadSingle(_port, _output, _result) \
  __RFIDInit(_port, _result) \
  wait 15 \
  __RFIDMode(_port, RFID_MODE_SINGLE, _result) \
  wait 250 \
  __RFIDRead(_port, _output, _result)

#define __RFIDReadContinuous(_port, _output, _result) \
  acquire __RFIDmutex \
  mov __RFIDCont_Port, _port \
  call __RFIDReadContinuousSub \
  mov _output, __RFIDCont_Output \
  mov _result, __RFIDCont_Result \
  release __RFIDmutex

#define __ReadSensorDIGPSStatus(_port, _status) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_STATUS, 1, _status, __RDSD_LSStatus)
#define __ReadSensorDIGPSTime(_port, _result) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_TIME, 4, _result, __RDSD_LSStatus)
#define __ReadSensorDIGPSLatitude(_port, _result) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_LATITUDE, 4, _result, __RDSD_LSStatus)
#define __ReadSensorDIGPSLongitude(_port, _result) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_LONGITUDE, 4, _result, __RDSD_LSStatus)
#define __ReadSensorDIGPSVelocity(_port, _result) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_VELOCITY, 3, _result, __RDSD_LSStatus)
#define __ReadSensorDIGPSHeading(_port, _result) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_HEADING, 2, _result, __RDSD_LSStatus)
#define __ReadSensorDIGPSDistanceToWaypoint(_port, _result) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_DISTANCE, 4, _result, __RDSD_LSStatus)
#define __ReadSensorDIGPSHeadingToWaypoint(_port, _result) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_WAYANGLE, 2, _result, __RDSD_LSStatus)
#define __ReadSensorDIGPSRelativeHeading(_port, _result) __ReadI2CBEValue(_port, DI_ADDR_DGPS, DGPS_REG_LASTANGLE, 4, _result, __RDSD_LSStatus)

dseg segment
  __digyro_divisor sword[] {128, 128, 128, 128}
  __tmp_digyro_divisor sword
  __tmp_digyro0 sword
  __tmp_digyro1 sword
  __tmp_digyro2 sword
  __tmp_digyro3 sword
  __tmp_digyroVar sword
  __tmp_digyrotemp sbyte
  __tmp_digyrovector TVector
dseg ends

#define __SetSensorDIGyro(_port, _range, _odr, _bw, _result) \
  __SetSensorLowspeed(_port) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  or __RLSReadPort, _odr, _bw \
  or __RLSReadPort, __RLSReadPort, 0x0F \
  or __RLSBytesCountVar, _range, DIGYRO_CTRL4_BLOCKDATA \
  and __RLSBytesCountVar, __RLSBytesCountVar, 0xF0 \
  arrbuild __RLSReadBufVar, DI_ADDR_GYRO, DIGYRO_REG_CTRL1AUTO, __RLSReadPort, 0x00, 0x08, __RLSBytesCountVar, 0x02, 0x00 \
  set __RLSBytesCountVar, 0 \
  mov __RLSReadPort, _port \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  set __tmp_digyro_divisor, 16 \
  brcmp EQ, __SSDIG_EndIf##__I__, DIGYRO_CTRL4_SCALE_2000, _range \
  set __tmp_digyro_divisor, 64 \
  brcmp EQ, __SSDIG_EndIf##__I__, DIGYRO_CTRL4_SCALE_500, _range \
  set __tmp_digyro_divisor, 128 \
  __SSDIG_EndIf##__I__: \
  __IncI__ \
  replace __digyro_divisor, __digyro_divisor, _port, __tmp_digyro_divisor \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  or __RLSReadPort, _odr, _bw \
  or __RLSReadPort, __RLSReadPort, 0x0F \
  or __RLSBytesCount##_port, _range, DIGYRO_CTRL4_BLOCKDATA \
  and __RLSBytesCount##_port, __RLSBytesCount##_port, 0xF0 \
  arrbuild __RLSReadBuf##_port, DI_ADDR_GYRO, DIGYRO_REG_CTRL1AUTO, __RLSReadPort, 0x00, 0x08, __RLSBytesCount##_port, 0x02, 0x00 \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  set __tmp_digyro_divisor, 16 \
  brcmp EQ, __SSDIG_EndIf##__I__, DIGYRO_CTRL4_SCALE_2000, _range \
  set __tmp_digyro_divisor, 64 \
  brcmp EQ, __SSDIG_EndIf##__I__, DIGYRO_CTRL4_SCALE_500, _range \
  set __tmp_digyro_divisor, 128 \
  __SSDIG_EndIf##__I__: \
  __IncI__ \
  replace __digyro_divisor, __digyro_divisor, _port, __tmp_digyro_divisor \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorDIGyroRaw(_port, _vector, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, DI_ADDR_GYRO, DIGYRO_REG_XLOWBURST \
  set __RLSBytesCountVar, 6 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index __RLSBytesCountVar, __RLSReadBufVar, NA \
  index __tmp_digyroVar, __RLSReadBufVar, 1 \
  mul __tmp_digyroVar, __tmp_digyroVar, 256 \
  add __tmp_digyroVar, __tmp_digyroVar, __RLSBytesCountVar \
  mov _vector.Y, __tmp_digyroVar \
  index __RLSBytesCountVar, __RLSReadBufVar, 2 \
  index __tmp_digyroVar, __RLSReadBufVar, 3 \
  mul __tmp_digyroVar, __tmp_digyroVar, 256 \
  add __tmp_digyroVar, __tmp_digyroVar, __RLSBytesCountVar \
  sub _vector.X, 0, __tmp_digyroVar \
  index __RLSBytesCountVar, __RLSReadBufVar, 4 \
  index __tmp_digyroVar, __RLSReadBufVar, 5 \
  mul __tmp_digyroVar, __tmp_digyroVar, 256 \
  add __tmp_digyroVar, __tmp_digyroVar, __RLSBytesCountVar \
  mov _vector.Z, __tmp_digyroVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, DI_ADDR_GYRO, DIGYRO_REG_XLOWBURST \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, NA \
  index __tmp_digyro##_port, __RLSReadBuf##_port, 1 \
  mul __tmp_digyro##_port, __tmp_digyro##_port, 256 \
  add __tmp_digyro##_port, __tmp_digyro##_port, __RLSBytesCount##_port \
  mov _vector.Y, __tmp_digyro##_port \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 2 \
  index __tmp_digyro##_port, __RLSReadBuf##_port, 3 \
  mul __tmp_digyro##_port, __tmp_digyro##_port, 256 \
  add __tmp_digyro##_port, __tmp_digyro##_port, __RLSBytesCount##_port \
  sub _vector.X, 0, __tmp_digyro##_port \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, 4 \
  index __tmp_digyro##_port, __RLSReadBuf##_port, 5 \
  mul __tmp_digyro##_port, __tmp_digyro##_port, 256 \
  add __tmp_digyro##_port, __tmp_digyro##_port, __RLSBytesCount##_port \
  mov _vector.Z, __tmp_digyro##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorDIGyro(_port, _vector, _result) \
  __ReadSensorDIGyroRaw(_port, _vector, _result) \
  index __tmp_digyro_divisor, __digyro_divisor, _port \
  div _vector.X, _vector.X, __tmp_digyro_divisor \
  div _vector.Y, _vector.Y, __tmp_digyro_divisor \
  div _vector.Z, _vector.Z, __tmp_digyro_divisor

#define __ReadSensorDIGyroTemperature(_port, _out, _result) \
  __MSReadValue(_port, DI_ADDR_GYRO, DIGYRO_REG_OUTTEMP, 1, _out, _result)

#define __ReadSensorDIGyroStatus(_port, _out, _result) \
  __MSReadValue(_port, DI_ADDR_GYRO, DIGYRO_REG_STATUS, 1, _out, _result)

dseg segment
  __diaccl_divisor sword[] {64, 64, 64, 64}
  __tmp_diaccl_divisor sword
  __tmp_diaccl10 sword
  __tmp_diaccl11 sword
  __tmp_diaccl12 sword
  __tmp_diaccl13 sword
  __tmp_diaccl20 sword
  __tmp_diaccl21 sword
  __tmp_diaccl22 sword
  __tmp_diaccl23 sword
  __tmp_diaccl1Var sword
  __tmp_diaccl2Var sword
  __tmp_diaccltemp sbyte
  __tmp_diacclvector TVector
dseg ends

#define __SetSensorDIAccl(_port, _mode, _result) \
  __SetSensorLowspeed(_port) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  or __RLSBytesCountVar, _mode, DIACCL_MODE_MEASURE \
  arrbuild __RLSReadBufVar, DI_ADDR_ACCL, DIACCL_REG_MODECTRL, __RLSBytesCountVar \
  set __RLSBytesCountVar, 0 \
  mov __RLSReadPort, _port \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  set __tmp_diaccl_divisor, 64 \
  brcmp EQ, __SSDIA_EndIf##__I__, DIACCL_MODE_GLVL2, _mode \
  set __tmp_diaccl_divisor, 32 \
  brcmp EQ, __SSDIA_EndIf##__I__, DIACCL_MODE_GLVL4, _mode \
  set __tmp_diaccl_divisor, 16 \
  __SSDIA_EndIf##__I__: \
  __IncI__ \
  replace __diaccl_divisor, __diaccl_divisor, _port, __tmp_diaccl_divisor \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  or __RLSBytesCount##_port, _mode, DIACCL_MODE_MEASURE \
  arrbuild __RLSReadBuf##_port, DI_ADDR_ACCL, DIACCL_REG_MODECTRL, __RLSBytesCount##_port \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  set __tmp_diaccl_divisor, 64 \
  brcmp EQ, __SSDIA_EndIf##__I__, DIACCL_MODE_GLVL2, _mode \
  set __tmp_diaccl_divisor, 32 \
  brcmp EQ, __SSDIA_EndIf##__I__, DIACCL_MODE_GLVL4, _mode \
  set __tmp_diaccl_divisor, 16 \
  __SSDIA_EndIf##__I__: \
  __IncI__ \
  replace __diaccl_divisor, __diaccl_divisor, _port, __tmp_diaccl_divisor \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorDIAcclRaw(_port, _reg, _vector, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, DI_ADDR_ACCL, _reg \
  set __RLSBytesCountVar, 6 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index __tmp_diaccl1Var, __RLSReadBufVar, NA \
  index __tmp_diaccl2Var, __RLSReadBufVar, 1 \
  mul __tmp_diaccl1Var, __tmp_diaccl1Var, 64 \
  mul __tmp_diaccl2Var, __tmp_diaccl2Var, 16384 \
  or __tmp_diaccl1Var, __tmp_diaccl1Var, __tmp_diaccl2Var \
  div __tmp_diaccl1Var, __tmp_diaccl1Var, 64 \
  mov _vector.X, __tmp_diaccl1Var \
  index __tmp_diaccl1Var, __RLSReadBufVar, 2 \
  index __tmp_diaccl2Var, __RLSReadBufVar, 3 \
  mul __tmp_diaccl1Var, __tmp_diaccl1Var, 64 \
  mul __tmp_diaccl2Var, __tmp_diaccl2Var, 16384 \
  or __tmp_diaccl1Var, __tmp_diaccl1Var, __tmp_diaccl2Var \
  div __tmp_diaccl1Var, __tmp_diaccl1Var, 64 \
  mov _vector.Y, __tmp_diaccl1Var \
  index __tmp_diaccl1Var, __RLSReadBufVar, 4 \
  index __tmp_diaccl2Var, __RLSReadBufVar, 5 \
  mul __tmp_diaccl1Var, __tmp_diaccl1Var, 64 \
  mul __tmp_diaccl2Var, __tmp_diaccl2Var, 16384 \
  or __tmp_diaccl1Var, __tmp_diaccl1Var, __tmp_diaccl2Var \
  div __tmp_diaccl1Var, __tmp_diaccl1Var, 64 \
  mov _vector.Z, __tmp_diaccl1Var \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, DI_ADDR_ACCL, _reg \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index __tmp_diaccl1##_port, __RLSReadBuf##_port, NA \
  index __tmp_diaccl2##_port, __RLSReadBuf##_port, 1 \
  mul __tmp_diaccl1##_port, __tmp_diaccl1##_port, 64 \
  mul __tmp_diaccl2##_port, __tmp_diaccl2##_port, 16384 \
  or __tmp_diaccl1##_port, __tmp_diaccl1##_port, __tmp_diaccl2##_port \
  div __tmp_diaccl1##_port, __tmp_diaccl1##_port, 64 \
  mov _vector.X, __tmp_diaccl1##_port \
  index __tmp_diaccl1##_port, __RLSReadBuf##_port, 2 \
  index __tmp_diaccl2##_port, __RLSReadBuf##_port, 3 \
  mul __tmp_diaccl1##_port, __tmp_diaccl1##_port, 64 \
  mul __tmp_diaccl2##_port, __tmp_diaccl2##_port, 16384 \
  or __tmp_diaccl1##_port, __tmp_diaccl1##_port, __tmp_diaccl2##_port \
  div __tmp_diaccl1##_port, __tmp_diaccl1##_port, 64 \
  mov _vector.Y, __tmp_diaccl1##_port \
  index __tmp_diaccl1##_port, __RLSReadBuf##_port, 4 \
  index __tmp_diaccl2##_port, __RLSReadBuf##_port, 5 \
  mul __tmp_diaccl1##_port, __tmp_diaccl1##_port, 64 \
  mul __tmp_diaccl2##_port, __tmp_diaccl2##_port, 16384 \
  or __tmp_diaccl1##_port, __tmp_diaccl1##_port, __tmp_diaccl2##_port \
  div __tmp_diaccl1##_port, __tmp_diaccl1##_port, 64 \
  mov _vector.Z, __tmp_diaccl1##_port \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorDIAccl8Raw(_port, _vector, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, DI_ADDR_ACCL, DIACCL_REG_X8 \
  set __RLSBytesCountVar, 3 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index __tmp_diaccltemp, __RLSReadBufVar, NA \
  mov _vector.X, __tmp_diaccltemp \
  index __tmp_diaccltemp, __RLSReadBufVar, 1 \
  mov _vector.Y, __tmp_diaccltemp \
  index __tmp_diaccltemp, __RLSReadBufVar, 2 \
  mov _vector.Z, __tmp_diaccltemp \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, DI_ADDR_ACCL, DIACCL_REG_X8 \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index __tmp_diaccltemp, __RLSReadBuf##_port, NA \
  mov _vector.X, __tmp_diaccltemp \
  index __tmp_diaccltemp, __RLSReadBuf##_port, 1 \
  mov _vector.Y, __tmp_diaccltemp \
  index __tmp_diaccltemp, __RLSReadBuf##_port, 2 \
  mov _vector.Z, __tmp_diaccltemp \
  release __RLSBmutex##_port \
  compend

#define __ReadSensorDIAccl(_port, _vector, _result) \
  __ReadSensorDIAcclRaw(_port, DIACCL_REG_XLOW, _vector, _result) \
  index __tmp_diaccl_divisor, __diaccl_divisor, _port \
  div _vector.X, _vector.X, __tmp_diaccl_divisor \
  div _vector.Y, _vector.Y, __tmp_diaccl_divisor \
  div _vector.Z, _vector.Z, __tmp_diaccl_divisor

#define __ReadSensorDIAccl8(_port, _vector, _result) \
  __ReadSensorDIAccl8Raw(_port, _vector, _result) \
  index __tmp_diaccl_divisor, __diaccl_divisor, _port \
  div _vector.X, _vector.X, __tmp_diaccl_divisor \
  div _vector.Y, _vector.Y, __tmp_diaccl_divisor \
  div _vector.Z, _vector.Z, __tmp_diaccl_divisor

#define __ReadSensorDIAcclStatus(_port, _out, _result) \
  __MSReadValue(_port, DI_ADDR_ACCL, DIACCL_REG_STATUS, 1, _out, _result)

#define __ReadSensorDIAcclDrift(_port, _x, _y, _z, _result) \
  __ReadSensorDIAcclRaw(_port, DIACCL_REG_XLOWDRIFT, __tmp_diacclvector, _result) \
  mov _x, __tmp_diacclvector.X \
  mov _y, __tmp_diacclvector.Y \
  mov _z, __tmp_diacclvector.Z

dseg segment
  __DIADWVar word
  __DIADW0 word
  __DIADW1 word
  __DIADW2 word
  __DIADW3 word
  __DIADB1Var byte
  __DIADB2Var byte
  __DIADB3Var byte
  __DIADB4Var byte
  __DIADB5Var byte
  __DIADB6Var byte
  __DIADB10 byte
  __DIADB20 byte
  __DIADB30 byte
  __DIADB40 byte
  __DIADB50 byte
  __DIADB60 byte
  __DIADB11 byte
  __DIADB21 byte
  __DIADB31 byte
  __DIADB41 byte
  __DIADB51 byte
  __DIADB61 byte
  __DIADB12 byte
  __DIADB22 byte
  __DIADB32 byte
  __DIADB42 byte
  __DIADB52 byte
  __DIADB62 byte
  __DIADB13 byte
  __DIADB23 byte
  __DIADB33 byte
  __DIADB43 byte
  __DIADB53 byte
  __DIADB63 byte
dseg ends

#define __SetSensorDIAcclDrift(_port, _x, _y, _z, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __DIADWVar, _x \
  and __DIADB1Var, __DIADWVar, 0xFF \
  div __DIADB2Var, __DIADWVar, 256 \
  mov __DIADWVar, _y \
  and __DIADB3Var, __DIADWVar, 0xFF \
  div __DIADB4Var, __DIADWVar, 256 \
  mov __DIADWVar, _z \
  and __DIADB5Var, __DIADWVar, 0xFF \
  div __DIADB6Var, __DIADWVar, 256 \
  arrbuild __RLSReadBufVar, DI_ADDR_ACCL, DIACCL_REG_XLOWDRIFT, __DIADB1Var, __DIADB2Var, __DIADB3Var, __DIADB4Var, __DIADB5Var, __DIADB6Var \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __DIADW##_port, _x \
  and __DIADB1##_port, __DIADW##_port, 0xFF \
  div __DIADB2##_port, __DIADW##_port, 256 \
  mov __DIADW##_port, _y \
  and __DIADB3##_port, __DIADW##_port, 0xFF \
  div __DIADB4##_port, __DIADW##_port, 256 \
  mov __DIADW##_port, _z \
  and __DIADB5##_port, __DIADW##_port, 0xFF \
  div __DIADB6##_port, __DIADW##_port, 256 \
  arrbuild __RLSReadBuf##_port, DI_ADDR_ACCL, DIACCL_REG_XLOWDRIFT, __DIADB1##_port, __DIADB2##_port, __DIADB3##_port, __DIADB4##_port, __DIADB5##_port, __DIADB6##_port \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend

dseg segment
  __tmp_vc1 float
  __tmp_vc2 float
dseg ends

#define __VectorCross(_a, _b, _out) \
  mul __tmp_vc1, _a.Y, _b.Z \
  mul __tmp_vc2, _a.Z, _b.Y \
  sub _out.X, __tmp_vc1, __tmp_vc2 \
  mul __tmp_vc1, _a.Z, _b.X \
  mul __tmp_vc2, _a.X, _b.Z \
  sub _out.Y, __tmp_vc1, __tmp_vc2 \
  mul __tmp_vc1, _a.X, _b.Y \
  mul __tmp_vc2, _a.Y, _b.X \
  sub _out.Z, __tmp_vc1, __tmp_vc2

#define __VectorDot(_a, _b, _out) \
  mul _out, _a.X, _b.X \
  mul __tmp_vc1, _a.Y, _b.Y \
  add _out, _out, __tmp_vc1 \
  mul __tmp_vc1, _a.Z, _b.Z \
  add _out, _out, __tmp_vc1

#define __VectorNormalize(_a) \
  __VectorDox(_a, _a, __tmp_vc1) \
  sqrt __tmp_vc1, __tmp_vc1 \
  div _a.X, _a.X, __tmp_vc1 \
  div _a.Y, _a.Y, __tmp_vc1 \
  div _a.Z, _a.Z, __tmp_vc1


dseg segment
  __BEBFLMutex mutex
  __BEBFLIn slong
  __BEBFLB1 byte
  __BEBFLB2 byte
  __BEBFLB3 byte
  __BEBFLB4 byte
  __BEBFLOut byte[]
dseg ends

subroutine __BEBufferFromLong
  flatten __BEBFLOut, __BEBFLIn
  index __BEBFLB1, __BEBFLOut, NA
  index __BEBFLB2, __BEBFLOut, 1
  index __BEBFLB3, __BEBFLOut, 2
  index __BEBFLB4, __BEBFLOut, 3
  arrbuild __BEBFLOut, __BEBFLB4, __BEBFLB3, __BEBFLB2, __BEBFLB1
  return
ends

dseg segment
  __DGPSWay_Buffer byte[]
  __DGPSWaymutex mutex
dseg ends

#define __SetSensorDIGPSWaypoint(_port, _lat, _long, _result) \
  acquire __DGPSWaymutex \
  acquire __BEBFLMutex \
  mov __BEBFLIn, _lat \
  call __BEBufferFromLong \
  arrbuild __DGPSWay_Buffer, DI_ADDR_DGPS, DGPS_REG_SETLATITUDE, __BEBFLOut \
  release __BEBFLMutex \
  __lowspeedWrite(_port, 0, __DGPSWay_Buffer, _result) \
  wait 150 \
  acquire __BEBFLMutex \
  mov __BEBFLIn, _long \
  call __BEBufferFromLong \
  arrbuild __DGPSWay_Buffer, DI_ADDR_DGPS, DGPS_REG_SETLONGITUDE, __BEBFLOut \
  release __BEBFLMutex \
  __lowspeedWrite(_port, 0, __DGPSWay_Buffer, _result) \
  wait 50 \
  release __DGPSWaymutex

dseg segment
  __XGAccRangeVar byte 2
  __XGAccRange0 byte 2
  __XGAccRange1 byte 2
  __XGAccRange2 byte 2
  __XGAccRange3 byte 2
  __XGTmpBufVar byte[]
  __XGTmpBuf0 byte[]
  __XGTmpBuf1 byte[]
  __XGTmpBuf2 byte[]
  __XGTmpBuf3 byte[]
  __XGErrVar byte
  __XGErr0 byte
  __XGErr1 byte
  __XGErr2 byte
  __XGErr3 byte
dseg ends

#define __ResetMIXG1300L(_port, _result) \
  __MSWriteToRegister(_port, MI_ADDR_XG1300L, XG1300L_REG_RESET, NA, _result) \
  compif EQ, isconst(_port), FALSE \
  set __XGAccRangeVar, 1 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  set __XGAccRange##_port, 1 \
  compend

#define __ReadSensorMIXG1300LScale(_port, _result) \
  compif EQ, isconst(_port), FALSE \
  mul _result, __XGAccRangeVar, 2 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  mul _result, __XGAccRange##_port, 2 \
  compend

#define __SetSensorMIXG1300LScale(_port, _scale, _result) \
  compchk EQ, (_scale==1)||(_scale==2)||(_scale==4), TRUE \
  compif EQ, isconst(_port), FALSE \
  set __XGAccRangeVar, _scale \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  set __XGAccRange##_port, _scale \
  compend \
  compif EQ, _scale, 1 \
  __MSWriteToRegister(_port, MI_ADDR_XG1300L, XG1300L_REG_2G, NA, _result) \
  compelse \
  compif EQ, _scale, 2 \
  __MSWriteToRegister(_port, MI_ADDR_XG1300L, XG1300L_REG_4G, NA, _result) \
  compelse \
  __MSWriteToRegister(_port, MI_ADDR_XG1300L, XG1300L_REG_8G, NA, _result) \
  compend \
  compend

#define __ReadSensorMIXG1300L(_port, _packet, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  mov __RLSReadBufVar, __RLSBbufLSWrite1 \
  set __RLSBytesCountVar, 10 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  arrtostr __XGTmpBufVar, __RLSReadBufVar \
  unflatten _packet, __XGErrVar, __XGTmpBufVar, _packet \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  mul _packet.XAxis, _packet.XAxis, __XGAccRangeVar \
  mul _packet.YAxis, _packet.YAxis, __XGAccRangeVar \
  mul _packet.ZAxis, _packet.ZAxis, __XGAccRangeVar \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  mov __RLSReadBuf##_port, __RLSBbufLSWrite1 \
  set __RLSBytesCount##_port, 10 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  arrtostr __XGTmpBuf##_port, __RLSReadBuf##_port \
  unflatten _packet, __XGErr##_port, __XGTmpBuf##_port, _packet \
  release __RLSBmutex##_port \
  mul _packet.XAxis, _packet.XAxis, __XGAccRange##_port \
  mul _packet.YAxis, _packet.YAxis, __XGAccRange##_port \
  mul _packet.ZAxis, _packet.ZAxis, __XGAccRange##_port \
  compend


#define __NXTServoInit(_port, _i2caddr, _servo, _result) \
  __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_INIT, _result) \
  __I2CSendCmd(_port, _i2caddr, _servo+1, _result)

#define __NXTServoGotoMacroAddress(_port, _i2caddr, _macro, _result) \
  __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_GOTO, _result) \
  __I2CSendCmd(_port, _i2caddr, _macro, _result)

#define __NXTServoEditMacro(_port, _i2caddr, _result) \
  __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_EDIT1, _result) \
  __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_EDIT2, _result)

#define __NXTHIDLoadCharacter(_port, _i2caddr, _modifier, _character, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, _modifier, _character \
  set __RLSBytesCountVar, 0 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, _modifier, _character \
  set __RLSBytesCount##_port, 0 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  release __RLSBmutex##_port \
  compend

dseg segment
  __WDSC_LSB byte
  __WDSC_MSB byte
  __WDSC_Port byte
  __WDSC_WriteBytes byte[]
  __WDSC_SensorAddress byte
  __WDSC_SensorRegister byte
  __WDSC_ByteCount byte
  __WDSC_lswArgs TCommLSWrite
  __WDSC_LSStatus sbyte
  __WDSC_Result sbyte
  __WDSCmutex mutex
  __DNRVmutex mutex
  __RDSD_Port byte
  __RDSD_SensorAddress byte
  __RDSD_SensorRegister byte
  __RDSD_NumBytesToRead byte
  __RDSD_Value sdword
  __RDSD_lswArgs TCommLSWrite
  __RDSD_lsrArgs TCommLSRead
  __RDSD_LSStatus sbyte
  __RDSD_bytesRead sdword
  __RDSD_PreviousValue sdword
  __RDSD_Byte byte
dseg ends

#define __MSWriteToRegister(_port, _i2caddr, _reg, _bytes, _result) \
  acquire __WDSCmutex \
  mov __WDSC_Port, _port \
  mov __WDSC_SensorAddress, _i2caddr \
  set __WDSC_SensorRegister, _reg \
  compif EQ, valueof(_bytes), NA \
  arrinit __WDSC_WriteBytes, 0, 0 \
  compelse \
  arrbuild __WDSC_WriteBytes, _bytes \
  compend \
  call __MSWriteBytesSub \
  mov _result, __WDSC_LSStatus \
  release __WDSCmutex

#define __MSWriteLEIntToRegister(_port, _i2caddr, _reg, _ival, _result) \
  acquire __WDSCmutex \
  mov __WDSC_Port, _port \
  mov __WDSC_SensorAddress, _i2caddr \
  set __WDSC_SensorRegister, _reg \
  and __WDSC_LSB, _ival, 0xFF \
  div __WDSC_MSB, _ival, 0xFF \
  arrbuild __WDSC_WriteBytes, __WDSC_LSB, __WDSC_MSB \
  call __MSWriteBytesSub \
  mov _result, __WDSC_LSStatus \
  release __WDSCmutex

#define __I2CSendCmd(_port, _i2caddr, _cmd, _result) \
  __MSWriteToRegister(_port, _i2caddr, I2C_REG_CMD, _cmd, _result)

#define __TempSendCmd(_port, _cmd, _result) \
  __MSWriteToRegister(_port, LEGO_ADDR_TEMP, TEMP_REG_CONFIG, _cmd, _result)

#define __MSReadValue(_port, _i2caddr, _reg, _bytes, _out, _result) \
  acquire __DNRVmutex \
  mov __RDSD_Port, _port \
  mov __RDSD_SensorAddress, _i2caddr \
  mov __RDSD_SensorRegister, _reg \
  set __RDSD_NumBytesToRead, _bytes \
  call __MSReadLEValueSub \
  mov _out, __RDSD_Value \
  mov _result, __RDSD_LSStatus \
  release __DNRVmutex

#define __ReadI2CBEValue(_port, _i2caddr, _reg, _bytes, _out, _result) \
  acquire __DNRVmutex \
  mov __RDSD_Port, _port \
  mov __RDSD_SensorAddress, _i2caddr \
  mov __RDSD_SensorRegister, _reg \
  set __RDSD_NumBytesToRead, _bytes \
  call __MSReadBEValueSub \
  mov _out, __RDSD_Value \
  mov _result, __RDSD_LSStatus \
  release __DNRVmutex

subroutine __RFIDReadContinuousSub
  __RFIDInit(__RFIDCont_Port, __RFIDCont_Result)
  wait 15
  __RFIDStatus(__RFIDCont_Port, __RFIDCont_Result)
  brtst GT, __RFIDCont_Endif, __RFIDCont_Result
  __RFIDMode(__RFIDCont_Port, RFID_MODE_CONTINUOUS, __RFIDCont_Result)
  wait 250
__RFIDCont_Endif:
  __RFIDRead(__RFIDCont_Port, __RFIDCont_Output, __RFIDCont_Result)
  return
ends

subroutine __MSWriteBytesSub
  or __WDSC_lswArgs.Port, __WDSC_Port, __LSWriteOptionsVar
  arrbuild __WDSC_lswArgs.Buffer, __WDSC_SensorAddress, __WDSC_SensorRegister, __WDSC_WriteBytes
  set __WDSC_lswArgs.ReturnLen, 0
  syscall CommLSWrite, __WDSC_lswArgs
__WDSC_StatusLoop:
  __lowspeedCheckStatus(__WDSC_Port, __WDSC_LSStatus)
  brtst GT, __WDSC_StatusLoop, __WDSC_LSStatus
  return
ends

subroutine __MSReadLEValueSub
  or __RDSD_lswArgs.Port, __RDSD_Port, __LSWriteOptionsVar
  arrbuild __RDSD_lswArgs.Buffer, __RDSD_SensorAddress, __RDSD_SensorRegister
  mov __RDSD_lswArgs.ReturnLen, __RDSD_NumBytesToRead
  syscall CommLSWrite, __RDSD_lswArgs
__RDSD_CheckStatusAfterWriteLoop:
  __lowspeedCheckStatus(__RDSD_Port, __RDSD_LSStatus)
  brtst GT, __RDSD_CheckStatusAfterWriteLoop, __RDSD_LSStatus
  brtst EQ, __RDSD_GoAheadWithRead, __RDSD_LSStatus
  jmp __RDSD_ReadError
__RDSD_GoAheadWithRead:
  mov __RDSD_lsrArgs.Port, __RDSD_Port
  mov __RDSD_lsrArgs.BufferLen, __RDSD_NumBytesToRead
  syscall CommLSRead, __RDSD_lsrArgs
__RDSD_CheckStatusAfterReadLoop:
  __lowspeedCheckStatus(__RDSD_Port, __RDSD_LSStatus)
  brtst GT, __RDSD_CheckStatusAfterReadLoop, __RDSD_LSStatus
  arrsize __RDSD_bytesRead, __RDSD_lsrArgs.Buffer
  brcmp NEQ, __RDSD_ReadError, __RDSD_bytesRead, __RDSD_NumBytesToRead
  brtst EQ, __RDSD_GoAheadAndCalculateValue, __RDSD_LSStatus
__RDSD_ReadError:
  mov __RDSD_Value, __RDSD_PreviousValue
  jmp __RDSD_ReturnResults
__RDSD_GoAheadAndCalculateValue:
  set __RDSD_Value, 0
  brcmp EQ, __RDSD_OneByte, __RDSD_NumBytesToRead, 1
  brcmp EQ, __RDSD_TwoBytes, __RDSD_NumBytesToRead, 2
  brcmp EQ, __RDSD_ThreeBytes, __RDSD_NumBytesToRead, 3
  brcmp NEQ, __RDSD_ReadError, __RDSD_NumBytesToRead, 4
  index __RDSD_Byte, __RDSD_lsrArgs.Buffer, 3
  mul __RDSD_Value, __RDSD_Byte, 256
__RDSD_ThreeBytes:
  index __RDSD_Byte, __RDSD_lsrArgs.Buffer, 2
  add __RDSD_Value, __RDSD_Value, __RDSD_Byte
  mul __RDSD_Value, __RDSD_Value, 256
__RDSD_TwoBytes:
  index __RDSD_Byte, __RDSD_lsrArgs.Buffer, 1
  add __RDSD_Value, __RDSD_Value, __RDSD_Byte
  mul __RDSD_Value, __RDSD_Value, 256
__RDSD_OneByte:
  index __RDSD_Byte, __RDSD_lsrArgs.Buffer, NA
  add __RDSD_Value, __RDSD_Value, __RDSD_Byte
  mov __RDSD_PreviousValue, __RDSD_Value
__RDSD_ReturnResults:
  return
ends

subroutine __MSReadBEValueSub
  or __RDSD_lswArgs.Port, __RDSD_Port, __LSWriteOptionsVar
  arrbuild __RDSD_lswArgs.Buffer, __RDSD_SensorAddress, __RDSD_SensorRegister
  mov __RDSD_lswArgs.ReturnLen, __RDSD_NumBytesToRead
  syscall CommLSWrite, __RDSD_lswArgs
__RDSD_CheckStatusAfterWriteLoop:
  __lowspeedCheckStatus(__RDSD_Port, __RDSD_LSStatus)
  brtst GT, __RDSD_CheckStatusAfterWriteLoop, __RDSD_LSStatus
  brtst EQ, __RDSD_GoAheadWithRead, __RDSD_LSStatus
  jmp __RDSD_ReadError
__RDSD_GoAheadWithRead:
  mov __RDSD_lsrArgs.Port, __RDSD_Port
  mov __RDSD_lsrArgs.BufferLen, __RDSD_NumBytesToRead
  syscall CommLSRead, __RDSD_lsrArgs
__RDSD_CheckStatusAfterReadLoop:
  __lowspeedCheckStatus(__RDSD_Port, __RDSD_LSStatus)
  brtst GT, __RDSD_CheckStatusAfterReadLoop, __RDSD_LSStatus
  arrsize __RDSD_bytesRead, __RDSD_lsrArgs.Buffer
  brcmp NEQ, __RDSD_ReadError, __RDSD_bytesRead, __RDSD_NumBytesToRead
  brtst EQ, __RDSD_GoAheadAndCalculateValue, __RDSD_LSStatus
__RDSD_ReadError:
  mov __RDSD_Value, __RDSD_PreviousValue
  jmp __RDSD_ReturnResults
__RDSD_GoAheadAndCalculateValue:
  set __RDSD_Value, 0
  index __RDSD_Byte, __RDSD_lsrArgs.Buffer, NA
  mov __RDSD_Value, __RDSD_Byte
  brcmp EQ, __RDSD_ReturnResults, __RDSD_NumBytesToRead, 1
  mul __RDSD_Value, __RDSD_Value, 256
  index __RDSD_Byte, __RDSD_lsrArgs.Buffer, 1
  add __RDSD_Value, __RDSD_Value, __RDSD_Byte
  brcmp EQ, __RDSD_ReturnResults, __RDSD_NumBytesToRead, 2
  mul __RDSD_Value, __RDSD_Value, 256
  index __RDSD_Byte, __RDSD_lsrArgs.Buffer, 2
  add __RDSD_Value, __RDSD_Value, __RDSD_Byte
  brcmp EQ, __RDSD_ReturnResults, __RDSD_NumBytesToRead, 3
  mul __RDSD_Value, __RDSD_Value, 256
  index __RDSD_Byte, __RDSD_lsrArgs.Buffer, 3
  add __RDSD_Value, __RDSD_Value, __RDSD_Byte
  brcmp NEQ, __RDSD_ReadError, __RDSD_NumBytesToRead, 4
  mov __RDSD_PreviousValue, __RDSD_Value
__RDSD_ReturnResults:
  return
ends

#define __ReadSensorMSPlayStation(_port, _i2caddr, _b1, _b2, _xleft, _yleft, _xright, _yright, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, PSP_REG_BTNSET1 \
  set __RLSBytesCountVar, 6 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _b1, __RLSReadBufVar, NA \
  index _b2, __RLSReadBufVar, 1 \
  index _xleft, __RLSReadBufVar, 2 \
  index _yleft, __RLSReadBufVar, 3 \
  index _xright, __RLSReadBufVar, 4 \
  index _yright, __RLSReadBufVar, 5 \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, PSP_REG_BTNSET1 \
  set __RLSBytesCount##_port, 6 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _b1, __RLSReadBuf##_port, NA \
  index _b2, __RLSReadBuf##_port, 1 \
  index _xleft, __RLSReadBuf##_port, 2 \
  index _yleft, __RLSReadBuf##_port, 3 \
  index _xright, __RLSReadBuf##_port, 4 \
  index _yright, __RLSReadBuf##_port, 5 \
  release __RLSBmutex##_port \
  compend

#define __RunNRLinkMacro(_port, _i2caddr, _macro, _result) \
  acquire __WDSCmutex \
  mov __WDSC_Port, _port \
  mov __WDSC_SensorAddress, _i2caddr \
  arrbuild __WDSC_WriteBytes, NRLINK_CMD_RUN_MACRO, _macro \
  call __MSWriteBytesSub \
  mov _result, __WDSC_LSStatus \
  release __WDSCmutex

#define __ReadNRLinkStatus(_port, _i2caddr, _value, _result) \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, I2C_REG_CMD \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  index _value, __RLSReadBufVar, NA \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, I2C_REG_CMD \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  index _value, __RLSReadBuf##_port, NA \
  release __RLSBmutex##_port \
  compend

#define __WriteNRLinkBytes(_port, _i2caddr, _bytes, _result) \
  __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_FLUSH, _result) \
  __MSWriteToRegister(_port, _i2caddr, NRLINK_REG_DATA, _bytes, _result) \
  arrsize __WDSC_ByteCount, _bytes \
  __MSWriteToRegister(_port, _i2caddr, NRLINK_REG_BYTES, __WDSC_ByteCount, _result)

#define __ReadNRLinkBytes(_port, _i2caddr, _bytes, _result) \
  acquire __DNRVmutex \
  compif EQ, isconst(_port), FALSE \
  acquire __RLSBmutex0 \
  acquire __RLSBmutex1 \
  acquire __RLSBmutex2 \
  acquire __RLSBmutex3 \
  mov __RLSReadPort, _port \
  arrbuild __RLSReadBufVar, _i2caddr, NRLINK_REG_BYTES \
  set __RLSBytesCountVar, 1 \
  call __ReadLSBytesVar \
  index __RLSBytesCountVar, __RLSReadBufVar, NA \
  arrbuild __RLSReadBufVar, _i2caddr, NRLINK_REG_DATA \
  call __ReadLSBytesVar \
  tst EQ, _result, __RLSBResultVar \
  mov _bytes, __RLSReadBufVar \
  release __RLSBmutex0 \
  release __RLSBmutex1 \
  release __RLSBmutex2 \
  release __RLSBmutex3 \
  compelse \
  compchk LT, _port, 0x04 \
  compchk GTEQ, _port, 0x00 \
  acquire __RLSBmutex##_port \
  arrbuild __RLSReadBuf##_port, _i2caddr, NRLINK_REG_BYTES \
  set __RLSBytesCount##_port, 1 \
  call __ReadLSBytes##_port \
  index __RLSBytesCount##_port, __RLSReadBuf##_port, NA \
  arrbuild __RLSReadBuf##_port, _i2caddr, NRLINK_REG_DATA \
  call __ReadLSBytes##_port \
  tst EQ, _result, __RLSBResult##_port \
  mov _bytes, __RLSReadBuf##_port \
  release __RLSBmutex##_port \
  compend \
  __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_FLUSH, _result) \
  release __DNRVmutex

dseg segment
  __MSPFByte1 byte
  __MSPFByte2 byte
dseg ends

subroutine __MSPowerFunctionCalcBytes
  call __PFCalcChecksum
  // build __PFBytes using two values calculated from the __PFNibbles
  index __MSPFByte1, __PFNibbles, NA
  index __PFTmp, __PFNibbles, 1
  mul __MSPFByte1, __MSPFByte1, 16
  add __MSPFByte1, __MSPFByte1, __PFTmp
  index __MSPFByte2, __PFNibbles, 2
  index __PFTmp, __PFNibbles, 3
  mul __MSPFByte2, __MSPFByte2, 16
  add __MSPFByte2, __MSPFByte2, __PFTmp
  arrbuild __PFBytes, __MSPFByte1, __MSPFByte2
  return
ends

#define __MSPFComboDirect(_port, _i2caddr, _channel, _outa, _outb, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _outa, 4 \
  mod __PF_p3, _outb, 4 \
  call __PFComboDirectSub \
  set __PFPowerFuncMode, TRUE \
  call __MSPowerFunctionCalcBytes \
  __WriteNRLinkBytes(_port, _i2caddr, __PFBytes, _result) \
  release __PFMutex

#define __MSPFSinglePin(_port, _i2caddr, _channel, _out, _pin, _func, _cont, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _out, 2 \
  mod __PF_p3, _pin, 2 \
  mod __PF_p4, _func, 4 \
  set __PF_p5, _cont \
  call __PFSinglePinSub \
  set __PFPowerFuncMode, TRUE \
  call __MSPowerFunctionCalcBytes \
  __WriteNRLinkBytes(_port, _i2caddr, __PFBytes, _result) \
  release __PFMutex

#define __MSPFSingleOutput(_port, _i2caddr, _channel, _out, _func, _cst, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _out, 2 \
  mod __PF_p3, _func, 16 \
  set __PF_p4, _cst \
  call __PFSingleOutputSub \
  set __PFPowerFuncMode, TRUE \
  call __MSPowerFunctionCalcBytes \
  __WriteNRLinkBytes(_port, _i2caddr, __PFBytes, _result) \
  release __PFMutex

#define __MSPFComboPWM(_port, _i2caddr, _channel, _outa, _outb, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _outa, 16 \
  mod __PF_p3, _outb, 16 \
  call __PFComboPWMSub \
  set __PFPowerFuncMode, TRUE \
  call __MSPowerFunctionCalcBytes \
  __WriteNRLinkBytes(_port, _i2caddr, __PFBytes, _result) \
  release __PFMutex

#define __MSIRTrain(_port, _i2caddr, _channel, _func, _PFMode, _result) \
  acquire __PFMutex \
  mod __PF_p1, _channel, 4 \
  mod __PF_p2, _func, 5 \
  compif EQ, _PFMode, TRUE \
  call __PFTrainSub \
  compelse \
  call __RCTrainSub \
  compend \
  set __PFPowerFuncMode, _PFMode \
  call __MSPowerFunctionCalcBytes \
  __WriteNRLinkBytes(_port, _i2caddr, __PFBytes, _result) \
  release __PFMutex

#define __MSPFRawOutput(_port, _i2caddr, _nibble0, _nibble1, _nibble2, _result) \
  acquire __PFMutex \
  mod __PF_p1, _nibble0, 16 \
  mod __PF_p2, _nibble1, 16 \
  mod __PF_p3, _nibble2, 16 \
  call __PFRawOutputSub \
  set __PFPowerFuncMode, TRUE \
  call __MSPowerFunctionCalcBytes \
  __WriteNRLinkBytes(_port, _i2caddr, __PFBytes, _result) \
  release __PFMutex

#define __MSPFRepeatLastCommand(_port, _i2caddr, _count, _delay, _result) \
  acquire __PFMutex \
  mov __PF_p1, _count \
  __MSPFRepeatLoop##__I__: \
  __WriteNRLinkBytes(_port, _i2caddr, __PFBytes, _result) \
  waitv _delay \
  sub __PF_p1, __PF_p1, 1 \
  brtst GT, __MSPFRepeatLoop##__I__, __PF_p1 \
  release __PFMutex \
  __IncI__

subroutine __MSRCXCommandSub
  dseg segment
    __MSRCSToggle byte
    __MSRCSI byte
    __MSRCSInCmd byte[]
    __MSRCSTmpBuf byte[]
    __MSRCSCmdBytes sbyte
    __MSRCSCmd byte
    __MSRCSCSum byte
    __MSRCSMsgBufSize byte
    __MSRCSTmpByte byte
    __MSRCSTmpSByte sbyte
    __MSRCSTmpWord word
    __MSRCSTmpByte2 byte
    __MSRCSResult byte
  dseg ends
  arrsize __MSRCSCmdBytes, __gRCXCmd.Command
  index __MSRCSCmd, __gRCXCmd.Command, NA
  set __MSRCSCSum, 0

  // build the message
  set __MSRCSMsgBufSize, 2
  mul __MSRCSMsgBufSize, __MSRCSMsgBufSize, __MSRCSCmdBytes
  add __MSRCSMsgBufSize, __MSRCSMsgBufSize, 5

  arrinit __MSRCSInCmd, 0, __MSRCSMsgBufSize
  replace __MSRCSInCmd, __MSRCSInCmd, NA, 0x55
  replace __MSRCSInCmd, __MSRCSInCmd, 1, 0xFF
  replace __MSRCSInCmd, __MSRCSInCmd, 2, 0x00
  // add cmd and ~cmd bytes
  or __MSRCSTmpByte, __MSRCSCmd, __MSRCSToggle
  replace __MSRCSInCmd, __MSRCSInCmd, 3, __MSRCSTmpByte
  mov __MSRCSCSum, __MSRCSTmpByte
  sub __MSRCSTmpByte, 0xFF, __MSRCSCSum
  replace __MSRCSInCmd, __MSRCSInCmd, 4, __MSRCSTmpByte

  set __MSRCSI, 0
  xor __MSRCSToggle, __MSRCSToggle, 8

  brcmp LTEQ, __MSRCSEndWhileILTCmdBytes, __MSRCSCmdBytes, 1

__MSRCSWhileILTCmdBytes:
  sub __MSRCSTmpByte, __MSRCSCmdBytes, 1
  brcmp GTEQ, __MSRCSEndWhileILTCmdBytes, __MSRCSI, __MSRCSTmpByte
  add __MSRCSTmpByte, __MSRCSI, 1
  index __MSRCSTmpByte2, __gRCXCmd.Command, __MSRCSTmpByte
  mul __MSRCSTmpByte, __MSRCSI, 2
  add __MSRCSTmpByte, __MSRCSTmpByte, 5
  replace __MSRCSInCmd, __MSRCSInCmd, __MSRCSTmpByte, __MSRCSTmpByte2
  // calculate checksum
  add __MSRCSCSum, __MSRCSCSum, __MSRCSTmpByte2
  add __MSRCSTmpByte, __MSRCSTmpByte, 1
  sub __MSRCSTmpByte2, 255, __MSRCSTmpByte2
  replace __MSRCSInCmd, __MSRCSInCmd, __MSRCSTmpByte, __MSRCSTmpByte2
  add __MSRCSI, __MSRCSI, 1
  jmp __MSRCSWhileILTCmdBytes
__MSRCSEndWhileILTCmdBytes:

  // add the two checksum bytes
  mul __MSRCSTmpByte, __MSRCSI, 2
  add __MSRCSTmpByte, __MSRCSTmpByte, 5
  replace __MSRCSInCmd, __MSRCSInCmd, __MSRCSTmpByte, __MSRCSCSum
  sub __MSRCSTmpByte2, 255, __MSRCSCSum
  add __MSRCSTmpByte, __MSRCSTmpByte, 1
  replace __MSRCSInCmd, __MSRCSInCmd, __MSRCSTmpByte, __MSRCSTmpByte2

  // if the size of __MSRCSInCmd > 14 then we need to chunk up the transmission
  mov __MSRCSTmpSByte, __MSRCSMsgBufSize
__MSRCSWhileMsgBufSizeGTZero:
  arrsubset __gRCXCmd.Command, __MSRCSInCmd, NA, 14
  arrbuild __MSRCSTmpBuf, __gRCXCmd.Address, 0x42, __gRCXCmd.Command
  // write message bytes to the NRLink device
  __WriteNRLinkBytes(__gRCXCmd.Port, __gRCXCmd.Address, __MSRCSTmpBuf, __MSRCSResult)
  sub __MSRCSTmpSByte, __MSRCSTmpSByte, 14
  brtst LTEQ, __MSRCSEndWhileMsgBufSizeGTZero, __MSRCSTmpSByte
  arrsubset __MSRCSTmpBuf, __MSRCSInCmd, 14, NA
  mov __MSRCSInCmd, __MSRCSTmpBuf
  jmp __MSRCSWhileMsgBufSizeGTZero
__MSRCSEndWhileMsgBufSizeGTZero:

  // Now send the IR message
  arrbuild __MSRCSTmpBuf, __gRCXCmd.Address, 0x40, __MSRCSMsgBufSize
  __WriteNRLinkBytes(__gRCXCmd.Port, __gRCXCmd.Address, __MSRCSTmpBuf, __MSRCSResult)

  // give the message time to be transferred
  mul __MSRCSTmpWord, __MSRCSMsgBufSize, 5
  waitv __MSRCSTmpWord

  // do we need to read a response?
  brtst EQ, __MSRCSNoResponse, __gRCXCmd.ResponseBytes

  // give the message time to be transferred
  add __MSRCSTmpWord, __MSRCSMsgBufSize, __gRCXCmd.ResponseBytes
  mul __MSRCSTmpWord, __MSRCSTmpWord, 5
  waitv __MSRCSTmpWord

  // read the response
  __ReadNRLinkBytes(__gRCXCmd.Port, __gRCXCmd.Address, __gRCXCmd.Response, __MSRCSResult)

__MSRCSNoResponse:
  return
ends


#define __MSRCXSetNRLink(_port, _i2caddr) \
  set __gRCXCmd.Port, _port \
  set __gRCXCmd.Address, _i2caddr

#define __MSRCXPoll(_src, _value, _result) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_PollOp, _src, _value \
  set __gRCXCmd.ResponseBytes, 12 \
  call __MSRCXCommandSub \
  index _result, __gRCXCmd.Response, 4 \
  index __MSRCSTmpByte, __gRCXCmd.Response, 2 \
  mul _result, _result, 256 \
  add _result, _result, __MSRCSTmpByte \
  release __RCXCmdMutex

#define __MSRCXBatteryLevel(_result) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_BatteryLevelOp \
  set __gRCXCmd.ResponseBytes, 12 \
  call __MSRCXCommandSub \
  index _result, __gRCXCmd.Response, 4 \
  index __MSRCSTmpByte, __gRCXCmd.Response, 2 \
  mul _result, _result, 256 \
  add _result, _result, __MSRCSTmpByte \
  release __RCXCmdMutex

#define __MSRCXOpNoArgs(_op) \
  acquire __RCXCmdMutex \
  arrinit __gRCXCmd.Command, _op, 1 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetOutput(_outputs, _mode) \
  acquire __RCXCmdMutex \
  add __RCSTmpByte, _outputs, _mode \
  arrbuild __gRCXCmd.Command, RCX_OnOffFloatOp, __RCSTmpByte \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetDirection(_outputs, _dir) \
  acquire __RCXCmdMutex \
  add __RCSTmpByte, _outputs, _dir \
  arrbuild __gRCXCmd.Command, RCX_OutputDirOp, __RCSTmpByte \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetPower(_outputs, _pwrsrc, _pwrval) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_OutputPowerOp, _outputs, _pwrsrc, _pwrval \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXOnFwd(_outputs) \
  __MSRCXSetDirection(_outputs, RCX_OUT_FWD) \
  __MSRCXSetOutput(_outputs, RCX_OUT_ON)

#define __MSRCXOnRev(_outputs) \
  __MSRCXSetDirection(_outputs, RCX_OUT_REV) \
  __MSRCXSetOutput(_outputs, RCX_OUT_ON)

#define __MSRCXOnFor(_outputs, _ms) \
  __MSRCXSetOutput(_outputs, RCX_OUT_ON) \
  waitv _ms \
  __MSRCXSetOutput(_outputs, RCX_OUT_OFF)

#define __MSRCXSetTxPower(_pwr) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_IRModeOp, _pwr \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXPlaySound(_snd) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_PlaySoundOp, _snd \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXDeleteTask(_t) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_DeleteTaskOp, _t \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXStartTask(_t) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_StartTaskOp, _t \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXStopTask(_t) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_StopTaskOp, _t \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSelectProgram(_prog) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SelectProgramOp, _prog \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXClearTimer(_timer) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ClearTimerOp, _timer \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetSleepTime(_t) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_AutoOffOp, _t \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXDeleteSub(_s) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_DeleteSubOp, _s \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXClearSensor(_port) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ClearSensorOp, _port \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXPlayToneVar(_varnum, _duration) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_PlayToneVarOp, _varnum, _duration \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetWatch(_hours, _minutes) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SetWatchOp, _hours, _minutes \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetSensorType(_port, _type) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_InputTypeOp, _port, _type \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetSensorMode(_port, _mode) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_InputModeOp, _port, _mode \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXCreateDatalog(_size) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _size, 0xFF \
  div __MSRCSTmpByte2, _size, 256 \
  arrbuild __gRCXCmd.Command, RCX_SetDatalogOp, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXAddToDatalog(_src, _value) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_DatalogOp, _src, _value \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSendSerial(_first, _count) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SendUARTDataOp, _first, _count \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXRemote(_cmd) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _cmd, 0xFF \
  div __MSRCSTmpByte2, _cmd, 256 \
  arrbuild __gRCXCmd.Command, RCX_RemoteOp, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXEvent(_src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_DirectEventOp, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXPlayTone(_freq, _duration) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _freq, 0xFF \
  div __MSRCSTmpByte2, _freq, 256 \
  arrbuild __gRCXCmd.Command, RCX_PlayToneOp, __MSRCSTmpByte, __MSRCSTmpByte2, _duration \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSelectDisplay(_src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_DisplayOp, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXPollMemory(_memaddress, _result) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _memaddress, 0xFF \
  div __MSRCSTmpByte2, _memaddress, 256 \
  arrbuild __gRCXCmd.Command, RCX_PollMemoryOp, __MSRCSTmpByte, __MSRCSTmpByte2, 1 \
  set __gRCXCmd.ResponseBytes, 12 \
  call __MSRCXCommandSub \
  index _result, __gRCXCmd.Response, 4 \
  index __MSRCSTmpByte, __gRCXCmd.Response, 2 \
  mul _result, _result, 256 \
  add _result, _result, __MSRCSTmpByte \
  release __RCXCmdMutex

#define __MSRCXSetEvent(_evt, _src, _type) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SetEventOp, _evt, _src, _type \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetGlobalOutput(_outputs, _mode) \
  acquire __RCXCmdMutex \
  add __MSRCSTmpByte, _outputs, _mode \
  arrbuild __gRCXCmd.Command, RCX_GOutputModeOp, __MSRCSTmpByte \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetGlobalDirection(_outputs, _dir) \
  acquire __RCXCmdMutex \
  add __MSRCSTmpByte, _outputs, _dir \
  arrbuild __gRCXCmd.Command, RCX_GOutputDirOp, __MSRCSTmpByte \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetMaxPower(_outputs, _pwrsrc, _pwrval) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_GOutputPowerOp, _outputs, _pwrsrc, _pwrval \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXCalibrateEvent(_evt, _low, _hi, _hyst) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_CalibrateEventOp, _evt, _low, _hi, _hyst \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __RCXVarOp(_op, _vnum, _src, _val) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _val, 0xFF \
  div __MSRCSTmpByte2, _val, 256 \
  arrbuild __gRCXCmd.Command, _op, _vnum, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSet(_dstsrc, _dstval, _src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_SetSourceValueOp, _dstsrc, _dstval, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXUnlock() \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_UnlockOp, 1, 3, 5, 7, 11 \
  set __gRCXCmd.ResponseBytes, 16 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXReset() \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_BootModeOp, 1, 3, 5, 7, 11 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXBoot() \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_UnlockFirmOp, 0x4c, 0x45, 0x47, 0x4F, 0xAE \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetUserDisplay(_src, _value, _precision) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_ViewSourceValOp, 0, _precision, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXIncCounter(_counter) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_IncCounterOp, _counter \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXDecCounter(_counter) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_DecCounterOp, _counter \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXClearCounter(_counter) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ClearCounterOp, _counter \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetPriority(_p) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SetPriorityOp, _p \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSRCXSetMessage(_msg) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_MessageOp, _msg \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetScoutMode(_mode) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ScoutOp, _mode \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetScoutRules(_m, _t, _l, _tm, _fx) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_ScoutRulesOp, _m, _t, _l, _tm, _fx \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSendVLL(_src, _value) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_VLLOp, _src, _value \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetSensorClickTime(_src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_LSBlinkTimeOp, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetSensorHysteresis(_src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_LSHysteresisOp, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetSensorLowerLimit(_src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_LSLowerThreshOp, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetSensorUpperLimit(_src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_LSUpperThreshOp, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetEventFeedback(_src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_SetFeedbackOp, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetCounterLimit(_ctr, _src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_SetCounterOp, _ctr, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetTimerLimit(_tmr, _src, _value) \
  acquire __RCXCmdMutex \
  and __MSRCSTmpByte, _value, 0xFF \
  div __MSRCSTmpByte2, _value, 256 \
  arrbuild __gRCXCmd.Command, RCX_SetTimerLimitOp, _tmr, _src, __MSRCSTmpByte, __MSRCSTmpByte2 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutMuteSound() \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SoundOp, 0x80 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutUnmuteSound() \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SoundOp, 0xc0 \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSelectSounds(_grp) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_SoundOp, _grp \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __MSScoutSetLight(_x) \
  acquire __RCXCmdMutex \
  arrbuild __gRCXCmd.Command, RCX_LightOp, _x \
  set __gRCXCmd.ResponseBytes, 0 \
  call __MSRCXCommandSub \
  release __RCXCmdMutex

#define __glInit()                                                                             \
         call     __GL_glInit

#define __glSet(_glType, _glValue)                                                             \
         mov      __GL_glSettingType,         _glType                                          \
         mov      __GL_glSettingValue,        _glValue                                         \
         call     __GL_glSet

#define __glBeginObject(_glObjId)                                                              \
         mov      __GL_object.firstVertex,    __GL_vertexCount                                 \
         mov      __GL_object.lastVertex,     __GL_vertexCount                                 \
         mov      __GL_object.firstPolygon,   __GL_polygonCount                                \
         mov      _glObjId,                   __GL_objectCount

#define __glEndObject()                                                                        \
         call     __GL_glEndObject

#define __glObjectAction(_glObjectId, _glAction, _glValue)                                     \
         mov      __GL_objectIndex,           _glObjectId                                      \
         mov      __GL_action,                _glAction                                        \
         mov      __GL_value,                 _glValue                                         \
         call     __GL_glObjectAction

#define __glAddVertex(_glX, _glY, _glZ)                                                        \
         mov      __GL_vertex0.orig.x,        _glX                                             \
         mov      __GL_vertex0.orig.y,        _glY                                             \
         mov      __GL_vertex0.orig.z,        _glZ                                             \
         call     __GL_glAddVertex

#define __glBegin(_glBeginMode)                                                                \
         mov      __GL_polygon.beginMode,     _glBeginMode                                     \
         mov      __GL_polygon.firstVertex,   __GL_pvDataCount                                 \
         mov      __GL_polygon.lastVertex,    __GL_pvDataCount

#define __glEnd()                                                                              \
         call     __GL_glEnd

#define __glBeginRender()                                                                      \
         call     __GL_glResetObjects

#define __glCallObject(_glObjectId)                                                            \
         mov      __GL_objectIndex,           _glObjectId                                      \
         call     __GL_glCallObject

#define __glFinishRender()                                                                     \
         call     __GL_glRotateVertexList                                                      \
         set      __GL_glDrawPoint.Location.X, 200                                             \
         set      __GL_glDrawPoint.Options,    DRAW_OPT_CLEAR_WHOLE_SCREEN                     \
         syscall  DrawPoint,                   __GL_glDrawPoint                                \
         call     __GL_glRenderObjects

#define __glSetAngleX(_glValue)                                                                \
         add      __GL_angleX,                _glValue,    3600                                \
         mod      __GL_angleX,                __GL_angleX, 360

#define __glAddToAngleX(_glValue)                                                              \
         add      __GL_angleX,                __GL_angleX, _glValue                            \
         add      __GL_angleX,                __GL_angleX, 3600                                \
         mod      __GL_angleX,                __GL_angleX, 360

#define __glSetAngleY(_glValue)                                                                \
         add      __GL_angleY,                _glValue,    3600                                \
         mod      __GL_angleY,                __GL_angleY, 360

#define __glAddToAngleY(_glValue)                                                              \
         add      __GL_angleY,                __GL_angleY, _glValue                            \
         add      __GL_angleY,                __GL_angleY, 3600                                \
         mod      __GL_angleY,                __GL_angleY, 360

#define __glSetAngleZ(_glValue)                                                                \
         add      __GL_angleZ,                _glValue,    3600                                \
         mod      __GL_angleZ,                __GL_angleZ, 360

#define __glAddToAngleZ(_glValue)                                                              \
         add      __GL_angleZ,                __GL_angleZ, _glValue                            \
         add      __GL_angleZ,                __GL_angleZ, 3600                                \
         mod      __GL_angleZ,                __GL_angleZ, 360

#define __glSin32768(_glAngle, _glResult)                                                      \
         mov      __GL_angle,                 _glAngle                                         \
         mod      __GL_angle,                 __GL_angle, 360                                  \
         index    _glResult,                  __GL_SIN_TABLE, __GL_angle

#define __glCos32768(_glAngle, _glResult)                                                      \
         mov      __GL_angle,                 _glAngle                                         \
         add      __GL_angle,                 __GL_angle, 90                                   \
         mod      __GL_angle,                 __GL_angle, 360                                  \
         index    _glResult,                  __GL_SIN_TABLE, __GL_angle

#define __glBox(_glMode, _glSizeX, _glSizeY, _glSizeZ, _glObjId)                               \
         mov      __GL_mode                   _glMode                                          \
         mov      __GL_sizeX                  _glSizeX                                         \
         mov      __GL_sizeY                  _glSizeY                                         \
         mov      __GL_sizeZ                  _glSizeZ                                         \
         call     __GL_glBox                                                                   \
         mov      _glObjId,                   __GL_tmpId

#define __glPyramid(_glMode, _glSizeX, _glSizeY, _glSizeZ, _glObjId)                           \
         mov      __GL_mode                   _glMode                                          \
         mov      __GL_sizeX                  _glSizeX                                         \
         mov      __GL_sizeY                  _glSizeY                                         \
         mov      __GL_sizeZ                  _glSizeZ                                         \
         call     __GL_glPyramid                                                               \
         mov      _glObjId,                   __GL_tmpId

//-----------------------------------------------------------------------------------------
//
// Private definitions...
//
//-----------------------------------------------------------------------------------------
#define __glRangeCheck(_glValue, _glMaxValue, _glErrorMsg)                                     \
         mov      __GL_glRangeValue,          _glValue                                         \
         mov      __GL_glRangeMaxValue,       _glMaxValue                                      \
         mov      __GL_glRangeErrorMsg,       _glErrorMsg                                      \
         call     __GL_glRangeCheck

// Data sizes...
#define __GL_MAX_VERTICES       256
#define __GL_MAX_LINES          256
#define __GL_MAX_POLYGONS       128
#define __GL_MAX_OBJECT_ACTIONS  32
#define __GL_MAX_OBJECTS         16
#define __GL_MAX_PV_DATA        256
#define __GL_MAX_PL_DATA        256

dseg segment
  // Sine table constants...
  __GL_SIN_TABLE sword[] 0,572,1144,1715,2286,2856,3425,3993,4560,5126,5690,6252,6813,7371,7927,   \
 8481,9032,9580,10126,10668,11207,11743,12275,12803,13328,13848,14365,14876,15384,15886,16384,     \
 16877,17364,17847,18324,18795,19261,19720,20174,20622,21063,21498,21926,22348,22763,23170,23571,  \
 23965,24351,24730,25102,25466,25822,26170,26510,26842,27166,27482,27789,28088,28378,28660,28932,  \
 29197,29452,29698,29935,30163,30382,30592,30792,30983,31164,31336,31499,31651,31795,31928,32052,  \
 32166,32270,32365,32449,32524,32588,32643,32688,32723,32748,32763,32767,32763,32748,32723,32688,  \
 32643,32588,32524,32449,32365,32270,32166,32052,31928,31795,31651,31499,31336,31164,30983,30792,  \
 30592,30382,30163,29935,29698,29452,29197,28932,28660,28378,28088,27789,27482,27166,26842,26510,  \
 26170,25822,25466,25102,24730,24351,23965,23571,23170,22763,22348,21926,21498,21063,20622,20174,  \
 19720,19261,18795,18324,17847,17364,16877,16384,15886,15384,14876,14365,13848,13328,12803,12275,  \
 11743,11207,10668,10126,9580,9032,8481,7927,7371,6813,6252,5690,5126,4560,3993,3425,2856,2286,    \
 1715,1144,572,0,-572,-1144,-1715,-2286,-2856,-3425,-3993,-4560,-5126,-5690,-6252,-6813,-7371,     \
 -7927,-8481,-9032,-9580,-10126,-10668,-11207,-11743,-12275,-12803,-13328,-13848,-14365,-14876,    \
 -15384,-15886,-16384,-16877,-17364,-17847,-18324,-18795,-19261,-19720,-20174,-20622,-21063,-21498,\
 -21926,-22348,-22763,-23170,-23571,-23965,-24351,-24730,-25102,-25466,-25822,-26170,-26510,-26842,\
 -27166,-27482,-27789,-28088,-28378,-28660,-28932,-29197,-29452,-29698,-29935,-30163,-30382,-30592,\
 -30792,-30983,-31164,-31336,-31499,-31651,-31795,-31928,-32052,-32166,-32270,-32365,-32449,-32524,\
 -32588,-32643,-32688,-32723,-32748,-32763,-32767,-32763,-32748,-32723,-32688,-32643,-32588,-32524,\
 -32449,-32365,-32270,-32166,-32052,-31928,-31795,-31651,-31499,-31336,-31164,-30983,-30792,-30592,\
 -30382,-30163,-29935,-29698,-29452,-29197,-28932,-28660,-28378,-28088,-27789,-27482,-27166,-26842,\
 -26510,-26170,-25822,-25466,-25102,-24730,-24351,-23965,-23571,-23170,-22763,-22348,-21926,-21498,\
 -21063,-20622,-20174,-19720,-19261,-18795,-18324,-17847,-17364,-16877,-16384,-15886,-15384,-14876,\
 -14365,-13848,-13328,-12803,-12275,-11743,-11207,-10668,-10126,-9580,-9032,-8481,-7927,-7371,     \
 -6813,-6252,-5690,-5126,-4560,-3993,-3425,-2856,-2286,-1715,-1144,-572,0

  // General stuff, copied from NXTDefs.h...
  __GL_glDrawLine        TDrawLine
  __GL_glDrawPoint       TDrawPoint
  __GL_glDrawCircle      TDrawCircle
  __GL_glDrawData        TDrawText

  // settings...
  TGLSettings struct
    cullMode         byte
    circleSize       byte
    camDepth         byte
    zoom             byte
  TGLSettings ends

  __GL_glSettings        TGLSettings
  __GL_glSettingType     byte
  __GL_glSettingValue    byte

  // Vertex data...
  TGLVertex struct
    x                sword //sdword
    y                sword //sdword
    z                sword //sdword
  TGLVertex ends

  TGLScreenVertex struct
    x                sword //sdword
    y                sword //sdword
  TGLScreenVertex ends

  TGLRotVertex struct
    orig             TGLVertex
    rot              TGLVertex
    screen           TGLScreenVertex
  TGLRotVertex ends

  __GL_vertexData        TGLRotVertex[]
  __GL_vertex0           TGLRotVertex
  __GL_vertex1           TGLRotVertex
  __GL_vertex2           TGLRotVertex
  __GL_vertexCount       byte
  __GL_vertexIndex       byte
  __GL_vertexOffset      byte

  // Line data...
  TGLLine struct
    firstVertex      byte
    lastVertex       byte
  TGLLine ends

  __GL_lineData          TGLLine[]
  __GL_line              TGLLine
  __GL_lineCount         byte
  __GL_lineIndex         byte
  __GL_lineDone          byte[]

  // Polygon data...
  TGLPolygon struct
    beginMode        byte
    firstVertex      byte
    lastVertex       byte
    firstLine        byte
    lastLine         byte
  TGLPolygon ends

  __GL_polygonData       TGLPolygon[]
  __GL_polygon           TGLPolygon
  __GL_polygonCount      byte
  __GL_polygonIndex      byte

  // Polygon/vertex link...
  __GL_pvData            byte[]
  __GL_pvDataCount       byte

  // Polygon/line link...
  __GL_plData            byte[]
  __GL_plDataCount       byte

  // Object action...
  TGLObjectAction struct
    type             byte
    value            sword //sdword
//    fsin             float
//    fcos             float
    lsin             sword //sdword
    lcos             sword //sdword
  TGLObjectAction ends

  __GL_objectAction      TGLObjectAction
  __GL_objectActionData  TGLObjectAction[]
  __GL_objectActionCount byte

  // Object data...
  TObject struct
    firstVertex      byte
    lastVertex       byte
    firstPolygon     byte
    lastPolygon      byte
    firstLine        byte
    lastLine         byte
    render           byte
    
    // settings...
    circleSize       byte
    cullMode         byte

    actionCount      byte
    actionList       byte[]
  TObject ends

  __GL_objectData        TObject[]
  __GL_object            TObject
  __GL_objectCount       byte
  __GL_objectIndex       byte

  // Temp offset...
  __GL_offset            word

  // Counters...
  __GL_i                 word
  __GL_j                 word
  __GL_k                 word
  __GL_l                 word

  // Angles...
  __GL_angleX            sword //sdword
  __GL_angleY            sword //sdword
  __GL_angleZ            sword //sdword

  // Save angles...
  __GL_saveAngleX        sword //sdword
  __GL_saveAngleY        sword //sdword
  __GL_saveAngleZ        sword //sdword

  __GL_sinX              sword //sdword
  __GL_cosX              sword //sdword
  __GL_sinY              sword //sdword
  __GL_cosY              sword //sdword
  __GL_sinZ              sword //sdword
  __GL_cosZ              sword //sdword
//  __GL_sinX              float
//  __GL_cosX              float
//  __GL_sinY              float
//  __GL_cosY              float
//  __GL_sinZ              float
//  __GL_cosZ              float

  // Temp vars for calculations...
  __GL_a                 sdword
  __GL_b                 sdword
  __GL_c                 sdword
  __GL_d                 sdword
  __GL_e                 sdword
  __GL_f                 sdword

  // Rotated x, y, z coords...
  __GL_xx                sdword
  __GL_yy                sdword
  __GL_zz                sdword

  __GL_camDepth          sdword
  __GL_zoom              sdword
  
  __GL_x0                sdword
  __GL_y0                sdword
  __GL_z0                sdword
  
  __GL_x1                sdword
  __GL_y1                sdword
  __GL_z1                sdword

  __GL_x2                sdword
  __GL_y2                sdword
  __GL_z2                sdword

  // data for filling polygons...
  __GL_buffer            byte[]
  
  __GL_minX              sword
  __GL_maxX              sword
  
  __GL_startY            sword
  __GL_startX            sword
  __GL_endY              sword
  __GL_endX              sword
  
  __GL_deltaY            sword
  __GL_deltaX            sword
  
  __GL_action            byte
  __GL_index             word
  __GL_value             sword //sdword
  __GL_type              sword //sdword
  
  // rangecheck data...
  __GL_glRangeValue      word
  __GL_glRangeMaxValue   word
  __GL_glRangeErrorMsg   byte[]

  __GL_glErrorState      byte FALSE
  __GL_glErrorMsg        byte[]

  __GL_glLinesClipped    byte
dseg ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glRangeCheck
// Description : Check array sizes.
//-----------------------------------------------------------------------------------------
subroutine __GL_glRangeCheck
  // check if there's an already error...
  brcmp    EQ,                     __GL_nbc_gl_range_ok, __GL_glErrorState, TRUE
  // check the range...
  brcmp    LT,                     __GL_nbc_gl_range_ok, __GL_glRangeValue, __GL_glRangeMaxValue
  set      __GL_glErrorState,      TRUE
  mov      __GL_glErrorMsg,        __GL_glRangeErrorMsg
__GL_nbc_gl_range_ok:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glInit
// Description : Initialize vars.
//-----------------------------------------------------------------------------------------
subroutine __GL_glInit
  set      __GL_glSettings.cullMode,   GL_CULL_BACK
  set      __GL_glSettings.circleSize, 4
  set      __GL_glSettings.camDepth,   100
  set      __GL_glSettings.zoom,       0
  arrinit  __GL_vertexData,            __GL_vertex0, __GL_MAX_VERTICES
  set      __GL_vertexCount,           0
  arrinit  __GL_lineData,              __GL_line, __GL_MAX_LINES
  set      __GL_lineCount,             0
  arrinit  __GL_polygonData,           __GL_polygon, __GL_MAX_POLYGONS
  set      __GL_polygonCount,          0
  arrinit  __GL_objectActionData,      __GL_objectAction, __GL_MAX_OBJECT_ACTIONS
  arrinit  __GL_object.actionList,     0, __GL_MAX_OBJECT_ACTIONS
  arrinit  __GL_objectData,            __GL_object, __GL_MAX_OBJECTS
  set      __GL_objectCount,           0
  arrinit  __GL_pvData                 0, __GL_MAX_PV_DATA
  set      __GL_pvDataCount,           0
  arrinit  __GL_plData                 0, __GL_MAX_PL_DATA
  set      __GL_plDataCount            0
  set      __GL_angleX,                0
  set      __GL_angleY,                0
  set      __GL_angleZ,                0
  arrinit  __GL_buffer,                0, 200
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glSet
// Description : Change settings.
//-----------------------------------------------------------------------------------------
subroutine __GL_glSet
  brcmp    EQ,                     __GL_nbc_gl_set_circle_size,  __GL_glSettingType, GL_CIRCLE_SIZE
  brcmp    EQ,                     __GL_nbc_gl_set_cull_mode,    __GL_glSettingType, GL_CULL_MODE
  brcmp    EQ,                     __GL_nbc_gl_set_camera_depth, __GL_glSettingType, GL_CAMERA_DEPTH
  brcmp    EQ,                     __GL_nbc_gl_set_zoom_factor,  __GL_glSettingType, GL_ZOOM_FACTOR
  // unknown setting...
  jmp      __GL_nbc_gl_set_done
__GL_nbc_gl_set_circle_size:
  mov      __GL_glSettings.circleSize, __GL_glSettingValue
  jmp      __GL_nbc_gl_set_done
__GL_nbc_gl_set_cull_mode:
  mov      __GL_glSettings.cullMode,   __GL_glSettingValue
  jmp      __GL_nbc_gl_set_done
__GL_nbc_gl_set_camera_depth:
  mov      __GL_glSettings.camDepth,   __GL_glSettingValue
  jmp      __GL_nbc_gl_set_done
__GL_nbc_gl_set_zoom_factor:
  mov      __GL_glSettings.zoom,       __GL_glSettingValue
__GL_nbc_gl_set_done:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glAddVertex
// Description : Check if there's an existing vertex with the same (x,y,z) coord.
//               If there's an existing vertex found then return the index to that vertex
//               else add the vertex to the list and return the index of the added vertex.
//-----------------------------------------------------------------------------------------
subroutine __GL_glAddVertex
  brcmp    EQ,                      __GL_nbc_gl_add_vertex_error, __GL_glErrorState, TRUE
  // check if the list is empty...
  brcmp    EQ,                      __GL_nbc_gl_empty_vertex_list, __GL_vertexCount, 0
  // loop through the list...
  mov      __GL_i,                  __GL_object.firstVertex
__GL_nbc_gl_find_vertex:
  index    __GL_vertex1,            __GL_vertexData, __GL_i
  brcmp    NEQ,                     __GL_nbc_gl_vertex_not_equal, __GL_vertex1.orig.x, __GL_vertex0.orig.x
  brcmp    NEQ,                     __GL_nbc_gl_vertex_not_equal, __GL_vertex1.orig.y, __GL_vertex0.orig.y
  brcmp    NEQ,                     __GL_nbc_gl_vertex_not_equal, __GL_vertex1.orig.z, __GL_vertex0.orig.z
  mov      __GL_vertexIndex,        __GL_i
  jmp      __GL_nbc_gl_add_vertex_done
__GL_nbc_gl_vertex_not_equal:
  add      __GL_i,                  __GL_i, 1
  brcmp    LT,                      __GL_nbc_gl_find_vertex, __GL_i, __GL_object.lastVertex
__GL_nbc_gl_empty_vertex_list:
  __glRangeCheck(__GL_vertexCount, __GL_MAX_VERTICES, 'Too many vertices')
  brcmp    EQ,                      __GL_nbc_gl_add_vertex_error, __GL_glErrorState, TRUE
  // there's no matching vertex found, add a new vertex to the list...
  replace  __GL_vertexData,         __GL_vertexData, __GL_vertexCount, __GL_vertex0
  mov      __GL_vertexIndex,        __GL_vertexCount
  add      __GL_vertexCount,        __GL_vertexCount, 1
__GL_nbc_gl_add_vertex_done:
  replace  __GL_pvData,             __GL_pvData, __GL_polygon.lastVertex, __GL_vertexIndex
  add      __GL_polygon.lastVertex, __GL_polygon.lastVertex, 1
  add      __GL_pvDataCount,        __GL_pvDataCount, 1
  mov      __GL_object.lastVertex,  __GL_vertexCount
__GL_nbc_gl_add_vertex_error:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glEnd
// Description : Store the polygon data, call __GL_glAddLines to optimize lines list.
//-----------------------------------------------------------------------------------------
subroutine __GL_glEnd
  brcmp    EQ,                     __GL_nbc_gl_end_error, __GL_glErrorState, TRUE
  call     __GL_glAddLines
  replace  __GL_polygonData,       __GL_polygonData, __GL_polygonCount, __GL_polygon
  add      __GL_polygonCount,      __GL_polygonCount, 1
__GL_nbc_gl_end_error:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glAddLines
// Description : Add the lines of the polygon and check if the line already exists.
//               Each line should be rendered only once.
//-----------------------------------------------------------------------------------------
subroutine __GL_glAddLines
  brcmp    EQ,                     __GL_nbc_gl_add_lines_error, __GL_glErrorState, TRUE
  mov      __GL_polygon.firstLine, __GL_plDataCount
  // loop through polygon vertex the list...
  mov      __GL_i,                 __GL_polygon.firstVertex
__GL_nbc_gl_find_lines1:
  add      __GL_j,                 __GL_i, 1
  brcmp    LT,                     __GL_nbc_gl_find_lines_modj, __GL_j, __GL_polygon.lastVertex
  mov      __GL_j,                 __GL_polygon.firstVertex
  // if the beginMode is GL_LINE then don't close the polygon...
  brcmp    EQ,                     __GL_nbc_gl_add_line_done2, __GL_polygon.beginMode, GL_LINE
__GL_nbc_gl_find_lines_modj:
  // _a = _pvData[_i]
  index    __GL_a,                 __GL_pvData, __GL_i
  // _b = _pvData[_j]
  index    __GL_b,                 __GL_pvData, __GL_j
  // check if the list is empty...
  brcmp    EQ,                     __GL_nbc_empty_lines_list, __GL_lineCount, 0
  // loop through the line list to find a matching line...
  mov      __GL_k,                 __GL_object.firstLine
__GL_nbc_gl_find_lines2:
  index    __GL_line,              __GL_lineData, __GL_k
  brcmp    NEQ,                    __GL_nbc_gl_find_line_not_equal1, __GL_a, __GL_line.firstVertex
  brcmp    NEQ,                    __GL_nbc_gl_find_line_not_equal1, __GL_b, __GL_line.lastVertex
  mov      __GL_lineIndex,         __GL_k
  jmp      __GL_nbc_gl_add_line_done1
__GL_nbc_gl_find_line_not_equal1:
  brcmp    NEQ,                    __GL_nbc_gl_find_line_not_equal2, __GL_b, __GL_line.firstVertex
  brcmp    NEQ,                    __GL_nbc_gl_find_line_not_equal2, __GL_a, __GL_line.lastVertex
  mov      __GL_lineIndex,         __GL_k
  jmp      __GL_nbc_gl_add_line_done1
__GL_nbc_gl_find_line_not_equal2:
  add      __GL_k,                 __GL_k, 1
  brcmp    LT,                     __GL_nbc_gl_find_lines2, __GL_k, __GL_lineCount
__GL_nbc_empty_lines_list:
  mov      __GL_line.firstVertex,  __GL_a
  mov      __GL_line.lastVertex,   __GL_b
  __glRangeCheck(__GL_lineCount, __GL_MAX_LINES, 'Too many lines')
  brcmp    EQ,                     __GL_nbc_gl_add_lines_error, __GL_glErrorState, TRUE
  // _lineData[_lineCount] = _line
  replace  __GL_lineData,          __GL_lineData, __GL_lineCount, __GL_line
  mov      __GL_lineIndex,         __GL_lineCount
  add      __GL_lineCount,         __GL_lineCount, 1
__GL_nbc_gl_add_line_done1:
  __glRangeCheck(__GL_plDataCount, __GL_MAX_PL_DATA, 'Too many poly-lines')
  brcmp    EQ,                     __GL_nbc_gl_add_lines_error, __GL_glErrorState, TRUE
  // _plData[_plDataCount] = _lineIndex
  replace  __GL_plData,            __GL_plData, __GL_plDataCount, __GL_lineIndex
  add      __GL_plDataCount,       __GL_plDataCount, 1
  add      __GL_i,                 __GL_i, 1
  brcmp    LT,                     __GL_nbc_gl_find_lines1, __GL_i, __GL_polygon.lastVertex
__GL_nbc_gl_add_line_done2:
  mov      __GL_polygon.lastLine,  __GL_plDataCount
__GL_nbc_gl_add_lines_error:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glEndObject
// Description : Save the last polygon number, store the object in the objectlist.
//-----------------------------------------------------------------------------------------
subroutine __GL_glEndObject
  brcmp    EQ,                      __GL_nbc_gl_end_object_error, __GL_glErrorState, TRUE
  mov      __GL_object.lastPolygon, __GL_polygonCount
  replace  __GL_objectData,         __GL_objectData, __GL_objectCount, __GL_object
  add      __GL_objectCount,        __GL_objectCount, 1
__GL_nbc_gl_end_object_error:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glObjectAction
// Description : Add an action to the object...
//-----------------------------------------------------------------------------------------
subroutine __GL_glObjectAction
  index    __GL_object,             __GL_objectData, __GL_objectIndex
  mov      __GL_objectAction.type,  __GL_action
  mov      __GL_objectAction.value, __GL_value
  brcmp    EQ,                      __GL_nbc_gl_action_rotate, __GL_action, GL_ROTATE_X
  brcmp    EQ,                      __GL_nbc_gl_action_rotate, __GL_action, GL_ROTATE_Y
  brcmp    EQ,                      __GL_nbc_gl_action_rotate, __GL_action, GL_ROTATE_Z
  jmp      __GL_nbc_gl_action_no_rotate
__GL_nbc_gl_action_rotate:
  // if the action is a rotation of any kind then grab the sin and cos of the angle
  mod      __GL_value,              __GL_value, 360
//  sind     __GL_objectAction.fsin,  __GL_value
//  cosd     __GL_objectAction.fcos,  __GL_value
  index    __GL_objectAction.lsin,  __GL_SIN_TABLE, __GL_value
  add      __GL_value,              __GL_value, 90
  mod      __GL_value,              __GL_value, 360
  index    __GL_objectAction.lcos,  __GL_SIN_TABLE, __GL_value
__GL_nbc_gl_action_no_rotate:
  __glRangeCheck(__GL_object.actionCount, __GL_MAX_OBJECT_ACTIONS, 'Too many object-actions')
  brcmp    EQ,                      __GL_nbc_gl_add_object_error, __GL_glErrorState, TRUE
  // _object.actionList[_object.actionCount] = _objectActionCount
  replace  __GL_object.actionList,  __GL_object.actionList, __GL_object.actionCount, __GL_objectActionCount
  add      __GL_object.actionCount, __GL_object.actionCount, 1
  replace  __GL_objectData,         __GL_objectData, __GL_objectIndex, __GL_object
  __glRangeCheck(__GL_objectActionCount, __GL_MAX_OBJECT_ACTIONS, 'Too many object-actions')
  brcmp    EQ,                      __GL_nbc_gl_add_object_error, __GL_glErrorState, TRUE
  // _objectActionData[_objectActionCount] = _objectAction
  replace  __GL_objectActionData,   __GL_objectActionData, __GL_objectActionCount, __GL_objectAction
  add      __GL_objectActionCount,  __GL_objectActionCount, 1
__GL_nbc_gl_add_object_error:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glRotateObject
// Description : Check the object actions and apply them to the object...
//-----------------------------------------------------------------------------------------
subroutine __GL_glRotateObject
  mov      __GL_i,                 __GL_object.firstVertex
__GL_nbc_gl_apply_next_vertex:
  index    __GL_vertex0,           __GL_vertexData, __GL_i
  mov      __GL_vertex0.rot.x,     __GL_vertex0.orig.x
  mov      __GL_vertex0.rot.y,     __GL_vertex0.orig.y
  mov      __GL_vertex0.rot.z,     __GL_vertex0.orig.z
  brcmp    EQ,                     __GL_nbc_gl_no_actions, __GL_object.actionCount, 0
  set      __GL_j,                 0
__GL_nbc_gl_apply_next_action:
  // _objectAction = _objectActionData[_object.actionData[_j]]
  index    __GL_k,                 __GL_object.actionList, __GL_j
  index    __GL_objectAction,      __GL_objectActionData, __GL_k
  brcmp    EQ,                     __GL_nbc_gl_apply_translate_x, __GL_objectAction.type, GL_TRANSLATE_X
  brcmp    EQ,                     __GL_nbc_gl_apply_translate_y, __GL_objectAction.type, GL_TRANSLATE_Y
  brcmp    EQ,                     __GL_nbc_gl_apply_translate_z, __GL_objectAction.type, GL_TRANSLATE_Z
  brcmp    EQ,                     __GL_nbc_gl_apply_rotate_x,    __GL_objectAction.type, GL_ROTATE_X
  brcmp    EQ,                     __GL_nbc_gl_apply_rotate_y,    __GL_objectAction.type, GL_ROTATE_Y
  brcmp    EQ,                     __GL_nbc_gl_apply_rotate_z,    __GL_objectAction.type, GL_ROTATE_Z
  brcmp    EQ,                     __GL_nbc_gl_apply_scale_x,     __GL_objectAction.type, GL_SCALE_X
  brcmp    EQ,                     __GL_nbc_gl_apply_scale_y,     __GL_objectAction.type, GL_SCALE_Y
  brcmp    EQ,                     __GL_nbc_gl_apply_scale_z,     __GL_objectAction.type, GL_SCALE_Z
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_translate_x:
  add      __GL_vertex0.rot.x,     __GL_vertex0.rot.x, __GL_objectAction.value
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_translate_y:
  add      __GL_vertex0.rot.y,     __GL_vertex0.rot.y, __GL_objectAction.value
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_translate_z:
  add      __GL_vertex0.rot.z,     __GL_vertex0.rot.z, __GL_objectAction.value
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_rotate_x:
  mul      __GL_a,                 __GL_objectAction.lcos, __GL_vertex0.rot.y
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_objectAction.lsin, __GL_vertex0.rot.z
  shr      __GL_b,                 __GL_b, 15
  sub      __GL_c,                 __GL_a, __GL_b
  mul      __GL_a,                 __GL_objectAction.lsin, __GL_vertex0.rot.y
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_objectAction.lcos, __GL_vertex0.rot.z
  shr      __GL_b,                 __GL_b, 15
  add      __GL_d,                 __GL_a, __GL_b
  mov      __GL_vertex0.rot.y,     __GL_c
  mov      __GL_vertex0.rot.z,     __GL_d
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_rotate_y:
  mul      __GL_a,                 __GL_objectAction.lsin, __GL_vertex0.rot.z
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_objectAction.lcos, __GL_vertex0.rot.x
  shr      __GL_b,                 __GL_b, 15
  add      __GL_c,                 __GL_a, __GL_b
  mul      __GL_a,                 __GL_objectAction.lcos, __GL_vertex0.rot.z
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_objectAction.lsin, __GL_vertex0.rot.x
  shr      __GL_b,                 __GL_b, 15
  sub      __GL_d,                 __GL_a, __GL_b
  mov      __GL_vertex0.rot.x,     __GL_c
  mov      __GL_vertex0.rot.z,     __GL_d
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_rotate_z:
  mul      __GL_a,                 __GL_objectAction.lcos, __GL_vertex0.rot.x
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_objectAction.lsin, __GL_vertex0.rot.y
  shr      __GL_b,                 __GL_b, 15
  sub      __GL_c,                 __GL_a, __GL_b
  mul      __GL_a,                 __GL_objectAction.lsin, __GL_vertex0.rot.x
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_objectAction.lcos, __GL_vertex0.rot.y
  shr      __GL_b,                 __GL_b, 15
  add      __GL_d,                 __GL_a, __GL_b
  mov      __GL_vertex0.rot.x,     __GL_c
  mov      __GL_vertex0.rot.y,     __GL_d
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_scale_x:
  mul      __GL_vertex0.rot.x,     __GL_vertex0.rot.x, __GL_objectAction.value
  shr      __GL_vertex0.rot.x,     __GL_vertex0.rot.x, 8
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_scale_y:
  mul      __GL_vertex0.rot.y,     __GL_vertex0.rot.y, __GL_objectAction.value
  shr      __GL_vertex0.rot.y,     __GL_vertex0.rot.y, 8
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_scale_z:
  mul      __GL_vertex0.rot.z,     __GL_vertex0.rot.z, __GL_objectAction.value
  shr      __GL_vertex0.rot.z,     __GL_vertex0.rot.z, 8
  jmp      __GL_nbc_gl_apply_done
__GL_nbc_gl_apply_done:
  add      __GL_j,                 __GL_j, 1
  brcmp    LT,                     __GL_nbc_gl_apply_next_action, __GL_j, __GL_object.actionCount
__GL_nbc_gl_no_actions:
  replace  __GL_vertexData,        __GL_vertexData, __GL_i, __GL_vertex0
  add      __GL_i,                 __GL_i, 1
  brcmp    LT,                     __GL_nbc_gl_apply_next_vertex, __GL_i, __GL_object.lastVertex
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glRotateVertexList
// Description : Rotate all the vertices in the vertext list...
//-----------------------------------------------------------------------------------------
subroutine __GL_glRotateVertexList
  // update all object actions first...
  set      __GL_l,                 0
__GL_nbc_gl_rotate_objects:
  index    __GL_object,            __GL_objectData, __GL_l
  brcmp    EQ,                     __GL_nbc_gl_dont_rotate_object, __GL_object.render, FALSE
  call     __GL_glRotateObject
__GL_nbc_gl_dont_rotate_object:
  add      __GL_l,                 __GL_l, 1
  brcmp    LT,                     __GL_nbc_gl_rotate_objects, __GL_l, __GL_objectCount
  mov      __GL_saveAngleX,        __GL_angleX
  mov      __GL_saveAngleY,        __GL_angleY
  index    __GL_sinX,              __GL_SIN_TABLE, __GL_angleX
  add      __GL_angleX,            __GL_angleX, 90
  mod      __GL_angleX,            __GL_angleX, 360
  index    __GL_cosX,              __GL_SIN_TABLE, __GL_angleX
  index    __GL_sinY,              __GL_SIN_TABLE, __GL_angleY
  add      __GL_angleY,            __GL_angleY, 90
  mod      __GL_angleY,            __GL_angleY, 360
  index    __GL_cosY,              __GL_SIN_TABLE, __GL_angleY
  mov      __GL_camDepth,          __GL_glSettings.camDepth
  mov      __GL_zoom,              __GL_glSettings.zoom
  set      __GL_i,                 0
  set      __GL_vertexOffset,      0
__GL_nbc_gl_rotate_loop:
  // get the values from the vertex list...
  index    __GL_vertex0,           __GL_vertexData, __GL_vertexOffset
  // z1 = (_vertex0.rot.z * _cosY) - (_vertex0.rot.x * _sinY)
  mul      __GL_a,                 __GL_vertex0.rot.z, __GL_cosY
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_vertex0.rot.x, __GL_sinY
  shr      __GL_b,                 __GL_b, 15
  sub      __GL_z1,                __GL_a, __GL_b
  // xx = (_vertex0.rot.z * _sinY) + (_vertex0.rot.x * _cosY)
  mul      __GL_a,                 __GL_vertex0.rot.z, __GL_sinY
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_vertex0.rot.x, __GL_cosY
  shr      __GL_b,                 __GL_b, 15
  add      __GL_xx,                __GL_a, __GL_b
  // zz = (_vertex0.rot.y * _sinX) + (_z1 * _cosX) + _zoom
  mul      __GL_a,                 __GL_vertex0.rot.y, __GL_sinX
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_z1, __GL_cosX
  shr      __GL_b,                 __GL_b, 15
  add      __GL_zz,                __GL_a, __GL_b
  add      __GL_zz,                __GL_zz, __GL_zoom
  // yy = (_vertex0.rot.y * cosX) - (z1 * sinX)
  mul      __GL_a,                 __GL_vertex0.rot.y, __GL_cosX
  shr      __GL_a,                 __GL_a, 15
  mul      __GL_b,                 __GL_z1, __GL_sinX
  shr      __GL_b,                 __GL_b, 15
  sub      __GL_yy,                __GL_a, __GL_b
  // the actual screen coords...
  add      __GL_zz,                __GL_zz, __GL_camDepth
  // _vertex0.screen.sx = width  + (x * camDepth) / (zz + camDepth))
  // _vertex0.screen.sy = height - (y * camDepth) / (zz + camDepth))
  mul      __GL_vertex0.screen.x,  __GL_xx, __GL_camDepth
  div      __GL_vertex0.screen.x,  __GL_vertex0.screen.x, __GL_zz
  add      __GL_vertex0.screen.x,  __GL_vertex0.screen.x, 50
  mul      __GL_vertex0.screen.y,  __GL_yy, __GL_camDepth
  div      __GL_vertex0.screen.y,  __GL_vertex0.screen.y, __GL_zz
  sub      __GL_vertex0.screen.y,  32, __GL_vertex0.screen.y
  // save the screen coords...
  replace  __GL_vertexData,        __GL_vertexData, __GL_vertexOffset, __GL_vertex0
  add      __GL_vertexOffset,      __GL_vertexOffset, 1
  add      __GL_i,                 __GL_i, 1
  brcmp    LT,                     __GL_nbc_gl_rotate_loop, __GL_i, __GL_vertexCount
  mov      __GL_angleX,            __GL_saveAngleX
  mov      __GL_angleY,            __GL_saveAngleY
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glResetObjects
// Description : Reset the rotate, translate and scale actions for all objects...
//-----------------------------------------------------------------------------------------
subroutine __GL_glResetObjects
  set      __GL_glLinesClipped,     0
  brcmp    EQ,                      __GL_nbc_gl_reset_objects_error, __GL_glErrorState, TRUE
  arrinit  __GL_lineDone,           0, __GL_lineCount
  set      __GL_objectActionCount,  0
  set      __GL_i,                  0
__GL_nbc_gl_reset_actions:
  index    __GL_object,             __GL_objectData, __GL_i
  set      __GL_object.actionCount, 0
  set      __GL_object.render,      FALSE
  replace  __GL_objectData,         __GL_objectData, __GL_i, __GL_object
  add      __GL_i,                  __GL_i, 1
  brcmp    LT,                      __GL_nbc_gl_reset_actions, __GL_i, __GL_objectCount
__GL_nbc_gl_reset_objects_error:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glCallObject
// Description : Set the render boolean, copy the settings...
//-----------------------------------------------------------------------------------------
subroutine __GL_glCallObject
  brcmp    EQ,                     __GL_nbc_gl_call_object_error, __GL_glErrorState, TRUE
  index    __GL_object,            __GL_objectData, __GL_objectIndex
  set      __GL_object.render,     TRUE
  mov      __GL_object.cullMode,   __GL_glSettings.cullMode
  mov      __GL_object.circleSize, __GL_glSettings.circleSize
  replace  __GL_objectData,        __GL_objectData, __GL_objectIndex, __GL_object
__GL_nbc_gl_call_object_error:
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glDrawObject
// Description : Draw the object, this routine expects the '_object' struct to be set.
//-----------------------------------------------------------------------------------------
subroutine __GL_glDrawObject
  // set once...
  mov      __GL_glDrawLine.Options,     0
  // loop through the polygon list for this object...
  mov      __GL_i,                      __GL_object.firstPolygon
__GL_nbc_gl_draw_polygons:
  // get the information for the polygon...
  index    __GL_polygon,                __GL_polygonData, __GL_i
  brcmp    EQ,                          __GL_nbc_gl_render_polygon, __GL_polygon.beginMode, GL_POLYGON
  brcmp    EQ,                          __GL_nbc_gl_render_line,    __GL_polygon.beginMode, GL_LINE
  brcmp    EQ,                          __GL_nbc_gl_render_point,   __GL_polygon.beginMode, GL_POINT
  brcmp    EQ,                          __GL_nbc_gl_render_circle,  __GL_polygon.beginMode, GL_CIRCLE
  jmp      __GL_nbc_gl_cull_polygon
  //---------------------------------------------------------------------------------------
  // Render a polygon...
  //---------------------------------------------------------------------------------------
__GL_nbc_gl_render_polygon:
  // loop through the vertex list for this polygon...
  mov      __GL_j,                      __GL_polygon.firstVertex
  mov      __GL_k,                      __GL_polygon.lastVertex
  // _vertex0 = _vertexData[_pvData[j]]
  index    __GL_vertexOffset,           __GL_pvData, __GL_j
  index    __GL_vertex0,                __GL_vertexData, __GL_vertexOffset
  // _vertex1 = _vertexData[_pvData[j + 1]]
  add      __GL_j,                      __GL_j, 1
  index    __GL_vertexOffset,           __GL_pvData, __GL_j
  index    __GL_vertex1,                __GL_vertexData, __GL_vertexOffset
  // _vertex2 = _vertexData[_pvData[j + 2]]
  add      __GL_j,                      __GL_j, 1
  index    __GL_vertexOffset,           __GL_pvData, __GL_j
  index    __GL_vertex2,                __GL_vertexData, __GL_vertexOffset
  // check if culling is enabled...
  brcmp    EQ,                          __GL_nbc_gl_no_culling, __GL_object.cullMode, GL_CULL_NONE
  // calculate the culling...
  // ((x1 - x0) * (y2 - y0) >= (x2 - x0) * (y1 - y0))
  sub      __GL_a,                      __GL_vertex1.screen.x, __GL_vertex0.screen.x
  sub      __GL_b,                      __GL_vertex2.screen.y, __GL_vertex0.screen.y
  mul      __GL_c,                      __GL_a, __GL_b
  sub      __GL_d,                      __GL_vertex2.screen.x, __GL_vertex0.screen.x
  sub      __GL_e,                      __GL_vertex1.screen.y, __GL_vertex0.screen.y
  mul      __GL_f,                      __GL_d, __GL_e
  // check if culling is enabled...
  brcmp    EQ,                          __GL_nbc_gl_check_front_cull, __GL_object.cullMode, GL_CULL_FRONT
  brcmp    GTEQ,                        __GL_nbc_gl_cull_polygon, __GL_c, __GL_f
  jmp      __GL_nbc_gl_no_culling
__GL_nbc_gl_check_front_cull:
  brcmp    GTEQ,                        __GL_nbc_gl_cull_polygon, __GL_f, __GL_c
__GL_nbc_gl_no_culling:
  //--> render the lines...
  mov      __GL_j,                      __GL_polygon.firstLine
__GL_nbc_gl_draw_lines:
  // _k = _plData[_j]
  index    __GL_k,                      __GL_plData, __GL_j
  // render every line only once!
  // _l = _lineDone[_k]
  index    __GL_l,                      __GL_lineDone, __GL_k
  brcmp    EQ,                          __GL_nbc_gl_line_done, __GL_l, 1
  // set the 'done' byte...
  replace  __GL_lineDone,               __GL_lineDone, 1, __GL_l
  // _line = _lineData[_k]
  index    __GL_line,                   __GL_lineData, __GL_k
  // _vertex1 = _vertexData[_line.firstVertex]
  index    __GL_vertex1,                __GL_vertexData, __GL_line.firstVertex
  // _vertex1 = _vertexData[_line.lastVertex]
  index    __GL_vertex2,                __GL_vertexData, __GL_line.lastVertex
  // very crude clipping...
//  add      __GL_glLinesClipped,         __GL_glLinesClipped, 1
//  brcmp    LT,                          __GL_nbc_gl_line_done, __GL_vertex1.screen.x,  0
//  brcmp    LT,                          __GL_nbc_gl_line_done, __GL_vertex2.screen.x,  0
//  brcmp    LT,                          __GL_nbc_gl_line_done, __GL_vertex1.screen.y,  0
//  brcmp    LT,                          __GL_nbc_gl_line_done, __GL_vertex2.screen.y,  0
//  brcmp    GT,                          __GL_nbc_gl_line_done, __GL_vertex1.screen.x, 99
//  brcmp    GT,                          __GL_nbc_gl_line_done, __GL_vertex2.screen.x, 99
//  brcmp    GT,                          __GL_nbc_gl_line_done, __GL_vertex1.screen.y, 63
//  brcmp    GT,                          __GL_nbc_gl_line_done, __GL_vertex2.screen.y, 63
//  sub      __GL_glLinesClipped,         __GL_glLinesClipped, 1
//  mov      __GL_glDrawLine.StartLoc.X,  __GL_vertex1.screen.x
//  mov      __GL_glDrawLine.StartLoc.Y,  __GL_vertex1.screen.y
//  mov      __GL_glDrawLine.EndLoc.X,    __GL_vertex2.screen.x
//  mov      __GL_glDrawLine.EndLoc.Y,    __GL_vertex2.screen.y
  mov      __GL_glDrawLine.StartLoc,    __GL_vertex1.screen
  mov      __GL_glDrawLine.EndLoc,      __GL_vertex2.screen
  syscall  DrawLine,                    __GL_glDrawLine
__GL_nbc_gl_line_done:
  add      __GL_j,                      __GL_j, 1
  brcmp    LT,                          __GL_nbc_gl_draw_lines, __GL_j, __GL_polygon.lastLine
  //<-- render the lines...
/*
  mov      __GL_minX,                  1000
  mov      __GL_maxX,                 -1000

  set      __GL_a,                     0
__GL_nbc_gl_polygon_loop:
  add      __GL_b,                     __GL_a, 1

  brcmp    LT,                         __GL_nbc_gl_modb, __GL_b, __GL_polygon.lastVertex
  mov      __GL_b,                     __GL_polygon.firstVertex
__GL_nbc_gl_modb:

  // _vertex1 = _vertexData[_pvData[_a]]
  index    __GL_vertexOffset,          __GL_pvData, __GL_a
  index    __GL_vertex1,               __GL_vertexData, __GL_vertexOffset
  // _vertex1 = _vertexData[_pvData[_b]]
  index    __GL_vertexOffset,          __GL_pvData, __GL_b
  index    __GL_vertex2,               __GL_vertexData, __GL_vertexOffset

  brcmp    GTEQ,                       __GL_nbc_gl_minx1, __GL_vertex1.screen.x, __GL_minX
  mov      __GL_minX,                  __GL_vertex1.screen.x
__GL_nbc_gl_minx1:
  brcmp    GTEQ,                       __GL_nbc_gl_minx2, __GL_vertex2.screen.x, __GL_minX
  mov      __GL_minX,                  __GL_vertex2.screen.x
__GL_nbc_gl_minx2:

  brcmp    LTEQ,                       __GL_nbc_gl_maxx1, __GL_vertex1.screen.x, __GL_maxX
  mov      __GL_maxX,                  __GL_vertex1.screen.x
__GL_nbc_gl_maxx1:
  brcmp    LTEQ,                       __GL_nbc_gl_maxx2, __GL_vertex2.screen.x, __GL_maxX
  mov      __GL_maxX,                  __GL_vertex2.screen.x
__GL_nbc_gl_maxx2:

  mov      __GL_index,                 0

  mov      __GL_startY,                __GL_vertex1.screen.y
  mov      __GL_startX,                __GL_vertex1.screen.x
  mov      __GL_endY,                  __GL_vertex2.screen.y
  mov      __GL_endX,                  __GL_vertex2.screen.x

  brcmp    GTEQ,                       __GL_nbc_gl_polygon_flip, __GL_endX, __GL_startX
  mov      __GL_startY,                __GL_vertex2.screen.y
  mov      __GL_startX,                __GL_vertex2.screen.x
  mov      __GL_endY,                  __GL_vertex1.screen.y
  mov      __GL_endX,                  __GL_vertex1.screen.x
  mov      __GL_index,                 100
__GL_nbc_gl_polygon_flip:

  sub      __GL_deltaY,                __GL_endY, __GL_startY
  sub      __GL_deltaX,                __GL_endX, __GL_startX

  mov      __GL_c,                     __GL_startX
__GL_nbc_gl_polygon_line:
  add      __GL_offset,                __GL_c, __GL_index

  // _startY + _deltaY * (_c - _startX) / _deltaX
  sub      __GL_value,                 __GL_c, __GL_startX
  mul      __GL_value,                 __GL_value, __GL_deltaY
  div      __GL_value,                 __GL_value, __GL_deltaX
  add      __GL_value,                 __GL_value, __GL_startY

  replace  __GL_buffer,                __GL_buffer, __GL_offset, __GL_value

  add      __GL_c,                     __GL_c, 1
  brcmp    LTEQ                        __GL_nbc_gl_polygon_line, __GL_c, __GL_endX

  add      __GL_a,                     __GL_a, 1
  brcmp    LT                          __GL_nbc_gl_polygon_loop, __GL_a, __GL_polygon.lastVertex

  mov      __GL_a,                     __GL_minX
__GL_nbc_gl_polygon_lines:
  index    __GL_startY,                __GL_buffer, __GL_a
  add      __GL_b,                     __GL_a, 100
  index    __GL_endY,                  __GL_buffer, __GL_b

  mov      __GL_glDrawLine.Options,    0
  mov      __GL_glDrawLine.StartLoc.X, __GL_a
  mov      __GL_glDrawLine.StartLoc.Y, __GL_startY
  mov      __GL_glDrawLine.EndLoc.X,   __GL_a
  mov      __GL_glDrawLine.EndLoc.Y,   __GL_endY
  syscall  DrawLine,                   __GL_glDrawLine

  add      __GL_a,                     __GL_a, 1
  brcmp    LTEQ,                       __GL_nbc_gl_polygon_lines, __GL_a, __GL_maxX
*/
  jmp      __GL_nbc_gl_cull_polygon
  //---------------------------------------------------------------------------------------
  // Render lines...
  //---------------------------------------------------------------------------------------
__GL_nbc_gl_render_line:
  mov      __GL_j,                      __GL_polygon.firstLine
__GL_nbc_gl_render_lines:
  // _k = _plData[_j]
  index    __GL_k,                      __GL_plData, __GL_j
  // render every line only once!
  // _l = _lineDone[_k]
  index    __GL_l,                      __GL_lineDone, __GL_k
  brcmp    EQ,                          __GL_nbc_gl_render_lines_done, __GL_l, 1
  // set the 'done' byte...
  replace  __GL_lineDone,               __GL_lineDone, 1, __GL_l
  // _line = _lineData[_k]
  index    __GL_line,                   __GL_lineData, __GL_k
  // _vertex1 = _vertexData[_line.firstVertex]
  // _vertex2 = _vertexData[_line.lastVertex]
  index    __GL_vertex1,                __GL_vertexData, __GL_line.firstVertex
  index    __GL_vertex2,                __GL_vertexData, __GL_line.lastVertex
  mov      __GL_glDrawLine.StartLoc,    __GL_vertex1.screen
  mov      __GL_glDrawLine.EndLoc,      __GL_vertex2.screen
//  mov      __GL_glDrawLine.StartLoc.X,  __GL_vertex1.screen.x
//  mov      __GL_glDrawLine.StartLoc.Y,  __GL_vertex1.screen.y
//  mov      __GL_glDrawLine.EndLoc.X,    __GL_vertex2.screen.x
//  mov      __GL_glDrawLine.EndLoc.Y,    __GL_vertex2.screen.y
  syscall  DrawLine,                    __GL_glDrawLine
__GL_nbc_gl_render_lines_done:
  add      __GL_j,                      __GL_j, 1
  brcmp    LT,                          __GL_nbc_gl_render_lines, __GL_j, __GL_polygon.lastLine
  jmp      __GL_nbc_gl_cull_polygon
  //---------------------------------------------------------------------------------------
  // Render points...
  //---------------------------------------------------------------------------------------
__GL_nbc_gl_render_point:
  set      __GL_glDrawPoint.Options,    0
  mov      __GL_j,                      __GL_polygon.firstVertex
__GL_nbc_gl_render_points:
  // _vertex0 = _vertexData[_pvData[j]]
  index    __GL_vertexOffset,           __GL_pvData, __GL_j
  index    __GL_vertex0,                __GL_vertexData, __GL_vertexOffset
  mov      __GL_glDrawPoint.Location,   __GL_vertex0.screen
//  mov      __GL_glDrawPoint.Location.X, __GL_vertex0.screen.x
//  mov      __GL_glDrawPoint.Location.Y, __GL_vertex0.screen.y
  syscall  DrawPoint,                   __GL_glDrawPoint
  add      __GL_j,                      __GL_j, 1
  brcmp    LT,                          __GL_nbc_gl_render_points, __GL_j, __GL_polygon.lastVertex
  jmp      __GL_nbc_gl_cull_polygon
  //---------------------------------------------------------------------------------------
  // Render circle...
  //---------------------------------------------------------------------------------------
__GL_nbc_gl_render_circle:
  set      __GL_glDrawCircle.Options,   0
  mov      __GL_glDrawCircle.Size,      __GL_object.circleSize
  mov      __GL_j,                      __GL_polygon.firstVertex
__GL_nbc_gl_render_circles:
  // _vertex0 = _vertexData[_pvData[j]]
  index    __GL_vertexOffset,           __GL_pvData, __GL_j
  index    __GL_vertex0,                __GL_vertexData, __GL_vertexOffset
  mov      __GL_glDrawCircle.Center,    __GL_vertex0.screen
//  mov      __GL_glDrawCircle.Center.X,  __GL_vertex0.screen.x
//  mov      __GL_glDrawCircle.Center.Y,  __GL_vertex0.screen.y
  syscall  DrawCircle,                  __GL_glDrawCircle
  add      __GL_j,                      __GL_j, 1
  brcmp    LT,                          __GL_nbc_gl_render_circles, __GL_j, __GL_polygon.lastVertex
  jmp      __GL_nbc_gl_cull_polygon
__GL_nbc_gl_cull_polygon:
  add      __GL_i,                      __GL_i, 1
  brcmp    LT,                          __GL_nbc_gl_draw_polygons, __GL_i, __GL_object.lastPolygon
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glRenderObjects
// Description : Draw all objects which have been called...
//-----------------------------------------------------------------------------------------
subroutine __GL_glRenderObjects
  brcmp    EQ,                          __GL_nbc_gl_render_objects_error, __GL_glErrorState, TRUE
  set      __GL_objectIndex,            0
__GL_nbc_gl_render_objects:
  // get the information for the object...
  index    __GL_object,                 __GL_objectData, __GL_objectIndex
  brcmp    EQ,                          __GL_nbc_gl_dont_render_object, __GL_object.render, FALSE
  call     __GL_glDrawObject
__GL_nbc_gl_dont_render_object:
  add      __GL_objectIndex,            __GL_objectIndex, 1
  brcmp    LT,                          __GL_nbc_gl_render_objects, __GL_objectIndex, __GL_objectCount
  return
__GL_nbc_gl_render_objects_error:
  // Display the error message...
  set       __GL_glDrawData.Options,    1
  set       __GL_glDrawData.Location.X, 0
  set       __GL_glDrawData.Location.Y, 56
  mov       __GL_glDrawData.Text,       'Error:'
  syscall   DrawText,                   __GL_glDrawData
  set       __GL_glDrawData.Options,    0
  set       __GL_glDrawData.Location.Y, 48
  mov       __GL_glDrawData.Text,       __GL_glErrorMsg
  syscall   DrawText,                   __GL_glDrawData
  return
ends

dseg segment
  __GL_tmpId             byte
  __GL_mode              byte
  __GL_sizeX             sdword
  __GL_sizeY             sdword
  __GL_sizeZ             sdword
  __GL_angle             sdword
dseg ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glBox
// Description : Add a box with the dimensions: _sizeX, _sizeY, _sizeZ.
//               Use mode _mode.
//-----------------------------------------------------------------------------------------
subroutine __GL_glBox
  shr      __GL_x1,                    __GL_sizeX, 1
  neg      __GL_x0,                    __GL_x1
  shr      __GL_y1,                    __GL_sizeY, 1
  neg      __GL_y0,                    __GL_y1
  shr      __GL_z1,                    __GL_sizeZ, 1
  neg      __GL_z0,                    __GL_z1
  __glBeginObject(__GL_tmpId)
    __glBegin(__GL_mode)
      __glAddVertex(__GL_x0, __GL_y0, __GL_z0)
      __glAddVertex(__GL_x1, __GL_y0, __GL_z0)
      __glAddVertex(__GL_x1, __GL_y1, __GL_z0)
      __glAddVertex(__GL_x0, __GL_y1, __GL_z0)
    __glEnd()
    __glBegin(__GL_mode)
      __glAddVertex(__GL_x0, __GL_y1, __GL_z1)
      __glAddVertex(__GL_x1, __GL_y1, __GL_z1)
      __glAddVertex(__GL_x1, __GL_y0, __GL_z1)
      __glAddVertex(__GL_x0, __GL_y0, __GL_z1)
    __glEnd()

    __glBegin(__GL_mode)
      __glAddVertex(__GL_x0, __GL_y1, __GL_z0)
      __glAddVertex(__GL_x0, __GL_y1, __GL_z1)
      __glAddVertex(__GL_x0, __GL_y0, __GL_z1)
      __glAddVertex(__GL_x0, __GL_y0, __GL_z0)
    __glEnd()
    __glBegin(__GL_mode)
      __glAddVertex(__GL_x1, __GL_y0, __GL_z0)
      __glAddVertex(__GL_x1, __GL_y0, __GL_z1)
      __glAddVertex(__GL_x1, __GL_y1, __GL_z1)
      __glAddVertex(__GL_x1, __GL_y1, __GL_z0)
    __glEnd()

    __glBegin(__GL_mode)
      __glAddVertex(__GL_x0, __GL_y0, __GL_z0)
      __glAddVertex(__GL_x0, __GL_y0, __GL_z1)
      __glAddVertex(__GL_x1, __GL_y0, __GL_z1)
      __glAddVertex(__GL_x1, __GL_y0, __GL_z0)
    __glEnd()
    __glBegin(__GL_mode)
      __glAddVertex(__GL_x1, __GL_y1, __GL_z0)
      __glAddVertex(__GL_x1, __GL_y1, __GL_z1)
      __glAddVertex(__GL_x0, __GL_y1, __GL_z1)
      __glAddVertex(__GL_x0, __GL_y1, __GL_z0)
    __glEnd()
  __glEndObject()
  return
ends

//-----------------------------------------------------------------------------------------
// Subroutine  : __GL_glPyramid
// Description : Add a pyramid with the dimensions: _sizeX, _sizeY, _sizeZ.
//               Use mode _mode.
//-----------------------------------------------------------------------------------------
subroutine __GL_glPyramid
  shr      __GL_x1,                    __GL_sizeX, 1
  neg      __GL_x0,                    __GL_x1
  shr      __GL_z1,                    __GL_sizeZ, 1
  neg      __GL_z0,                    __GL_z1
  neg      __GL_y0,                    __GL_sizeY
  __glBeginObject(__GL_tmpId)
    __glBegin(__GL_mode)
      __glAddVertex(__GL_x1, 0, __GL_z0)
      __glAddVertex(__GL_x1, 0, __GL_z1)
      __glAddVertex(__GL_x0, 0, __GL_z1)
      __glAddVertex(__GL_x0, 0, __GL_z0)
    __glEnd()

    __glBegin(__GL_mode)
      __glAddVertex(__GL_x0, 0,   __GL_z0)
      __glAddVertex(__GL_x0, 0,   __GL_z1)
      __glAddVertex(0,   __GL_y0, 0)
    __glEnd()
    __glBegin(__GL_mode)
      __glAddVertex(__GL_x1, 0,   __GL_z1)
      __glAddVertex(__GL_x1, 0,   __GL_z0)
      __glAddVertex(0,   __GL_y0, 0)
    __glEnd()
    __glBegin(__GL_mode)
      __glAddVertex(__GL_x1, 0,   __GL_z0)
      __glAddVertex(__GL_x0, 0,   __GL_z0)
      __glAddVertex(0,   __GL_y0, 0)
    __glEnd()
    __glBegin(__GL_mode)
      __glAddVertex(__GL_x0, 0,   __GL_z1)
      __glAddVertex(__GL_x1, 0,   __GL_z1)
      __glAddVertex(0,   __GL_y0, 0)
    __glEnd()
  __glEndObject()
  return
ends

// no documentation for these functions since they are essentially readonly
#define SetLSInputBuffer(_p, _offset, _cnt, _data) __setLSInputBuffer(_p, _offset, _cnt, _data)
#define SetLSInputBufferInPtr(_p, _n) __setLSInputBufferInPtr(_p, _n)
#define SetLSInputBufferOutPtr(_p, _n) __setLSInputBufferOutPtr(_p, _n)
#define SetLSInputBufferBytesToRx(_p, _n) __setLSInputBufferBytesToRx(_p, _n)

#define SetLSOutputBuffer(_p, _offset, _cnt, _data) __setLSOutputBuffer(_p, _offset, _cnt, _data)
#define SetLSOutputBufferInPtr(_p, _n) __setLSOutputBufferInPtr(_p, _n)
#define SetLSOutputBufferOutPtr(_p, _n) __setLSOutputBufferOutPtr(_p, _n)
#define SetLSOutputBufferBytesToRx(_p, _n) __setLSOutputBufferBytesToRx(_p, _n)

#define SetLSMode(_p, _n) __setLSMode(_p, _n)
#define SetLSChannelState(_p, _n) __setLSChannelState(_p, _n)
#define SetLSErrorType(_p, _n) __setLSErrorType(_p, _n)
#define SetLSState(_n) __setLSState(_n)
#define SetLSSpeed(_n) __setLSSpeed(_n)

#ifdef __ENHANCED_FIRMWARE
#define SetLSNoRestartOnRead(_n) __setLSNoRestartOnRead(_n)
#endif

// these functions really cannot be used for any useful purpose (read-only)
#define SetBTDeviceName(_p, _str) __setBTDeviceName(_p, _str)
#define SetBTDeviceAddress(_p, _btaddr) __setBTDeviceAddress(_p, _btaddr)
#define SetBTConnectionName(_p, _str) __setBTConnectionName(_p, _str)
#define SetBTConnectionPinCode(_p, _code) __setBTConnectionPinCode(_p, _code)
#define SetBTConnectionAddress(_p, _btaddr) __setBTConnectionAddress(_p, _btaddr)
#define SetBrickDataName(_str) SetCommModuleBytes(CommOffsetBrickDataName, 16, _str)
#define SetBrickDataAddress(_btaddr) SetCommModuleBytes(CommOffsetBrickDataBdAddr, 7, _btaddr)
#define SetBTDeviceClass(_p, _n) __setBTDeviceClass(_p, _n)
#define SetBTDeviceStatus(_p, _n) __setBTDeviceStatus(_p, _n)
#define SetBTConnectionClass(_p, _n) __setBTConnectionClass(_p, _n)
#define SetBTConnectionHandleNum(_p, _n) __setBTConnectionHandleNum(_p, _n)
#define SetBTConnectionStreamStatus(_p, _n) __setBTConnectionStreamStatus(_p, _n)
#define SetBTConnectionLinkQuality(_p, _n) __setBTConnectionLinkQuality(_p, _n)
#define SetBrickDataBluecoreVersion(_n) __setBrickDataBluecoreVersion(_n)
#define SetBrickDataBtStateStatus(_n) __setBrickDataBtStateStatus(_n)
#define SetBrickDataBtHardwareStatus(_n) __setBrickDataBtHardwareStatus(_n)
#define SetBrickDataTimeoutValue(_n) __setBrickDataTimeoutValue(_n)
#define SetBTDeviceCount(_n) __setBTDeviceCount(_n)
#define SetBTDeviceNameCount(_n) __setBTDeviceNameCount(_n)

// not ready to be documented
#define SpawnProgram(_fname) __spawnProgram(_fname)

// standard firmware math functions written by Tamas Sorosy (www.sorosy.com)

// X is any integer, Y is the sqrt value (0->max), if X<0, Y is the sqrt value of absolute X
#define Sqrt(_X,_R) __SQRT(_X,_R)

// X is any integer in degrees, Y is 100* the sin value (-100->100)
#define Sin(_X,_R) __SIN(_X,_R)

// X is any integer in degrees, Y is 100* the cos value (-100->100)
#define Cos(_X,_R) __COS(_X,_R)

// X is 100* the sin value (-100->100), Y is -90->90, Y is 101 if X is outside -100->100 range
#define Asin(_X,_R) __ASIN(_X,_R)

// X is 100* the cos value (-100->100), Y is 0->180, Y is -11 if X is outside -100->100 range
#define Acos(_X,_R) __ACOS(_X,_R)


dseg segment
  __Pos_i sword
  __Pos_l1 sword
  __Pos_lDelta sword
  __Pos_tmpstr byte[]
  __Pos_s2 byte[]
  __Pos_s1 byte[]
  __Pos_Result sword
  __Pos_Mutex mutex
dseg ends

subroutine __PosSubroutine
	arrsize __Pos_l1, __Pos_s1
	sub __Pos_l1, __Pos_l1, 1
	arrsize __Pos_lDelta, __Pos_s2
	sub __Pos_lDelta, __Pos_lDelta, __Pos_l1
	set __Pos_i, 0
__Pos_Repeat:
	sub __Pos_lDelta, __Pos_lDelta, 1
	brtst 0, __Pos_RepeatEnd, __Pos_lDelta
	strsubset __Pos_tmpstr, __Pos_s2, __Pos_i, __Pos_l1
	cmp 4, __Pos_Result, __Pos_s1, __Pos_tmpstr
	brtst 4, __Pos_RepeatAgain, __Pos_Result
    mov __Pos_Result, __Pos_i
	return
__Pos_RepeatAgain:
	add __Pos_i, __Pos_i, 1
	jmp __Pos_Repeat
__Pos_RepeatEnd:
	set __Pos_Result, -1
	return
ends

#define __doPos(_s1, _s2, _result) \
  acquire __Pos_Mutex \
  mov __Pos_s1, _s1 \
  mov __Pos_s2, _s2 \
  call __PosSubroutine \
  mov _result, __Pos_Result \
  release __Pos_Mutex \


#endif


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// OUTPUT MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup OutputModule
 * @{
 */
/** @defgroup OutputModuleFunctions Output module functions
 * Functions for accessing and modifying output module features.
 * @{
 */
/**
 * Reset tachometer counter.
 * Reset the tachometer count and tachometer limit goal for the specified
 * outputs.
 *
 * \param _p Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 */
#define ResetTachoCount(_p) __resetTachoCount(_p)

/**
 * Reset block-relative counter.
 * Reset the block-relative position counter for the specified outputs.
 *
 * \param _p Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 */
#define ResetBlockTachoCount(_p) __resetBlockTachoCount(_p)

/**
 * Reset program-relative counter.
 * Reset the program-relative position counter for the specified outputs.
 *
 * \param _p Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 */
#define ResetRotationCount(_p) __resetRotationCount(_p)

/**
 * Reset all tachometer counters.
 * Reset all three position counters and reset the current tachometer limit
 * goal for the specified outputs.
 *
 * \param _p Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 */
#define ResetAllTachoCounts(_p) __resetAllTachoCounts(_p)

/**
 * Run motors forward and reset counters.
 * Set outputs to forward direction and turn them on.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
#define OnFwdEx(_ports, _pwr, _reset) __OnFwdEx(_ports, _pwr, _reset)

/**
 * Run motors backward and reset counters.
 * Set outputs to reverse direction and turn them on.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
#define OnRevEx(_ports, _pwr, _reset) __OnRevEx(_ports, _pwr, _reset)

/**
 * Run motors forward and reset counters.
 * Set outputs to forward direction and turn them on.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnFwdExPID(_ports, _pwr, _reset, _p, _i, _d) __OnFwdExPID(_ports, _pwr, _reset, _p, _i, _d)

/**
 * Run motors backward and reset counters.
 * Set outputs to reverse direction and turn them on.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnRevExPID(_ports, _pwr, _reset, _p, _i, _d) __OnRevExPID(_ports, _pwr, _reset, _p, _i, _d)

/**
 * Run motors forward.
 * Set outputs to forward direction and turn them on.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 */
#define OnFwd(_ports, _pwr) OnFwdEx(_ports, _pwr, RESET_BLOCKANDTACHO)

/**
 * Run motors backward.
 * Set outputs to reverse direction and turn them on.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 */
#define OnRev(_ports, _pwr) OnRevEx(_ports, _pwr, RESET_BLOCKANDTACHO)

/**
 * Coast motors and reset counters.
 * Turn off the specified outputs, making them coast to a stop.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
#define CoastEx(_ports, _reset) __CoastEx(_ports, _reset)

/**
 * Turn motors off and reset counters.
 * Turn the specified outputs off (with braking).
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
#define OffEx(_ports, _reset) __OffEx(_ports, _reset)

/**
 * Coast motors.
 * Turn off the specified outputs, making them coast to a stop.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 */
#define Coast(_ports) CoastEx(_ports, RESET_BLOCKANDTACHO)

/**
 * Turn motors off.
 * Turn the specified outputs off (with braking).
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 */
#define Off(_ports) OffEx(_ports, RESET_BLOCKANDTACHO)

/**
 * Float motors.
 * Make outputs float. Float is an alias for Coast.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 */
#define Float(_ports) Coast(_ports)

/**
 * Run motors forward regulated and reset counters.
 * Run the specified outputs forward using the specified regulation mode.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _regmode Regulation mode, see \ref OutRegModeConstants.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
#define OnFwdRegEx(_ports, _pwr, _regmode, _reset) __OnFwdRegEx(_ports, _pwr, _regmode, _reset)

/**
 * Run motors backward regulated and reset counters.
 * Run the specified outputs in reverse using the specified regulation mode.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _regmode Regulation mode, see \ref OutRegModeConstants.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
#define OnRevRegEx(_ports, _pwr, _regmode, _reset) __OnRevRegEx(_ports, _pwr, _regmode, _reset)

/**
 * Run motors forward regulated and reset counters with PID factors.
 * Run the specified outputs forward using the specified regulation mode.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _regmode Regulation mode, see \ref OutRegModeConstants.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnFwdRegExPID(_ports, _pwr, _regmode, _reset, _p, _i, _d) __OnFwdRegExPID(_ports, _pwr, _regmode, _reset, _p, _i, _d)

/**
 * Run motors backward regulated and reset counters with PID factors.
 * Run the specified outputs in reverse using the specified regulation mode.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _regmode Regulation mode, see \ref OutRegModeConstants.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnRevRegExPID(_ports, _pwr, _regmode, _reset, _p, _i, _d) __OnRevRegExPID(_ports, _pwr, _regmode, _reset, _p, _i, _d)

/**
 * Run motors forward regulated.
 * Run the specified outputs forward using the specified regulation mode.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _regmode Regulation mode, see \ref OutRegModeConstants.
 */
#define OnFwdReg(_ports, _pwr, _regmode) OnFwdRegEx(_ports, _pwr, _regmode, RESET_BLOCKANDTACHO)

/**
 * Run motors forward regulated.
 * Run the specified outputs in reverse using the specified regulation mode.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _regmode Regulation mode, see \ref OutRegModeConstants.
 */
#define OnRevReg(_ports, _pwr, _regmode) OnRevRegEx(_ports, _pwr, _regmode, RESET_BLOCKANDTACHO)

/**
 * Run motors forward regulated with PID factors.
 * Run the specified outputs forward using the specified regulation mode.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _regmode Regulation mode, see \ref OutRegModeConstants.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnFwdRegPID(_ports, _pwr, _regmode, _p, _i, _d) OnFwdRegExPID(_ports, _pwr, _regmode, RESET_BLOCKANDTACHO, _p, _i, _d)

/**
 * Run motors reverse regulated with PID factors.
 * Run the specified outputs in reverse using the specified regulation mode.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _regmode Regulation mode, see \ref OutRegModeConstants.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnRevRegPID(_ports, _pwr, _regmode, _p, _i, _d) OnRevRegExPID(_ports, _pwr, _regmode, RESET_BLOCKANDTACHO, _p, _i, _d)

/**
 * Run motors forward synchronised and reset counters.
 * Run the specified outputs forward with regulated synchronization using the
 * specified turn ratio.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
#define OnFwdSyncEx(_ports, _pwr, _turnpct, _reset) __OnFwdSyncEx(_ports, _pwr, _turnpct, _reset)

/**
 * Run motors backward synchronised and reset counters.
 * Run the specified outputs in reverse with regulated synchronization using
 * the specified turn ratio.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
#define OnRevSyncEx(_ports, _pwr, _turnpct, _reset) __OnRevSyncEx(_ports, _pwr, _turnpct, _reset)

/**
 * Run motors forward synchronised and reset counters with PID factors.
 * Run the specified outputs forward with regulated synchronization using the
 * specified turn ratio.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnFwdSyncExPID(_ports, _pwr, _turnpct, _reset, _p, _i, _d) __OnFwdSyncExPID(_ports, _pwr, _turnpct, _reset, _p, _i, _d)

/**
 * Run motors backward synchronised and reset counters with PID factors.
 * Run the specified outputs in reverse with regulated synchronization using
 * the specified turn ratio.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param _reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnRevSyncExPID(_ports, _pwr, _turnpct, _reset, _p, _i, _d) __OnRevSyncExPID(_ports, _pwr, _turnpct, _reset, _p, _i, _d)

/**
 * Run motors forward synchronised.
 * Run the specified outputs forward with regulated synchronization using the
 * specified turn ratio.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 */
#define OnFwdSync(_ports, _pwr, _turnpct) OnFwdSyncEx(_ports, _pwr, _turnpct, RESET_BLOCKANDTACHO)

/**
 * Run motors backward synchronised.
 * Run the specified outputs in reverse with regulated synchronization using
 * the specified turn ratio.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 */
#define OnRevSync(_ports, _pwr, _turnpct) OnRevSyncEx(_ports, _pwr, _turnpct, RESET_BLOCKANDTACHO)

/**
 * Run motors forward synchronised with PID factors.
 * Run the specified outputs forward with regulated synchronization using the
 * specified turn ratio.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnFwdSyncPID(_ports, _pwr, _turnpct, _p, _i, _d) OnFwdSyncExPID(_ports, _pwr, _turnpct, RESET_BLOCKANDTACHO, _p, _i, _d)

/**
 * Run motors backward synchronised with PID factors.
 * Run the specified outputs in reverse with regulated synchronization using
 * the specified turn ratio.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define OnRevSyncPID(_ports, _pwr, _turnpct, _p, _i, _d) OnRevSyncExPID(_ports, _pwr, _turnpct, RESET_BLOCKANDTACHO, _p, _i, _d)

/**
 * Rotate motor.
 * Run the specified outputs forward for the specified number of degrees.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _angle Angle limit, in degree. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param _bSync Synchronise two motors. Should be set to true if a non-zero
 * turn percent is specified or no turning will occur.
 * \param _bStop Specify whether the motor(s) should brake at the end of the
 * rotation.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define RotateMotorExPID(_ports, _pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d) \
   __RotateMotorExPID(_ports, _pwr, _angle, _turnpct, _bSync, _bStop, _p, _i, _d)

// default PID values are 96, 32, 32 (PID_3, PID_1, PID_1)

/**
 * Rotate motor with PID factors.
 * Run the specified outputs forward for the specified number of degrees.
 * Specify proportional, integral, and derivative factors.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _angle Angle limit, in degree. Can be negative to reverse direction.
 * \param _p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param _d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
#define RotateMotorPID(_ports, _pwr, _angle, _p, _i, _d) \
   __RotateMotorExPID(_ports, _pwr, _angle, 0, FALSE, TRUE, _p, _i, _d)

/**
 * Rotate motor.
 * Run the specified outputs forward for the specified number of degrees.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _angle Angle limit, in degree. Can be negative to reverse direction.
 * \param _turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param _bSync Synchronise two motors. Should be set to true if a non-zero
 * turn percent is specified or no turning will occur.
 * \param _bStop Specify whether the motor(s) should brake at the end of the
 * rotation.
 */
#define RotateMotorEx(_ports, _pwr, _angle, _turnpct, _bSync, _bStop) \
   __RotateMotorExPID(_ports, _pwr, _angle, _turnpct, _bSync, _bStop, PID_1, PID_0, PID_3)

/**
 * Rotate motor.
 * Run the specified outputs forward for the specified number of degrees.
 *
 * \param _ports Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param _pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param _angle Angle limit, in degree. Can be negative to reverse direction.
 */
#define RotateMotor(_ports, _pwr, _angle) \
   __RotateMotorExPID(_ports, _pwr, _angle, 0, FALSE, TRUE, PID_1, PID_0, PID_3)

/**
 * Set motor regulation frequency.
 * Set the motor regulation frequency to the specified number of milliseconds.
 * \param _n The motor regulation frequency in milliseconds
 */
#define SetOutPwnFreq(_n) __setOutPwnFreq(_n)

/**
 * Get motor regulation frequency.
 * Get the current motor regulation frequency.
 * \param _n The motor regulation frequency in milliseconds
 */
#define GetOutPwnFreq(_n) __GetOutPwnFreq(_n)

/**
 * Set motor regulation time.
 * Set the motor regulation time to the specified number of milliseconds.
 * \param _n The motor regulation time in milliseconds
 */
#define SetOutRegulationTime(_n) __setOutRegulationTime(_n)

/**
 * Get motor regulation time.
 * Get the current motor regulation time.
 * \param _n The motor regulation time in milliseconds
 */
#define GetOutRegulationTime(_n) __GetOutRegulationTime(_n)

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Set motor regulation options.
 * Set the motor regulation options.
 * \param _n The motor regulation options
 */
#define SetOutRegulationOptions(_n) __setOutRegulationOptions(_n)

/**
 * Get motor regulation options.
 * Get the current motor regulation options.
 * \param _n The motor regulation options
 */
#define GetOutRegulationOptions(_n) __GetOutRegulationOptions(_n)
#endif

/** @} */ // end of OutputModuleFunctions group
/** @} */ // end of OutputModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// INPUT MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup InputModule
 * @{
 */
/** @defgroup InputModuleFunctions Input module functions
 * Functions for accessing and modifying input module features.
 * @{
 */

/**
 * Set sensor type.
 * Set a sensor's type, which must be one of the predefined sensor type
 * constants.  After changing the type or the mode of a sensor
 * port you must call \ref ResetSensor to give the firmware time to reconfigure
 * the sensor port.
 * \sa SetSensorMode()
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 * \param _t The desired sensor type.  See \ref NBCSensorTypeConstants.
 */
#define SetSensorType(_port,_t) setin _t, _port, TypeField

/**
 * Set sensor mode.
 * Set a sensor's mode, which should be one of the predefined sensor mode
 * constants. A slope parameter for boolean conversion, if desired, may be
 * added to the mode. After changing the type or the mode of a sensor
 * port you must call \ref ResetSensor to give the firmware time to reconfigure
 * the sensor port.
 * \sa SetSensorType()
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 * \param _m The desired sensor mode. See \ref NBCSensorModeConstants.
 */
#define SetSensorMode(_port,_m) setin _m, _port, InputModeField

/**
 * Read sensor scaled value.
 * Return the processed sensor reading for a sensor on the specified port.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants. A variable whose value is
 * the desired sensor port may also be used.
 * \param _value The sensor's scaled value.
 */
#define ReadSensor(_port,_value) getin _value, _port, ScaledValueField

/**
 * Clear a sensor value.
 * Clear the value of a sensor - only affects sensors that are configured
 * to measure a cumulative quantity such as rotation or a pulse count.
 * \param _port The port to clear. See \ref NBCInputPortConstants.
 */
#define ClearSensor(_port) setin 0, _port, ScaledValueField

/**
 * Configure a touch sensor.
 * Configure the sensor on the specified port as a touch sensor.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorTouch(_port) __SetSensorTouch(_port)

/**
 * Configure a light sensor.
 * Configure the sensor on the specified port as an NXT light sensor.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorLight(_port) __SetSensorLight(_port)

/**
 * Configure a sound sensor.
 * Configure the sensor on the specified port as a sound sensor.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorSound(_port) __SetSensorSound(_port)

/**
 * Configure an I2C sensor.
 * Configure the sensor on the specified port as a 9V powered I2C digital sensor.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorLowspeed(_port) __SetSensorLowspeed(_port)

/**
 * Configure an ultrasonic sensor.
 * Configure the sensor on the specified port as an ultrasonic sensor.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorUltrasonic(_port) __SetSensorLowspeed(_port)

/**
 * Configure an EMeter sensor.
 * Configure the sensor on the specified port as an EMeter sensor.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorEMeter(_port) __SetSensorLowspeed(_port)

/**
 * Configure a temperature sensor.
 * Configure the sensor on the specified port as a temperature sensor. Use this
 * to setup the temperature sensor rather than \ref SetSensorLowspeed so that
 * the sensor is properly configured in 12-bit conversion mode.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorTemperature(_port) \
  __SetSensorLowspeed(_port) \
  __MSWriteToRegister(_port, LEGO_ADDR_TEMP, TEMP_REG_CONFIG, TEMP_RES_12BIT, __WDSC_LSStatus)


#if __FIRMWARE_VERSION > 107

/**
 * Configure an NXT 2.0 full color sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in full color mode. Requires an NXT 2.0 compatible firmware.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define SetSensorColorFull(_port) __SetSensorColorFull(_port)

/**
 * Configure an NXT 2.0 red light sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in red light mode. Requires an NXT 2.0 compatible firmware.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define SetSensorColorRed(_port) __SetSensorColorRed(_port)

/**
 * Configure an NXT 2.0 green light sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in green light mode. Requires an NXT 2.0 compatible firmware.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define SetSensorColorGreen(_port) __SetSensorColorGreen(_port)

/**
 * Configure an NXT 2.0 blue light sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in blue light mode. Requires an NXT 2.0 compatible firmware.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define SetSensorColorBlue(_port) __SetSensorColorBlue(_port)

/**
 * Configure an NXT 2.0 no light sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in no light mode. Requires an NXT 2.0 compatible firmware.
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define SetSensorColorNone(_port) __SetSensorColorNone(_port)

#endif

/**
 * Reset the sensor port.
 * Sets the invalid data flag on the specified port and waits for it to
 * become valid again. After changing the type or the mode of a sensor
 * port you must call this function to give the firmware time to reconfigure
 * the sensor port.
 * \param _port The port to reset. See \ref NBCInputPortConstants.
 */
#define ResetSensor(_port) __ResetSensor(_port)

#if __FIRMWARE_VERSION > 107

/**
 * Read LEGO color sensor raw values.
 * This function lets you read the LEGO color sensor. It returns an array
 * containing raw color values for red, green, blue, and none indices.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _rawVals An array containing four raw color values. See \ref InputColorIdxConstants.
 * \param _result The function call result.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define ReadSensorColorRaw(_port, _rawVals, _result) __ReadSensorColorRaw(_port, _rawVals, _result)

/**
 * Read LEGO color sensor extra.
 * This function lets you read the LEGO color sensor. It returns the color value,
 * and three arrays containing raw, normalized, and scaled color values for
 * red, green, blue, and none indices.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _colorval The color value. See \ref InputColorValueConstants.
 * \param _rawVals An array containing four raw color values. See \ref InputColorIdxConstants.
 * \param _normVals An array containing four normalized color values. See \ref InputColorIdxConstants.
 * \param _scaledVals An array containing four scaled color values. See \ref InputColorIdxConstants.
 * \param _result The function call result.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define ReadSensorColorEx(_port, _colorval, _rawVals, _normVals, _scaledVals, _result) \
   __ReadSensorColorEx(_port, _colorval, _rawVals, _normVals, _scaledVals, _result)

#endif

/**
 * Get the custom sensor zero offset.
 * Return the custom sensor zero offset value of a sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants.
 * \param _n The custom sensor zero offset.
 */
#define GetInCustomZeroOffset(_p, _n) __GetInCustomZeroOffset(_p, _n)

/**
 * Read sensor boolean value.
 * Return the boolean value of a sensor on the specified port. Boolean
 * conversion is either done based on preset cutoffs, or a slope parameter
 * specified by calling SetSensorMode.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The sensor's boolean value.
 */
#define GetInSensorBoolean(_p, _n) __GetInSensorBoolean(_p, _n)

/**
 * Read sensor digital pins direction.
 * Return the digital pins direction value of a sensor on the specified port.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The sensor's digital pins direction.
 */
#define GetInDigiPinsDirection(_p, _n) __GetInDigiPinsDirection(_p, _n)

/**
 * Read sensor digital pins status.
 * Return the digital pins status value of a sensor on the specified port.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The sensor's digital pins status.
 */
#define GetInDigiPinsStatus(_p, _n) __GetInDigiPinsStatus(_p, _n)

/**
 * Read sensor digital pins output level.
 * Return the digital pins output level value of a sensor on the specified port.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The sensor's digital pins output level.
 */
#define GetInDigiPinsOutputLevel(_p, _n) __GetInDigiPinsOutputLevel(_p, _n)

/**
 * Get the custom sensor percent full scale.
 * Return the custom sensor percent full scale value of a sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants.
 * \param _n The custom sensor percent full scale.
 */
#define GetInCustomPercentFullScale(_p, _n) __GetInCustomPercentFullScale(_p, _n)

/**
 * Get the custom sensor active status.
 * Return the custom sensor active status value of a sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants.
 * \param _n The custom sensor active status.
*/
#define GetInCustomActiveStatus(_p, _n) __GetInCustomActiveStatus(_p, _n)

#if __FIRMWARE_VERSION > 107

/**
 * Read a LEGO color sensor calibration point value.
 * This function lets you directly access a specific LEGO color calibration point value.
 * The port, point, and color index must be constants.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _np The calibration point. See \ref InputColorCalibrationConstants. Must be a constant.
 * \param _nc The color index. See \ref InputColorIdxConstants. Must be a constant.
 * \param _n The calibration point value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define GetInColorCalibration(_p, _np, _nc, _n) __GetInColorCalibration(_p, _np, _nc, _n)

/**
 * Read a LEGO color sensor calibration limit value.
 * This function lets you directly access a specific LEGO color calibration limit value.
 * The port and the point must be constants.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _np The calibration point. See \ref InputColorCalibrationConstants. Must be a constant.
 * \param _n The calibration limit value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define GetInColorCalLimits(_p, _np, _n) __GetInColorCalLimits(_p, _np, _n)

/**
 * Read a LEGO color sensor AD raw value.
 * This function lets you directly access a specific LEGO color sensor AD raw value. Both the
 * port and the color index must be constants.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _nc The color index. See \ref InputColorIdxConstants. Must be a constant.
 * \param _n The AD raw value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define GetInColorADRaw(_p, _nc, _n) __GetInColorADRaw(_p, _nc, _n)

/**
 * Read a LEGO color sensor raw value.
 * This function lets you directly access a specific LEGO color sensor raw value. Both the
 * port and the color index must be constants.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _nc The color index. See \ref InputColorIdxConstants. Must be a constant.
 * \param _n The raw value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define GetInColorSensorRaw(_p, _nc, _n) __GetInColorSensorRaw(_p, _nc, _n)

/**
 * Read a LEGO color sensor scaled value.
 * This function lets you directly access a specific LEGO color sensor scaled value. Both the
 * port and the color index must be constants.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _nc The color index. See \ref InputColorIdxConstants. Must be a constant.
 * \param _n The scaled value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define GetInColorSensorValue(_p, _nc, _n) __GetInColorSensorValue(_p, _nc, _n)

/**
 * Read a LEGO color sensor boolean value.
 * This function lets you directly access a specific LEGO color sensor boolean value. Both the
 * port and the color index must be constants.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _nc The color index. See \ref InputColorIdxConstants. Must be a constant.
 * \param _n The boolean value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define GetInColorBoolean(_p, _nc, _n) __GetInColorBoolean(_p, _nc, _n)

/**
 * Read LEGO color sensor calibration state.
 * This function lets you directly access the LEGO color calibration state.
 * The port must be a constant.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The calibration state.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
#define GetInColorCalibrationState(_p, _n) __GetInColorCalibrationState(_p, _n)

#endif

/**
 * Set custom zero offset.
 * Sets the zero offset value of a custom sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The new zero offset value.
 */
#define SetInCustomZeroOffset(_p, _n) __setInCustomZeroOffset(_p, _n)

/**
 * Set sensor boolean value.
 * Sets the boolean value of a sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The new boolean value.
 */
#define SetInSensorBoolean(_p, _n) __setInSensorBoolean(_p, _n)

/**
 * Set digital pins direction.
 * Sets the digital pins direction value of a sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The new digital pins direction value.
 */
#define SetInDigiPinsDirection(_p, _n) __setInDigiPinsDirection(_p, _n)

/**
 * Set digital pins status.
 * Sets the digital pins status value of a sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The new digital pins status value.
 */
#define SetInDigiPinsStatus(_p, _n) __setInDigiPinsStatus(_p, _n)

/**
 * Set digital pins output level.
 * Sets the digital pins output level value of a sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The new digital pins output level value.
 */
#define SetInDigiPinsOutputLevel(_p, _n) __setInDigiPinsOutputLevel(_p, _n)

/**
 * Set percent full scale.
 * Sets the percent full scale value of a custom sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The new percent full scale value.
 */
#define SetInCustomPercentFullScale(_p, _n) __setInCustomPercentFullScale(_p, _n)

/**
 * Set active status.
 * Sets the active status value of a custom sensor.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants. Must be a constant.
 * \param _n The new active status value.
 */
#define SetInCustomActiveStatus(_p, _n) __setInCustomActiveStatus(_p, _n)

/** @} */ // end of InputModuleFunctions group
/** @} */ // end of InputModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LOWSPEED MODULE ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup LowSpeedModule
 * @{
 */
/** @defgroup LowSpeedModuleFunctions LowSpeed module functions
 * Functions for accessing and modifying low speed module features.
 * @{
 */

/**
 * Read ultrasonic sensor value.
 * Return the ultrasonic sensor distance value. Since an
 * ultrasonic sensor is an I2C digital sensor its value cannot be read using
 * the standard Sensor(n) value.
 * The port must be configured as a Lowspeed port before using this function.
 * \param _port The port to which the ultrasonic sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _value The ultrasonic sensor distance value (0..255)
 */
#define ReadSensorUS(_port, _value) __ReadSensorUS(_port, _value)

/**
 * Read multiple ultrasonic sensor values.
 * Return eight ultrasonic sensor distance values.
 * \param _port The port to which the ultrasonic sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _values An array of bytes that will contain the 8 distance values
 * read from the ultrasonic sensor.
 * \param _result A status code indicating whether the read completed successfully or not.
 * See \ref TCommLSRead for possible Result values.
 */
#define ReadSensorUSEx(_port, _values, _result) __ReadSensorUSEx(_port, _values, _result)

/**
 * Read the LEGO EMeter values.
 * Read all the LEGO EMeter register values.
 * They must all be read at once to ensure data coherency.
 *
 * \param _port The port to which the LEGO EMeter sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _vIn Input voltage
 * \param _aIn Input current
 * \param _vOut Output voltage
 * \param _aOut Output current
 * \param _joules The number of joules stored in E-Meter
 * \param _wIn The number of watts generated
 * \param _wOut The number of watts consumed
 * \param _result A status code indicating whether the read completed successfully or not.
 * See \ref TCommLSRead for possible Result values.
 */
#define ReadSensorEMeter(_port, _vIn, _aIn, _vOut, _aOut, _joules, _wIn, _wOut, _result) __ReadSensorEMeter(_port, _vIn, _aIn, _vOut, _aOut, _joules, _wIn, _wOut, _result)

/**
 * Configure LEGO Temperature sensor options.
 * Set various LEGO Temperature sensor options.
 *
 * \param _port The port to which the LEGO EMeter sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _config The temperature sensor configuration settings.  See
 * \ref TempI2CConstants for configuration constants that can be ORed or added
 * together.
 * \param _result A status code indicating whether the read completed successfully or not.
 * See \ref TCommLSRead for possible Result values.
 */
#define ConfigureTemperatureSensor(_port, _config, _result) __TempSendCmd(_port, _config, _result)

/**
 * Read the LEGO Temperature sensor value.
 * Return the temperature sensor value in degrees celcius. Since a
 * temperature sensor is an I2C digital sensor its value cannot be read using
 * the standard Sensor(n) value.
 * The port must be configured as a temperature sensor port before using this
 * function. Use \ref SetSensorTemperature to configure the port.
 * \param _port The port to which the temperature sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _temp The temperature sensor value in degrees celcius.
 */
#define ReadSensorTemperature(_port, _temp) __ReadSensorTemperature(_port, _temp)

/**
 * Get lowspeed status.
 * This method checks the status of the I2C communication on the specified
 * port. If the last operation on this port was a successful LowspeedWrite
 * call that requested response data from the device then bytesready will
 * be set to the number of bytes in the internal read buffer.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _bready The number of bytes available to be read from the internal I2C buffer.
 * The maximum number of bytes that can be read is 16.
 * \param _result A status code indicating whether the write completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * Avoid calls to \ref LowspeedRead or \ref LowspeedWrite while LowspeedStatus returns
 * \ref STAT_COMM_PENDING.
 * \sa LowspeedRead, LowspeedWrite, and LowspeedCheckStatus
 */
#define LowspeedStatus(_port, _bready, _result) __lowspeedStatus(_port, _bready, _result)

/**
 * Check lowspeed status.
 * This method checks the status of the I2C communication on the specified
 * port.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _result A status code indicating whether the write completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * Avoid calls to \ref LowspeedRead or \ref LowspeedWrite while LowspeedCheckStatus returns
 * \ref STAT_COMM_PENDING.
 * \sa LowspeedRead, LowspeedWrite, and LowspeedStatus
 */
#define LowspeedCheckStatus(_port, _result) __lowspeedCheckStatus(_port, _result)

/**
 * Get lowspeed bytes ready.
 * This method checks the number of bytes that are ready to be read on the
 * specified port. If the last operation on this port was a successful
 * LowspeedWrite call that requested response data from the device then the
 * return value will be the number of bytes in the internal read buffer.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _bready The number of bytes available to be read from the internal I2C buffer.
 * The maximum number of bytes that can be read is 16.
 * \sa LowspeedRead, LowspeedWrite, and LowspeedStatus
 */
#define LowspeedBytesReady(_port, _bready) __lowspeedBytesReady(_port, _bready)

/**
 * Write lowspeed data.
 * This method starts a transaction to write the bytes contained in the array
 * buffer to the I2C device on the specified port. It also tells the I2C device
 * the number of bytes that should be included in the response. The maximum
 * number of bytes that can be written or read is 16.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _retlen The number of bytes that should be returned by the I2C device.
 * \param _buffer A byte array containing the address of the I2C device, the I2C
 * device register at which to write data, and up to 14 bytes of data to be
 * written at the specified register.
 * \param _result A status code indicating whether the write completed successfully or not.
 * See \ref TCommLSWrite for possible Result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * \sa LowspeedRead, LowspeedCheckStatus, LowspeedBytesReady, and LowspeedStatus
 */
#define LowspeedWrite(_port, _retlen, _buffer, _result) __lowspeedWrite(_port, _retlen, _buffer, _result)

/**
 * Read lowspeed data.
 * Read the specified number of bytes from the I2C device on the specified
 * port and store the bytes read in the byte array buffer provided.  The maximum
 * number of bytes that can be written or read is 16.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _buflen The initial size of the output buffer.
 * \param _buffer A byte array that contains the data read from the internal I2C
 * buffer.  If the return value is negative then the output buffer will be empty.
 * \param _result A status code indicating whether the write completed successfully or not.
 * See \ref TCommLSRead for possible Result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * \sa LowspeedWrite, LowspeedCheckStatus, LowspeedBytesReady, and LowspeedStatus
 */
#define LowspeedRead(_port, _buflen, _buffer, _result) __lowspeedRead(_port, _buflen, _buffer, _result)

/**
 * Perform an I2C write/read transaction.
 * This method writes the bytes contained in the input buffer (inbuf) to the
 * I2C device on the specified port, checks for the specified number of bytes
 * to be ready for reading, and then tries to read the specified number (count)
 * of bytes from the I2C device into the output buffer (outbuf).
 *
 * This is a higher-level wrapper around the three main I2C functions. It also
 * maintains a "last good read" buffer and returns values from that buffer if
 * the I2C communication transaction fails.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _inbuf A byte array containing the address of the I2C device, the I2C
 * device register at which to write data, and up to 14 bytes of data to be
 * written at the specified register.
 * \param _count The number of bytes that should be returned by the I2C device.
 * On output count is set to the number of bytes in outbuf.
 * \param _outbuf A byte array that contains the data read from the internal I2C
 * buffer.
 * \param _result Returns true or false indicating whether the I2C transaction
 * succeeded or failed.
 * \sa LowspeedRead, LowspeedWrite, LowspeedCheckStatus, LowspeedBytesReady,
 * and LowspeedStatus
 */
#define ReadI2CBytes(_port, _inbuf, _count, _outbuf, _result) __ReadI2CBytes(_port, _inbuf, _count, _outbuf, _result)

/**
 * Read I2C device information.
 * Read standard I2C device information: version, vendor, and device ID. The
 * I2C device uses the specified address.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _i2caddr The I2C device address.
 * \param _info A value indicating the type of device information you are requesting.
 * See \ref GenericI2CConstants.
 * \param _strVal A string containing the requested device information.
 */
#define ReadI2CDeviceInfo(_port, _i2caddr, _info, _strVal) __ReadI2CDeviceInfo(_port, _i2caddr, _info, _strVal)

/**
 * Read I2C device version.
 * Read standard I2C device version. The I2C device uses the specified address.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _i2caddr The I2C device address.
 * \param _strVal A string containing the device version.
 */
#define ReadI2CVersion(_port, _i2caddr, _strVal) ReadI2CDeviceInfo(_port, _i2caddr, I2C_REG_VERSION, _strVal)

/**
 * Read I2C device vendor.
 * Read standard I2C device vendor. The I2C device uses the specified address.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _i2caddr The I2C device address.
 * \param _strVal A string containing the device vendor.
 */
#define ReadI2CVendorId(_port, _i2caddr, _strVal) ReadI2CDeviceInfo(_port, _i2caddr, I2C_REG_VENDOR_ID, _strVal)

/**
 * Read I2C device identifier.
 * Read standard I2C device identifier. The I2C device uses the specified address.
 *
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _i2caddr The I2C device address.
 * \param _strVal A string containing the device identifier.
 */
#define ReadI2CDeviceId(_port, _i2caddr, _strVal) ReadI2CDeviceInfo(_port, _i2caddr, I2C_REG_DEVICE_ID, _strVal)

/**
 * Read I2C register.
 * Read a single byte from an I2C device register.
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _i2caddr The I2C device address.
 * \param _reg The I2C device register from which to read a single byte.
 * \param _out The single byte read from the I2C device.
 * \param _result A status code indicating whether the read completed successfully or not.
 * See \ref TCommLSRead for possible Result values.
 */
#define ReadI2CRegister(_port, _i2caddr, _reg, _out, _result) __MSReadValue(_port, _i2caddr, _reg, 1, _out, _result)

/**
 * Write I2C register.
 * Write a single byte to an I2C device register.
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _i2caddr The I2C device address.
 * \param _reg The I2C device register to which to write a single byte.
 * \param _val The byte to write to the I2C device.
 * \param _result A status code indicating whether the write completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define WriteI2CRegister(_port, _i2caddr, _reg, _val, _result) __MSWriteToRegister(_port, _i2caddr, _reg, _val, _result)

/**
 * Send an I2C command.
 * Send a command to an I2C device at the standard command register: \ref I2C_REG_CMD.
 * The I2C device uses the specified address.
 * \param _port The port to which the I2C device is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param _i2caddr The I2C device address.
 * \param _cmd The command to send to the I2C device.
 * \param _result A status code indicating whether the write completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define I2CSendCommand(_port, _i2caddr, _cmd, _result) __I2CSendCmd(_port, _i2caddr, _cmd, _result)

/** @defgroup LowLevelLowSpeedModuleFunctions Low level LowSpeed module functions
 * Low level functions for accessing low speed module features.
 * @{
 */

/**
 * Get I2C input buffer data.
 * This method reads count bytes of data from the I2C input buffer for the
 * specified port and writes it to the buffer provided.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _offset A constant offset into the I2C input buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the I2C input buffer.
 */
#define GetLSInputBuffer(_p, _offset, _cnt, _data) __getLSInputBuffer(_p, _offset, _cnt, _data)

/**
 * Get I2C input buffer in-pointer.
 * This method returns the value of the input pointer of the I2C input
 * buffer for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C input buffer's in-pointer value.
 */
#define GetLSInputBufferInPtr(_p, _n) __GetLSInputBufferInPtr(_p, _n)

/**
 * Get I2C input buffer out-pointer.
 * This method returns the value of the output pointer of the I2C input
 * buffer for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C input buffer's out-pointer value.
 */
#define GetLSInputBufferOutPtr(_p, _n) __GetLSInputBufferOutPtr(_p, _n)

/**
 * Get I2C input buffer bytes to rx.
 * This method returns the value of the bytes to rx field of the I2C input
 * buffer for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C input buffer's bytes to rx value.
 */
#define GetLSInputBufferBytesToRx(_p, _n) __GetLSInputBufferBytesToRx(_p, _n)

/**
 * Get I2C output buffer data.
 * This method reads cnt bytes of data from the I2C output buffer for the
 * specified port and writes it to the buffer provided.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _offset A constant offset into the I2C output buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the I2C output buffer.
 */
#define GetLSOutputBuffer(_p, _offset, _cnt, _data) __getLSOutputBuffer(_p, _offset, _cnt, _data)

/**
 * Get I2C output buffer in-pointer.
 * This method returns the value of the input pointer of the I2C output
 * buffer for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C output buffer's in-pointer value.
 */
#define GetLSOutputBufferInPtr(_p, _n) __GetLSOutputBufferInPtr(_p, _n)

/**
 * Get I2C output buffer out-pointer.
 * This method returns the value of the output pointer of the I2C output
 * buffer for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C output buffer's out-pointer value.
 */
#define GetLSOutputBufferOutPtr(_p, _n) __GetLSOutputBufferOutPtr(_p, _n)

/**
 * Get I2C output buffer bytes to rx.
 * This method returns the value of the bytes to rx field of the I2C output
 * buffer for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C output buffer's bytes to rx value.
 */
#define GetLSOutputBufferBytesToRx(_p, _n) __GetLSOutputBufferBytesToRx(_p, _n)

/**
 * Get I2C mode.
 * This method returns the value of the I2C mode for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C port mode. See \ref LowSpeedModeConstants.
 */
#define GetLSMode(_p, _n) __GetLSMode(_p, _n)

/**
 * Get I2C channel state.
 * This method returns the value of the I2C channel state for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C port channel state. See \ref LowSpeedChannelStateConstants.
 */
#define GetLSChannelState(_p, _n) __GetLSChannelState(_p, _n)

/**
 * Get I2C error type.
 * This method returns the value of the I2C error type for the specified port.
 * \param _p A constant port number (S1..S4). See \ref NBCInputPortConstants.
 * \param _n The I2C port error type. See \ref LowSpeedErrorTypeConstants.
 */
#define GetLSErrorType(_p, _n) __GetLSErrorType(_p, _n)

/**
 * Get I2C state.
 * This method returns the value of the I2C state.
 * \param _n The I2C state. See \ref LowSpeedStateConstants.
 */
#define GetLSState(_n) __GetLSState(_n)

/**
 * Get I2C speed.
 * This method returns the value of the I2C speed.
 * \param _n The I2C speed.
 *
 * \warning This function is unimplemented within the firmware.
 */
#define GetLSSpeed(_n) __GetLSSpeed(_n)

#ifdef __ENHANCED_FIRMWARE
/**
 * Get I2C no restart on read setting.
 * This method returns the value of the I2C no restart on read field.
 * \param _n The I2C no restart on read field. See \ref LowSpeedNoRestartConstants.
 */
#define GetLSNoRestartOnRead(_n) __GetLSNoRestartOnRead(_n)
#endif

/** @} */ // end of LowLevelLowSpeedModuleFunctions group

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Set I2C options.
 * This method lets you modify I2C options. Use this function to turn on
 * or off the fast I2C mode and also control whether the standard I2C mode
 * performs a restart prior to the read operation.
 *
 * \param _port The port whose I2C options you wish to change. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _options The new option value. See \ref I2COptionConstants.
 */
#define SetI2COptions(_port, _options) __setI2COptions(_port, _options)

#endif

/** @} */ // end of LowSpeedModuleFunctions group
/** @} */ // end of LowSpeedModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// DISPLAY MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup DisplayModule
 * @{
 */
/** @defgroup DisplayModuleFunctions Display module functions
 * Functions for accessing and modifying display module features.
 * @{
 */

/**
 * Clear a line on the LCD screen.
 * This function lets you clear a single line on the NXT LCD.
 * \param _line The line you want to clear. See \ref LineConstants.
 */
#define ClearLine(_line) __TextOutEx(0, _line, __BlankLine, 0)

/**
 * Draw a point with drawing options.
 * This function lets you draw a point on the screen at x, y.
 * Also specify drawing options. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa TDrawPoint
 *
 * \param _x The x value for the point.
 * \param _y The y value for the point.
 * \param _options The optional drawing options.
 */
#define PointOutEx(_x,_y,_options) __PointOutEx(_x,_y,_options)

/**
 * Draw a point.
 * This function lets you draw
 a point on the screen at x, y.
 * \sa TDrawPoint
 *
 * \param _x The x value for the point.
 * \param _y The y value for the point.
 */
#define PointOut(_x,_y) __PointOutEx(_x,_y,0)

/**
 * Clear LCD screen.
 * This function lets you clear the NXT LCD to a blank screen.
 */
#define ClearScreen() __PointOutEx(200, 200, 1)

/**
 * Draw a line with drawing options.
 * This function lets you draw a line on the screen from x1, y1 to x2, y2.
 * Also specify drawing options. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa TDrawLine
 *
 * \param _x1 The x value for the start of the line.
 * \param _y1 The y value for the start of the line.
 * \param _x2 The x value for the end of the line.
 * \param _y2 The y value for the end of the line.
 * \param _options The optional drawing options.
 */
#define LineOutEx(_x1,_y1,_x2,_y2,_options) __LineOutEx(_x1,_y1,_x2,_y2,_options)

/**
 * Draw a line.
 * This function lets you draw a line on the screen from x1, y1 to x2, y2.
 * \sa TDrawLine
 *
 * \param _x1 The x value for the start of the line.
 * \param _y1 The y value for the start of the line.
 * \param _x2 The x value for the end of the line.
 * \param _y2 The y value for the end of the line.
 */
#define LineOut(_x1,_y1,_x2,_y2) __LineOutEx(_x1,_y1,_x2,_y2,0)

/**
 * Draw a rectangle with drawing options.
 * This function lets you draw a rectangle on the screen at x, y with the
 * specified width and height.
 * Also specify drawing options. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa TDrawRect
 *
 * \param _x The x value for the top left corner of the rectangle.
 * \param _y The y value for the top left corner of the rectangle.
 * \param _w The width of the rectangle.
 * \param _h The height of the rectangle.
 * \param _options The optional drawing options.
 */
#define RectOutEx(_x,_y,_w,_h,_options) __RectOutEx(_x,_y,_w,_h,_options)

/**
 * Draw a rectangle.
 * This function lets you draw a rectangle on the screen at x, y with the
 * specified width and height.
 * \sa TDrawRect
 *
 * \param _x The x value for the top left corner of the rectangle.
 * \param _y The y value for the top left corner of the rectangle.
 * \param _w The width of the rectangle.
 * \param _h The height of the rectangle.
 */
#define RectOut(_x,_y,_w,_h) __RectOutEx(_x,_y,_w,_h,0)

/**
 * Draw a circle with drawing options.
 * This function lets you draw a circle on the screen with its center at the
 * specified x and y location, using the specified radius. Also specify
 * drawing options. Valid display option constants are listed in the
 * \ref DisplayDrawOptionConstants group.
 * \sa TDrawCircle
 *
 * \param _x The x value for the center of the circle.
 * \param _y The y value for the center of the circle.
 * \param _r The radius of the circle.
 * \param _options The optional drawing options.
 */
#define CircleOutEx(_x,_y,_r,_options) __CircleOutEx(_x,_y,_r,_options)

/**
 * Draw a circle.
 * This function lets you draw a circle on the screen with its center at the
 * specified x and y location, using the specified radius.
 * \sa TDrawCircle
 *
 * \param _x The x value for the center of the circle.
 * \param _y The y value for the center of the circle.
 * \param _r The radius of the circle.
 */
#define CircleOut(_x,_y,_r) __CircleOutEx(_x,_y,_r,0)

/**
 * Draw a number with drawing options.
 * Draw a numeric value on the screen at the specified x and y location. The y
 * value must be a multiple of 8.  Valid line number constants are listed in
 * the \ref LineConstants group.
 * Also specify drawing options. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa TDrawText
 *
 * \param _x The x value for the start of the number output.
 * \param _y The text line number for the number output.
 * \param _num The value to output to the LCD screen. Any numeric type is supported.
 * \param _options The optional drawing options.
 */
#define NumOutEx(_x,_y,_num,_options) __NumOutEx(_x,_y,_num,_options)

/**
 * Draw a number.
 * Draw a numeric value on the screen at the specified x and y location. The y
 * value must be a multiple of 8.  Valid line number constants are listed in
 * the \ref LineConstants group.
 * \sa TDrawText
 *
 * \param _x The x value for the start of the number output.
 * \param _y The text line number for the number output.
 * \param _num The value to output to the LCD screen. Any numeric type is supported.
 */
#define NumOut(_x,_y,_num) __NumOutEx(_x,_y,_num,0)

/**
 * Draw text.
 * Draw a text value on the screen at the specified x and y location. The y
 * value must be a multiple of 8.  Valid line number constants are listed in
 * the \ref LineConstants group.
 * Also specify drawing options. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa TDrawText
 *
 * \param _x The x value for the start of the text output.
 * \param _y The text line number for the text output.
 * \param _txt The text to output to the LCD screen.
 * \param _options The optional drawing options.
 */
#define TextOutEx(_x,_y,_txt,_options) __TextOutEx(_x,_y,_txt,_options)

/**
 * Draw text.
 * Draw a text value on the screen at the specified x and y location. The y
 * value must be a multiple of 8.  Valid line number constants are listed in
 * the \ref LineConstants group.
 * \sa TDrawText
 *
 * \param _x The x value for the start of the text output.
 * \param _y The text line number for the text output.
 * \param _txt The text to output to the LCD screen.
 */
#define TextOut(_x,_y,_txt) __TextOutEx(_x,_y,_txt,0)

/**
 * Draw a graphic image with parameters and drawing options.
 * Draw a graphic image file on the screen at the specified x and y location using
 * an array of parameters. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group. If the file cannot be found then
 * nothing will be drawn and no errors will be reported.
 * \sa TDrawGraphic
 *
 * \param _x The x value for the position of the graphic image.
 * \param _y The y value for the position of the graphic image.
 * \param _file The filename of the RIC graphic image.
 * \param _vars The byte array of parameters.
 * \param _options The drawing options.
 */
#define GraphicOutEx(_x,_y,_file,_vars,_options) __GraphicOutEx(_x,_y,_file,_vars,_options)

/**
 * Draw a graphic image.
 * Draw a graphic image file on the screen at the specified x and y location.
 * If the file cannot be found then
 * nothing will be drawn and no errors will be reported.
 * \sa TDrawGraphic
 *
 * \param _x The x value for the position of the graphic image.
 * \param _y The y value for the position of the graphic image.
 * \param _file The filename of the RIC graphic image.
 */
#define GraphicOut(_x,_y,_file) __GraphicOutEx(_x,_y,_file,__GraphicOutEmptyVars,0)

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)

/**
 * Draw a graphic image from byte array with parameters and drawing options.
 * Draw a graphic image byte array on the screen at the specified x and y
 * location using an array of parameters and drawing options.
 * Valid display option constants are listed in the
 * \ref DisplayDrawOptionConstants group. If the file cannot be found then
 * nothing will be drawn and no errors will be reported.
 * \sa TDrawGraphicArray
 *
 * \param _x The x value for the position of the graphic image.
 * \param _y The y value for the position of the graphic image.
 * \param _data The byte array of the RIC graphic image.
 * \param _vars The byte array of parameters.
 * \param _options The drawing options.
 */
#define GraphicArrayOutEx(_x,_y,_data,_vars,_options) __GraphicArrayOutEx(_x,_y,_data,_vars,_options)

/**
 * Draw a graphic image from byte array.
 * Draw a graphic image byte array on the screen at the specified x and y
 * location. If the file cannot be found then nothing will be drawn and no
 * errors will be reported.
 * \sa TDrawGraphicArray
 *
 * \param _x The x value for the position of the graphic image.
 * \param _y The y value for the position of the graphic image.
 * \param _data The byte array of the RIC graphic image.
 */
#define GraphicArrayOut(_x,_y,_data) __GraphicArrayOutEx(_x,_y,_data,__GraphicOutEmptyVars,0)

/**
 * Draw an ellipse with drawing options.
 * This function lets you draw an ellipse on the screen with its center at the
 * specified x and y location, using the specified radii. Also specify
 * drawing options. Valid display option constants are listed in the
 * \ref DisplayDrawOptionConstants group.
 * \sa SysDrawEllipse, DrawEllipseType
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _x The x value for the center of the ellipse.
 * \param _y The y value for the center of the ellipse.
 * \param _rX The x axis radius.
 * \param _rY The y axis radius.
 * \param _options The drawing options.
 */
#define EllipseOutEx(_x,_y,_rX,_rY,_options) __EllipseOutEx(_x,_y,_rX,_rY,_options)

/**
 * Draw an ellipse.
 * This function lets you draw an ellipse on the screen with its center at the
 * specified x and y location, using the specified radii.
 * \sa TDrawEllipse
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _x The x value for the center of the ellipse.
 * \param _y The y value for the center of the ellipse.
 * \param _rX The x axis radius.
 * \param _rY The y axis radius.
 */
#define EllipseOut(_x,_y,_rX,_rY) __EllipseOutEx(_x,_y,_rX,_rY,0)

/**
 * Draw a polygon with drawing options.
 * This function lets you draw a polygon on the screen using an array of points.
 * Also specify drawing options. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa TDrawPolygon
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _points An array of \ref TLocation points that define the polygon.
 * \param _options The drawing options.
 */
#define PolyOutEx(_points,_options) __PolyOutEx(_points,_options)

/**
 * Draw a polygon.
 * This function lets you draw a polygon on the screen using an array of points.
 * \sa TDrawPolygon
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _points An array of LocationType points that define the polygon.
 */
#define PolyOut(_points) __PolyOutEx(_points,0)

/**
 * Draw text with font and drawing options.
 * Draw a text value on the screen at the specified x and y location using
 * a custom RIC font. Also specify drawing options. Valid display option
 * constants are listed in the \ref DisplayDrawOptionConstants group.  See the
 * \ref DisplayFontDrawOptionConstants for options specific to the font
 * drawing functions.
 * \sa FontNumOut, TDrawFont
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _x The x value for the start of the text output.
 * \param _y The y value for the start of the text output.
 * \param _fnt The filename of the RIC font.
 * \param _txt The text to output to the LCD screen.
 * \param _options The drawing options.
 */
#define FontTextOutEx(_x,_y,_fnt,_txt,_options) __FontTextOutEx(_x,_y,_fnt,_txt,_options)

/**
 * Draw text with font.
 * Draw a text value on the screen at the specified x and y location using
 * a custom RIC font.
 * \sa FontNumOut, TDrawFont
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _x The x value for the start of the text output.
 * \param _y The y value for the start of the text output.
 * \param _fnt The filename of the RIC font.
 * \param _txt The text to output to the LCD screen.
 */
#define FontTextOut(_x,_y,_fnt,_txt) __FontTextOutEx(_x,_y,_fnt,_txt,0)

/**
 * Draw a number with font and drawing options.
 * Draw a numeric value on the screen at the specified x and y location using
 * a custom RIC font. Also specify drawing options. Valid display option
 * constants are listed in the \ref DisplayDrawOptionConstants group.  See the
 * \ref DisplayFontDrawOptionConstants for options specific to the font
 * drawing functions.
 * \sa FontTextOut, TDrawFont
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _x The x value for the start of the number output.
 * \param _y The y value for the start of the number output.
 * \param _fnt The filename of the RIC font.
 * \param _num The value to output to the LCD screen. Any numeric type is supported.
 * \param _options The optional drawing options.
 */
#define FontNumOutEx(_x,_y,_fnt,_num,_options) __FontNumOutEx(_x,_y,_fnt,_num,_options)

/**
 * Draw a number with font.
 * Draw a numeric value on the screen at the specified x and y location using
 * a custom RIC font.
 * \sa FontTextOut, TDrawFont
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _x The x value for the start of the number output.
 * \param _y The y value for the start of the number output.
 * \param _fnt The filename of the RIC font.
 * \param _num The value to output to the LCD screen. Any numeric type is supported.
 */
#define FontNumOut(_x,_y,_fnt,_num) __FontNumOutEx(_x,_y,_fnt,_num,0)

#endif

/**
 * Read the display erase mask value.
 * This function lets you read the current display erase mask value.
 * \param _n The current display erase mask value.
 */
#define GetDisplayEraseMask(_n) __GetDisplayEraseMask(_n)

/**
 * Read the display update mask value.
 * This function lets you read the current display update mask value.
 * \param _n The current display update mask.
 */
#define GetDisplayUpdateMask(_n) __GetDisplayUpdateMask(_n)

/**
 * Read the display font memory address.
 * This function lets you read the current display font memory address.
 * \param _n The current display font memory address.
 */
#define GetDisplayFont(_n) __GetDisplayFont(_n)

/**
 * Read the display memory address.
 * This function lets you read the current display memory address.
 * \param _n The current display memory address.
 */
#define GetDisplayDisplay(_n) __GetDisplayDisplay(_n)

/**
 * Read the display flags.
 * This function lets you read the current display flags.
 * Valid flag values are listed in the \ref DisplayFlagsGroup group.
 * \param _n The current display flags.
 */
#define GetDisplayFlags(_n) __GetDisplayFlags(_n)

/**
 * Read the display text lines center flags.
 * This function lets you read the current display text lines center flags.
 * \param _n The current display text lines center flags.
 */
#define GetDisplayTextLinesCenterFlags(_n) __GetDisplayTextLinesCenterFlags(_n)

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Read the display contrast setting.
 * This function lets you read the current display contrast setting.
 * \param _n The current display contrast (byte).
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define GetDisplayContrast(_n) __GetDisplayContrast(_n)
#endif

/**
 * Read pixel data from the normal display buffer.
 * Read "cnt" bytes from the normal display memory into the data array. Start
 * reading from the specified x, line coordinate. Each byte of data read from
 * screen memory is a vertical strip of 8 bits at the desired location. Each
 * bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through
 * TEXTLINE_8 for the "line" parameter.
 *
 * \param _x The desired x position from which to read pixel data.
 * \param _line The desired line from which to read pixel data.
 * \param _cnt The number of bytes of pixel data to read.
 * \param _data The array of bytes into which pixel data is read.
 */
#define GetDisplayNormal(_x, _line, _cnt, _data) __getDisplayNormal(_x, _line, _cnt, _data)

/**
 * Read pixel data from the popup display buffer.
 * Read "cnt" bytes from the popup display memory into the data array. Start
 * reading from the specified x, line coordinate. Each byte of data read from
 * screen memory is a vertical strip of 8 bits at the desired location. Each
 * bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through
 * TEXTLINE_8 for the "line" parameter.
 *
 * \param _x The desired x position from which to read pixel data.
 * \param _line The desired line from which to read pixel data.
 * \param _cnt The number of bytes of pixel data to read.
 * \param _data The array of bytes into which pixel data is read.
 */
#define GetDisplayPopup(_x, _line, _cnt, _data) __getDisplayPopup(_x, _line, _cnt, _data)

/**
 * Set the display font memory address.
 * This function lets you set the current display font memory address.
 *
 * \param _n The new display font memory address.
 */
#define SetDisplayFont(_n) __setDisplayFont(_n)

/**
 * Set the display memory address.
 * This function lets you set the current display memory address.
 *
 * \param _n The new display memory address.
 */
#define SetDisplayDisplay(_n) __setDisplayDisplay(_n)

/**
 * Set the display erase mask.
 * This function lets you set the current display erase mask.
 *
 * \param _n The new display erase mask.
 */
#define SetDisplayEraseMask(_n) __setDisplayEraseMask(_n)

/**
 * Set the display flags.
 * This function lets you set the current display flags.
 *
 * \param _n The new display flags. See \ref DisplayFlagsGroup.
 */
#define SetDisplayFlags(_n) __setDisplayFlags(_n)

/**
 * Set the display text lines center flags.
 * This function lets you set the current display text lines center flags.
 *
 * \param _n The new display text lines center flags.
 */
#define SetDisplayTextLinesCenterFlags(_n) __setDisplayTextLinesCenterFlags(_n)

/**
 * Set the display update mask.
 * This function lets you set the current display update mask.
 *
 * \param _n The new display update mask.
 */
#define SetDisplayUpdateMask(_n) __setDisplayUpdateMask(_n)

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Set the display contrast.
 * This function lets you set the display contrast setting.
 *
 * \param _n The desired display contrast.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define SetDisplayContrast(_n) __setDisplayContrast(_n)
#endif

/**
 * Write pixel data to the normal display buffer.
 * Write "cnt" bytes to the normal display memory from the data array. Start
 * writing at the specified x, line coordinate. Each byte of data is a
 * vertical strip of 8 bits at the desired location. Each
 * bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through
 * TEXTLINE_8 for the "line" parameter.
 *
 * \param _x The desired x position where you wish to write pixel data.
 * \param _line The desired line where you wish to write pixel data.
 * \param _cnt The number of bytes of pixel data to write.
 * \param _data The array of bytes from which pixel data is read.
 */
#define SetDisplayNormal(_x, _line, _cnt, _data) __setDisplayNormal(_x, _line, _cnt, _data)

/**
 * Write pixel data to the popup display buffer.
 * Write "cnt" bytes to the popup display memory from the data array. Start
 * writing at the specified x, line coordinate. Each byte of data is a
 * vertical strip of 8 bits at the desired location. Each
 * bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through
 * TEXTLINE_8 for the "line" parameter.
 *
 * \param _x The desired x position where you wish to write pixel data.
 * \param _line The desired line where you wish to write pixel data.
 * \param _cnt The number of bytes of pixel data to write.
 * \param _data The array of bytes from which pixel data is read.
 */
#define SetDisplayPopup(_x, _line, _cnt, _data) __setDisplayPopup(_x, _line, _cnt, _data)

/** @} */ // end of DisplayModuleFunctions group
/** @} */ // end of DisplayModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SOUND MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup SoundModule
 * @{
 */
/** @defgroup SoundModuleFunctions Sound module functions
 * Functions for accessing and modifying sound module features.
 * @{
 */

/**
 * Play a tone with extra options.
 * Play a single tone of the specified frequency, duration, and volume. The
 * frequency is in Hz (see the \ref ToneConstants group). The duration is in
 * 1000ths of a second (see the \ref TimeConstants group). Volume should be a
 * number from 0 (silent) to 4 (loudest). Play the tone repeatedly if loop is
 * true.
 *
 * \param _freq The desired tone frequency, in Hz.
 * \param _dur The desired tone duration, in ms.
 * \param _vol The desired tone volume.
 * \param _loop A boolean flag indicating whether to play the tone repeatedly.
 */
#define PlayToneEx(_freq,_dur,_vol,_loop) __PlayToneEx(_freq,_dur,_vol,_loop)

/**
 * Play a tone.
 * Play a single tone of the specified frequency and duration. The frequency is
 * in Hz (see the \ref ToneConstants group). The duration is in 1000ths of a
 * second (see the \ref TimeConstants group). The tone is played at the loudest
 * sound level supported by the firmware and it is not looped.
 *
 * \param _freq The desired tone frequency, in Hz.
 * \param _dur The desired tone duration, in ms.
 */
#define PlayTone(_freq,_dur) __PlayToneEx(_freq,_dur,4,0)

/**
 * Play a file.
 * Play the specified file. The filename may be any valid string expression.
 * The sound file can either be an RSO file containing PCM or compressed ADPCM
 * samples or it can be an NXT melody (RMD) file containing frequency and
 * duration values.
 *
 * \param _file The name of the sound or melody file to play.
 */
#define PlayFile(_file) __PlayFileEx(_file,4,0)

/**
 * Play a file with extra options.
 * Play the specified file. The filename may be any valid string expression.
 * Volume should be a number from 0 (silent) to 4 (loudest). Play the file
 * repeatedly if loop is true.
 * The sound file can either be an RSO file containing PCM or compressed ADPCM
 * samples or it can be an NXT melody (RMD) file containing frequency and
 * duration values.
 *
 * \param _file The name of the sound or melody file to play.
 * \param _vol The desired tone volume.
 * \param _loop A boolean flag indicating whether to play the file repeatedly.
 */
#define PlayFileEx(_file,_vol,_loop) __PlayFileEx(_file,_vol,_loop)

/**
 * Get sound module state and flags.
 * Return the current sound module state and flags.
 * See the \ref SoundStateConstants group.
 *
 * \sa SetSoundState
 * \param _state The current sound module state.
 * \param _flags The current sound module flags.
 */
#define GetSoundState(_state, _flags) __GetSoundState(_state, _flags)

/**
 * Set sound module state and flags.
 * Set the sound module state and flags.
 * See the \ref SoundStateConstants group.
 *
 * \sa GetSoundState
 * \param _state The sound module state.
 * \param _flags The sound module flags.
 * \param _result The function call result.
 */
#define SetSoundState(_state, _flags, _result) __setSoundState(_state, _flags, _result)

/**
 * Get sound frequency.
 * Return the current sound frequency.
 *
 * \sa SetSoundFrequency
 * \param _n The current sound frequency.
 */
#define GetSoundFrequency(_n) __GetSoundFrequency(_n)

/**
 * Get sound duration.
 * Return the current sound duration.
 *
 * \sa SetSoundDuration
 * \param _n The current sound duration.
 */
#define GetSoundDuration(_n) __GetSoundDuration(_n)

/**
 * Get sample rate.
 * Return the current sound sample rate.
 *
 * \sa SetSoundSampleRate
 * \param _n The current sound sample rate.
 */
#define GetSoundSampleRate(_n) __GetSoundSampleRate(_n)

/**
 * Get sound mode.
 * Return the current sound mode.  See the \ref SoundModeConstants group.
 *
 * \sa SetSoundMode
 * \param _n The current sound mode.
 */
#define GetSoundMode(_n) __GetSoundMode(_n)

/**
 * Get volume.
 * Return the current sound volume.
 *
 * \sa SetSoundVolume
 * \param _n The current sound volume.
 */
#define GetSoundVolume(_n) __GetSoundVolume(_n)

/**
 * Set sound duration.
 * Set the sound duration.
 *
 * \sa GetSoundDuration
 * \param _n The new sound duration
 */
#define SetSoundDuration(_n) __setSoundDuration(_n)

/**
 * Set sound module flags.
 * Set the sound module flags. See the \ref SoundFlagsConstants group.
 *
 * \param _n The new sound module flags
 */
#define SetSoundFlags(_n) __setSoundFlags(_n)

/**
 * Set sound frequency.
 * Set the sound frequency.
 *
 * \sa GetSoundFrequency
 * \param _n The new sound frequency
 */
#define SetSoundFrequency(_n) __setSoundFrequency(_n)

/**
 * Set sound mode.
 * Set the sound mode.  See the \ref SoundModeConstants group.
 *
 * \sa GetSoundMode
 * \param _n The new sound mode
 */
#define SetSoundMode(_n) __setSoundMode(_n)

/**
 * Set sound module state.
 * Set the sound module state. See the \ref SoundStateConstants group.
 *
 * \sa GetSoundState
 * \param _n The new sound state
 */
#define SetSoundModuleState(_n) __setSoundModuleState(_n)

/**
 * Set sample rate.
 * Set the sound sample rate.
 *
 * \sa GetSoundSampleRate
 * \param _n The new sample rate
 */
#define SetSoundSampleRate(_n) __setSoundSampleRate(_n)

/**
 * Set sound volume.
 * Set the sound volume.
 *
 * \sa GetSoundVolume
 * \param _n The new volume
 */
#define SetSoundVolume(_n) __setSoundVolume(_n)

/** @} */ // end of SoundModuleFunctions group
/** @} */ // end of SoundModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// COMMAND MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup CommandModule
 * @{
 */
/** @defgroup CommandModuleFunctions Command module functions
 * Functions for accessing and modifying Command module features.
 * @{
 */

/**
 * Set IOMap bytes by name.
 * Modify one or more bytes of data in an IOMap structure. The IOMap
 * structure is specified by its module name. You also provide the offset into
 * the IOMap structure where you want to start writing, the number of bytes to
 * write at that location, and a byte array containing the new data.
 * \param _modName The module name of the IOMap to modify. See \ref ModuleNameConstants.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the data should be written
 * \param _cnt The number of bytes to write at the specified IOMap
 * offset.
 * \param _arrIn The byte array containing the data to write to the IOMap
 */
#define SetIOMapBytes(_modName, _offset, _cnt, _arrIn) __SetIOMapBytes(_modName, _offset, _cnt, _arrIn)

/**
 * Set IOMap value by name.
 * Set one of the fields of an IOMap structure to a new value.  The IOMap
 * structure is specified by its module name. You also provide the offset into
 * the IOMap structure where you want to write the value along with a variable
 * containing the new value.
 * \param _modName The module name of the IOMap to modify. See \ref ModuleNameConstants.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the new value should be written
 * \param _n A variable containing the new value to write to the IOMap
 */
#define SetIOMapValue(_modName, _offset, _n) __SetIOMapValue(_modName, _offset, _n)

#ifdef __ENHANCED_FIRMWARE

/**
 * Set IOMap bytes by ID.
 * Modify one or more bytes of data in an IOMap structure. The IOMap
 * structure is specified by its Module ID. You also provide the offset into
 * the IOMap structure where you want to start writing, the number of bytes to
 * write at that location, and a byte array containing the new data.
 * \param _modID The module ID of the IOMap to modify. See \ref ModuleIDConstants.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the data should be written.
 * \param _cnt The number of bytes to write at the specified IOMap
 * offset.
 * \param _arrIn The byte array containing the data to write to the IOMap.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define SetIOMapBytesByID(_modID, _offset, _cnt, _arrIn) __SetIOMapBytesByID(_modID, _offset, _cnt, _arrIn)

/**
 * Set IOMap value by ID.
 * Set one of the fields of an IOMap structure to a new value.  The IOMap
 * structure is specified by its Module ID. You also provide the offset into
 * the IOMap structure where you want to write the value along with a variable
 * containing the new value.
 * \param _modID The module ID of the IOMap to modify. See \ref ModuleIDConstants.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the new value should be written.
 * \param _n A variable containing the new value to write to the IOMap.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define SetIOMapValueByID(_modID, _offset, _n) __SetIOMapValueByID(_modID, _offset, _n)

/**
 * Set Command module IOMap value.
 * Set one of the fields of the Command module IOMap structure to a new value.
 * You provide the offset into the Command module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Command
 * module IOMap structure where the new value should be written. See \ref CommandIOMAP.
 * \param _n A variable containing the new value to write to the Command
 * module IOMap.
 */
#define SetCommandModuleValue(_offset, _n) SetIOMapValueByID(CommandModuleID, _offset, _n)

/**
 * Set IOCtrl module IOMap value.
 * Set one of the fields of the IOCtrl module IOMap structure to a new value.
 * You provide the offset into the IOCtrl module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the IOCtrl
 * module IOMap structure where the new value should be written. See \ref IOCtrlIOMAP.
 * \param _n A variable containing the new value to write to the IOCtrl
 * module IOMap.
 */
#define SetIOCtrlModuleValue(_offset, _n) SetIOMapValueByID(IOCtrlModuleID, _offset, _n)

/**
 * Set Loader module IOMap value.
 * Set one of the fields of the Loader module IOMap structure to a new value.
 * You provide the offset into the Loader module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Loader
 * module IOMap structure where the new value should be written. See \ref LoaderIOMAP.
 * \param _n A variable containing the new value to write to the Loader
 * module IOMap.
 */
#define SetLoaderModuleValue(_offset, _n) SetIOMapValueByID(LoaderModuleID, _offset, _n)

/**
 * Set Ui module IOMap value.
 * Set one of the fields of the Ui module IOMap structure to a new value.
 * You provide the offset into the Ui module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Ui
 * module IOMap structure where the new value should be written. See \ref UiIOMAP.
 * \param _n A variable containing the new value to write to the Ui
 * module IOMap.
 */
#define SetUIModuleValue(_offset, _n) SetIOMapValueByID(UIModuleID, _offset, _n)

/**
 * Set Sound module IOMap value.
 * Set one of the fields of the Sound module IOMap structure to a new value.
 * You provide the offset into the Sound module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Sound
 * module IOMap structure where the new value should be written. See \ref SoundIOMAP.
 * \param _n A variable containing the new value to write to the Sound
 * module IOMap.
 */
#define SetSoundModuleValue(_offset, _n) SetIOMapValueByID(SoundModuleID, _offset, _n)

/**
 * Set Button module IOMap value.
 * Set one of the fields of the Button module IOMap structure to a new value.
 * You provide the offset into the Button module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Button
 * module IOMap structure where the new value should be written. See \ref ButtonIOMAP.
 * \param _n A variable containing the new value to write to the Button
 * module IOMap.
 */
#define SetButtonModuleValue(_offset, _n) SetIOMapValueByID(ButtonModuleID, _offset, _n)

/**
 * Set Input module IOMap value.
 * Set one of the fields of the Input module IOMap structure to a new value.
 * You provide the offset into the Input module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Input
 * module IOMap structure where the new value should be written. See \ref InputIOMAP.
 * \param _n A variable containing the new value to write to the Input
 * module IOMap.
 */
#define SetInputModuleValue(_offset, _n) SetIOMapValueByID(InputModuleID, _offset, _n)

/**
 * Set Output module IOMap value.
 * Set one of the fields of the Output module IOMap structure to a new value.
 * You provide the offset into the Output module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Output
 * module IOMap structure where the new value should be written. See \ref OutputIOMAP.
 * \param _n A variable containing the new value to write to the Output
 * module IOMap.
 */
#define SetOutputModuleValue(_offset, _n) SetIOMapValueByID(OutputModuleID, _offset, _n)

/**
 * Set Lowspeed module IOMap value.
 * Set one of the fields of the Lowspeed module IOMap structure to a new value.
 * You provide the offset into the Lowspeed module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Lowspeed
 * module IOMap structure where the new value should be written. See \ref LowSpeedIOMAP.
 * \param _n A variable containing the new value to write to the Lowspeed
 * module IOMap.
 */
#define SetLowSpeedModuleValue(_offset, _n) SetIOMapValueByID(LowSpeedModuleID, _offset, _n)

/**
 * Set Display module IOMap value.
 * Set one of the fields of the Display module IOMap structure to a new value.
 * You provide the offset into the Display module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Display
 * module IOMap structure where the new value should be written. See \ref DisplayIOMAP.
 * \param _n A variable containing the new value to write to the Display
 * module IOMap.
 */
#define SetDisplayModuleValue(_offset, _n) SetIOMapValueByID(DisplayModuleID, _offset, _n)

/**
 * Set Comm module IOMap value.
 * Set one of the fields of the Comm module IOMap structure to a new value.
 * You provide the offset into the Comm module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param _offset The number of bytes offset from the start of the Comm
 * module IOMap structure where the new value should be written. See \ref CommIOMAP.
 * \param _n A variable containing the new value to write to the Comm
 * module IOMap.
 */
#define SetCommModuleValue(_offset, _n) SetIOMapValueByID(CommModuleID, _offset, _n)

/**
 * Set Command module IOMap bytes.
 * Modify one or more bytes of data in the Command module IOMap structure. You
 * provide the offset into the Command module IOMap structure where you want
 * to start writing, the number of bytes to write at that location, and a byte
 * array containing the new data.
 * \param _offset The number of bytes offset from the start of the Command module
 * IOMap structure where the data should be written. See \ref CommandIOMAP.
 * \param _cnt The number of bytes to write at the specified Command module
 * IOMap offset.
 * \param _arrIn The byte array containing the data to write to the Command
 * module IOMap.
 */
#define SetCommandModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytesByID(CommandModuleID, _offset, _cnt, _arrIn)

/**
 * Set Lowspeed module IOMap bytes.
 * Modify one or more bytes of data in the Lowspeed module IOMap structure. You
 * provide the offset into the Lowspeed module IOMap structure where you want
 * to start writing, the number of bytes to write at that location, and a byte
 * array containing the new data.
 * \param _offset The number of bytes offset from the start of the Lowspeed
 * module IOMap structure where the data should be written. See \ref LowSpeedIOMAP.
 * \param _cnt The number of bytes to write at the specified Lowspeed module
 * IOMap offset.
 * \param _arrIn The byte array containing the data to write to the Lowspeed
 * module IOMap.
 */
#define SetLowSpeedModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytesByID(LowSpeedModuleID, _offset, _cnt, _arrIn)

/**
 * Set Display module IOMap bytes.
 * Modify one or more bytes of data in the Display module IOMap structure. You
 * provide the offset into the Display module IOMap structure where you want to
 * start writing, the number of bytes to write at that location, and a byte
 * array containing the new data.
 * \param _offset The number of bytes offset from the start of the Display module
 * IOMap structure where the data should be written. See \ref DisplayIOMAP.
 * \param _cnt The number of bytes to write at the specified Display module
 * IOMap offset.
 * \param _arrIn The byte array containing the data to write to the Display
 * module IOMap.
 */
#define SetDisplayModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytesByID(DisplayModuleID, _offset, _cnt, _arrIn)

/**
 * Set Comm module IOMap bytes.
 * Modify one or more bytes of data in an IOMap structure. You provide the
 * offset into the Comm module IOMap structure where you want to start writing,
 * the number of bytes to write at that location, and a byte array containing
 * the new data.
 * \param _offset The number of bytes offset from the start of the Comm module
 * IOMap structure where the data should be written. See \ref CommIOMAP.
 * \param _cnt The number of bytes to write at the specified Comm module IOMap
 * offset.
 * \param _arrIn The byte array containing the data to write to the Comm module
 * IOMap.
 */
#define SetCommModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytesByID(CommModuleID, _offset, _cnt, _arrIn)

#else

#define SetCommandModuleValue(_offset, _n) SetIOMapValue(CommandModuleName, _offset, _n)
#define SetIOCtrlModuleValue(_offset, _n) SetIOMapValue(IOCtrlModuleName, _offset, _n)
#define SetLoaderModuleValue(_offset, _n) SetIOMapValue(LoaderModuleName, _offset, _n)
#define SetUIModuleValue(_offset, _n) SetIOMapValue(UIModuleName, _offset, _n)
#define SetSoundModuleValue(_offset, _n) SetIOMapValue(SoundModuleName, _offset, _n)
#define SetButtonModuleValue(_offset, _n) SetIOMapValue(ButtonModuleName, _offset, _n)
#define SetInputModuleValue(_offset, _n) SetIOMapValue(InputModuleName, _offset, _n)
#define SetOutputModuleValue(_offset, _n) SetIOMapValue(OutputModuleName, _offset, _n)
#define SetLowSpeedModuleValue(_offset, _n) SetIOMapValue(LowSpeedModuleName, _offset, _n)
#define SetDisplayModuleValue(_offset, _n) SetIOMapValue(DisplayModuleName, _offset, _n)
#define SetCommModuleValue(_offset, _n) SetIOMapValue(CommModuleName, _offset, _n)

#define SetCommandModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytes(CommandModuleName, _offset, _cnt, _arrIn)
#define SetLowSpeedModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytes(LowSpeedModuleName, _offset, _cnt, _arrIn)
#define SetDisplayModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytes(DisplayModuleName, _offset, _cnt, _arrIn)
#define SetCommModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytes(CommModuleName, _offset, _cnt, _arrIn)

#endif

/**
 * Get IOMap bytes by name.
 * Read one or more bytes of data from an IOMap structure. The IOMap
 * structure is specified by its module name. You also provide the offset into
 * the IOMap structure where you want to start reading, the number of bytes to
 * read from that location, and a byte array where the data will be stored.
 * \param _modName The module name of the IOMap. See \ref ModuleNameConstants.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the data should be read
 * \param _cnt The number of bytes to read from the specified IOMap
 * offset.
 * \param _arrOut A byte array that will contain the data read from the IOMap
 */
#define GetIOMapBytes(_modName, _offset, _cnt, _arrOut) __getIOMapBytes(_modName, _offset, _cnt, _arrOut)

/**
 * Get IOMap value by name.
 * Read a value from an IOMap structure.  The IOMap
 * structure is specified by its module name. You also provide the offset into
 * the IOMap structure where you want to read the value along with a variable
 * that will contain the IOMap value.
 * \param _modName The module name of the IOMap. See \ref ModuleNameConstants.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read
 * \param _n A variable that will contain the value read from the IOMap
 */
#define GetIOMapValue(_modName, _offset, _n) __getIOMapValue(_modName, _offset, _n)

#ifdef __ENHANCED_FIRMWARE

/**
 * Get IOMap bytes by ID.
 * Read one or more bytes of data from an IOMap structure. The IOMap
 * structure is specified by its Module ID. You also provide the offset into
 * the IOMap structure where you want to start reading, the number of bytes to
 * read from that location, and a byte array where the data will be stored.
 * \param _modID The module ID of the IOMap. See \ref ModuleIDConstants.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the data should be read.
 * \param _cnt The number of bytes to read from the specified IOMap
 * offset.
 * \param _arrOut A byte array that will contain the data read from the IOMap.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define GetIOMapBytesByID(_modID, _offset, _cnt, _arrOut) __getIOMapBytesByID(_modID, _offset, _cnt, _arrOut)

/**
 * Get IOMap value by ID.
 * Read a value from an IOMap structure.  The IOMap
 * structure is specified by its Module ID. You also provide the offset into
 * the IOMap structure where you want to read the value along with a variable
 * that will contain the IOMap value.
 * \param _modID The module ID of the IOMap. See \ref ModuleIDConstants.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read.
 * \param _n A variable that will contain the value read from the IOMap.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define GetIOMapValueByID(_modID, _offset, _n) __getIOMapValueByID(_modID, _offset, _n)

/**
 * Get Command module IOMap value.
 * Read a value from the Command module IOMap structure.  You provide the
 * offset into the Command module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref CommandIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetCommandModuleValue(_offset, _n) GetIOMapValueByID(CommandModuleID, _offset, _n)

/**
 * Get Loader module IOMap value.
 * Read a value from the Loader module IOMap structure.  You provide the
 * offset into the Loader module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref LoaderIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetLoaderModuleValue(_offset, _n) GetIOMapValueByID(LoaderModuleID, _offset, _n)

/**
 * Get Sound module IOMap value.
 * Read a value from the Sound module IOMap structure.  You provide the
 * offset into the Sound module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref SoundIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetSoundModuleValue(_offset, _n) GetIOMapValueByID(SoundModuleID, _offset, _n)

/**
 * Get Button module IOMap value.
 * Read a value from the Button module IOMap structure.  You provide the
 * offset into the Button module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref ButtonIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetButtonModuleValue(_offset, _n) GetIOMapValueByID(ButtonModuleID, _offset, _n)

/**
 * Get Ui module IOMap value.
 * Read a value from the Ui module IOMap structure.  You provide the
 * offset into the Ui module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref UiIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetUIModuleValue(_offset, _n) GetIOMapValueByID(UIModuleID, _offset, _n)

/**
 * Get Input module IOMap value.
 * Read a value from the Input module IOMap structure.  You provide the
 * offset into the Input module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref InputIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetInputModuleValue(_offset, _n) GetIOMapValueByID(InputModuleID, _offset, _n)

/**
 * Get Output module IOMap value.
 * Read a value from the Output module IOMap structure.  You provide the
 * offset into the Output module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref OutputIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetOutputModuleValue(_offset, _n) GetIOMapValueByID(OutputModuleID, _offset, _n)

/**
 * Get LowSpeed module IOMap value.
 * Read a value from the LowSpeed module IOMap structure.  You provide the
 * offset into the Command module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref LowSpeedIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetLowSpeedModuleValue(_offset, _n) GetIOMapValueByID(LowSpeedModuleID, _offset, _n)

/**
 * Get Display module IOMap value.
 * Read a value from the Display module IOMap structure.  You provide the
 * offset into the Display module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref DisplayIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetDisplayModuleValue(_offset, _n) GetIOMapValueByID(DisplayModuleID, _offset, _n)

/**
 * Get Comm module IOMap value.
 * Read a value from the Comm module IOMap structure.  You provide the
 * offset into the Comm module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param _offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref CommIOMAP.
 * \param _n A variable that will contain the value read from the IOMap.
 */
#define GetCommModuleValue(_offset, _n) GetIOMapValueByID(CommModuleID, _offset, _n)

#else

#define GetCommandModuleValue(_offset, _n) GetIOMapValue(CommandModuleName, _offset, _n)
#define GetLoaderModuleValue(_offset, _n) GetIOMapValue(LoaderModuleName, _offset, _n)
#define GetSoundModuleValue(_offset, _n) GetIOMapValue(SoundModuleName, _offset, _n)
#define GetButtonModuleValue(_offset, _n) GetIOMapValue(ButtonModuleName, _offset, _n)
#define GetUIModuleValue(_offset, _n) GetIOMapValue(UIModuleName, _offset, _n)
#define GetInputModuleValue(_offset, _n) GetIOMapValue(InputModuleName, _offset, _n)
#define GetOutputModuleValue(_offset, _n) GetIOMapValue(OutputModuleName, _offset, _n)
#define GetLowSpeedModuleValue(_offset, _n) GetIOMapValue(LowSpeedModuleName, _offset, _n)
#define GetDisplayModuleValue(_offset, _n) GetIOMapValue(DisplayModuleName, _offset, _n)
#define GetCommModuleValue(_offset, _n) GetIOMapValue(CommModuleName, _offset, _n)

#endif

/**
 * Get Lowspeed module IOMap bytes.
 * Read one or more bytes of data from Lowspeed module IOMap structure.
 * You provide the offset into the Lowspeed module IOMap structure where you
 * want to start reading, the number of bytes to read from that location, and
 * a byte array where the data will be stored.
 * \param _offset The number of bytes offset from the start of the Lowspeed
 * module IOMap structure where the data should be read. See \ref LowSpeedIOMAP.
 * \param _cnt The number of bytes to read from the specified Lowspeed module
 * IOMap offset.
 * \param _arrOut A byte array that will contain the data read from the Lowspeed
 * module IOMap.
 */
#define GetLowSpeedModuleBytes(_offset, _cnt, _arrOut) __getLowSpeedModuleBytes(_offset, _cnt, _arrOut)

/**
 * Get Display module IOMap bytes.
 * Read one or more bytes of data from Display module IOMap structure.
 * You provide the offset into the Display module IOMap structure where you
 * want to start reading, the number of bytes to read from that location, and
 * a byte array where the data will be stored.
 * \param _offset The number of bytes offset from the start of the Display
 * module IOMap structure where the data should be read. See \ref DisplayIOMAP.
 * \param _cnt The number of bytes to read from the specified Display module
 * IOMap offset.
 * \param _arrOut A byte array that will contain the data read from the Display
 * module IOMap.
 */
#define GetDisplayModuleBytes(_offset, _cnt, _arrOut) __getDisplayModuleBytes(_offset, _cnt, _arrOut)

/**
 * Get Comm module IOMap bytes.
 * Read one or more bytes of data from Comm module IOMap structure.
 * You provide the offset into the Comm module IOMap structure where you
 * want to start reading, the number of bytes to read from that location, and
 * a byte array where the data will be stored.
 * \param _offset The number of bytes offset from the start of the Comm module
 * IOMap structure where the data should be read. See \ref CommIOMAP.
 * \param _cnt The number of bytes to read from the specified Comm module
 * IOMap offset.
 * \param _arrOut A byte array that will contain the data read from the Comm
 * module IOMap.
 */
#define GetCommModuleBytes(_offset, _cnt, _arrOut) __getCommModuleBytes(_offset, _cnt, _arrOut)

/**
 * Get Command module IOMap bytes.
 * Read one or more bytes of data from Command module IOMap structure.
 * You provide the offset into the Command module IOMap structure where you
 * want to start reading, the number of bytes to read from that location, and
 * a byte array where the data will be stored.
 * \param _offset The number of bytes offset from the start of the Command module
 * IOMap structure where the data should be read. See \ref CommandIOMAP.
 * \param _cnt The number of bytes to read from the specified Command module
 * IOMap offset.
 * \param _arrOut A byte array that will contain the data read from the Command
 * module IOMap.
 */
#define GetCommandModuleBytes(_offset, _cnt, _arrOut) __getCommandModuleBytes(_offset, _cnt, _arrOut)

/**
 * Reset the sleep timer.
 * This function lets you reset the sleep timer.
 *
 */
#define ResetSleepTimer syscall KeepAlive, __KeepAliveArgs

/**
 * Get the first tick.
 * Return an unsigned 32-bit value, which is the system timing value
 * (called a "tick") in milliseconds at the time that the program began
 * running.
 *
 * \param _value The tick count at the start of program execution.
 */
#define GetFirstTick(_value) __GetFirstTick(_value)

/**
 * Wait some milliseconds.
 * Make a task sleep for specified amount of time (in 1000ths of a second).
 *
 * \param _n The number of milliseconds to sleep.
 */
#define Wait(_n) waitv _n

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Read memory information.
 * Read the current pool size and dataspace size.  Optionally compact the
 * dataspace before returning the information. Running programs have a maximum
 * of 32k bytes of memory available.  The amount of free RAM can be calculated
 * by subtracting the value returned by this function from \ref POOL_MAX_SIZE.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _Compact A boolean value indicating whether to compact the dataspace or not.
 * \param _PoolSize The current pool size.
 * \param _DataspaceSize The current dataspace size.
 * \param _Result The function call result. It will be \ref NO_ERR if the compact
 * operation is not performed.  Otherwise it will be the result of the compact
 * operation.
 */
#define GetMemoryInfo(_Compact,_PoolSize,_DataspaceSize,_Result) __GetMemoryInfo(_Compact,_PoolSize,_DataspaceSize,_Result)

/**
 * Read last response information.
 * Read the last direct or system command response packet received by the NXT.
 * Optionally clear the response after retrieving the information.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+.
 *
 * \param _Clear A boolean value indicating whether to clear the response or not.
 * \param _Length The response packet length.
 * \param _Command The original command byte.
 * \param _Buffer The response packet buffer.
 * \param _Result The response status code.
 */
#define GetLastResponseInfo(_Clear,_Length,_Command,_Buffer,_Result) __GetLastResponseInfo(_Clear,_Length,_Command,_Buffer,_Result)

#endif


/** @} */ // end of CommandModuleFunctions group
/** @} */ // end of CommandModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// BUTTON MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup ButtonModule
 * @{
 */
/** @defgroup ButtonModuleFunctions Button module functions
 * Functions for accessing and modifying Button module features.
 * @{
 */

/**
 * Read button information.
 * Read the specified button. Set the pressed and count parameters with the
 * current state of the button. Optionally reset the press count after
 * reading it.
 *
 * \param _idx The button to check. See \ref ButtonNameConstants.
 * \param _reset Whether or not to reset the press counter.
 * \param _pressed The button pressed state.
 * \param _count The button press count.
 * \param _result The function call result.
 */
#define ReadButtonEx(_idx, _reset, _pressed, _count, _result) __ReadButtonEx(_idx, _reset, _pressed, _count, _result)

/**
 * Get button press count.
 * Return the press count of the specified button.
 *
 * \param _b The button to check. See \ref ButtonNameConstants.
 * \param _n The button press count.
 */
#define GetButtonPressCount(_b, _n) __GetButtonPressCount(_b, _n)

/**
 * Get button long press count.
 * Return the long press count of the specified button.
 *
 * \param _b The button to check. See \ref ButtonNameConstants.
 * \param _n The button long press count.
 */
#define GetButtonLongPressCount(_b, _n) __GetButtonLongPressCount(_b, _n)

/**
 * Get button short release count.
 * Return the short release count of the specified button.
 *
 * \param _b The button to check. See \ref ButtonNameConstants.
 * \param _n The button short release count.
 */
#define GetButtonShortReleaseCount(_b, _n) __GetButtonShortReleaseCount(_b, _n)

/**
 * Get button long release count.
 * Return the long release count of the specified button.
 *
 * \param _b The button to check. See \ref ButtonNameConstants.
 * \param _n The button long release count.
 */
#define GetButtonLongReleaseCount(_b, _n) __GetButtonLongReleaseCount(_b, _n)

/**
 * Get button release count.
 * Return the release count of the specified button.
 *
 * \param _b The button to check. See \ref ButtonNameConstants.
 * \param _n The button release count.
*/
#define GetButtonReleaseCount(_b, _n) __GetButtonReleaseCount(_b, _n)

/**
 * Get button state.
 * Return the state of the specified button. See \ref ButtonStateConstants.
 *
 * \param _b The button to check. See \ref ButtonNameConstants.
 * \param _n The button state.
 */
#define GetButtonState(_b, _n) __GetButtonState(_b, _n)

/**
 * Set button press count.
 * Set the press count of the specified button.
 *
 * \param _b The button number. See \ref ButtonNameConstants.
 * \param _n The new press count value.
 */
#define SetButtonPressCount(_b, _n) __setButtonPressCount(_b, _n)

/**
 * Set button long press count.
 * Set the long press count of the specified button.
 *
 * \param _b The button number. See \ref ButtonNameConstants.
 * \param _n The new long press count value.
 */
#define SetButtonLongPressCount(_b, _n) __setButtonLongPressCount(_b, _n)

/**
 * Set button short release count.
 * Set the short release count of the specified button.
 *
 * \param _b The button number. See \ref ButtonNameConstants.
 * \param _n The new short release count value.
 */
#define SetButtonShortReleaseCount(_b, _n) __setButtonShortReleaseCount(_b, _n)

/**
 * Set button long release count.
 * Set the long release count of the specified button.
 *
 * \param _b The button number. See \ref ButtonNameConstants.
 * \param _n The new long release count value.
 */
#define SetButtonLongReleaseCount(_b, _n) __setButtonLongReleaseCount(_b, _n)

/**
 * Set button release count.
 * Set the release count of the specified button.
 *
 * \param _b The button number. See \ref ButtonNameConstants.
 * \param _n The new release count value.
 */
#define SetButtonReleaseCount(_b, _n) __setButtonReleaseCount(_b, _n)

/**
 * Set button state.
 * Set the state of the specified button.
 *
 * \param _b The button to check. See \ref ButtonNameConstants.
 * \param _n The new button state. See \ref ButtonStateConstants.
*/
#define SetButtonState(_b, _n) __setButtonState(_b, _n)

/** @} */ // end of ButtonModuleFunctions group
/** @} */ // end of ButtonModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
////////////////////////////////// UI MODULE //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup UiModule
 * @{
 */
/** @defgroup UiModuleFunctions Ui module functions
 * Functions for accessing and modifying Ui module features.
 * @{
 */

/**
 * Set command flags.
 * Set the command flags.
 *
 * \param _n The new command flags. See \ref UiFlagsConstants.
 */
#define SetCommandFlags(_n) __setCommandFlags(_n)

/**
 * Set UI state.
 * Set the user interface state.
 *
 * \param _n A user interface state value. See \ref UiStateConstants.
 */
#define SetUIState(_n) __setUIState(_n)

/**
 * Set UI button.
 * Set user interface button information.
 *
 * \param _n A user interface button value. See \ref UiButtonConstants.
 */
#define SetUIButton(_n) __setUIButton(_n)

/**
 * Set VM run state.
 * Set VM run state information.
 *
 * \param _n The desired VM run state. See \ref UiVMRunStateConstants.
 */
#define SetVMRunState(_n) __setVMRunState(_n)

/**
 * Set battery state.
 * Set battery state information.
 *
 * \param _n The desired battery state (0..4).
 */
#define SetBatteryState(_n) __setBatteryState(_n)

/**
 * Set bluetooth state.
 * Set the Bluetooth state.
 *
 * \param _n The desired bluetooth state. See \ref UiBluetoothStateConstants.
 */
#define SetBluetoothState(_n) __setBluetoothState(_n)

/**
 * Set Usb state.
 * This method sets the value of the Usb state.
 * \param _n The Usb state.
 */
#define SetUsbState(_n) __setUsbState(_n)

/**
 * Set sleep timeout.
 * Set the NXT sleep timeout value to the specified number of minutes.
 *
 * \param _n The minutes to wait before sleeping.
 */
#define SetSleepTimeout(_n) __setSleepTimeout(_n)

/**
 * Set the sleep timer.
 * Set the system sleep timer to the specified number of minutes.
 *
 * \param _n The minutes left on the timer.
 */
#define SetSleepTimer(_n) __setSleepTimer(_n)

/**
 * Set volume.
 * Set the user interface volume level. Valid values are from 0 to 4.
 *
 * \param _n The new volume level.
 */
#define SetVolume(_n) __setVolume(_n)

/**
 * Set on-brick program pointer.
 * Set the current OBP (on-brick program) step.
 *
 * \param _n The new on-brick program step.
 */
#define SetOnBrickProgramPointer(_n) __setOnBrickProgramPointer(_n)

/**
 * Turn off NXT.
 * Force the NXT to turn off if the specified value is greater than zero.
 * \param _n If greater than zero the NXT will turn off.
*/
#define ForceOff(_n) __forceOff(_n)

/**
 * Set abort flag.
 * Set the enhanced NBC/NXC firmware's program abort flag. By default the
 * running program can be interrupted by a short press of the escape button.
 * You can change this to any other button state flag.
 *
 * \param _n The new abort flag value. See \ref ButtonStateConstants
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define SetAbortFlag(_n) __setAbortFlag(_n)

/**
 * Get battery Level.
 * Return the battery level in millivolts.
 * \param _n The battery level
 */
#define GetBatteryLevel(_n) __GetBatteryLevel(_n)

/**
 * Get command flags.
 * Return the command flags.
 * \param _n Command flags. See \ref UiFlagsConstants
 */
#define GetCommandFlags(_n) __GetCommandFlags(_n)

/**
 * Get UI module state.
 * Return the user interface state.
 * \param _n The UI module state. See \ref UiStateConstants.
 */
#define GetUIState(_n) __GetUIState(_n)

/**
 * Read UI button.
 * Return user interface button information.
 * \param _n A UI button value.  See \ref UiButtonConstants.
 */
#define GetUIButton(_n) __GetUIButton(_n)

/**
 * Read VM run state.
 * Return VM run state information.
 * \param _n VM run state. See \ref UiVMRunStateConstants.
 */
#define GetVMRunState(_n) __GetVMRunState(_n)

/**
 * Get battery state.
 * Return battery state information (0..4).
 * \param _n The battery state (0..4)
 */
#define GetBatteryState(_n) __GetBatteryState(_n)

/**
 * Get bluetooth state.
 * Return the bluetooth state.
 * \param _n The bluetooth state. See \ref UiBluetoothStateConstants.
 */
#define GetBluetoothState(_n) __GetBluetoothState(_n)

/**
 * Get UI module USB state.
 * This method returns the UI module USB state.
 * \param _n The UI module USB state.  (0=disconnected, 1=connected, 2=working)
 */
#define GetUsbState(_n) __GetUsbState(_n)

/**
 * Read sleep timeout.
 * Return the number of minutes that the NXT will remain on before
 * it automatically shuts down.
 * \param _n The sleep timeout value
 */
#define GetSleepTimeout(_n) __GetSleepTimeout(_n)

/**
 * Read sleep timer.
 * Return the number of minutes left in the countdown to zero from the
 * original SleepTimeout value. When the SleepTimer value reaches zero the
 * NXT will shutdown.
 * \param _n The sleep timer value
 */
#define GetSleepTimer(_n) __GetSleepTimer(_n)

/**
 * Read battery type.
 * Return whether the NXT has a rechargeable battery installed or not.
 * \param _n Whether the battery is rechargeable or not. (false = no, true = yes)
 */
#define GetRechargeableBattery(_n) __GetRechargeableBattery(_n)

/**
 * Read volume.
 * Return the user interface volume level. Valid values are from 0 to 4.
 * \param _n The UI module volume. (0..4)
 */
#define GetVolume(_n) __GetVolume(_n)

/**
 * Read the on brick program pointer value.
 * Return the current OBP (on-brick program) step
 *
 * \param _n On brick program pointer (step).
 */
#define GetOnBrickProgramPointer(_n) __GetOnBrickProgramPointer(_n)

/**
 * Read abort flag.
 * Return the enhanced NBC/NXC firmware's abort flag.
 *
 * \param _n The current abort flag value.  See \ref ButtonStateConstants.
 * \warning This function requires the enhanced NBC/NXC firmware.
*/
#define GetAbortFlag(_n) __GetAbortFlag(_n)

/** @} */ // end of UiModuleFunctions group
/** @} */ // end of UiModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// COMM MODULE /////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup CommModule
 * @{
 */
/** @defgroup CommModuleFunctions Comm module functions
 * Functions for accessing and modifying Comm module features.
 * @{
 */

/**
 * Send a message to a queue/mailbox.
 * Write a message into a local mailbox.
 * 
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _msg The message to write to the mailbox.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define SendMessage(_queue, _msg, _result) __sendMessage(_queue, _msg, _result)

/**
 * Read a message from a queue/mailbox.
 * Read a message from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.
 *
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param _msg The message that is read from the mailbox.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define ReceiveMessage(_queue, _clear, _msg, _result) __receiveMessage(_queue, _clear, _msg, _result)

/**
 * Read a boolean value from a queue/mailbox.
 * Read a boolean value from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.
 *
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param _bval The boolean value that is read from the mailbox.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define ReceiveRemoteBool(_queue, _clear, _bval, _result) __receiveRemoteBool(_queue, _clear, _bval, _result)

/**
 * Read a numeric value from a queue/mailbox.
 * Read a numeric value from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.
 *
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param _val The numeric value that is read from the mailbox.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define ReceiveRemoteNumber(_queue, _clear, _val, _result) __receiveRemoteNumber(_queue, _clear, _val, _result)

/**
 * Read a string value from a queue/mailbox.
 * Read a string value from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.
 *
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param _str The string value that is read from the mailbox.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define ReceiveRemoteString(_queue, _clear, _str, _result) __receiveMessage(_queue, _clear, _str, _result)

/**
 * Read a value from a queue/mailbox.
 * Read a value from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.  Output the value in string, number, and
 * boolean form.
 *
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param _str The string value that is read from the mailbox.
 * \param _val The numeric value that is read from the mailbox.
 * \param _bval The boolean value that is read from the mailbox.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define ReceiveRemoteMessageEx(_queue, _clear, _str, _val, _bval, _result) __receiveRemoteMessageEx(_queue, _clear, _str, _val, _bval, _result)

/**
 * Write a string value to a local response mailbox.
 * Write a string value to a response mailbox (the mailbox number + 10).
 *
 * \param _queue The mailbox number. See \ref MailboxConstants. This function
 * shifts the specified value into the range of response mailbox numbers by
 * adding 10.
 * \param _msg The string value to write.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define SendResponseString(_queue, _msg, _result) __sendResponseString(_queue, _msg, _result)

/**
 * Write a boolean value to a local response mailbox.
 * Write a boolean value to a response mailbox (the mailbox number + 10).
 *
 * \param _queue The mailbox number. See \ref MailboxConstants. This function
 * shifts the specified value into the range of response mailbox numbers by
 * adding 10.
 * \param _bval The boolean value to write.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define SendResponseBool(_queue, _bval, _result) __sendResponseBool(_queue, _bval, _result)

/**
 * Write a numeric value to a local response mailbox.
 * Write a numeric value to a response mailbox (the mailbox number + 10).
 *
 * \param _queue The mailbox number. See \ref MailboxConstants. This function
 * shifts the specified value into the range of response mailbox numbers by
 * adding 10.
 * \param _val The numeric value to write.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define SendResponseNumber(_queue, _val, _result) __sendResponseNumber(_queue, _val, _result)

/**
 * Check bluetooth status.
 * Check the status of the bluetooth subsystem for the specified connection slot.
 *
 * \param _conn The connection slot (0..3). Connections 0 through 3 are for
 * bluetooth connections. See \ref CommConnectionConstants.
 * \param _result The bluetooth status for the specified connection.
 */
#define BluetoothStatus(_conn, _result) __bluetoothStatus(_conn, _result)

/**
 * Write to a bluetooth connection.
 * This method tells the NXT firmware to write the data in the buffer to the
 * device on the specified Bluetooth connection. Use \ref BluetoothStatus to
 * determine when this write request is completed.
 *
 * \param _conn The connection slot (0..3). Connections 0 through 3 are for
 * bluetooth connections.  See \ref CommConnectionConstants.
 * \param _buffer The data to be written (up to 128 bytes)
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define BluetoothWrite(_conn, _buffer, _result) __bluetoothWrite(_conn, _buffer, _result)

/**
 * Write to a remote connection.
 * This method tells the NXT firmware to write the data in the buffer to the
 * device on the specified connection. Use \ref RemoteConnectionIdle to determine
 * when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _buffer The data to be written (up to 128 bytes)
 * \param _result A char value indicating whether the function call succeeded or not.
 *
 * \warning Writing to the RS485 hi-speed connection requires the enhanced
 * NBC/NXC firmware 
 */
#define RemoteConnectionWrite(_conn, _buffer, _result) __connectionRawWrite(_conn, _buffer, _result)

/**
 * Check if remote connection is idle.
 * Check whether a Bluetooth or RS485 hi-speed port connection is idle,
 * i.e., not currently sending data.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A boolean value indicating whether the connection is idle or busy.
 *
 * \warning Checking the status of the RS485 hi-speed connection requires the
 * enhanced NBC/NXC firmware
 */
#define RemoteConnectionIdle(_conn, _result) __remoteConnectionIdle(_conn, _result)

/**
 * Send a boolean value to a remote mailbox.
 * Send a boolean value on the specified connection to the
 * specified remote mailbox number.  Use \ref RemoteConnectionIdle to determine
 * when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _bval The boolean value to send.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define SendRemoteBool(_conn, _queue, _bval, _result) __sendRemoteBool(_conn, _queue, _bval, _result)

/**
 * Send a numeric value to a remote mailbox.
 * Send a numeric value on the specified connection to the
 * specified remote mailbox number.  Use \ref RemoteConnectionIdle to determine
 * when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _val The numeric value to send.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define SendRemoteNumber(_conn, _queue, _val, _result) __sendRemoteNumber(_conn, _queue, _val, _result)

/**
 * Send a string value to a remote mailbox.
 * Send a string value on the specified connection to the
 * specified remote mailbox number. Use \ref RemoteConnectionIdle to determine
 * when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _queue The mailbox number. See \ref MailboxConstants.
 * \param _str The string value to send.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define SendRemoteString(_conn, _queue, _str, _result) __sendRemoteString(_conn, _queue, _str, _result)


/** @defgroup CommModuleDCFunctions Direct Command functions
 * Functions for sending direct commands to another NXT.
 * @{
 */

/**
 * Send a MessageRead message.
 * This method sends a MessageRead direct command to the device on the
 * specified connection. Use \ref RemoteConnectionIdle to determine when this write
 * request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _queue The mailbox to read. See \ref MailboxConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteMessageRead(_conn, _queue, _result) __remoteMessageRead(_conn, _queue, _result)

/**
 * Send a MessageWrite message.
 * This method sends a MessageWrite direct command to the device on the
 * specified connection. Use \ref RemoteConnectionIdle to determine when this write
 * request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _queue The mailbox to write. See \ref MailboxConstants.
 * \param _msg The message to write to the mailbox.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteMessageWrite(_conn, _queue, _msg, _result) __sendRemoteString(_conn, _queue, _msg, _result)

/**
 * Send a StartProgram message.
 * Send the StartProgram direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to start running.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteStartProgram(_conn, _filename, _result) __remoteStartProgram(_conn, _filename, _result)

/**
 * Send a StopProgram message.
 * Send the StopProgram direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteStopProgram(_conn, _result) __connectionSCDCWrite(_conn, __DCStopProgramPacket, _result)

/**
 * Send a PlaySoundFile message.
 * Send the PlaySoundFile direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the sound file to play.
 * \param _bloop A boolean value indicating whether to loop the sound file or not.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemotePlaySoundFile(_conn, _filename, _bloop, _result) __remotePlaySoundFile(_conn, _filename, _bloop, _result)

/**
 * Send a PlayTone message.
 * Send the PlayTone direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _frequency The frequency of the tone.
 * \param _duration The duration of the tone.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemotePlayTone(_conn, _frequency, _duration, _result) __remotePlayTone(_conn, _frequency, _duration, _result)

/**
 * Send a StopSound message.
 * Send the StopSound direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteStopSound(_conn, _result) __connectionSCDCWrite(_conn, __DCStopSoundPacket, _result)

/**
 * Send a KeepAlive message.
 * This method sends a KeepAlive direct command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteKeepAlive(_conn, _result) __connectionSCDCWrite(_conn, __DCKeepAlivePacket, _result)

/**
 * Send a ResetScaledValue message.
 * Send the ResetScaledValue direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The input port to reset.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteResetScaledValue(_conn, _port, _result) __remoteResetScaledValue(_conn, _port, _result)

/**
 * Send a ResetMotorPosition message.
 * Send the ResetMotorPosition direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The output port to reset.
 * \param _brelative A flag indicating whether the counter to reset is relative.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteResetMotorPosition(_conn, _port, _brelative, _result) __remoteResetMotorPosition(_conn, _port, _brelative, _result)

/**
 * Send a SetInputMode message.
 * Send the SetInputMode direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The input port to configure. See \ref NBCInputPortConstants.
 * \param _type The sensor type. See \ref NBCSensorTypeConstants.
 * \param _mode The sensor mode. See \ref NBCSensorModeConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteSetInputMode(_conn, _port, _type, _mode, _result) __remoteSetInputMode(_conn, _port, _type, _mode, _result)

/**
 * Send a SetOutputMode message.
 * Send the SetOutputMode direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The output port to configure. See \ref OutputPortConstants.
 * \param _speed The motor speed. (-100..100)
 * \param _mode The motor mode. See \ref OutModeConstants.
 * \param _regmode The motor regulation mode. See \ref OutRegModeConstants.
 * \param _turnpct The motor synchronized turn percentage. (-100..100)
 * \param _runstate The motor run state. See \ref OutRunStateConstants.
 * \param _tacholimit The motor tachometer limit.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteSetOutputState(_conn, _port, _speed, _mode, _regmode, _turnpct, _runstate, _tacholimit, _result) \
  __remoteSetOutputState(_conn, _port, _speed, _mode, _regmode, _turnpct, _runstate, _tacholimit, _result)

#ifdef __ENHANCED_FIRMWARE

/**
 * Send a GetOutputState message.
 * Send the GetOutputState direct command on the specified connection slot.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _params The input and output parameters for the function call.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetOutputState(_conn, _params, _result) \
  compchktype _params, TOutputState \
  __remoteGetOutputState(_conn, _params, _result)

/**
 * Send a GetInputValues message.
 * Send the GetInputValues direct command on the specified connection slot.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _params The input and output parameters for the function call.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetInputValues(_conn, _params, _result) \
  compchktype _params, TInputValues \
__remoteGetInputValues(_conn, _params, _result)

/**
 * Send a GetBatteryLevel message.
 * This method sends a GetBatteryLevel direct command to the device on the specified
 * connection.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _value The battery level value.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetBatteryLevel(_conn, _value, _result) __remoteGetBatteryLevel(_conn, _value, _result)

/**
 * Send a LSGetStatus message.
 * This method sends a LSGetStatus direct command to the device on the specified
 * connection.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _value The count of available bytes to read.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteLowspeedGetStatus(_conn, _value, _result) __remoteLowspeedGetStatus(_conn, _value, _result)

/**
 * Send a LowspeedRead message.
 * Send the LowspeedRead direct command on the specified connection slot.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The input port from which to read I2C data. See \ref NBCInputPortConstants.
 * \param _bread The number of bytes read.
 * \param _data A byte array containing the data read from the I2C device.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteLowspeedRead(_conn, _port, _bread, _data, _result) __remoteLowspeedRead(_conn, _port, _bread, _data, _result)

/**
 * Send a GetCurrentProgramName message.
 * This method sends a GetCurrentProgramName direct command to the device on the specified
 * connection.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _name The current program name.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetCurrentProgramName(_conn, _name, _result) __remoteGetCurrentProgramName(_conn, _name, _result)

/**
 * Send a DatalogRead message.
 * Send the DatalogRead direct command on the specified connection slot.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _remove Remove the datalog message from the queue after reading it (true or false).
 * \param _cnt The number of bytes read from the datalog.
 * \param _log A byte array containing the datalog contents.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteDatalogRead(_conn, _remove, _cnt, _log, _result) __remoteDatalogRead(_conn, _remove, _cnt, _log, _result)

/**
 * Send a GetContactCount message.
 * This method sends a GetContactCount direct command to the device on the specified
 * connection.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _cnt The number of contacts.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetContactCount(_conn, _cnt, _result) __remoteGetContactCount(_conn, _cnt, _result)

/**
 * Send a GetContactName message.
 * Send the GetContactName direct command on the specified connection slot.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _idx The index of the contact.
 * \param _name The name of the specified contact.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetContactName(_conn, _idx, _name, _result) __remoteGetContactName(_conn, _idx, _name, _result)

/**
 * Send a GetConnectionCount message.
 * This method sends a GetConnectionCount direct command to the device on the specified
 * connection.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _cnt The number of connections.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetConnectionCount(_conn, _cnt, _result) __remoteGetConnectionCount(_conn, _cnt, _result)

/**
 * Send a GetConnectionName message.
 * Send the GetConnectionName direct command on the specified connection slot.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _idx The index of the connection.
 * \param _name The name of the specified connection.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetConnectionName(_conn, _idx, _name, _result) __remoteGetConnectionName(_conn, _idx, _name, _result)


#else

/**
 * Send a GetOutputState message.
 * Send the GetOutputState direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The output port from which to read state information. See \ref OutputPortConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetOutputState(_conn, _port, _result) __remoteGetOutputState(_conn, _port, _result)

/**
 * Send a GetInputValues message.
 * Send the GetInputValues direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The input port from which to read sensor values. See \ref NBCInputPortConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetInputValues(_conn, _port, _result) __remoteGetInputValues(_conn, _port, _result)

/**
 * Send a GetBatteryLevel message.
 * This method sends a GetBatteryLevel direct command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetBatteryLevel(_conn, _result) __remoteGetBatteryLevel(_conn, _result)

/**
 * Send a LSGetStatus message.
 * This method sends a LSGetStatus direct command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteLowspeedGetStatus(_conn, _result) __remoteLowspeedGetStatus(_conn, _result)

/**
 * Send a LowspeedRead message.
 * Send the LowspeedRead direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The input port from which to read I2C data. See \ref NBCInputPortConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteLowspeedRead(_conn, _port, _result) __remoteLowspeedRead(_conn, _port, _result)

/**
 * Send a GetCurrentProgramName message.
 * This method sends a GetCurrentProgramName direct command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetCurrentProgramName(_conn, _result) __remoteGetCurrentProgramName(_conn, _result)

/**
 * Send a DatalogRead message.
 * Send the DatalogRead direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _remove Remove the datalog message from the queue after reading it (true or false).
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteDatalogRead(_conn, _remove, _result) __remoteDatalogRead(_conn, _remove, _result)

/**
 * Send a GetContactCount message.
 * This method sends a GetContactCount direct command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetContactCount(_conn, _result) __remoteGetContactCount(_conn, _result)

/**
 * Send a GetContactName message.
 * Send the GetContactName direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _idx The index of the contact.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetContactName(_conn, _idx, _result) __remoteGetContactName(_conn, _idx, _result)

/**
 * Send a GetConnectionCount message.
 * This method sends a GetConnectionCount direct command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write
 * request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetConnectionCount(_conn, _result) __remoteGetConnectionCount(_conn, _result)

/**
 * Send a GetConnectionName message.
 * Send the GetConnectionName direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _idx The index of the connection.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetConnectionName(_conn, _idx, _result) __remoteGetConnectionName(_conn, _idx, _result)


#endif

/**
 * Send a ResetTachoCount message.
 * Send the ResetTachoCount direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The output port to reset the tachometer count on. See \ref OutputPortConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteResetTachoCount(_conn, _port, _result) __remoteResetTachoCount(_conn, _port, _result)

/**
 * Send a GetProperty message.
 * Send the GetProperty direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _property The property to read. See \ref RCPropertyConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetProperty(_conn, _property, _result) __remoteGetProperty(_conn, _property, _result)

/**
 * Send a DatalogSetTimes message.
 * Send the DatalogSetTimes direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _synctime The datalog sync time.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteDatalogSetTimes(_conn, _synctime, _result) __remoteDatalogSetTimes(_conn, _synctime, _result)

/**
 * Send a SetProperty message.
 * Send the SetProperty direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _prop The property to set. See \ref RCPropertyConstants.
 * \param _value The new property value.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteSetProperty(_conn, _prop, _value, _result) __remoteSetProperty(_conn, _prop, _value, _result)

/**
 * Send a LowspeedWrite message.
 * Send the LowspeedWrite direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _port The I2C port. See \ref NBCInputPortConstants.
 * \param _txlen The number of bytes you are writing to the I2C device.
 * \param _rxlen The number of bytes want to read from the I2C device.
 * \param _data A byte array containing the data you are writing to the device.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteLowspeedWrite(_conn, _port, _txlen, _rxlen, _data, _result) __remoteLowspeedWrite(_conn, _port, _txlen, _rxlen, _data, _result)


/** @} */ // end of CommModuleDCFunctions group

/** @defgroup CommModuleSCFunctions System Command functions
 * Functions for sending system commands to another NXT.
 * @{
 */

#ifdef __ENHANCED_FIRMWARE

/**
 * Send an OpenRead message.
 * Send the OpenRead system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the file to open for reading.
 * \param _handle The handle of the file.
 * \param _size The size of the file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenRead(_conn, _filename, _handle, _size, _result) __remoteOpenRead(_conn, _filename, _handle, _size, _result)

/**
 * Send an OpenAppendData message.
 * Send the OpenAppendData system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the file to open for appending.
 * \param _handle The handle of the file.
 * \param _size The size of the file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenAppendData(_conn, _filename, _handle, _size, _result) __remoteOpenAppendData(_conn, _filename, _handle, _size, _result)

/**
 * Send a DeleteFile message.
 * Send the DeleteFile system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to delete.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteDeleteFile(_conn, _filename, _result) __remoteDeleteFile(_conn, _filename, _result)

/**
 * Send a FindFirstFile message.
 * Send the FindFirstFile system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _mask The filename mask for the files you want to find.
 * \param _handle The handle of the found file.
 * \param _name The name of the found file.
 * \param _size The size of the found file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteFindFirstFile(_conn, _mask, _handle, _name, _size, _result) __remoteFindFirstFile(_conn, _mask, _handle, _name, _size, _result)

/**
 * Send a GetFirmwareVersion message.
 * This method sends a GetFirmwareVersion system command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _pmin The protocol minor version byte.
 * \param _pmaj The protocol major version byte.
 * \param _fmin The firmware minor version byte.
 * \param _fmaj The firmware major version byte.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetFirmwareVersion(_conn, _pmin, _pmaj, _fmin, _fmaj, _result) __remoteGetFirmwareVersion(_conn, _pmin, _pmaj, _fmin, _fmaj, _result)

/**
 * Send a GetBluetoothAddress message.
 * This method sends a GetBluetoothAddress system command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _btaddr The bluetooth address of the remote device.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetBluetoothAddress(_conn, _btaddr, _result) __remoteGetBluetoothAddress(_conn, _btaddr, _result)

/**
 * Send a GetDeviceInfo message.
 * This method sends a GetDeviceInfo system command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _name The name of the remote device.
 * \param _btaddr The bluetooth address of the remote device.
 * \param _btsignal The signal strength of each connection on the remote device.
 * \param _freemem The number of bytes of free flash memory on the remote device.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetDeviceInfo(_conn, _name, _btaddr, _btsignal, _freemem, _result) __remoteGetDeviceInfo(_conn, _name, _btaddr, _btsignal, _freemem, _result)

/**
 * Send a DeleteUserFlash message.
 * This method sends a DeleteUserFlash system command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteDeleteUserFlash(_conn, _result) __remoteDeleteUserFlash(_conn, _result)

/**
 * Send an OpenWrite message.
 * Send the OpenWrite system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to open for writing (i.e., create the file).
 * \param _size The size for the new file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenWrite(_conn, _filename, _size, _result) __remoteOpenWrite(_conn, _filename, _size, _result)

/**
 * Send an OpenWriteLinear message.
 * Send the OpenWriteLinear system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to open for writing (i.e., create the file).
 * \param _size The size for the new file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenWriteLinear(_conn, _filename, _size, _result) __remoteOpenWriteLinear(_conn, _filename, _size, _result)

/**
 * Send an OpenWriteData message.
 * Send the OpenWriteData system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to open for writing (i.e., create the file).
 * \param _size The size for the new file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenWriteData(_conn, _filename, _size, _result) __remoteOpenWriteData(_conn, _filename, _size, _result)

/**
 * Send a CloseFile message.
 * Send the CloseFile system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _handle The handle of the file to close.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteCloseFile(_conn, _handle, _result) __remoteCloseFile(_conn, _handle, _result)

/**
 * Send a FindNextFile message.
 * Send the FindNextFile system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _handle The handle returned by the last \ref FindFirstFile or FindNextFile call.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteFindNextFile(_conn, _handle, _result) __remoteFindNextFile(_conn, _handle, _result)

/**
 * Send a PollCommandLength message.
 * Send the PollCommandLength system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _bufnum The poll buffer you want to query (0=USBPoll, 1=HiSpeed).
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemotePollCommandLength(_conn, _bufnum, _result) __remotePollCommandLength(_conn, _bufnum, _result)

/**
 * Send a Write message.
 * Send the Write system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _handle The handle of the file you are writing to.
 * \param _data A byte array containing the data you are writing.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteWrite(_conn, _handle, _data, _result) __remoteWrite(_conn, _handle, _data, _result)

/**
 * Send a Read message.
 * Send the Read system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _handle The handle of the file you are reading from.
 * \param _numbytes The number of bytes you want to read.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteRead(_conn, _handle, _numbytes, _result) __remoteRead(_conn, _handle, _numbytes, _result)

/**
 * Send an IOMapRead message.
 * Send the IOMapRead system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _id The ID of the module from which to read data.
 * \param _offset The offset into the IOMap structure from which to read.
 * \param _numbytes The number of bytes of data to read.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteIOMapRead(_conn, _id, _offset, _numbytes, _result) __remoteIOMapRead(_conn, _id, _offset, _numbytes, _result)

/**
 * Send a PollCommand message.
 * Send the PollCommand system command on the specified connection slot to
 * write the data provided.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _bufnum The buffer from which to read data (0=USBPoll, 1=HiSpeed).
 * \param _len The number of bytes to read.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemotePollCommand(_conn, _bufnum, _len, _result) __remotePollCommand(_conn, _bufnum, _len, _result)

/**
 * Send a RenameFile message.
 * Send the RenameFile system command on the specified connection slot to
 * write the data provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _oldname The old filename.
 * \param _newname The new filename.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteRenameFile(_conn, _oldname, _newname, _result) __remoteRenameFile(_conn, _oldname, _newname, _result)

#else

/**
 * Send an OpenRead message.
 * Send the OpenRead system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to open for reading.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenRead(_conn, _filename, _result) __remoteOpenRead(_conn, _filename, _result)

/**
 * Send an OpenAppendData message.
 * Send the OpenAppendData system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to open for appending.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenAppendData(_conn, _filename, _result) __remoteOpenAppendData(_conn, _filename, _result)

/**
 * Send a DeleteFile message.
 * Send the DeleteFile system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to delete.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteDeleteFile(_conn, _filename, _result) __remoteDeleteFile(_conn, _filename, _result)

/**
 * Send a FindFirstFile message.
 * Send the FindFirstFile system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _mask The filename mask for the files you want to find.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteFindFirstFile(_conn, _mask, _result) __remoteFindFirstFile(_conn, _mask, _result)

/**
 * Send a GetFirmwareVersion message.
 * This method sends a GetFirmwareVersion system command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetFirmwareVersion(_conn, _result) __connectionSCDCWrite(_conn, __SCGetFirmwareVerPacket, _result)

/**
 * Send a GetBluetoothAddress message.
 * This method sends a GetBluetoothAddress system command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetBluetoothAddress(_conn, _result) __connectionSCDCWrite(_conn, __SCBTGetAddressPacket, _result)

/**
 * Send a GetDeviceInfo message.
 * This method sends a GetDeviceInfo system command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteGetDeviceInfo(_conn, _result) __connectionSCDCWrite(_conn, __SCGetDeviceInfoPacket, _result)

/**
 * Send a DeleteUserFlash message.
 * This method sends a DeleteUserFlash system command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteDeleteUserFlash(_conn, _result) __connectionSCDCWrite(_conn, __SCDeleteUserFlashPacket, _result)

/**
 * Send an OpenWrite message.
 * Send the OpenWrite system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to open for writing (i.e., create the file).
 * \param _size The size for the new file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenWrite(_conn, _filename, _size, _result) __remoteOpenWrite(_conn, _filename, _size, _result)

/**
 * Send an OpenWriteLinear message.
 * Send the OpenWriteLinear system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to open for writing (i.e., create the file).
 * \param _size The size for the new file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenWriteLinear(_conn, _filename, _size, _result) __remoteOpenWriteLinear(_conn, _filename, _size, _result)

/**
 * Send an OpenWriteData message.
 * Send the OpenWriteData system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _filename The name of the program to open for writing (i.e., create the file).
 * \param _size The size for the new file.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteOpenWriteData(_conn, _filename, _size, _result) __remoteOpenWriteData(_conn, _filename, _size, _result)

/**
 * Send a CloseFile message.
 * Send the CloseFile system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _handle The handle of the file to close.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteCloseFile(_conn, _handle, _result) __remoteCloseFile(_conn, _handle, _result)

/**
 * Send a FindNextFile message.
 * Send the FindNextFile system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _handle The handle returned by the last \ref FindFirstFile or FindNextFile call.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteFindNextFile(_conn, _handle, _result) __remoteFindNextFile(_conn, _handle, _result)

/**
 * Send a PollCommandLength message.
 * Send the PollCommandLength system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _bufnum The poll buffer you want to query (0=USBPoll, 1=HiSpeed).
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemotePollCommandLength(_conn, _bufnum, _result) __remotePollCommandLength(_conn, _bufnum, _result)

/**
 * Send a Write message.
 * Send the Write system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _handle The handle of the file you are writing to.
 * \param _data A byte array containing the data you are writing.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteWrite(_conn, _handle, _data, _result) __remoteWrite(_conn, _handle, _data, _result)

/**
 * Send a Read message.
 * Send the Read system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _handle The handle of the file you are reading from.
 * \param _numbytes The number of bytes you want to read.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteRead(_conn, _handle, _numbytes, _result) __remoteRead(_conn, _handle, _numbytes, _result)

/**
 * Send an IOMapRead message.
 * Send the IOMapRead system command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _id The ID of the module from which to read data.
 * \param _offset The offset into the IOMap structure from which to read.
 * \param _numbytes The number of bytes of data to read.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteIOMapRead(_conn, _id, _offset, _numbytes, _result) __remoteIOMapRead(_conn, _id, _offset, _numbytes, _result)

/**
 * Send a PollCommand message.
 * Send the PollCommand system command on the specified connection slot to
 * write the data provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _bufnum The buffer from which to read data (0=USBPoll, 1=HiSpeed).
 * \param _len The number of bytes to read.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemotePollCommand(_conn, _bufnum, _len, _result) __remotePollCommand(_conn, _bufnum, _len, _result)

#endif

/**
 * Send a BluetoothFactoryReset message.
 * This method sends a BluetoothFactoryReset system command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteBluetoothFactoryReset(_conn, _result) __connectionSCDCWrite(_conn, __SCBTFactoryResetPacket, _result)

/**
 * Send an IOMapWrite value message.
 * Send the IOMapWrite system command on the specified connection slot to
 * write the value provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _id The ID of the module to which to write data.
 * \param _offset The offset into the IOMap structure to which to write.
 * \param _value A scalar variable containing the value you are writing to the IOMap structure.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteIOMapWriteValue(_conn, _id, _offset, _value, _result) __remoteIOMapWriteValue(_conn, _id, _offset, _value, _result)

/**
 * Send an IOMapWrite bytes message.
 * Send the IOMapWrite system command on the specified connection slot to
 * write the data provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _id The ID of the module to which to write data.
 * \param _offset The offset into the IOMap structure to which to write.
 * \param _data A byte array containing the data you are writing to the IOMap structure.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteIOMapWriteBytes(_conn, _id, _offset, _data, _result) __remoteIOMapWriteBytes(_conn, _id, _offset, _data, _result)

/**
 * Send a SetBrickName message.
 * Send the SetBrickName system command on the specified connection slot to
 * write the data provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param _conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param _name The new brick name.
 * \param _result A char value indicating whether the function call succeeded or not.
 */
#define RemoteSetBrickName(_conn, _name, _result) __remoteSetBrickName(_conn, _name, _result)

/** @} */ // end of CommModuleSCFunctions group

/**
 * Use the RS485 port.
 * Configure port 4 for RS485 usage.
 *
 */
#define UseRS485() __UseRS485()

#ifdef __ENHANCED_FIRMWARE

/**
 * Check RS485 status.
 * Check the status of the RS485 hi-speed port.
 *
 * \param _sendingData A boolean value set to true on output if data is being sent.
 * \param _dataAvail A boolean value set to true on output if data is available to be read.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define RS485Status(_sendingData, _dataAvail) __RS485Status(_sendingData, _dataAvail)

/**
 * Write RS485 data.
 * Write data to the RS485 hi-speed port.
 *
 * \param _buffer A byte array containing the data to write to the RS485 port.
 * \param _status A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define RS485Write(_buffer, _status) __RS485Write(_buffer, _status)

/**
 * Read RS485 data.
 * Read data from the RS485 hi-speed port.
 *
 * \param _buffer A byte array that will contain the data read from the RS485 port.
 * \param _status A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define RS485Read(_buffer, _status) __RS485Read(_buffer, _status)

#if __FIRMWARE_VERSION > 107

/**
 * Read limited RS485 data.
 * Read a limited number of bytes of data from the RS485 hi-speed port.
 *
 * \param _buffer A byte array that will contain the data read from the RS485 port.
 * \param _buflen The number of bytes you want to read.
 * \param _status A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+.
 */
#define RS485ReadEx(_buffer, _buflen, _status) __RS485ReadEx(_buffer, _buflen, _status)

/**
 * Control the RS485 port.
 * Control the RS485 hi-speed port using the specified parameters.
 *
 * \param _cmd The control command to send to the port. See \ref CommHiSpeedCtrlConstants.
 * \param _baud The baud rate for the RS485 port. See \ref CommHiSpeedBaudConstants.
 * \param _mode The RS485 port mode (data bits, stop bits, parity).  See \ref
 * CommHiSpeedDataBitsConstants, \ref CommHiSpeedStopBitsConstants, \ref
 * CommHiSpeedParityConstants, and \ref CommHiSpeedCombinedConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define RS485Control(_cmd, _baud, _mode, _result) __RS485Control(_cmd, _baud, _mode, _result)

/**
 * Configure RS485 UART.
 * Configure the RS485 UART parameters, including baud rate, data bits,
 * stop bits, and parity.
 *
 * \param _baud The baud rate for the RS485 port. See \ref CommHiSpeedBaudConstants.
 * \param _mode The RS485 port mode (data bits, stop bits, parity).  See \ref
 * CommHiSpeedDataBitsConstants, \ref CommHiSpeedStopBitsConstants, \ref
 * CommHiSpeedParityConstants, and \ref CommHiSpeedCombinedConstants.
 * \param _result A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define RS485Uart(_baud, _mode, _result) __RS485Control(HS_CTRL_UART, _baud, _mode, _result)

/**
 * Initialize RS485 port.
 * Initialize the RS485 UART port to its default values.  The baud rate is
 * set to 921600 and the mode is set to 8N1 (8 data bits, no parity, 1 stop bit).
 * Data cannot be sent or received over the RS485 port until the UART is
 * initialized and the port has been configured for RS485 usage.
 *
 * \param _result A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define RS485Initialize(_result) __RS485Control(HS_CTRL_UART, HS_BAUD_DEFAULT, HS_MODE_DEFAULT, _result)

/**
 * Enable RS485.
 * Turn on the RS485 hi-speed port so that it can be used.
 *
 * \param _result A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define RS485Enable(_result) __RS485Control(HS_CTRL_INIT, HS_BAUD_DEFAULT, HS_MODE_DEFAULT, _result)

/**
 * Disable RS485.
 * Turn off the RS485 port.
 *
 * \param _result A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define RS485Disable(_result) __RS485Control(HS_CTRL_EXIT, HS_BAUD_DEFAULT, HS_MODE_DEFAULT, _result)

#else

#define RS485Control(_cmd, _baud, _result) __RS485Control(_cmd, _baud, _result)
#define RS485Uart(_baud, _result) __RS485Control(HS_CTRL_UART, _baud, _result)
#define RS485Initialize(_result) __RS485Control(HS_CTRL_UART, HS_BAUD_DEFAULT, _result)
#define RS485Enable(_result) __RS485Control(HS_CTRL_INIT, HS_BAUD_DEFAULT, _result)
#define RS485Disable(_result) __RS485Control(HS_CTRL_EXIT, HS_BAUD_DEFAULT, _result)

#endif

/**
 * Write RS485 boolean.
 * Write a boolean value to the RS485 hi-speed port.
 *
 * \param _bval A boolean value to write over the RS485 port.
 * \param _status A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define SendRS485Bool(_bval, _status) __sendRS485Bool(_bval, _status)

/**
 * Write RS485 numeric.
 * Write a numeric value to the RS485 hi-speed port.
 *
 * \param _val A numeric value to write over the RS485 port.
 * \param _status A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define SendRS485Number(_val, _status) __sendRS485Number(_val, _status)

/**
 * Write RS485 string.
 * Write a string value to the RS485 hi-speed port.
 *
 * \param _str A string value to write over the RS485 port.
 * \param _status A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define SendRS485String(_str, _status) __sendRS485String(_str, _status)

#endif

/**
 * Get bluetooth device name.
 * This method returns the name of the device at the specified index in the
 * Bluetooth device table.
 * \param _p The device table index.
 * \param _str The device name of the specified bluetooth device.
 */
#define GetBTDeviceName(_p, _str) __GetBTDeviceName(_p, _str)

/**
 * Get bluetooth device class.
 * This method returns the class of the device at the specified index within
 * the Bluetooth device table.
 * \param _p The device table index.
 * \param _n The device class of the specified bluetooth device.
 */
#define GetBTDeviceClass(_p, _n) __GetBTDeviceClass(_p, _n)

/**
 * Get bluetooth device address.
 * This method reads the address of the device at the specified index within
 * the Bluetooth device table and stores it in the data buffer provided.
 * \param _p The device table index.
 * \param _btaddr The byte array reference that will contain the device address.
 */
#define GetBTDeviceAddress(_p, _btaddr) __getBTDeviceAddress(_p, _btaddr)

/**
 * Get bluetooth device status.
 * This method returns the status of the device at the specified index within
 * the Bluetooth device table.
 * \param _p The device table index.
 * \param _n The status of the specified bluetooth device.
 */
#define GetBTDeviceStatus(_p, _n) __GetBTDeviceStatus(_p, _n)

/**
 * Get bluetooth device name.
 * This method returns the name of the device at the specified index in the
 * Bluetooth connection table.
 * \param _p The connection slot (0..3).
 * \param _str The name of the bluetooth device at the specified connection slot.
 */
#define GetBTConnectionName(_p, _str) __GetBTConnectionName(_p, _str)

/**
 * Get bluetooth device class.
 * This method returns the class of the device at the specified index within
 * the Bluetooth connection table.
 * \param _p The connection slot (0..3).
 * \param _n The class of the bluetooth device at the specified connection slot.
 */
#define GetBTConnectionClass(_p, _n) __GetBTConnectionClass(_p, _n)

/**
 * Get bluetooth device pin code.
 * This method returns the pin code of the device at the specified index in the
 * Bluetooth connection table.
 * \param _p The connection slot (0..3).
 * \param _code The pin code for the bluetooth device at the specified connection slot.
 */
#define GetBTConnectionPinCode(_p, _code) __GetBTConnectionPinCode(_p, _code)

/**
 * Get bluetooth device address.
 * This method reads the address of the device at the specified index within
 * the Bluetooth connection table and stores it in the data buffer provided.
 * \param _p The connection slot (0..3).
 * \param _btaddr The byte array reference that will contain the device address.
 */
#define GetBTConnectionAddress(_p, _btaddr) __getBTConnectionAddress(_p, _btaddr)

/**
 * Get bluetooth device handle number.
 * This method returns the handle number of the device at the specified index within
 * the Bluetooth connection table.
 * \param _p The connection slot (0..3).
 * \param _n The handle number of the bluetooth device at the specified connection slot.
 */
#define GetBTConnectionHandleNum(_p, _n) __GetBTConnectionHandleNum(_p, _n)

/**
 * Get bluetooth device stream status.
 * This method returns the stream status of the device at the specified index within
 * the Bluetooth connection table.
 * \param _p The connection slot (0..3).
 * \param _n The stream status of the bluetooth device at the specified connection slot.
 */
#define GetBTConnectionStreamStatus(_p, _n) __GetBTConnectionStreamStatus(_p, _n)

/**
 * Get bluetooth device link quality.
 * This method returns the link quality of the device at the specified index within
 * the Bluetooth connection table.
 * \param _p The connection slot (0..3).
 * \param _n The link quality of the specified connection slot (unimplemented).
 * \warning This function is not implemented at the firmware level.
 */
#define GetBTConnectionLinkQuality(_p, _n) __GetBTConnectionLinkQuality(_p, _n)

/**
 * Get NXT name.
 * This method returns the name of the NXT.
 * \param _str The NXT's bluetooth name.
 */
#define GetBrickDataName(_str) GetCommModuleBytes(CommOffsetBrickDataName, 16, _str)

/**
 * Get NXT bluecore version.
 * This method returns the bluecore version of the NXT.
 * \param _n The NXT's bluecore version number.
 */
#define GetBrickDataBluecoreVersion(_n) \
  compchk EQ, sizeof(_n), 2 \
  GetCommModuleValue(CommOffsetBrickDataBluecoreVersion, _n)

/**
 * Get NXT address.
 * This method reads the address of the NXT and stores it in the data buffer
 * provided.
 * \param _btaddr The byte array reference that will contain the device address.
 */
#define GetBrickDataAddress(_btaddr) GetCommModuleBytes(CommOffsetBrickDataBdAddr, 7, _btaddr)

/**
 * Get NXT bluetooth state status.
 * This method returns the Bluetooth state status of the NXT.
 * \param _n The NXT's bluetooth state status.
 */
#define GetBrickDataBtStateStatus(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBrickDataBtStateStatus, _n)

/**
 * Get NXT bluetooth hardware status.
 * This method returns the Bluetooth hardware status of the NXT.
 * \param _n The NXT's bluetooth hardware status.
 */
#define GetBrickDataBtHardwareStatus(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBrickDataBtHwStatus, _n)

/**
 * Get NXT bluetooth timeout value.
 * This method returns the Bluetooth timeout value of the NXT.
 * \param _n The NXT's bluetooth timeout value.
 */
#define GetBrickDataTimeoutValue(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBrickDataTimeOutValue, _n)

/**
 * Get bluetooth input buffer data.
 * This method reads count bytes of data from the Bluetooth input buffer and
 * writes it to the buffer provided.
 * 
 * \param _offset A constant offset into the bluetooth input buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the bluetooth input buffer.
 */
#define GetBTInputBuffer(_offset, _cnt, _data) __getBTInputBuffer(_offset, _cnt, _data)

/**
 * Get bluetooth input buffer in-pointer.
 * This method returns the value of the input pointer of the Bluetooth input
 * buffer.
 * \param _n The bluetooth input buffer's in-pointer value.
 */
#define GetBTInputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBtInBufInPtr, _n)

/**
 * Get bluetooth input buffer out-pointer.
 * This method returns the value of the output pointer of the Bluetooth input
 * buffer.
 * \param _n The bluetooth input buffer's out-pointer value.
 */
#define GetBTInputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBtInBufOutPtr, _n)

/**
 * Get bluetooth output buffer data.
 * This method reads count bytes of data from the Bluetooth output buffer and
 * writes it to the buffer provided.
 *
 * \param _offset A constant offset into the bluetooth output buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the bluetooth output buffer.
 */
#define GetBTOutputBuffer(_offset, _cnt, _data) __getBTOutputBuffer(_offset, _cnt, _data)

/**
 * Get bluetooth output buffer in-pointer.
 * This method returns the value of the input pointer of the Bluetooth output
 * buffer.
 * \param _n The bluetooth output buffer's in-pointer value.
 */
#define GetBTOutputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBtOutBufInPtr, _n)

/**
 * Get bluetooth output buffer out-pointer.
 * This method returns the value of the output pointer of the Bluetooth output
 * buffer.
 * \param _n The bluetooth output buffer's out-pointer value.
 */
#define GetBTOutputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBtOutBufOutPtr, _n)

/**
 * Get hi-speed port input buffer data.
 * This method reads count bytes of data from the hi-speed port input buffer and
 * writes it to the buffer provided.
 * 
 * \param _offset A constant offset into the hi-speed port input buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the hi-speed port input buffer.
 */
#define GetHSInputBuffer(_offset, _cnt, _data) __getHSInputBuffer(_offset, _cnt, _data)

/**
 * Get hi-speed port input buffer in-pointer.
 * This method returns the value of the input pointer of the hi-speed port input
 * buffer.
 * \param _n The hi-speed port input buffer's in-pointer value.
 */
#define GetHSInputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsInBufInPtr, _n)

/**
 * Get hi-speed port input buffer out-pointer.
 * This method returns the value of the output pointer of the hi-speed port input
 * buffer.
 * \param _n The hi-speed port input buffer's out-pointer value.
 */
#define GetHSInputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsInBufOutPtr, _n)

/**
 * Get hi-speed port output buffer data.
 * This method reads count bytes of data from the hi-speed port output buffer and
 * writes it to the buffer provided.
 *
 * \param _offset A constant offset into the hi-speed port output buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the hi-speed port output buffer.
 */
#define GetHSOutputBuffer(_offset, _cnt, _data) __getHSOutputBuffer(_offset, _cnt, _data)

/**
 * Get hi-speed port output buffer in-pointer.
 * This method returns the value of the input pointer of the hi-speed port output
 * buffer.
 * \param _n The hi-speed port output buffer's in-pointer value.
 */
#define GetHSOutputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsOutBufInPtr, _n)

/**
 * Get hi-speed port output buffer out-pointer.
 * This method returns the value of the output pointer of the hi-speed port output
 * buffer.
 * \param _n The hi-speed port output buffer's out-pointer value.
 */
#define GetHSOutputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsOutBufOutPtr, _n)

/**
 * Get usb input buffer data.
 * This method reads count bytes of data from the usb input buffer and
 * writes it to the buffer provided.
 *
 * \param _offset A constant offset into the usb input buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the usb input buffer.
 */
#define GetUSBInputBuffer(_offset, _cnt, _data) __getUSBInputBuffer(_offset, _cnt, _data)

/**
 * Get usb port input buffer in-pointer.
 * This method returns the value of the input pointer of the usb port input
 * buffer.
 * \param _n The USB port input buffer's in-pointer value.
 */
#define GetUSBInputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetUsbInBufInPtr, _n)

/**
 * Get usb port input buffer out-pointer.
 * This method returns the value of the output pointer of the usb port input
 * buffer.
 * \param _n The USB port input buffer's out-pointer value.
 */
#define GetUSBInputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetUsbInBufOutPtr, _n)

/**
 * Get usb output buffer data.
 * This method reads count bytes of data from the usb output buffer and
 * writes it to the buffer provided.
 * \param _offset A constant offset into the usb output buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the usb output buffer.
 */
#define GetUSBOutputBuffer(_offset, _cnt, _data) __getUSBOutputBuffer(_offset, _cnt, _data)

/**
 * Get usb port output buffer in-pointer.
 * This method returns the value of the input pointer of the usb port output
 * buffer.
 * \param _n The USB port output buffer's in-pointer value.
 */
#define GetUSBOutputBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetUsbOutBufInPtr, _n)

/**
 * Get usb port output buffer out-pointer.
 * This method returns the value of the output pointer of the usb port output
 * buffer.
 * \param _n The USB port output buffer's out-pointer value.
 */
#define GetUSBOutputBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetUsbOutBufOutPtr, _n)

/**
 * Get usb poll buffer data.
 * This method reads count bytes of data from the usb poll buffer and
 * writes it to the buffer provided.
 * \param _offset A constant offset into the usb poll buffer.
 * \param _cnt The number of bytes to read.
 * \param _data The byte array reference which will contain the data read from
 * the usb poll buffer.
 */
#define GetUSBPollBuffer(_offset, _cnt, _data) __getUSBPollBuffer(_offset, _cnt, _data)

/**
 * Get usb port poll buffer in-pointer.
 * This method returns the value of the input pointer of the usb port poll
 * buffer.
 * \param _n The USB port poll buffer's in-pointer value.
 */
#define GetUSBPollBufferInPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetUsbPollBufInPtr, _n)

/**
 * Get usb port poll buffer out-pointer.
 * This method returns the value of the output pointer of the usb port poll
 * buffer.
 * \param _n The USB port poll buffer's out-pointer value.
 */
#define GetUSBPollBufferOutPtr(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetUsbPollBufOutPtr, _n)

/**
 * Get bluetooth device count.
 * This method returns the number of devices defined within the Bluetooth
 * device table.
 * \return The count of known bluetooth devices.
 */
#define GetBTDeviceCount(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBtDeviceCnt, _n)

/**
 * Get bluetooth device name count.
 * This method returns the number of device names defined within the Bluetooth
 * device table. This usually has the same value as BTDeviceCount but it can
 * differ in some instances.
 * \param _n The count of known bluetooth device names.
 */
#define GetBTDeviceNameCount(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBtDeviceNameCnt, _n)

/**
 * Get hi-speed port flags.
 * This method returns the value of the hi-speed port flags.
 * \param _n The hi-speed port flags. See \ref CommHiSpeedFlagsConstants.
 */
#define GetHSFlags(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsFlags, _n)

/**
 * Get hi-speed port speed.
 * This method returns the value of the hi-speed port speed (baud rate).
 * \param _n The hi-speed port speed (baud rate).  See \ref CommHiSpeedBaudConstants.
 */
#define GetHSSpeed(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsSpeed, _n)

/**
 * Get hi-speed port state.
 * This method returns the value of the hi-speed port state.
 * \param _n The hi-speed port state. See \ref CommHiSpeedStateConstants.
 */
#define GetHSState(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsState, _n)

/**
 * Get USB state.
 * This method returns the value of the USB state.
 * \param _n The USB state.
 */
#define GetUSBState(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetUsbState, _n)

/**
 * Get hi-speed port address.
 * This method returns the value of the hi-speed port address.
 * \param _n The hi-speed port address. See \ref CommHiSpeedAddressConstants.
 */
#define GetHSAddress(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsAddress, _n)

#if (__FIRMWARE_VERSION > 107) && defined(__ENHANCED_FIRMWARE)

/**
 * Get hi-speed port mode.
 * This method returns the value of the hi-speed port mode.
 * \param _n The hi-speed port mode (data bits, stop bits, parity).  See
 * \ref CommHiSpeedDataBitsConstants, \ref CommHiSpeedStopBitsConstants,
 * \ref CommHiSpeedParityConstants, and \ref CommHiSpeedCombinedConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define GetHSMode(_n) \
  compchk EQ, sizeof(_n), 2 \
  GetCommModuleValue(CommOffsetHsMode, _n)

/**
 * Get Bluetooth data mode.
 * This method returns the value of the Bluetooth data mode.
 * \param _n The Bluetooth data mode.  See \ref CommDataModeConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define GetBTDataMode(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetBtDataMode, _n)

/**
 * Get hi-speed port data mode.
 * This method returns the value of the hi-speed port data mode.
 * \param _n The hi-speed port data mode.  See \ref CommDataModeConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define GetHSDataMode(_n) \
  compchk EQ, sizeof(_n), 1 \
  GetCommModuleValue(CommOffsetHsDataMode, _n)

#endif  

/**
 * Set bluetooth input buffer data.
 * Write cnt bytes of data to the bluetooth input buffer at offset.
 * \param _offset A constant offset into the input buffer
 * \param _cnt The number of bytes to write
 * \param _data A byte array containing the data to write
 */
#define SetBTInputBuffer(_offset, _cnt, _data) __setBTInputBuffer(_offset, _cnt, _data)

/**
 * Set bluetooth input buffer in-pointer.
 * Set the value of the input buffer in-pointer.
 * \param _n The new in-pointer value (0..127).
 */
#define SetBTInputBufferInPtr(_n) __setBTInputBufferInPtr(_n)

/**
 * Set bluetooth input buffer out-pointer.
 * Set the value of the input buffer out-pointer.
 * \param _n The new out-pointer value (0..127).
 */
#define SetBTInputBufferOutPtr(_n) __setBTInputBufferOutPtr(_n)

/**
 * Set bluetooth output buffer data.
 * Write cnt bytes of data to the bluetooth output buffer at offset.
 * \param _offset A constant offset into the output buffer
 * \param _cnt The number of bytes to write
 * \param _data A byte array containing the data to write
 */
#define SetBTOutputBuffer(_offset, _cnt, _data) __setBTOutputBuffer(_offset, _cnt, _data)

/**
 * Set bluetooth output buffer in-pointer.
 * Set the value of the output buffer in-pointer.
 * \param _n The new in-pointer value (0..127).
 */
#define SetBTOutputBufferInPtr(_n) __setBTOutputBufferInPtr(_n)

/**
 * Set bluetooth output buffer out-pointer.
 * Set the value of the output buffer out-pointer.
 * \param _n The new out-pointer value (0..127).
 */
#define SetBTOutputBufferOutPtr(_n) __setBTOutputBufferOutPtr(_n)

/**
 * Set hi-speed port input buffer data.
 * Write cnt bytes of data to the hi-speed port input buffer at offset.
 * \param _offset A constant offset into the input buffer
 * \param _cnt The number of bytes to write
 * \param _data A byte array containing the data to write
 */
#define SetHSInputBuffer(_offset, _cnt, _data) __setHSInputBuffer(_offset, _cnt, _data)

/**
 * Set hi-speed port input buffer in-pointer.
 * Set the value of the input buffer in-pointer.
 * \param _n The new in-pointer value (0..127).
 */
#define SetHSInputBufferInPtr(_n) __setHSInputBufferInPtr(_n)

/**
 * Set hi-speed port input buffer out-pointer.
 * Set the value of the input buffer out-pointer.
 * \param _n The new out-pointer value (0..127).
 */
#define SetHSInputBufferOutPtr(_n) __setHSInputBufferOutPtr(_n)

/**
 * Set hi-speed port output buffer data.
 * Write cnt bytes of data to the hi-speed port output buffer at offset.
 * \param _offset A constant offset into the output buffer
 * \param _cnt The number of bytes to write
 * \param _data A byte array containing the data to write
 */
#define SetHSOutputBuffer(_offset, _cnt, _data) __setHSOutputBuffer(_offset, _cnt, _data)

/**
 * Set hi-speed port output buffer in-pointer.
 * Set the value of the output buffer in-pointer.
 * \param _n The new in-pointer value (0..127).
 */
#define SetHSOutputBufferInPtr(_n) __setHSOutputBufferInPtr(_n)

/**
 * Set hi-speed port output buffer out-pointer.
 * Set the value of the output buffer out-pointer.
 * \param _n The new out-pointer value (0..127).
 */
#define SetHSOutputBufferOutPtr(_n) __setHSOutputBufferOutPtr(_n)

/**
 * Set USB input buffer data.
 * Write cnt bytes of data to the USB input buffer at offset.
 * \param _offset A constant offset into the input buffer
 * \param _cnt The number of bytes to write
 * \param _data A byte array containing the data to write
 */
#define SetUSBInputBuffer(_offset, _cnt, _data) __setUSBInputBuffer(_offset, _cnt, _data)

/**
 * Set USB input buffer in-pointer.
 * Set the value of the input buffer in-pointer.
 * \param _n The new in-pointer value (0..63).
 */
#define SetUSBInputBufferInPtr(_n) __setUSBInputBufferInPtr(_n)

/**
 * Set USB input buffer out-pointer.
 * Set the value of the input buffer out-pointer.
 * \param _n The new out-pointer value (0..63).
 */
#define SetUSBInputBufferOutPtr(_n) __setUSBInputBufferOutPtr(_n)

/**
 * Set USB output buffer data.
 * Write cnt bytes of data to the USB output buffer at offset.
 * \param _offset A constant offset into the output buffer
 * \param _cnt The number of bytes to write
 * \param _data A byte array containing the data to write
 */
#define SetUSBOutputBuffer(_offset, _cnt, _data) __setUSBOutputBuffer(_offset, _cnt, _data)

/**
 * Set USB output buffer in-pointer.
 * Set the value of the output buffer in-pointer.
 * \param _n The new in-pointer value (0..63).
 */
#define SetUSBOutputBufferInPtr(_n) __setUSBOutputBufferInPtr(_n)

/**
 * Set USB output buffer out-pointer.
 * Set the value of the output buffer out-pointer.
 * \param _n The new out-pointer value (0..63).
 */
#define SetUSBOutputBufferOutPtr(_n) __setUSBOutputBufferOutPtr(_n)

/**
 * Set USB poll buffer data.
 * Write cnt bytes of data to the USB poll buffer at offset.
 * \param _offset A constant offset into the poll buffer
 * \param _cnt The number of bytes to write
 * \param _data A byte array containing the data to write
 */
#define SetUSBPollBuffer(_offset, _cnt, _data) __setUSBPollBuffer(_offset, _cnt, _data)

/**
 * Set USB poll buffer in-pointer.
 * Set the value of the poll buffer in-pointer.
 * \param _n The new in-pointer value (0..63).
 */
#define SetUSBPollBufferInPtr(_n) __setUSBPollBufferInPtr(_n)

/**
 * Set USB poll buffer out-pointer.
 * Set the value of the poll buffer out-pointer.
 * \param _n The new out-pointer value (0..63).
 */
#define SetUSBPollBufferOutPtr(_n) __setUSBPollBufferOutPtr(_n)

/**
 * Set hi-speed port flags.
 * This method sets the value of the hi-speed port flags.
 * \param _n The hi-speed port flags. See \ref CommHiSpeedFlagsConstants.
 */
#define SetHSFlags(_n) __setHSFlags(_n)

/**
 * Set hi-speed port speed.
 * This method sets the value of the hi-speed port speed (baud rate).
 * \param _n The hi-speed port speed (baud rate).  See \ref CommHiSpeedBaudConstants.
 */
#define SetHSSpeed(_n) __setHSSpeed(_n)

/**
 * Set hi-speed port state.
 * This method sets the value of the hi-speed port state.
 * \param _n The hi-speed port state. See \ref CommHiSpeedStateConstants.
 */
#define SetHSState(_n) __setHSState(_n)

/**
 * Set USB state.
 * This method sets the value of the USB state.
 * \param _n The USB state.
 */
#define SetUSBState(_n) __setUSBState(_n)

/**
 * Set hi-speed port address.
 * This method sets the value of the hi-speed port address.
 * \param _n The hi-speed port address. See \ref CommHiSpeedAddressConstants.
 */
#define SetHSAddress(_n) __setHSAddress(_n)

#if (__FIRMWARE_VERSION > 107) && defined(__ENHANCED_FIRMWARE)

/**
 * Set hi-speed port mode.
 * This method sets the value of the hi-speed port mode.
 * \param _n The hi-speed port mode (data bits, stop bits, parity).  See
 * \ref CommHiSpeedDataBitsConstants, \ref CommHiSpeedStopBitsConstants,
 * \ref CommHiSpeedParityConstants, and \ref CommHiSpeedCombinedConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define SetHSMode(_n) __setHSMode(_n)

/**
 * Set Bluetooth data mode.
 * This method sets the value of the Bluetooth data mode.
 * \param _n The Bluetooth data mode.  See \ref CommDataModeConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define SetBTDataMode(_n) __setBTDataMode(_n)

/**
 * Set hi-speed port data mode.
 * This method sets the value of the hi-speed port data mode.
 * \param _n The hi-speed port data mode.  See \ref CommDataModeConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
#define SetHSDataMode(_n) __setHSDataMode(_n)

#endif

/** @} */ // end of CommModuleFunctions group
/** @} */ // end of CommModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// IOCTRL MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup IOCtrlModule
 * @{
 */
/** @defgroup IOCtrlModuleFunctions IOCtrl module functions
 * Functions for accessing and modifying IOCtrl module features.
 * @{
 */

/**
 * Power down the NXT.
 * This function powers down the NXT.
 * The running program will terminate as a result of this action.
 */
#define PowerDown SetIOCtrlModuleValue(IOCtrlOffsetPowerOn, IOCTRL_POWERDOWN)

/**
 * Reboot the NXT in firmware download mode.
 * This function lets you reboot the NXT into SAMBA or firmware download mode.
 * The running program will terminate as a result of this action.
 */
#define RebootInFirmwareMode SetIOCtrlModuleValue(IOCtrlOffsetPowerOn, IOCTRL_BOOT)

/** @} */ // end of IOCtrlModuleFunctions group
/** @} */ // end of IOCtrlModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// LOADER MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup LoaderModule
 * @{
 */
/** @defgroup LoaderModuleFunctions Loader module functions
 * Functions for accessing and modifying Loader module features.
 * @{
 */

/**
 * Get free flash memory.
 * Get the number of bytes of flash memory that are available for use.
 *
 * \param _value The number of bytes of unused flash memory.
 */
#define GetFreeMemory(_value) __GetFreeMemory(_value)

/**
 * Create a file.
 * Create a new file with the specified filename and size and open it for
 * writing. The file handle is returned in the last parameter, which must be a
 * variable. The loader result code is returned as the value of the function
 * call. The filename and size parameters must be constants, constant
 * expressions, or variables. A file created with a size of zero bytes cannot
 * be written to since the NXC file writing functions do not grow the file if
 * its capacity is exceeded during a write attempt.
 *
 * \param _fname The name of the file to create.
 * \param _fsize The size of the file.
 * \param _handle The file handle output from the function call.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define CreateFile(_fname, _fsize, _handle, _result) __createFile(_fname, _fsize, _handle, _result)

/**
 * Open a file for appending.
 * Open an existing file with the specified filename for writing. The file
 * size is returned in the second parameter, which must be a variable. The
 * file handle is returned in the last parameter, which must be a variable.
 * The loader result code is returned as the value of the function call.
 * The filename parameter must be a constant or a variable.
 *
 * \param _fname The name of the file to open.
 * \param _fsize The size of the file returned by the function.
 * \param _handle The file handle output from the function call.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define OpenFileAppend(_fname, _fsize, _handle, _result) __openFileAppend(_fname, _fsize, _handle, _result)

/**
 * Open a file for reading.
 * Open an existing file with the specified filename for reading. The file
 * size is returned in the second parameter, which must be a variable. The
 * file handle is returned in the last parameter, which must be a variable.
 * The loader result code is returned as the value of the function call. The
 * filename parameter must be a constant or a variable.
 *
 * \param _fname The name of the file to open.
 * \param _fsize The size of the file returned by the function.
 * \param _handle The file handle output from the function call.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define OpenFileRead(_fname, _fsize, _handle, _result) __openFileRead(_fname, _fsize, _handle, _result)

/**
 * Close a file.
 * Close the file associated with the specified file handle. The loader
 * result code is returned as the value of the function call. The handle
 * parameter must be a constant or a variable.
 *
 * \param _handle The file handle.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define CloseFile(_handle, _result) __closeFile(_handle, _result)

/**
 * Resolve a handle.
 * Resolve a file handle from the specified filename. The file handle is
 * returned in the second parameter, which must be a variable. A boolean
 * value indicating whether the handle can be used to write to the file or
 * not is returned in the last parameter, which must be a variable. The
 * loader result code is returned as the value of the function call. The
 * filename parameter must be a constant or a variable.
 *
 * \param _fname The name of the file for which to resolve a handle.
 * \param _handle The file handle output from the function call.
 * \param _writable A boolean flag indicating whether the handle is
 * to a file open for writing (true) or reading (false).
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define ResolveHandle(_fname, _handle, _writable, _result) __resolveHandle(_fname, _handle, _writable, _result)

/**
 * Rename a file.
 * Rename a file from the old filename to the new filename. The loader
 * param _result code is returned as the value of the function call. The filename
 * parameters must be constants or variables.
 *
 * \param _oldname The old filename.
 * \param _newname The new filename.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define RenameFile(_oldname, _newname, _result) __renameFile(_oldname, _newname, _result)

/**
 * Delete a file.
 * Delete the specified file. The loader result code is returned as the
 * value of the function call. The filename parameter must be a constant or a
 * variable.
 *
 * \param _fname The name of the file to delete.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define DeleteFile(_fname, _result) __deleteFile(_fname, _result)

/**
 * Resize a file.
 * Resize the specified file. The loader result code is returned as the
 * value of the function call. The filename parameter must be a constant or a
 * variable.
 *
 * \param _fname The name of the file to resize.
 * \param _newsize The new size for the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define ResizeFile(_fname, _newsize, _result) __fileResize(_fname, _newsize, _result)

#ifdef __ENHANCED_FIRMWARE

/**
 * Create a linear file.
 * Create a new linear file with the specified filename and size and open it for
 * writing. The file handle is returned in the last parameter, which must be a
 * variable. The loader result code is returned as the value of the function
 * call. The filename and size parameters must be constants, constant
 * expressions, or variables. A file created with a size of zero bytes cannot
 * be written to since the NXC file writing functions do not grow the file if
 * its capacity is exceeded during a write attempt.
 *
 * \param _fname The name of the file to create.
 * \param _fsize The size of the file.
 * \param _handle The file handle output from the function call.
 * \param _result The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define CreateFileLinear(_fname, _fsize, _handle, _result) __createFileLinear(_fname, _fsize, _handle, _result)

/**
 * Create a non-linear file.
 * Create a new non-linear file with the specified filename and size and open it for
 * writing. The file handle is returned in the last parameter, which must be a
 * variable. The loader result code is returned as the value of the function
 * call. The filename and size parameters must be constants, constant
 * expressions, or variables. A file created with a size of zero bytes cannot
 * be written to since the NXC file writing functions do not grow the file if
 * its capacity is exceeded during a write attempt.
 *
 * \param _fname The name of the file to create.
 * \param _fsize The size of the file.
 * \param _handle The file handle output from the function call.
 * \param _result The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define CreateFileNonLinear(_fname, _fsize, _handle, _result) __createFileNonLinear(_fname, _fsize, _handle, _result)

/**
 * Open a linear file for reading.
 * Open an existing linear file with the specified filename for reading. The file
 * size is returned in the second parameter, which must be a variable. The
 * file handle is returned in the last parameter, which must be a variable.
 * The loader result code is returned as the value of the function call. The
 * filename parameter must be a constant or a variable.
 *
 * \param _fname The name of the file to open.
 * \param _fsize The size of the file returned by the function.
 * \param _handle The file handle output from the function call.
 * \param _result The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define OpenFileReadLinear(_fname, _fsize, _handle, _result) __openFileReadLinear(_fname, _fsize, _handle, _result)

/**
 * Start searching for files.
 * This function lets you begin iterating through files stored on the NXT.
 *
 * \param _fname On input this contains the filename pattern you are searching
 * for. On output this contains the name of the first file found that matches
 * the pattern.
 * \param _handle The search handle input to and output from the function call.
 * \param _result The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define FindFirstFile(_fname, _handle, _result) __findFirstFile(_fname, _handle, _result)

/**
 * Continue searching for files.
 * This function lets you continue iterating through files stored on the NXT.
 *
 * \param _fname On output this contains the name of the next file found that
 * matches the pattern used when the search began by calling \ref FindFirstFile.
 * \param _handle The search handle input to and output from the function call.
 * \param _result The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
#define FindNextFile(_fname, _handle, _result) __findNextFile(_fname, _handle, _result)
#endif

/**
 * Calculate the size of a variable.
 * Calculate the number of bytes required to store the contents of the
 * variable passed into the function.
 *
 * \param _n The variable.
 * \param _result The number of bytes occupied by the variable.
 */
#define SizeOf(_n, _result) __sizeOF(_n, _result)

/**
 * Read a value from a file.
 * Read a value from the file associated with the specified handle.
 * The handle parameter must be a variable. The value parameter must be a
 * variable. The type of the value parameter determines the number of bytes of
 * data read.
 *
 * \param _handle The file handle.
 * \param _n The variable to store the data read from the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define Read(_handle, _n, _result) __readValue(_handle, _n, _result)

/**
 * Read a value from a file plus line ending.
 * Read a value from the file associated with the specified handle.
 * The handle parameter must be a variable. The value parameter must be a
 * variable. The type of the value parameter determines the number of bytes
 * of data read. The ReadLn function reads two additional bytes from the
 * file which it assumes are a carriage return and line feed pair.
 *
 * \param _handle The file handle.
 * \param _n The variable to store the data read from the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define ReadLn(_handle, _n, _result) __readLnValue(_handle, _n, _result)

/**
 * Read bytes from a file.
 * Read the specified number of bytes from the file associated with the
 * specified handle. The handle parameter must be a variable. The length
 * parameter must be a variable. The buf parameter must be an array or a
 * string variable. The actual number of bytes read is returned in the
 * length parameter.
 *
 * \param _handle The file handle.
 * \param _len The number of bytes to read. Returns the number of bytes actually read.
 * \param _buf The byte array where the data is stored on output.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define ReadBytes(_handle, _len, _buf, _result) __readBytes(_handle, _len, _buf, _result)

/**
 * Read a string from a file plus line ending.
 * Read a string from the file associated with the specified handle.
 * The handle parameter must be a variable. The output parameter must be a
 * variable. Appends bytes to the output variable until a line ending (CRLF)
 * is reached. The line ending is also read but it is not appended to the
 * output parameter.
 *
 * \param _handle The file handle.
 * \param _output The variable to store the string read from the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define ReadLnString(_handle, _output, _result) __readLnString(_handle, _output, _result)

/**
 * Write value to file.
 * Write a value to the file associated with the specified handle.
 * The handle parameter must be a variable. The value parameter must be a
 * constant, a constant expression, or a variable. The type of the value
 * parameter determines the number of bytes of data written.
 *
 * \param _handle The file handle.
 * \param _n The value to write to the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define Write(_handle, _n, _result) __writeValue(_handle, _n, _result)

/**
 * Write a value and new line to a file.
 * Write a value to the file associated with the specified handle. The
 * handle parameter must be a variable. The value parameter must be a constant,
 * a constant expression, or a variable. The type of the value parameter
 * determines the number of bytes of data written. This function also
 * writes a carriage return and a line feed to the file following the numeric
 * data.
 *
 * \param _handle The file handle.
 * \param _n The value to write to the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define WriteLn(_handle, _n, _result) __writeLnValue(_handle, _n, _result)

/**
 * Write string to a file.
 * Write the string to the file associated with the specified handle. The
 * handle parameter must be a variable. The count parameter must be a variable.
 * The str parameter must be a string variable or string constant. The actual
 * number of bytes written is returned in the cnt parameter.
 *
 * \param _handle The file handle.
 * \param _str The string to write to the file.
 * \param _cnt The number of bytes actually written to the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define WriteString(_handle, _str, _cnt, _result) __writeString(_handle, _str, _cnt, _result)

/**
 * Write string and new line to a file.
 * Write the string to the file associated with the specified handle. The
 * handle parameter must be a variable. The count parameter must be a variable.
 * The str parameter must be a string variable or string constant. This
 * function also writes a carriage return and a line feed to the file following
 * the string data. The total number of bytes written is returned in the
 * cnt parameter.
 *
 * \param _handle The file handle.
 * \param _str The string to write to the file.
 * \param _cnt The number of bytes actually written to the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define WriteLnString(_handle, _str, _cnt, _result) __writeLnString(_handle, _str, _cnt, _result)

/**
 * Write bytes to file.
 * Write the contents of the data array to the file associated with the
 * specified handle. The handle parameter must be a variable. The cnt
 * parameter must be a variable. The data parameter must be a byte array. The
 * actual number of bytes written is returned in the cnt parameter.
 *
 * \param _handle The file handle.
 * \param _buf The byte array or string containing the data to write.
 * \param _cnt The number of bytes actually written to the file.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define WriteBytes(_handle, _buf, _cnt, _result) __writeBytes(_handle, _buf, _cnt, _result)

/**
 * Write bytes to a file with limit.
 * Write the specified number of bytes to the file associated with the
 * specified handle. The handle parameter must be a variable. The len
 * parameter must be a variable. The buf parameter must be a byte array or a
 * string variable or string constant. The actual number of bytes written is
 * returned in the len parameter.
 *
 * \param _handle The file handle.
 * \param _len The maximum number of bytes to write on input.  Returns the
 * actual number of bytes written.
 * \param _buf The byte array or string containing the data to write.
 * \param _result The function call result. See \ref LoaderErrors.
 */
#define WriteBytesEx(_handle, _len, _buf, _result) __writeBytesEx(_handle, _len, _buf, _result)

/** @} */ // end of LoaderModuleFunctions group
/** @} */ // end of LoaderModule group
/** @} */ // end of NXTFirmwareModules group

/** @addtogroup StandardCAPIFunctions
 * @{
 */

/** @defgroup cstdlibAPI cstdlib API
 * Standard C cstdlib API functions.
 * @{
 */

/**
 * Generate an unsigned random number.
 * Return an unsigned 16-bit random number. The
 * returned value will range between 0 and n (exclusive).
 *
 * \param _arg An unsigned random number.
 * \param _max The maximum unsigned value desired.
 */
#define Random(_arg,_max) __Random(_arg,_max)

/**
 * Generate signed random number.
 * Return a signed 16-bit random number.
 *
 * \param _arg A signed random number
 */
#define SignedRandom(_arg) __SignedRandom(_arg)

/** @} */ // end of cstdlibAPI group

/** @defgroup cmathAPI cmath API
 * Standard C cmath API functions.
 * @{
 */

/**
 * Convert from BCD to decimal
 * Return the decimal equivalent of the binary coded decimal value provided.
 *
 * \param _bcd The value you want to convert from bcd to decimal.
 * \param _result The decimal equivalent of the binary coded decimal byte.
 */
#define bcd2dec(_bcd, _result) __bcd2dec(_bcd, _result)

/** @} */ // end of cmathAPI group
/** @} */ // end of StandardCAPIFunctions group


/** @addtogroup ThirdPartyDevices
 * @{
 */

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// HiTechnic API ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup HiTechnicAPI
 * @{
 */

/**
 * Set sensor as HiTechnic Gyro.
 * Configure the sensor on the specified port as a HiTechnic Gyro sensor.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 */
#define SetSensorHTGyro(_port) __SetSensorHTGyro(_port)

/**
 * Read HiTechnic Gyro sensor.
 * Read the HiTechnic Gyro sensor on the specified port. The offset value
 * should be calculated by averaging several readings with an offset of zero
 * while the sensor is perfectly still.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants.
 * \param _offset The zero offset.
 * \param _val The Gyro sensor reading.
 */
#define ReadSensorHTGyro(_p, _offset, _val) __ReadSensorHTGyro(_p, _offset, _val)

/**
 * Set sensor as HiTechnic Magnet.
 * Configure the sensor on the specified port as a HiTechnic Magnet sensor.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 */
#define SetSensorHTMagnet(_port) __SetSensorHTGyro(_port)

/**
 * Read HiTechnic Magnet sensor.
 * Read the HiTechnic Magnet sensor on the specified port. The offset value
 * should be calculated by averaging several readings with an offset of zero
 * while the sensor is perfectly still.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants.
 * \param _offset The zero offset.
 * \param _val The Magnet sensor reading.
 */
#define ReadSensorHTMagnet(_p, _offset, _val) __ReadSensorHTGyro(_p, _offset, _val)

/**
 * Set sensor as HiTechnic EOPD.
 * Configure the sensor on the specified port as a HiTechnic EOPD sensor.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _bStd Configure in standard or long-range mode.
 */
#define SetSensorHTEOPD(_port, _bStd) __SetSensorHTEOPD(_port, _bStd)

/**
 * Read HiTechnic EOPD sensor.
 * Read the HiTechnic EOPD sensor on the specified port.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _val The EOPD sensor reading.
 */
#define ReadSensorHTEOPD(_port, _val) __ReadSensorHTEOPD(_port, _val)

/**
 * Read HiTechnic touch multiplexer.
 * Read touch sensor values from the HiTechnic touch multiplexer device.
 *
 * \param _p The sensor port. See \ref NBCInputPortConstants.
 * \param _t1 The value of touch sensor 1.
 * \param _t2 The value of touch sensor 2.
 * \param _t3 The value of touch sensor 3.
 * \param _t4 The value of touch sensor 4.
 */
#define ReadSensorHTTouchMultiplexer(_p, _t1, _t2, _t3, _t4) __ReadSensorHTTouchMultiplexer(_p, _t1, _t2, _t3, _t4)

/**
 * HTPowerFunctionCommand function.
 * Execute a pair of Power Function motor commands on the specified channel
 * using the HiTechnic iRLink device. Commands for outa and outb are
 * \ref PF_CMD_STOP, \ref PF_CMD_REV, \ref PF_CMD_FWD, and \ref PF_CMD_BRAKE.
 * Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _outa The Power Function command for output A. See \ref PFCmdConstants.
 * \param _outb The Power Function command for output B. See \ref PFCmdConstants.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPowerFunctionCommand(_port, _channel, _outa, _outb, _result) \
  __HTPFComboDirect(_port, _channel, _outa, _outb, _result)

/**
 * HTIRTrain function.
 * Control an IR Train receiver set to the specified channel using the
 * HiTechnic iRLink device. Valid func values are \ref TRAIN_FUNC_STOP,
 * \ref TRAIN_FUNC_INCR_SPEED, \ref TRAIN_FUNC_DECR_SPEED, and \ref TRAIN_FUNC_TOGGLE_LIGHT.
 * Valid channel values are \ref TRAIN_CHANNEL_1 through \ref TRAIN_CHANNEL_3 and
 * \ref TRAIN_CHANNEL_ALL. The port must be configured as a Lowspeed port before
 * using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _channel The IR Train channel.  See \ref IRTrainChannels.
 * \param _func The IR Train function. See \ref IRTrainFuncs
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTIRTrain(_port, _channel, _func, _result) \
  __HTIRTrain(_port, _channel, _func, FALSE, _result)

/**
 * HTPFComboDirect function.
 * Execute a pair of Power Function motor commands on the specified channel
 * using the HiTechnic iRLink device. Commands for outa and outb are
 * \ref PF_CMD_STOP, \ref PF_CMD_REV, \ref PF_CMD_FWD, and \ref PF_CMD_BRAKE. Valid channels are
 * \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _outa The Power Function command for output A. See \ref PFCmdConstants.
 * \param _outb The Power Function command for output B. See \ref PFCmdConstants.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPFComboDirect(_port, _channel, _outa, _outb, _result) \
  __HTPFComboDirect(_port, _channel, _outa, _outb, _result)

/**
 * HTPFComboPWM function.
 * Control the speed of both outputs on a Power Function receiver set to the
 * specified channel using the HiTechnic iRLink device. Valid output values
 * are \ref PF_PWM_FLOAT, \ref PF_PWM_FWD1, \ref PF_PWM_FWD2, \ref PF_PWM_FWD3, \ref PF_PWM_FWD4,
 * \ref PF_PWM_FWD5, \ref PF_PWM_FWD6, \ref PF_PWM_FWD7, \ref PF_PWM_BRAKE, \ref PF_PWM_REV7,
 * \ref PF_PWM_REV6, \ref PF_PWM_REV5, \ref PF_PWM_REV4, \ref PF_PWM_REV3, \ref PF_PWM_REV2, and
 * \ref PF_PWM_REV1. Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The
 * port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _outa The Power Function PWM command for output A. See \ref PFPWMOptions.
 * \param _outb The Power Function PWM command for output B. See \ref PFPWMOptions.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPFComboPWM(_port, _channel, _outa, _outb, _result) \
  __HTPFComboPWM(_port, _channel, _outa, _outb, _result)

/**
 * HTPFRawOutput function.
 * Control a Power Function receiver set to the specified channel using the
 * HiTechnic iRLink device. Build the raw data stream using the 3 nibbles
 * (4 bit values). The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _nibble0 The first raw data nibble.
 * \param _nibble1 The second raw data nibble.
 * \param _nibble2 The third raw data nibble.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPFRawOutput(_port, _nibble0, _nibble1, _nibble2, _result) \
  __HTPFRawOutput(_port, _nibble0, _nibble1, _nibble2, _result)

/**
 * HTPFRepeat function.
 * Repeat sending the last Power Function command using the HiTechnic
 * IRLink device. Specify the number of times to repeat the command and the
 * number of milliseconds of delay between each repetition. The port must be
 * configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _count The number of times to repeat the command.
 * \param _delay The number of milliseconds to delay between each repetition.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPFRepeat(_port, _count, _delay, _result) \
  __HTPFRepeatLastCommand(_port, _count, _delay, _result)

/**
 * HTPFSingleOutputCST function.
 * Control a single output on a Power Function receiver set to the specified
 * channel using the HiTechnic iRLink device. Select the desired output
 * using \ref PF_OUT_A or \ref PF_OUT_B. Valid functions are \ref PF_CST_CLEAR1_CLEAR2,
 * \ref PF_CST_SET1_CLEAR2, \ref PF_CST_CLEAR1_SET2, \ref PF_CST_SET1_SET2,
 * \ref PF_CST_INCREMENT_PWM, \ref PF_CST_DECREMENT_PWM, \ref PF_CST_FULL_FWD,
 * \ref PF_CST_FULL_REV, and \ref PF_CST_TOGGLE_DIR. Valid channels are
 * \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _out The Power Function output. See \ref PFOutputs.
 * \param _func The Power Function CST function. See \ref PFCSTOptions.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPFSingleOutputCST(_port, _channel, _out, _func, _result) \
  __HTPFSingleOutput(_port, _channel, _out, _func, TRUE, _result)

/**
 * HTPFSingleOutputPWM function.
 * Control the speed of a single output on a Power Function receiver set to
 * the specified channel using the HiTechnic iRLink device. Select the
 * desired output using \ref PF_OUT_A or \ref PF_OUT_B. Valid functions are
 * \ref PF_PWM_FLOAT, \ref PF_PWM_FWD1, \ref PF_PWM_FWD2, \ref PF_PWM_FWD3, \ref PF_PWM_FWD4,
 * \ref PF_PWM_FWD5, \ref PF_PWM_FWD6, \ref PF_PWM_FWD7, \ref PF_PWM_BRAKE, \ref PF_PWM_REV7,
 * \ref PF_PWM_REV6, \ref PF_PWM_REV5, \ref PF_PWM_REV4, \ref PF_PWM_REV3, \ref PF_PWM_REV2, and
 * \ref PF_PWM_REV1. Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The
 * port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _out The Power Function output. See \ref PFOutputs.
 * \param _func The Power Function PWM function. See \ref PFPWMOptions.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPFSingleOutputPWM(_port, _channel, _out, _func, _result) \
  __HTPFSingleOutput(_port, _channel, _out, _func, FALSE, _result)

/**
 * HTPFSinglePin function.
 * Control a single pin on a Power Function receiver set to the specified
 * channel using the HiTechnic iRLink device. Select the desired output
 * using \ref PF_OUT_A or \ref PF_OUT_B.  Select the desired pin using \ref PF_PIN_C1 or
 * \ref PF_PIN_C2. Valid functions are \ref PF_FUNC_NOCHANGE, \ref PF_FUNC_CLEAR,
 * \ref PF_FUNC_SET, and \ref PF_FUNC_TOGGLE. Valid channels are \ref PF_CHANNEL_1 through
 * \ref PF_CHANNEL_4. Specify whether the mode by passing true (continuous) or
 * false (timeout) as the final parameter. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _out The Power Function output. See \ref PFOutputs.
 * \param _pin The Power Function pin. See \ref PFPinConstants.
 * \param _func The Power Function single pin function. See \ref PFPinFuncs.
 * \param _cont Control whether the mode is continuous or timeout.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPFSinglePin(_port, _channel, _out, _pin, _func, _cont, _result) \
  __HTPFSinglePin(_port, _channel, _out, _pin, _func, _cont, _result)

/**
 * HTPFTrain function.
 * Control both outputs on a Power Function receiver set to the specified
 * channel using the HiTechnic iRLink device as if it were an IR Train
 * receiver. Valid function values are \ref TRAIN_FUNC_STOP, \ref TRAIN_FUNC_INCR_SPEED,
 * \ref TRAIN_FUNC_DECR_SPEED, and \ref TRAIN_FUNC_TOGGLE_LIGHT. Valid channels are
 * \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _func The Power Function train function. See \ref IRTrainFuncs.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define HTPFTrain(_port, _channel, _func, _result) \
  __HTIRTrain(_port, _channel, _func, TRUE, _result)

/**
 * HTRCXSetIRLinkPort function.
 * Set the global port in advance of using the HTRCX* and HTScout* API
 * functions for sending RCX and Scout messages over the HiTechnic iRLink
 * device. The port must be configured as a Lowspeed port before using any of
 * the HiTechnic RCX and Scout iRLink functions.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 */
#define HTRCXSetIRLinkPort(_port) __HTRCXSetIRLinkPort(_port)

/**
 * HTRCXBatteryLevel function.
 * Send the BatteryLevel command to an RCX to read the current battery level.
 *
 * \param _result The RCX battery level.
 */
#define HTRCXBatteryLevel(_result) __HTRCXBatteryLevel(_result)

/**
 * HTRCXPoll function
 * Send the Poll command to an RCX to read a signed 2-byte value at the
 * specified source and value combination.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 * \param _result The value read from the specified port and value.
 */
#define HTRCXPoll(_src, _value, _result) __HTRCXPoll(_src, _value, _result)

/**
 * HTRCXPollMemory function.
 * Send the PollMemory command to an RCX.
 *
 * \param _memaddress The RCX memory address.
 * \param _result The value read from the specified address.
 */
#define HTRCXPollMemory(_memaddress, _result) __HTRCXPollMemory(_memaddress, _result)

/**
 * HTRCXAddToDatalog function.
 * Send the AddToDatalog command to an RCX.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define HTRCXAddToDatalog(_src, _value) __HTRCXAddToDatalog(_src, _value)

/**
 * HTRCXClearAllEvents function.
 * Send the ClearAllEvents command to an RCX.
 */
#define HTRCXClearAllEvents() __HTRCXOpNoArgs(RCX_ClearAllEventsOp)

/**
 * HTRCXClearCounter function.
 * Send the ClearCounter command to an RCX.
 *
 * \param _counter The counter to clear.
 */
#define HTRCXClearCounter(_counter) __HTRCXClearCounter(_counter)

/**
 * HTRCXClearMsg function.
 * Send the ClearMsg command to an RCX.
 */
#define HTRCXClearMsg() __HTRCXOpNoArgs(RCX_ClearMsgOp)

/**
 * HTRCXClearSensor function.
 * Send the ClearSensor command to an RCX.
 *
 * \param _port The RCX port number.
 */
#define HTRCXClearSensor(_port) __HTRCXClearSensor(_port)

/**
 * HTRCXClearSound function.
 * Send the ClearSound command to an RCX.
 */
#define HTRCXClearSound() __HTRCXOpNoArgs(RCX_ClearSoundOp)

/**
 * HTRCXClearTimer function.
 * Send the ClearTimer command to an RCX.
 *
 * \param _timer The timer to clear.
 */
#define HTRCXClearTimer(_timer) __HTRCXClearTimer(_timer)

/**
 * HTRCXCreateDatalog function.
 * Send the CreateDatalog command to an RCX.
 *
 * \param _size The new datalog size.
 */
#define HTRCXCreateDatalog(_size) __HTRCXCreateDatalog(_size)

/**
 * HTRCXDecCounter function.
 * Send the DecCounter command to an RCX.
 *
 * \param _counter The counter to decrement.
 */
#define HTRCXDecCounter(_counter) __HTRCXDecCounter(_counter)

/**
 * HTRCXDeleteSub function.
 * Send the DeleteSub command to an RCX.
 *
 * \param _s The subroutine number to delete.
 */
#define HTRCXDeleteSub(_s) __HTRCXDeleteSub(_s)

/**
 * HTRCXDeleteSubs function.
 * Send the DeleteSubs command to an RCX.
 */
#define HTRCXDeleteSubs() __HTRCXOpNoArgs(RCX_DeleteSubsOp)

/**
 * HTRCXDeleteTask function.
 * Send the DeleteTask command to an RCX.
 *
 * \param _t The task number to delete.
 */
#define HTRCXDeleteTask(_t) __HTRCXDeleteTask(_t)

/**
 * HTRCXDeleteTasks function.
 * Send the DeleteTasks command to an RCX.
 */
#define HTRCXDeleteTasks() __HTRCXOpNoArgs(RCX_DeleteTasksOp)

/**
 * HTRCXDisableOutput function.
 * Send the DisableOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to disable. See \ref RCXOutputConstants.
 */
#define HTRCXDisableOutput(_outputs) __HTRCXSetGlobalOutput(_outputs, RCX_OUT_OFF)

/**
 * HTRCXEnableOutput function.
 * Send the EnableOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to enable. See \ref RCXOutputConstants.
 */
#define HTRCXEnableOutput(_outputs) __HTRCXSetGlobalOutput(_outputs, RCX_OUT_ON)

/**
 * HTRCXEvent function.
 * Send the Event command to an RCX.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define HTRCXEvent(_src, _value) __HTRCXEvent(_src, _value)

/**
 * HTRCXFloat function.
 * Send commands to an RCX to float the specified outputs.
 *
 * \param _outputs The RCX output(s) to float. See \ref RCXOutputConstants.
 */
#define HTRCXFloat(_outputs) __HTRCXSetOutput(_outputs, RCX_OUT_FLOAT)

/**
 * HTRCXFwd function.
 * Send commands to an RCX to set the specified outputs to the forward direction.
 *
 * \param _outputs The RCX output(s) to set forward. See \ref RCXOutputConstants.
 */
#define HTRCXFwd(_outputs) __HTRCXSetDirection(_outputs, RCX_OUT_FWD)

/**
 * HTRCXIncCounter function.
 * Send the IncCounter command to an RCX.
 *
 * \param _counter The counter to increment.
 */
#define HTRCXIncCounter(_counter) __HTRCXIncCounter(_counter)

/**
 * HTRCXInvertOutput function.
 * Send the InvertOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to invert. See \ref RCXOutputConstants.
 */
#define HTRCXInvertOutput(_outputs) __HTRCXSetGlobalDirection(_outputs, RCX_OUT_REV)

/**
 * HTRCXMuteSound function.
 * Send the MuteSound command to an RCX.
 */
#define HTRCXMuteSound() __HTRCXOpNoArgs(RCX_MuteSoundOp)

/**
 * HTRCXObvertOutput function.
 * Send the ObvertOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to obvert. See \ref RCXOutputConstants.
 */
#define HTRCXObvertOutput(_outputs) __HTRCXSetGlobalDirection(_outputs, RCX_OUT_FWD)

/**
 * HTRCXOff function.
 * Send commands to an RCX to turn off the specified outputs.
 *
 * \param _outputs The RCX output(s) to turn off. See \ref RCXOutputConstants.
 */
#define HTRCXOff(_outputs) __HTRCXSetOutput(_outputs, RCX_OUT_OFF)

/**
 * HTRCXOn function.
 * Send commands to an RCX to turn on the specified outputs.
 *
 * \param _outputs The RCX output(s) to turn on. See \ref RCXOutputConstants.
 */
#define HTRCXOn(_outputs) __HTRCXSetOutput(_outputs, RCX_OUT_ON)

/**
 * HTRCXOnFor function.
 * Send commands to an RCX to turn on the specified outputs in the forward
 * direction for the specified duration.
 *
 * \param _outputs The RCX output(s) to turn on. See \ref RCXOutputConstants.
 * \param _ms The number of milliseconds to leave the outputs on
 */
#define HTRCXOnFor(_outputs, _ms) __HTRCXOnFor(_outputs, _ms)

/**
 * HTRCXOnFwd function.
 * Send commands to an RCX to turn on the specified outputs in the forward
 * direction.
 *
 * \param _outputs The RCX output(s) to turn on in the forward direction. See \ref RCXOutputConstants.
 */
#define HTRCXOnFwd(_outputs) __HTRCXOnFwd(_outputs)

/**
 * HTRCXOnRev function.
 * Send commands to an RCX to turn on the specified outputs in the reverse direction.
 *
 * \param _outputs The RCX output(s) to turn on in the reverse direction. See \ref RCXOutputConstants.
 */
#define HTRCXOnRev(_outputs) __HTRCXOnRev(_outputs)

/**
 * HTRCXPBTurnOff function.
 * Send the PBTurnOff command to an RCX.
 */
#define HTRCXPBTurnOff() __HTRCXOpNoArgs(RCX_PBTurnOffOp)

/**
 * HTRCXPing function.
 * Send the Ping command to an RCX.
 */
#define HTRCXPing() __HTRCXOpNoArgs(RCX_PingOp)

/**
 * HTRCXPlaySound function.
 * Send the PlaySound command to an RCX.
 *
 * \param _snd The sound number to play.
 */
#define HTRCXPlaySound(_snd) __HTRCXPlaySound(_snd)

/**
 * HTRCXPlayTone function.
 * Send the PlayTone command to an RCX.
 *
 * \param _freq The frequency of the tone to play.
 * \param _duration The duration of the tone to play.
 */
#define HTRCXPlayTone(_freq, _duration) __HTRCXPlayTone(_freq, _duration)

/**
 * HTRCXPlayToneVar function.
 * Send the PlayToneVar command to an RCX.
 *
 * \param _varnum The variable containing the tone frequency to play.
 * \param _duration The duration of the tone to play.
 */
#define HTRCXPlayToneVar(_varnum, _duration) __HTRCXPlayToneVar(_varnum, _duration)

/**
 * HTRCXRemote function.
 * Send the Remote command to an RCX.
 *
 * \param _cmd The RCX IR remote command to send. See \ref RCXRemoteConstants.
 */
#define HTRCXRemote(_cmd) __HTRCXRemote(_cmd)

/**
 * HTRCXRev function.
 * Send commands to an RCX to set the specified outputs to the reverse direction.
 *
 * \param _outputs The RCX output(s) to reverse direction. See \ref RCXOutputConstants.
 */
#define HTRCXRev(_outputs) __HTRCXSetDirection(_outputs, RCX_OUT_REV)

/**
 * HTRCXSelectDisplay function.
 * Send the SelectDisplay command to an RCX.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define HTRCXSelectDisplay(_src, _value) __HTRCXSelectDisplay(_src, _value)

/**
 * HTRCXSelectProgram function.
 * Send the SelectProgram command to an RCX.
 *
 * \param _prog The program number to select.
 */
#define HTRCXSelectProgram(_prog) __HTRCXSelectProgram(_prog)

/**
 * HTRCXSendSerial function.
 * Send the SendSerial command to an RCX.
 *
 * \param _first The first byte address.
 * \param _count The number of bytes to send.
 */
#define HTRCXSendSerial(_first, _count) __HTRCXSendSerial(_first, _count)

/**
 * HTRCXSetDirection function.
 * Send the SetDirection command to an RCX to configure the direction of the specified outputs.
 *
 * \param _outputs The RCX output(s) to set direction. See \ref RCXOutputConstants.
 * \param _dir The RCX output direction. See \ref RCXOutputDirection.
 */
#define HTRCXSetDirection(_outputs, _dir) __HTRCXSetDirection(_outputs, _dir)

/**
 * HTRCXSetEvent function.
 * Send the SetEvent command to an RCX.
 *
 * \param _evt The event number to set.
 * \param _src The RCX source. See \ref RCXSourceConstants.
 * \param _type The event type.
 */
#define HTRCXSetEvent(_evt, _src, _type) __HTRCXSetEvent(_evt, _src, _type)

/**
 * HTRCXSetGlobalDirection function.
 * Send the SetGlobalDirection command to an RCX.
 *
 * \param _outputs The RCX output(s) to set global direction. See \ref RCXOutputConstants.
 * \param _dir The RCX output direction. See \ref RCXOutputDirection.
 */
#define HTRCXSetGlobalDirection(_outputs, _dir) __HTRCXSetGlobalDirection(_outputs, _dir)

/**
 * HTRCXSetGlobalOutput function.
 * Send the SetGlobalOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to set global mode. See \ref RCXOutputConstants.
 * \param _mode The RCX output mode. See \ref RCXOutputMode.
 */
#define HTRCXSetGlobalOutput(_outputs, _mode) __HTRCXSetGlobalOutput(_outputs, _mode)

/**
 * HTRCXSetMaxPower function.
 * Send the SetMaxPower command to an RCX.
 *
 * \param _outputs The RCX output(s) to set max power. See \ref RCXOutputConstants.
 * \param _pwrsrc The RCX source.  See \ref RCXSourceConstants.
 * \param _pwrval The RCX value.
 */
#define HTRCXSetMaxPower(_outputs, _pwrsrc, _pwrval) __HTRCXSetMaxPower(_outputs, _pwrsrc, _pwrval)

/**
 * HTRCXSetMessage function.
 * Send the SetMessage command to an RCX.
 *
 * \param _msg The numeric message to send.
 */
#define HTRCXSetMessage(_msg) __HTRCXSetMessage(_msg)

/**
 * HTRCXSetOutput function.
 * Send the SetOutput command to an RCX to configure the mode of the specified outputs
 *
 * \param _outputs The RCX output(s) to set mode. See \ref RCXOutputConstants.
 * \param _mode The RCX output mode. See \ref RCXOutputMode.
 */
#define HTRCXSetOutput(_outputs, _mode) __HTRCXSetOutput(_outputs, _mode)

/**
 * HTRCXSetPower function.
 * Send the SetPower command to an RCX to configure the power level of the specified outputs.
 *
 * \param _outputs The RCX output(s) to set power. See \ref RCXOutputConstants.
 * \param _pwrsrc The RCX source.  See \ref RCXSourceConstants.
 * \param _pwrval The RCX value.
 */
#define HTRCXSetPower(_outputs, _pwrsrc, _pwrval) __HTRCXSetPower(_outputs, _pwrsrc, _pwrval)

/**
 * HTRCXSetPriority function.
 * Send the SetPriority command to an RCX.
 *
 * \param _p The new task priority.
 */
#define HTRCXSetPriority(_p) __HTRCXSetPriority(_p)

/**
 * HTRCXSetSensorMode function.
 * Send the SetSensorMode command to an RCX.
 *
 * \param _port The RCX sensor port.
 * \param _mode The RCX sensor mode.
 */
#define HTRCXSetSensorMode(_port, _mode) __HTRCXSetSensorMode(_port, _mode)

/**
 * HTRCXSetSensorType function.
 * Send the SetSensorType command to an RCX.
 *
 * \param _port The RCX sensor port.
 * \param _type The RCX sensor type.
 */
#define HTRCXSetSensorType(_port, _type) __HTRCXSetSensorType(_port, _type)

/**
 * HTRCXSetSleepTime function.
 * Send the SetSleepTime command to an RCX.
 *
 * \param _t The new sleep time value.
 */
#define HTRCXSetSleepTime(_t) __HTRCXSetSleepTime(_t)

/**
 * HTRCXSetTxPower function.
 * Send the SetTxPower command to an RCX.
 *
 * \param _pwr The IR transmit power level.
 */
#define HTRCXSetTxPower(_pwr) __HTRCXSetTxPower(_pwr)

/**
 * HTRCXSetWatch function.
 * Send the SetWatch command to an RCX.
 *
 * \param _hours The new watch time hours value.
 * \param _minutes The new watch time minutes value.
 */
#define HTRCXSetWatch(_hours, _minutes) __HTRCXSetWatch(_hours, _minutes)

/**
 * HTRCXStartTask function.
 * Send the StartTask command to an RCX.
 *
 * \param _t The task number to start.
 */
#define HTRCXStartTask(_t) __HTRCXStartTask(_t)

/**
 * HTRCXStopAllTasks function.
 * Send the StopAllTasks command to an RCX.
 */
#define HTRCXStopAllTasks() __HTRCXOpNoArgs(RCX_StopAllTasksOp)

/**
 * HTRCXStopTask function.
 * Send the StopTask command to an RCX.
 *
 * \param _t The task number to stop.
 */
#define HTRCXStopTask(_t) __HTRCXStopTask(_t)

/**
 * HTRCXToggle function.
 * Send commands to an RCX to toggle the direction of the specified outputs.
 *
 * \param _outputs The RCX output(s) to toggle. See \ref RCXOutputConstants.
 */
#define HTRCXToggle(_outputs) __HTRCXSetDirection(_outputs, RCX_OUT_TOGGLE)

/**
 * HTRCXUnmuteSound function.
 * Send the UnmuteSound command to an RCX.
 */
#define HTRCXUnmuteSound() __HTRCXOpNoArgs(RCX_UnmuteSoundOp)

/**
 * HTScoutCalibrateSensor function.
 * Send the CalibrateSensor command to a Scout.
 */
#define HTScoutCalibrateSensor() __HTRCXOpNoArgs(RCX_LSCalibrateOp)

/**
 * HTScoutMuteSound function.
 * Send the MuteSound command to a Scout.
 */
#define HTScoutMuteSound() __HTScoutMuteSound()

/**
 * HTScoutSelectSounds function.
 * Send the SelectSounds command to a Scout.
 *
 * \param _grp The Scout sound group to select.
 */
#define HTScoutSelectSounds(_grp) __HTScoutSelectSounds(_grp)

/**
 * HTScoutSendVLL function.
 * Send the SendVLL command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define HTScoutSendVLL(_src, _value) __HTScoutSendVLL(_src, _value)

/**
 * HTScoutSetEventFeedback function.
 * Send the SetEventFeedback command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define HTScoutSetEventFeedback(_src, _value) __HTScoutSetEventFeedback(_src, _value)

/**
 * HTScoutSetLight function.
 * Send the SetLight command to a Scout.
 *
 * \param _x Set the light on or off using this value. See \ref ScoutLightConstants.
 */
#define HTScoutSetLight(_x) __HTScoutSetLight(_x)

/**
 * HTScoutSetScoutMode function.
 * Send the SetScoutMode command to a Scout.
 *
 * \param _mode Set the scout mode. See \ref ScoutModeConstants.
*/
#define HTScoutSetScoutMode(_mode) __HTScoutSetScoutMode(_mode)

/**
 * HTScoutSetSensorClickTime function.
 * Send the SetSensorClickTime command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define HTScoutSetSensorClickTime(_src, _value) __HTScoutSetSensorClickTime(_src, _value)

/**
 * HTScoutSetSensorHysteresis function.
 * Send the SetSensorHysteresis command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define HTScoutSetSensorHysteresis(_src, _value) __HTScoutSetSensorHysteresis(_src, _value)

/**
 * HTScoutSetSensorLowerLimit function.
 * Send the SetSensorLowerLimit command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define HTScoutSetSensorLowerLimit(_src, _value) __HTScoutSetSensorLowerLimit(_src, _value)

/**
 * HTScoutSetSensorUpperLimit function.
 * Send the SetSensorUpperLimit command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define HTScoutSetSensorUpperLimit(_src, _value) __HTScoutSetSensorUpperLimit(_src, _value)

/**
 * HTScoutUnmuteSound function.
 * Send the UnmuteSound command to a Scout.
 */
#define HTScoutUnmuteSound() __HTScoutUnmuteSound()

/**
 * Read HiTechnic compass.
 * Read the compass heading value of the HiTechnic Compass sensor on the
 * specified port. The port must be configured as a Lowspeed port before
 * using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The compass heading.
 */
#define ReadSensorHTCompass(_port, _value) __ReadSensorHTCompass(_port, _value)

/**
 * Read HiTechnic color sensor color number.
 * Read the color number from the HiTechnic Color sensor on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The color number.
 */
#define ReadSensorHTColorNum(_port, _value) __ReadSensorHTColorNum(_port, _value)

/**
 * Read HiTechnic IRSeeker direction.
 * Read the direction value of the HiTechnic IR Seeker on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The IRSeeker direction.
 */
#define ReadSensorHTIRSeekerDir(_port, _value) __ReadSensorHTIRSeekerDir(_port, _value)

/**
 * Read HiTechnic IRSeeker2 register.
 * Read a register value from the HiTechnic IR Seeker2 on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _reg The register address. See \ref HTIRSeeker2Constants.
 * \param _value The IRSeeker2 register value.
 */
#define ReadSensorHTIRSeeker2Addr(_port, _reg, _value) __ReadSensorHTIRSeeker2Addr(_port, _reg, _value)

/**
 * Read HiTechnic acceleration values.
 * Read X, Y, and Z axis acceleration values from the HiTechnic Accelerometer
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _x The output x-axis acceleration.
 * \param _y The output y-axis acceleration.
 * \param _z The output z-axis acceleration.
 * \param _result The function call result.
 */
#define ReadSensorHTAccel(_port, _x, _y, _z, _result) __ReadSensorHTAccel(_port, _x, _y, _z, _result)

/**
 * Read HiTechnic Color values.
 * Read color number, red, green, and blue values from the HiTechnic Color
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _ColorNum The output color number.
 * \param _Red The red color value.
 * \param _Green The green color value.
 * \param _Blue The blue color value.
 * \param _result The function call result.
 */
#define ReadSensorHTColor(_port, _ColorNum, _Red, _Green, _Blue, _result) __ReadSensorHTColor(_port, _ColorNum, _Red, _Green, _Blue, _result)

/**
 * Read HiTechnic Color raw values.
 * Read the raw red, green, and blue values from the HiTechnic Color sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _Red The raw red color value.
 * \param _Green The raw green color value.
 * \param _Blue The raw blue color value.
 * \param _result The function call result.
 */
#define ReadSensorHTRawColor(_port, _Red, _Green, _Blue, _result) __ReadSensorHTRawColor(_port, _Red, _Green, _Blue, _result)

/**
 * Read HiTechnic Color normalized values.
 * Read the color index and the normalized red, green, and blue values from
 * the HiTechnic Color sensor. Returns a boolean value indicating whether or
 * not the operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _ColorIdx The output color index.
 * \param _Red The normalized red color value.
 * \param _Green The normalized green color value.
 * \param _Blue The normalized blue color value.
 * \param _result The function call result.
 */
#define ReadSensorHTNormalizedColor(_port, _ColorIdx, _Red, _Green, _Blue, _result) __ReadSensorHTNormalizedColor(_port, _ColorIdx, _Red, _Green, _Blue, _result)

/**
 * Read HiTechnic IRSeeker values.
 * Read direction, and five signal strength values from the HiTechnic
 * IRSeeker sensor. Returns a boolean value indicating whether or not the
 * operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _dir The direction.
 * \param _s1 The signal strength from sensor 1.
 * \param _s3 The signal strength from sensor 3.
 * \param _s5 The signal strength from sensor 5.
 * \param _s7 The signal strength from sensor 7.
 * \param _s9 The signal strength from sensor 9.
 * \param _result The function call result.
 */
#define ReadSensorHTIRSeeker(_port, _dir, _s1, _s3, _s5, _s7, _s9, _result) __ReadSensorHTIRSeeker(_port, _dir, _s1, _s3, _s5, _s7, _s9, _result)

/**
 * Read HiTechnic IRSeeker2 DC values.
 * Read direction, five signal strength, and average strength values from the
 * HiTechnic IRSeeker2 sensor. Returns a boolean value indicating whether or
 * not the operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _dir The direction.
 * \param _s1 The signal strength from sensor 1.
 * \param _s3 The signal strength from sensor 3.
 * \param _s5 The signal strength from sensor 5.
 * \param _s7 The signal strength from sensor 7.
 * \param _s9 The signal strength from sensor 9.
 * \param _avg The average signal strength.
 * \param _result The function call result.
 */
#define ReadSensorHTIRSeeker2DC(_port, _dir, _s1, _s3, _s5, _s7, _s9, _avg, _result) __ReadSensorHTIRSeeker2DC(_port, _dir, _s1, _s3, _s5, _s7, _s9, _avg, _result)

/**
 * Read HiTechnic IRSeeker2 AC values.
 * Read direction, and five signal strength values from the HiTechnic
 * IRSeeker2 sensor in AC mode. Returns a boolean value indicating whether or
 * not the operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _dir The direction.
 * \param _s1 The signal strength from sensor 1.
 * \param _s3 The signal strength from sensor 3.
 * \param _s5 The signal strength from sensor 5.
 * \param _s7 The signal strength from sensor 7.
 * \param _s9 The signal strength from sensor 9.
 * \param _result The function call result.
 */
#define ReadSensorHTIRSeeker2AC(_port, _dir, _s1, _s3, _s5, _s7, _s9, _result) __ReadSensorHTIRSeeker2AC(_port, _dir, _s1, _s3, _s5, _s7, _s9, _result)

/**
 * Set HiTechnic IRSeeker2 mode.
 * Set the mode of the HiTechnic IRSeeker2 sensor on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _mode The IRSeeker2 mode. See \ref HTIRSeeker2Constants.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define SetHTIRSeeker2Mode(_port, _mode, _result) __SetHTIRSeeker2Mode(_port, _mode, _result)

/**
 * Set HiTechnic Color2 mode.
 * Set the mode of the HiTechnic Color2 sensor on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _mode The Color2 mode. See \ref HTColor2Constants.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define SetHTColor2Mode(_port, _mode, _result) __SetHTColor2Mode(_port, _mode, _result)

/**
 * Read HiTechnic Color2 active values.
 * Read color number, red, green, and blue values from the HiTechnic Color2
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _ColorNum The output color number.
 * \param _Red The red color value.
 * \param _Green The green color value.
 * \param _Blue The blue color value.
 * \param _White The white color value.
 * \param _result The function call result.
 */
#define ReadSensorHTColor2Active(_port, _ColorNum, _Red, _Green, _Blue, _White, _result) __ReadSensorHTColor2Active(_port, _ColorNum, _Red, _Green, _Blue, _White, _result)

/**
 * Read HiTechnic Color2 normalized active values.
 * Read the color index and the normalized red, green, and blue values from
 * the HiTechnic Color2 sensor. Returns a boolean value indicating whether or
 * not the operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _ColorIdx The output color index.
 * \param _Red The normalized red color value.
 * \param _Green The normalized green color value.
 * \param _Blue The normalized blue color value.
 * \param _result The function call result.
 */
#define ReadSensorHTNormalizedColor2Active(_port, _ColorIdx, _Red, _Green, _Blue, _result) __ReadSensorHTNormalizedColor2Active(_port, _ColorIdx, _Red, _Green, _Blue, _result)

/**
 * Read HiTechnic Color2 raw values.
 * Read the raw red, green, and blue values from the HiTechnic Color2 sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _Red The raw red color value.
 * \param _Green The raw green color value.
 * \param _Blue The raw blue color value.
 * \param _White The raw white color value.
 * \param _result The function call result.
 */
#define ReadSensorHTRawColor2(_port, _Red, _Green, _Blue, _White, _result) __ReadSensorHTRawColor2(_port, _Red, _Green, _Blue, _White, _result)

/**
 * Read HiTechnic IRReceiver Power Function bytes.
 * Read Power Function bytes from the HiTechnic IRReceiver sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _pfdata Eight bytes of power function remote IR data.
 * \param _result The function call result.
 */
#define ReadSensorHTIRReceiver(_port, _pfdata, _result) __ReadSensorHTIRReceiver(_port, _pfdata, _result)

/**
 * Read HiTechnic IRReceiver Power Function value.
 * Read a Power Function byte from the HiTechnic IRReceiver sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _reg The power function data offset. See \ref HTIRReceiverConstants.
 * \param _pfchar A single byte of power function remote IR data.
 * \param _result The function call result.
 */
#define ReadSensorHTIRReceiverEx(_port, _reg, _pfchar, _result) __ReadSensorHTIRReceiverEx(_port, _reg, _pfchar, _result)

/**
 * Reset HiTechnic Angle sensor.
 * Reset the HiTechnic Angle sensor on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _mode The Angle reset mode. See \ref HTAngleConstants.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define ResetSensorHTAngle(_port, _mode, _result) __ResetSensorHTAngle(_port, _mode, _result)

/**
 * Read HiTechnic Angle sensor values.
 * Read values from the HiTechnic Angle sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _Angle Current angle in degrees (0-359).
 * \param _AccAngle Accumulated angle in degrees (-2147483648 to 2147483647).
 * \param _RPM rotations per minute (-1000 to 1000).
 * \param _result The function call result.
 */
#define ReadSensorHTAngle(_port, _Angle, _AccAngle, _RPM, _result) __ReadSensorHTAngle(_port, _Angle, _AccAngle, _RPM, _result)

/**
 * Reset HiTechnic Barometric sensor calibration.
 * Reset the HiTechnic Barometric sensor to its factory calibration.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _result The function call result.
 */
#define ResetHTBarometricCalibration(_port, _result) __ResetHTBarometricCalibration(_port, _result)

/**
 * Set HiTechnic Barometric sensor calibration.
 * Set the HiTechnic Barometric sensor pressure calibration value.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _cal The new pressure calibration value.
 * \param _result The function call result.
 */
#define SetHTBarometricCalibration(_port, _cal, _result) __SetHTBarometricCalibration(_port, _cal, _result)

/**
 * Read HiTechnic Barometric sensor values.
 * Read values from the HiTechnic Barometric sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _temp Current temperature in 1/10ths of degrees Celcius.
 * \param _press Current barometric pressure in 1/1000 inches of mercury.
 * \param _result The function call result.
 */
#define ReadSensorHTBarometric(_port, _temp, _press, _result) __ReadSensorHTBarometric(_port, _temp, _press, _result)

/**
 * Read HiTechnic Prototype board analog input value.
 * Read an analog input value from the HiTechnic prototype board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _input The analog input. See \ref HTProtoAnalogInputConstants.
 * \param _value The analog input value.
 * \param _result The function call result.
 */
#define ReadSensorHTProtoAnalog(_port, _input, _value, _result) __ReadSensorHTProtoAnalog(_port, HT_ADDR_PROTOBOARD, _input, _value, _result)

/**
 * Read all HiTechnic Prototype board analog input values.
 * Read all 5 analog input values from the HiTechnic prototype board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _a0 The A0 analog input value.
 * \param _a1 The A1 analog input value.
 * \param _a2 The A2 analog input value.
 * \param _a3 The A3 analog input value.
 * \param _a4 The A4 analog input value.
 * \param _result The function call result.
 */
#define ReadSensorHTProtoAllAnalog(_port, _a0, _a1, _a2, _a3, _a4, _result) __ReadSensorHTProtoAllAnalog(_port, _a0, _a1, _a2, _a3, _a4, _result)

/**
 * Set HiTechnic Prototype board digital pin direction.
 * Set which of the six digital pins on the HiTechnic prototype board should be outputs.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The digital pin control value. See \ref DigitalPinConstants.
 * OR into this value the pins that you want to be output pins.  The pins not
 * included in the value will be input pins.
 * \param _result The function call result.
 */
#define SetSensorHTProtoDigitalControl(_port, _value, _result) __SetSensorHTProtoDigitalControl(_port, HT_ADDR_PROTOBOARD, _value, _result)

/**
 * Read HiTechnic Prototype board digital pin control value.
 * Read the HiTechnic prototype board digital control value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _out The digital control value. See \ref LEDCtrlConstants.
 * \param _result The function call result.
 */
#define ReadSensorHTProtoDigitalControl(_port, _out, _result) __MSReadValue(_port, HT_ADDR_PROTOBOARD, HTPROTO_REG_DCTRL, 1, _out, _result)

/**
 * Set HiTechnic Prototype board digital output values.
 * Set the digital pin output values on the HiTechnic prototype board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The digital pin output values. See \ref DigitalPinConstants.
 * \param _result The function call result.
 */
#define SetSensorHTProtoDigital(_port, _value, _result) __SetSensorHTProtoDigital(_port, HT_ADDR_PROTOBOARD, _value, _result)

/**
 * Read HiTechnic Prototype board digital input values.
 * Read digital input values from the HiTechnic prototype board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The digital input values. See \ref DigitalPinConstants.
 * \param _result The function call result.
 */
#define ReadSensorHTProtoDigital(_port, _value, _result) __ReadSensorHTProtoDigital(_port, HT_ADDR_PROTOBOARD, _value, _result)

/**
 * Read HiTechnic SuperPro board analog input value.
 * Read an analog input value from the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _input The analog input. See \ref HTSProAnalogInputConstants.
 * \param _value The analog input value.
 * \param _result The function call result.
 */
#define ReadSensorHTSuperProAnalog(_port, _input, _value, _result) __ReadSensorHTProtoAnalog(_port, HT_ADDR_SUPERPRO, _input, _value, _result)

/**
 * Read all HiTechnic SuperPro board analog input values.
 * Read all 4 analog input values from the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _a0 The A0 analog input value.
 * \param _a1 The A1 analog input value.
 * \param _a2 The A2 analog input value.
 * \param _a3 The A3 analog input value.
 * \param _result The function call result.
 */
#define ReadSensorHTSuperProAllAnalog(_port, _a0, _a1, _a2, _a3, _result) __ReadSensorHTSuperProAllAnalog(_port, _a0, _a1, _a2, _a3, _result)

/**
 * Control HiTechnic SuperPro board digital pin direction.
 * Control the direction of the eight digital pins on the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The digital pin control value. See \ref DigitalPinConstants.
 * OR into this value the pins that you want to be output pins.  The pins not
 * included in the value will be input pins.
 * \param _result The function call result.
 */
#define SetSensorHTSuperProDigitalControl(_port, _value, _result) __SetSensorHTProtoDigitalControl(_port, HT_ADDR_SUPERPRO, _value, _result)

/**
 * Read HiTechnic SuperPro digital control value.
 * Read the HiTechnic SuperPro digital control value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _out The digital control value. See \ref LEDCtrlConstants.
 * \param _result The function call result.
 */
#define ReadSensorHTSuperProDigitalControl(_port, _out, _result) __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_DCTRL, 1, _out, _result)

/**
 * Set HiTechnic SuperPro board digital output values.
 * Set the digital pin output values on the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The digital pin output values. See \ref DigitalPinConstants.
 * \param _result The function call result.
 */
#define SetSensorHTSuperProDigital(_port, _value, _result) __SetSensorHTProtoDigital(_port, HT_ADDR_SUPERPRO, _value, _result)

/**
 * Read HiTechnic SuperPro board digital input values.
 * Read digital input values from the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The digital input values. See \ref DigitalPinConstants.
 * \param _result The function call result.
 */
#define ReadSensorHTSuperProDigital(_port, _value, _result) __ReadSensorHTProtoDigital(_port, HT_ADDR_SUPERPRO, _value, _result)

/**
 * Set HiTechnic SuperPro board analog output parameters.
 * Set the analog output parameters on the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _dac The analog output index. See \ref HTSProDACIndexConstants.
 * \param _mode The analog output mode. See \ref DacModeConstants.
 * \param _freq The analog output frequency. Between 1 and 8191.
 * \param _volt The analog output voltage level. A 10 bit value (0..1023).
 * \param _result The function call result.
 */
#define SetSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt, _result) __SetSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt, _result)

/**
 * Read HiTechnic SuperPro board analog output parameters.
 * Read the analog output parameters on the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _dac The analog output index. See \ref HTSProDACIndexConstants.
 * \param _mode The analog output mode. See \ref DacModeConstants.
 * \param _freq The analog output frequency. Between 1 and 8191.
 * \param _volt The analog output voltage level. A 10 bit value (0..1023).
 * \param _result The function call result.
 */
#define ReadSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt, _result) __ReadSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt, _result)

/**
 * Set HiTechnic SuperPro LED value.
 * Set the HiTechnic SuperPro LED value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The LED value. See \ref LEDCtrlConstants.
 * \param _result The function call result.
 */
#define SetSensorHTSuperProLED(_port, _value, _result) __SetSensorHTSuperProLED(_port, _value, _result)

/**
 * Read HiTechnic SuperPro LED value.
 * Read the HiTechnic SuperPro LED value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _out The LED value. See \ref LEDCtrlConstants.
 * \param _result The function call result.
 */
#define ReadSensorHTSuperProLED(_port, _out, _result) __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_LED, 1, _out, _result)

/**
 * Set HiTechnic SuperPro strobe value.
 * Set the HiTechnic SuperPro strobe value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The strobe value. See \ref StrobeCtrlConstants.
 * \param _result The function call result.
 */
#define SetSensorHTSuperProStrobe(_port, _value, _result) __SetSensorHTSuperProStrobe(_port, _value, _result)

/**
 * Read HiTechnic SuperPro strobe value.
 * Read the HiTechnic SuperPro strobe value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _out The strobe value. See \ref StrobeCtrlConstants.
 * \param _result The function call result.
 */
#define ReadSensorHTSuperProStrobe(_port, _out, _result) __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_STROBE, 1, _out, _result)

/**
 * Set HiTechnic SuperPro program control value.
 * Set the HiTechnic SuperPro program control value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The program control value.
 * \param _result The function call result.
 */
#define SetSensorHTSuperProProgramControl(_port, _value, _result) __SetSensorHTSuperProProgramControl(_port, _value, _result)

/**
 * Read HiTechnic SuperPro program control value.
 * Read the HiTechnic SuperPro program control value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _out The program control value.
 * \param _result The function call result.
 */
#define ReadSensorHTSuperProProgramControl(_port, _out, _result) __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_CTRL, 1, _out, _result)


/** @} */ // end of HiTechnicAPI group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MindSensors API ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup MindSensorsAPI
 * @{
 */

/**
 * Read mindsensors compass value.
 * Return the Mindsensors Compass sensor value.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The mindsensors compass value
 */
#define ReadSensorMSCompass(_port, _i2caddr, _value) __ReadSensorMSCompass(_port, _i2caddr, _value)

/**
 * Read mindsensors DROD value.
 * Return the Mindsensors DROD sensor value.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The mindsensors DROD value
 */
#define ReadSensorMSDROD(_port, _value) __ReadSensorMSDROD(_port, _value)

/**
 * Configure a mindsensors DROD active sensor.
 * Configure the specified port for an active mindsensors DROD sensor.
 *
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorMSDRODActive(_port) __SetSensorMSDRODActive(_port)

/**
 * Configure a mindsensors DROD inactive sensor.
 * Configure the specified port for an inactive mindsensors DROD sensor.
 *
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorMSDRODInactive(_port) __SetSensorMSDRODInactive(_port)

/**
 * Read mindsensors NXTSumoEyes value.
 * Return the Mindsensors NXTSumoEyes sensor value.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The mindsensors NXTSumoEyes value
 */
#define ReadSensorNXTSumoEyes(_port, _value) __ReadSensorNXTSumoEyes(_port, _value)

/**
 * Configure a mindsensors NXTSumoEyes long range sensor.
 * Configure the specified port for a long range mindsensors NXTSumoEyes sensor.
 *
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorNXTSumoEyesLong(_port) __SetSensorNXTSumoEyesLong(_port)

/**
 * Configure a mindsensors NXTSumoEyes short range sensor.
 * Configure the specified port for a short range mindsensors NXTSumoEyes sensor.
 *
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorNXTSumoEyesShort(_port) __SetSensorNXTSumoEyesShort(_port)

/**
 * Read mindsensors raw pressure value.
 * Return the Mindsensors pressure sensor raw value.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The mindsensors raw pressure value
 */
#define ReadSensorMSPressureRaw(_port, _value) __ReadSensorMSPressureRaw(_port, _value)

/**
 * Read mindsensors processed pressure value.
 * Return the Mindsensors pressure sensor processed value.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _value The mindsensors processed pressure value
 */
#define ReadSensorMSPressure(_port, _value) __ReadSensorMSPressure(_port, _value)

/**
 * Configure a mindsensors pressure sensor.
 * Configure the specified port for a mindsensors pressure sensor.
 *
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorMSPressure(_port) __SetSensorMSPressure(_port)

/**
 * Configure a mindsensors touch sensor multiplexer.
 * Configure the specified port for a mindsensors touch sensor multiplexer.
 *
 * \param _port The port to configure. See \ref NBCInputPortConstants.
 */
#define SetSensorMSTouchMux(_port) __SetSensorMSTouchMux(_port)

/**
 * Read mindsensors acceleration values.
 * Read X, Y, and Z axis acceleration values from the mindsensors Accelerometer
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _x The output x-axis acceleration.
 * \param _y The output y-axis acceleration.
 * \param _z The output z-axis acceleration.
 * \param _result The function call result.
 */
#define ReadSensorMSAccel(_port, _i2caddr, _x, _y, _z, _result) __ReadSensorMSAccel(_port, _i2caddr, _x, _y, _z, _result)

/**
 * Read mindsensors playstation controller values.
 * Read playstation controller values from the mindsensors playstation
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _b1 The button set 1 values. See \ref MSPSPNXBtnSet1.
 * \param _b2 The button set 2 values. See \ref MSPSPNXBtnSet2.
 * \param _xleft The left joystick x value.
 * \param _yleft The left joystick y value.
 * \param _xright The right joystick x value.
 * \param _yright The right joystick y value.
 * \param _result The function call result.
 */
#define ReadSensorMSPlayStation(_port, _i2caddr, _b1, _b2, _xleft, _yleft, _xright, _yright, _result) \
  __ReadSensorMSPlayStation(_port, _i2caddr, _b1, _b2, _xleft, _yleft, _xright, _yright, _result)

/**
 * Read mindsensors RTClock values.
 * Read real-time clock values from the Mindsensors RTClock sensor. Returns
 * a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _sec The seconds.
 * \param _min The minutes.
 * \param _hrs The hours.
 * \param _dow The day of week number.
 * \param _date The day.
 * \param _month The month.
 * \param _year The year.
 * \param _result The function call result.
 */
#define ReadSensorMSRTClock(_port, _sec, _min, _hrs, _dow, _date, _month, _year, _result) \
  __ReadSensorMSRTClock(_port, _sec, _min, _hrs, _dow, _date, _month, _year, _result)

/**
 * Read mindsensors tilt values.
 * Read X, Y, and Z axis tilt values from the mindsensors tilt
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _x The output x-axis tilt.
 * \param _y The output y-axis tilt.
 * \param _z The output z-axis tilt.
 * \param _result The function call result.
 */
#define ReadSensorMSTilt(_port, _i2caddr, _x, _y, _z, _result) __ReadSensorMSTilt(_port, _i2caddr, _x, _y, _z, _result)

/**
 * Send PFMate command.
 * Send a PFMate command to the power function IR receiver.
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The power function IR receiver channel. See the \ref PFMateChannelConstants group.
 * \param _motors The motor(s) to control. See the \ref PFMateMotorConstants group.
 * \param _cmdA The power function command for motor A. See the \ref PFCmdConstants group.
 * \param _spdA The power function speed for motor A.
 * \param _cmdB The power function command for motor B. See the \ref PFCmdConstants group.
 * \param _spdB The power function speed for motor B.
 * \param _result The function call result.
 */
#define PFMateSend(_port, _i2caddr, _channel, _motors, _cmdA, _spdA, _cmdB, _spdB, _result) __PFMateSend(_port, _i2caddr, _channel, _motors, _cmdA, _spdA, _cmdB, _spdB, _result)

/**
 * Send raw PFMate command.
 * Send a raw PFMate command to the power function IR receiver.
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The power function IR receiver channel. See the \ref PFMateChannelConstants group.
 * \param _b1 Raw byte 1.
 * \param _b2 Raw byte 2.
 * \param _result The function call result.
 */
#define PFMateSendRaw(_port, _i2caddr, _channel, _b1, _b2, _result) __PFMateSendRaw(_port, _i2caddr, _channel, _b1, _b2, _result)

/**
 * Read a mindsensors device value.
 * Read a one, two, or four byte value from a mindsensors sensor. The value must be
 * stored with the least signficant byte (LSB) first (i.e., little endian). Returns a boolean value
 * indicating whether or not the operation completed successfully. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _reg The device register to read.
 * \param _bytes The number of bytes to read. Only 1, 2, or 4 byte values are supported.
 * \param _out The value read from the device.
 * \param _result The function call result.
 */
#define MSReadValue(_port, _i2caddr, _reg, _bytes, _out, _result) __MSReadValue(_port, _i2caddr, _reg, _bytes, _out, _result)

/**
 * Turn on power to device.
 * Turn the power on for the mindsensors device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define MSEnergize(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, MS_CMD_ENERGIZED, _result)

/**
 * Turn off power to device.
 * Turn power off for the mindsensors device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define MSDeenergize(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, MS_CMD_DEENERGIZED, _result)

/**
 * Turn on mindsensors ADPA mode.
 * Turn ADPA mode on for the mindsensors device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define MSADPAOn(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, MS_CMD_ADPA_ON, _result)

/**
 * Turn off mindsensors ADPA mode.
 * Turn ADPA mode off for the mindsensors device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define MSADPAOff(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, MS_CMD_ADPA_OFF, _result)

/**
 * Configure DIST-Nx as GP2D12.
 * Configure the mindsensors DIST-Nx sensor as GP2D12. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define DISTNxGP2D12(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, DIST_CMD_GP2D12, _result)

/**
 * Configure DIST-Nx as GP2D120.
 * Configure the mindsensors DIST-Nx sensor as GP2D120. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define DISTNxGP2D120(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, DIST_CMD_GP2D120, _result)

/**
 * Configure DIST-Nx as GP2YA02.
 * Configure the mindsensors DIST-Nx sensor as GP2YA02. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define DISTNxGP2YA02(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, DIST_CMD_GP2YA02, _result)

/**
 * Configure DIST-Nx as GP2YA21.
 * Configure the mindsensors DIST-Nx sensor as GP2YA21. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define DISTNxGP2YA21(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, DIST_CMD_GP2YA21, _result)

/**
 * Read DIST-Nx distance value.
 * Read the mindsensors DIST-Nx sensor's distance value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The distance value.
 * \param _result The function call result.
 */
#define ReadDISTNxDistance(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, DIST_REG_DIST, 2, _out, _result)

/**
 * Read DIST-Nx maximum distance value.
 * Read the mindsensors DIST-Nx sensor's maximum distance value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The maximum distance value.
 * \param _result The function call result.
 */
#define ReadDISTNxMaxDistance(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, DIST_REG_DIST_MAX, 2, _out, _result)

/**
 * Read DIST-Nx minimum distance value.
 * Read the mindsensors DIST-Nx sensor's minimum distance value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The minimum distance value.
 * \param _result The function call result.
 */
#define ReadDISTNxMinDistance(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, DIST_REG_DIST_MIN, 2, _out, _result)

/**
 * Read DIST-Nx module type value.
 * Read the mindsensors DIST-Nx sensor's module type value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The module type value.
 * \param _result The function call result.
 */
#define ReadDISTNxModuleType(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, DIST_REG_MODULE_TYPE, 1, _out, _result)

/**
 * Read DIST-Nx num points value.
 * Read the mindsensors DIST-Nx sensor's num points value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The num points value.
 * \param _result The function call result.
 */
#define ReadDISTNxNumPoints(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, DIST_REG_NUM_POINTS, 1, _out, _result)

/**
 * Read DIST-Nx voltage value.
 * Read the mindsensors DIST-Nx sensor's voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The voltage value.
 * \param _result The function call result.
 */
#define ReadDISTNxVoltage(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, DIST_REG_VOLT, 2, _out, _result)

/**
 * Calibrate ACCL-Nx X-axis.
 * Calibrate the mindsensors ACCL-Nx sensor X-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define ACCLNxCalibrateX(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, ACCL_CMD_X_CAL, _result)

/**
 * Stop calibrating ACCL-Nx X-axis.
 * Stop calibrating the mindsensors ACCL-Nx sensor X-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define ACCLNxCalibrateXEnd(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, ACCL_CMD_X_CAL_END, _result)

/**
 * Calibrate ACCL-Nx Y-axis.
 * Calibrate the mindsensors ACCL-Nx sensor Y-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define ACCLNxCalibrateY(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, ACCL_CMD_Y_CAL, _result)

/**
 * Stop calibrating ACCL-Nx Y-axis.
 * Stop calibrating the mindsensors ACCL-Nx sensor Y-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define ACCLNxCalibrateYEnd(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, ACCL_CMD_Y_CAL_END, _result)

/**
 * Calibrate ACCL-Nx Z-axis.
 * Calibrate the mindsensors ACCL-Nx sensor Z-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define ACCLNxCalibrateZ(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, ACCL_CMD_Z_CAL, _result)

/**
 * Stop calibrating ACCL-Nx Z-axis.
 * Stop calibrating the mindsensors ACCL-Nx sensor Z-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define ACCLNxCalibrateZEnd(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, ACCL_CMD_Z_CAL_END, _result)

/**
 * Reset ACCL-Nx calibration.
 * Reset the mindsensors ACCL-Nx sensor calibration to factory settings. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define ACCLNxResetCalibration(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, ACCL_CMD_RESET_CAL, _result)

/**
 * Set ACCL-Nx sensitivity.
 * Reset the mindsensors ACCL-Nx sensor calibration to factory settings. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _slevel The sensitivity level. See \ref MSACCLNxSLevel.
 * \param _result The function call result.
 */
#define SetACCLNxSensitivity(_port, _i2caddr, _slevel, _result) __I2CSendCmd(_port, _i2caddr, _slevel, _result)

/**
 * Read ACCL-Nx sensitivity value.
 * Read the mindsensors ACCL-Nx sensitivity value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The sensitivity value.
 * \param _result The function call result.
 */
#define ReadACCLNxSensitivity(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, ACCL_REG_sENS_LVL, 1, _out, _result)

/**
 * Read ACCL-Nx X offset value.
 * Read the mindsensors ACCL-Nx sensor's X offset value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The X offset value.
 * \param _result The function call result.
 */
#define ReadACCLNxXOffset(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, ACCL_REG_X_OFFSET, 2, _out, _result)

/**
 * Read ACCL-Nx X range value.
 * Read the mindsensors ACCL-Nx sensor's X range value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The X range value.
 * \param _result The function call result.
 */
#define ReadACCLNxXRange(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, ACCL_REG_X_RANGE, 2, _out, _result)

/**
 * Read ACCL-Nx Y offset value.
 * Read the mindsensors ACCL-Nx sensor's Y offset value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The Y offset value.
 * \param _result The function call result.
 */
#define ReadACCLNxYOffset(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, ACCL_REG_Y_OFFSET, 2, _out, _result)

/**
 * Read ACCL-Nx Y range value.
 * Read the mindsensors ACCL-Nx sensor's Y range value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The Y range value.
 * \param _result The function call result.
 */
#define ReadACCLNxYRange(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, ACCL_REG_Y_RANGE, 2, _out, _result)

/**
 * Read ACCL-Nx Z offset value.
 * Read the mindsensors ACCL-Nx sensor's Z offset value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The Z offset value.
 * \param _result The function call result.
 */
#define ReadACCLNxZOffset(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, ACCL_REG_Z_OFFSET, 2, _out, _result)

/**
 * Read ACCL-Nx Z range value.
 * Read the mindsensors ACCL-Nx sensor's Z range value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The Z range value.
 * \param _result The function call result.
 */
#define ReadACCLNxZRange(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, ACCL_REG_Z_RANGE, 2, _out, _result)

/**
 * Configure PSP-Nx in digital mode.
 * Configure the mindsensors PSP-Nx device in digital mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define PSPNxDigital(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, PSP_CMD_DIGITAL, _result)

/**
 * Configure PSP-Nx in analog mode.
 * Configure the mindsensors PSP-Nx device in analog mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define PSPNxAnalog(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, PSP_CMD_ANALOG, _result)

/**
 * Read NXTServo servo position value.
 * Read the mindsensors NXTServo device's servo position value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _servo The servo number. See \ref NXTServoNumbers group.
 * \param _out The specified servo's position value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTServoPosition(_port, _i2caddr, _servo, _out, _result) __MSReadValue(_port, _i2caddr, NXTSERVO_REG_S1_POS+(_servo*2), 2, _out, _result)

/**
 * Read NXTServo servo speed value.
 * Read the mindsensors NXTServo device's servo speed value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _servo The servo number. See \ref NXTServoNumbers group.
 * \param _out The specified servo's speed value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTServoSpeed(_port, _i2caddr, _servo, _out, _result) __MSReadValue(_port, _i2caddr, NXTSERVO_REG_S1_SPEED+_servo, 1, _out, _result)

/**
 * Read NXTServo battery voltage value.
 * Read the mindsensors NXTServo device's battery voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTServo battery voltage.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTServoBatteryVoltage(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTSERVO_REG_VOLTAGE, 1, _out, _result)

/**
 * Set NXTServo servo motor speed.
 * Set the speed of a servo motor controlled by the NXTServo device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _servo The servo number. See \ref NXTServoNumbers group.
 * \param _speed The servo speed. (0..255)
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTServoSpeed(_port, _i2caddr, _servo, _speed, _result) __MSWriteToRegister(_port, _i2caddr, NXTSERVO_REG_S1_SPEED+_servo, _speed, _result)

/**
 * Set NXTServo servo motor quick position.
 * Set the quick position of a servo motor controlled by the NXTServo device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _servo The servo number. See \ref NXTServoNumbers group.
 * \param _qpos The servo quick position. See \ref NXTServoQPos group.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTServoQuickPosition(_port, _i2caddr, _servo, _qpos, _result) __MSWriteToRegister(_port, _i2caddr, NXTSERVO_REG_S1_QPOS+_servo, _qpos, _result)

/**
 * Set NXTServo servo motor position.
 * Set the position of a servo motor controlled by the NXTServo device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _servo The servo number. See \ref NXTServoNumbers group.
 * \param _pos The servo position. See \ref NXTServoPos group.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTServoPosition(_port, _i2caddr, _servo, _pos, _result) __MSWriteLEIntToRegister(_port, _i2caddr, _reg, _pos, _result)

/**
 * Reset NXTServo properties.
 * Reset NXTServo device properties to factory defaults.
 * Initial position = 1500.  Initial speed = 0. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTServoReset(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_RESET, _result)

/**
 * Halt NXTServo macro.
 * Halt a macro executing on the NXTServo device. This command re-initializes
 * the macro environment.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTServoHaltMacro(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_HALT, _result)

/**
 * Resume NXTServo macro.
 * Resume a macro executing on the NXTServo device. This command resumes
 * executing a macro where it was paused last, using the same environment.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTServoResumeMacro(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_RESUME, _result)

/**
 * Pause NXTServo macro.
 * Pause a macro executing on the NXTServo device. This command will pause the
 * currently executing macro, and save the environment for subsequent resumption.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTServoPauseMacro(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_PAUSE, _result)

/**
 * Initialize NXTServo servo properties.
 * Store the initial speed and position properties of the servo motor 'n'.
 * Current speed and position values of the nth servo is read from the
 * servo speed register and servo position register and written to permanent
 * memory.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _servo The servo number. See \ref NXTServoNumbers group.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTServoInit(_port, _i2caddr, _servo, _result) __NXTServoInit(_port, _i2caddr, _servo, _result)

/**
 * Goto NXTServo macro address.
 * Run the macro found at the specified EEPROM macro address. This command
 * re-initializes the macro environment.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _macro The EEPROM macro address.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTServoGotoMacroAddress(_port, _i2caddr, _macro, _result) __NXTServoGotoMacroAddress(_port, _i2caddr, _macro, _result)

/**
 * Edit NXTServo macro.
 * Put the NXTServo device into macro edit mode. This operation changes the
 * I2C address of the device to 0x40.  Macros are written to EEPROM addresses
 * between 0x21 and 0xFF. Use \ref NXTServoQuitEdit to return the device to
 * its normal operation mode.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTServoEditMacro(_port, _i2caddr, _result) __NXTServoEditMacro(_port, _i2caddr, _result)

/**
 * Quit NXTServo macro edit mode.
 * Stop editing NXTServo device macro EEPROM memory. Use \ref NXTServoEditMacro
 * to start editing a macro.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTServoQuitEdit(_port, _result) __MSWriteToRegister(_port, MS_ADDR_NXTSERVO_EM, NXTSERVO_EM_REG_CMD, NXTSERVO_EM_CMD_QUIT, _result)

/**
 * Set NXTHID into ASCII data mode.
 * Set the NXTHID device into ASCII data mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTHIDAsciiMode(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTHID_CMD_ASCII, _result)

/**
 * Set NXTHID into direct data mode.
 * Set the NXTHID device into direct data mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTHIDDirectMode(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTHID_CMD_DIRECT, _result)

/**
 * Transmit NXTHID character.
 * Transmit a single character to a computer using the NXTHID device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTHIDTransmit(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTHID_CMD_TRANSMIT, _result)

/**
 * Load NXTHID character.
 * Load a character into the NXTHID device.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _modifier The key modifier.
 * \param _character The character.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTHIDLoadCharacter(_port, _i2caddr, _modifier, _character, _result) __NXTHIDLoadCharacter(_port, _i2caddr, _modifier, _character, _result)

/**
 * Reset NXTPowerMeter counters.
 * Reset the NXTPowerMeter counters back to zero. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTPowerMeterResetCounters(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTPM_CMD_RESET, _result)

/**
 * Read NXTPowerMeter present current.
 * Read the mindsensors NXTPowerMeter device's present current value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter present current.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterPresentCurrent(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_CURRENT, 2, _out, _result)

/**
 * Read NXTPowerMeter present voltage.
 * Read the mindsensors NXTPowerMeter device's present voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter present voltage.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterPresentVoltage(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_VOLTAGE, 2, _out, _result)

/**
 * Read NXTPowerMeter capacity used.
 * Read the mindsensors NXTPowerMeter device's capacity used since the last reset command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter capacity used value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterCapacityUsed(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_CAPACITY, 2, _out, _result)

/**
 * Read NXTPowerMeter present power.
 * Read the mindsensors NXTPowerMeter device's present power value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter present power value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterPresentPower(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_POWER, 2, _out, _result)

/**
 * Read NXTPowerMeter total power consumed.
 * Read the mindsensors NXTPowerMeter device's total power consumed since the last reset command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter total power consumed value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterTotalPowerConsumed(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_POWER, 4, _out, _result)

/**
 * Read NXTPowerMeter maximum current.
 * Read the mindsensors NXTPowerMeter device's maximum current value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter maximum current value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterMaxCurrent(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_MAXCURRENT, 2, _out, _result)

/**
 * Read NXTPowerMeter minimum current.
 * Read the mindsensors NXTPowerMeter device's minimum current value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter minimum current value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterMinCurrent(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_MINCURRENT, 2, _out, _result)

/**
 * Read NXTPowerMeter maximum voltage.
 * Read the mindsensors NXTPowerMeter device's maximum voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter maximum voltage value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterMaxVoltage(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_MAXVOLTAGE, 2, _out, _result)

/**
 * Read NXTPowerMeter minimum voltage.
 * Read the mindsensors NXTPowerMeter device's minimum voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter minimum voltage value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterMinVoltage(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_MINVOLTAGE, 2, _out, _result)

/**
 * Read NXTPowerMeter elapsed time.
 * Read the mindsensors NXTPowerMeter device's elapsed time since the last reset command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter elapsed time value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterElapsedTime(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_TIME, 4, _out, _result)

/**
 * Read NXTPowerMeter error count.
 * Read the mindsensors NXTPowerMeter device's error count value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTPowerMeter error count value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTPowerMeterErrorCount(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTPM_REG_ERRORCOUNT, 2, _out, _result)

/**
 * Powerdown NXTLineLeader device.
 * Put the NXTLineLeader to sleep so that it does not consume power when it is
 * not required. The device wakes up on its own when any I2C communication
 * happens or you can specifically wake it up by using the \ref NXTLineLeaderPowerUp
 * command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTLineLeaderPowerDown(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_POWERDOWN, _result)

/**
 * Powerup NXTLineLeader device.
 * Wake up the NXTLineLeader device so that it can be used. The device can be
 * put to sleep using the \ref NXTLineLeaderPowerDown command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTLineLeaderPowerUp(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_POWERUP, _result)

/**
 * Invert NXTLineLeader colors.
 * Invert color sensing so that the device can detect a white line on a
 * black background.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTLineLeaderInvert(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_INVERT, _result)

/**
 * Reset NXTLineLeader color inversion.
 * Reset the NXTLineLeader color detection back to its default state (black
 * line on a white background).
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTLineLeaderReset(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_RESET, _result)

/**
 * Take NXTLineLeader line snapshot.
 * Takes a snapshot of the line under the sensor and tracks that position in
 * subsequent tracking operations.  This function also will set color inversion
 * if it sees a white line on a black background.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTLineLeaderSnapshot(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_SNAPSHOT, _result)

/**
 * Calibrate NXTLineLeader white color.
 * Store calibration data for the white color.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTLineLeaderCalibrateWhite(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_WHITE, _result)

/**
 * Calibrate NXTLineLeader black color.
 * Store calibration data for the black color.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define NXTLineLeaderCalibrateBlack(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_BLACK, _result)

/**
 * Read NXTLineLeader steering.
 * Read the mindsensors NXTLineLeader device's steering value. This is the power
 * returned by the sensor to correct your course.  Add this value to your left
 * motor and subtract it from your right motor.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTLineLeader steering value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTLineLeaderSteering(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTLL_REG_STEERING, 1, _out, _result)

/**
 * Read NXTLineLeader average.
 * Read the mindsensors NXTLineLeader device's average value. The
 * average is a weighted average of the bits set to 1 based on the position.
 * The left most bit has a weight of 10, second bit has a weight of 20, and so
 * forth. When all 8 sensors are over a black surface the average will be 45.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTLineLeader average value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTLineLeaderAverage(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTLL_REG_AVERAGE, 1, _out, _result)

/**
 * Read NXTLineLeader result.
 * Read the mindsensors NXTLineLeader device's result value. This is a single
 * byte showing the 8 sensor's readings. Each bit corresponding to the sensor
 * where the line is seen is set to 1, otherwise it is set to 0.
 * When all 8 sensors are over a black surface the result will be 255 (b11111111).
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _out The NXTLineLeader result value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define ReadNXTLineLeaderResult(_port, _i2caddr, _out, _result) __MSReadValue(_port, _i2caddr, NXTLL_REG_RESULT, 1, _out, _result)

/**
 * Write NXTLineLeader setpoint.
 * Write a new setpoint value to the NXTLineLeader device. The Set Point is a
 * value you can ask sensor to maintain the average to. The default value is
 * 45, whereby the line is maintained in center of the sensor. If you need to
 * maintain line towards left of the sensor, set the Set Point to
 * a lower value (minimum: 10). If you need it to be towards on the right of the
 * sensor, set it to higher value (maximum: 80). Set point is also useful while
 * tracking an edge of dark and light areas.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The new setpoint value (10..80).
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTLineLeaderSetpoint(_port, _i2caddr, _value, _result) __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_SETPOINT, _value, _result)

/**
 * Write NXTLineLeader Kp value.
 * Write a Kp value to the NXTLineLeader device. This value divided by PID
 * Factor for Kp is the Proportional value for the PID control. Suggested value
 * is 25 with a divisor factor of 32 (which is also a factory default), start
 * with this value, and tune it to meet your needs. Value ranges
 * between 0 and 255.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The new Kp value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTLineLeaderKpValue(_port, _i2caddr, _value, _result) __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KP_VALUE, _value, _result)

/**
 * Write NXTLineLeader Ki value.
 * Write a Ki value to the NXTLineLeader device. This value divided by PID
 * Factor for Ki is the Integral value for the PID control. Suggested value
 * is 0 with a divisor factor of 32 (which is also a factory default), start
 * with this value, and tune it to meet your needs. Value ranges
 * between 0 and 255.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The new Ki value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTLineLeaderKiValue(_port, _i2caddr, _value, _result) __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KI_VALUE, _value, _result)

/**
 * Write NXTLineLeader Kd value.
 * Write a Kd value to the NXTLineLeader device. This value divided by PID
 * Factor for Kd is the Derivative value for the PID control. Suggested value
 * is 8 with a divisor factor of 32 (which is also a factory default), start
 * with this value, and tune it to meet your needs. Value ranges
 * between 0 and 255.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The new Kd value.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTLineLeaderKdValue(_port, _i2caddr, _value, _result) __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KD_VALUE, _value, _result)

/**
 * Write NXTLineLeader Kp factor.
 * Write a Kp divisor factor to the NXTLineLeader device. Value ranges between
 * 1 and 255. Change this value if you need more granularities in Kp value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The new Kp factor.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTLineLeaderKpFactor(_port, _i2caddr, _value, _result) __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KP_FACTOR, _value, _result)

/**
 * Write NXTLineLeader Ki factor.
 * Write a Ki divisor factor to the NXTLineLeader device. Value ranges between
 * 1 and 255. Change this value if you need more granularities in Ki value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The new Ki factor.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTLineLeaderKiFactor(_port, _i2caddr, _value, _result) __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KI_FACTOR, _value, _result)

/**
 * Write NXTLineLeader Kd factor.
 * Write a Kd divisor factor to the NXTLineLeader device. Value ranges between
 * 1 and 255. Change this value if you need more granularities in Kd value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The new Kd factor.
 * \param _result A status code indicating whether the operation completed successfully or not.
 * See \ref TCommLSCheckStatus for possible Result values.
 */
#define SetNXTLineLeaderKdFactor(_port, _i2caddr, _value, _result) __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KD_FACTOR, _value, _result)

/**
 * Configure NRLink in 2400 baud mode.
 * Configure the mindsensors NRLink device in 2400 baud mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLink2400(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_2400, _result)

/**
 * Configure NRLink in 4800 baud mode.
 * Configure the mindsensors NRLink device in 4800 baud mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLink4800(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_4800, _result)

/**
 * Flush NRLink buffers.
 * Flush the mindsensors NRLink device buffers. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLinkFlush(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_FLUSH, _result)

/**
 * Configure NRLink in IR long mode.
 * Configure the mindsensors NRLink device in IR long mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLinkIRLong(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_IR_LONG, _result)

/**
 * Configure NRLink in IR short mode.
 * Configure the mindsensors NRLink device in IR short mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLinkIRShort(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_IR_SHORT, _result)

/**
 * Configure NRLink in power function mode.
 * Configure the mindsensors NRLink device in power function mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLinkSetPF(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_SET_PF, _result)

/**
 * Configure NRLink in RCX mode.
 * Configure the mindsensors NRLink device in RCX mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLinkSetRCX(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_SET_RCX, _result)

/**
 * Configure NRLink in IR train mode.
 * Configure the mindsensors NRLink device in IR train mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLinkSetTrain(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_SET_TRAIN, _result)

/**
 * Configure NRLink in raw IR transmit mode.
 * Configure the mindsensors NRLink device in raw IR transmit mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _result The function call result.
 */
#define NRLinkTxRaw(_port, _i2caddr, _result) __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_TX_RAW, _result)

/**
 * Read NRLink status.
 * Read the status of the mindsensors NRLink device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _value The mindsensors NRLink status.
 * \param _result The function call result.
 */
#define ReadNRLinkStatus(_port, _i2caddr, _value, _result) __ReadNRLinkStatus(_port, _i2caddr, _value, _result)

/**
 * Run NRLink macro.
 * Run the specified mindsensors NRLink device macro. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _macro The address of the macro to execute.
 * \param _result The function call result.
 */
#define RunNRLinkMacro(_port, _i2caddr, _macro, _result) __RunNRLinkMacro(_port, _i2caddr, _macro, _result)

/**
 * Write data to NRLink.
 * Write data to the mindsensors NRLink device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _bytes A byte array containing the data to write.
 * \param _result The function call result.
 */
#define WriteNRLinkBytes(_port, _i2caddr, _bytes, _result) __WriteNRLinkBytes(_port, _i2caddr, _bytes, _result)

/**
 * Read data from NRLink.
 * Read data from the mindsensors NRLink device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _bytes A byte array that will contain the data read from the device on output.
 * \param _result The function call result.
 */
#define ReadNRLinkBytes(_port, _i2caddr, _bytes, _result) __ReadNRLinkBytes(_port, _i2caddr, _bytes, _result)

/**
 * MSIRTrain function.
 * Control an IR Train receiver set to the specified channel using the
 * mindsensors NRLink device. Valid function values are \ref TRAIN_FUNC_STOP,
 * \ref TRAIN_FUNC_INCR_SPEED, \ref TRAIN_FUNC_DECR_SPEED, and \ref TRAIN_FUNC_TOGGLE_LIGHT.
 * Valid channels are \ref TRAIN_CHANNEL_1 through \ref TRAIN_CHANNEL_3 and
 * \ref TRAIN_CHANNEL_ALL. The port must be configured as a Lowspeed port before
 * using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The IR Train channel.  See \ref IRTrainChannels.
 * \param _func The IR Train function. See \ref IRTrainFuncs
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSIRTrain(_port, _i2caddr, _channel, _func, _result) \
  __MSIRTrain(_port, _i2caddr, _channel, _func, FALSE, _result)

/**
 * MSPFComboDirect function.
 * Execute a pair of Power Function motor commands on the specified channel
 * using the mindsensors NRLink device. Commands for outa and outb are
 * PF_CMD_STOP, PF_CMD_REV, PF_CMD_FWD, and \ref PF_CMD_BRAKE. Valid channels are
 * PF_CHANNEL_1 through PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _outa The Power Function command for output A. See \ref PFCmdConstants.
 * \param _outb The Power Function command for output B. See \ref PFCmdConstants.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSPFComboDirect(_port, _i2caddr, _channel, _outa, _outb, _result) \
  __MSPFComboDirect(_port, _i2caddr, _channel, _outa, _outb, _result)

/**
 * MSPFComboPWM function.
 * Control the speed of both outputs on a Power Function receiver set to the
 * specified channel using the mindsensors NRLink device. Valid output values
 * are \ref PF_PWM_FLOAT, \ref PF_PWM_FWD1, \ref PF_PWM_FWD2, \ref PF_PWM_FWD3, \ref PF_PWM_FWD4,
 * \ref PF_PWM_FWD5, \ref PF_PWM_FWD6, \ref PF_PWM_FWD7, \ref PF_PWM_BRAKE, \ref PF_PWM_REV7,
 * \ref PF_PWM_REV6, \ref PF_PWM_REV5, \ref PF_PWM_REV4, \ref PF_PWM_REV3, \ref PF_PWM_REV2, and
 * \ref PF_PWM_REV1. Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The
 * port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _outa The Power Function PWM command for output A. See \ref PFPWMOptions.
 * \param _outb The Power Function PWM command for output B. See \ref PFPWMOptions.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSPFComboPWM(_port, _i2caddr, _channel, _outa, _outb, _result) \
  __MSPFComboPWM(_port, _i2caddr, _channel, _outa, _outb, _result)

/**
 * MSPFRawOutput function.
 * Control a Power Function receiver set to the specified channel using the
 * mindsensors NRLink device. Build the raw data stream using the 3 nibbles
 * (4 bit values). The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _nibble0 The first raw data nibble.
 * \param _nibble1 The second raw data nibble.
 * \param _nibble2 The third raw data nibble.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSPFRawOutput(_port, _i2caddr, _nibble0, _nibble1, _nibble2, _result) \
  __MSPFRawOutput(_port, _i2caddr, _nibble0, _nibble1, _nibble2, _result)

/**
 * MSPFRepeat function.
 * Repeat sending the last Power Function command using the mindsensors
 * NRLink device. Specify the number of times to repeat the command and the
 * number of milliseconds of delay between each repetition. The port must be
 * configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _count The number of times to repeat the command.
 * \param _delay The number of milliseconds to delay between each repetition.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSPFRepeat(_port, _i2caddr, _count, _delay, _result) \
  __MSPFRepeatLastCommand(_port, _i2caddr, _count, _delay, _result)

/**
 * MSPFSingleOutputCST function.
 * Control a single output on a Power Function receiver set to the specified
 * channel using the mindsensors NRLink device. Select the desired output
 * using \ref PF_OUT_A or \ref PF_OUT_B. Valid functions are \ref PF_CST_CLEAR1_CLEAR2,
 * \ref PF_CST_SET1_CLEAR2, \ref PF_CST_CLEAR1_SET2, \ref PF_CST_SET1_SET2,
 * \ref PF_CST_INCREMENT_PWM, \ref PF_CST_DECREMENT_PWM, \ref PF_CST_FULL_FWD,
 * \ref PF_CST_FULL_REV, and \ref PF_CST_TOGGLE_DIR. Valid channels are
 * \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _out The Power Function output. See \ref PFOutputs.
 * \param _func The Power Function CST function. See \ref PFCSTOptions.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSPFSingleOutputCST(_port, _i2caddr, _channel, _out, _func, _result) \
  __MSPFSingleOutput(_port, _i2caddr, _channel, _out, _func, TRUE, _result)

/**
 * MSPFSingleOutputPWM function.
 * Control the speed of a single output on a Power Function receiver set to
 * the specified channel using the mindsensors NRLink device. Select the
 * desired output using \ref PF_OUT_A or \ref PF_OUT_B. Valid functions are
 * \ref PF_PWM_FLOAT, \ref PF_PWM_FWD1, \ref PF_PWM_FWD2, \ref PF_PWM_FWD3, \ref PF_PWM_FWD4,
 * \ref PF_PWM_FWD5, \ref PF_PWM_FWD6, \ref PF_PWM_FWD7, \ref PF_PWM_BRAKE, \ref PF_PWM_REV7,
 * \ref PF_PWM_REV6, \ref PF_PWM_REV5, \ref PF_PWM_REV4, \ref PF_PWM_REV3, \ref PF_PWM_REV2, and
 * \ref PF_PWM_REV1. Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The
 * port must be configured as a Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _out The Power Function output. See \ref PFOutputs.
 * \param _func The Power Function PWM function. See \ref PFPWMOptions.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSPFSingleOutputPWM(_port, _i2caddr, _channel, _out, _func, _result) \
  __MSPFSingleOutput(_port, _i2caddr, _channel, _out, _func, FALSE, _result)

/**
 * MSPFSinglePin function.
 * Control a single pin on a Power Function receiver set to the specified
 * channel using the mindsensors NRLink device. Select the desired output
 * using \ref PF_OUT_A or \ref PF_OUT_B.  Select the desired pin using \ref PF_PIN_C1 or
 * \ref PF_PIN_C2. Valid functions are \ref PF_FUNC_NOCHANGE, \ref PF_FUNC_CLEAR,
 * \ref PF_FUNC_SET, and \ref PF_FUNC_TOGGLE. Valid channels are \ref PF_CHANNEL_1 through
 * \ref PF_CHANNEL_4. Specify whether the mode by passing true (continuous) or
 * false (timeout) as the final parameter. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _out The Power Function output. See \ref PFOutputs.
 * \param _pin The Power Function pin. See \ref PFPinConstants.
 * \param _func The Power Function single pin function. See \ref PFPinFuncs.
 * \param _cont Control whether the mode is continuous or timeout.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSPFSinglePin(_port, _i2caddr, _channel, _out, _pin, _func, _cont, _result) \
  __MSPFSinglePin(_port, _i2caddr, _channel, _out, _pin, _func, _cont, _result)

/**
 * MSPFTrain function.
 * Control both outputs on a Power Function receiver set to the specified
 * channel using the mindsensors NRLink device as if it were an IR Train
 * receiver. Valid function values are \ref TRAIN_FUNC_STOP, \ref TRAIN_FUNC_INCR_SPEED,
 * \ref TRAIN_FUNC_DECR_SPEED, and \ref TRAIN_FUNC_TOGGLE_LIGHT. Valid channels are
 * PF_CHANNEL_1 through PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param _channel The Power Function channel.  See \ref PFChannelConstants.
 * \param _func The Power Function train function. See \ref IRTrainFuncs.
 * \param _result The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
#define MSPFTrain(_port, _i2caddr, _channel, _func, _result) \
  __MSIRTrain(_port, _i2caddr, _channel, _func, TRUE, _result)

/**
 * MSRCXSetIRLinkPort function.
 * Set the global port in advance of using the MSRCX* and MSScout* API
 * functions for sending RCX and Scout messages over the mindsensors NRLink
 * device. The port must be configured as a Lowspeed port before using any of
 * the mindsensors RCX and Scout NRLink functions.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _i2caddr The sensor I2C address. See sensor documentation for this value.
 */
#define MSRCXSetNRLinkPort(_port, _i2caddr) __MSRCXSetNRLink(_port, _i2caddr)

/**
 * MSRCXBatteryLevel function.
 * Send the BatteryLevel command to an RCX to read the current battery level.
 *
 * \param _result The RCX battery level.
 */
#define MSRCXBatteryLevel(_result) __MSRCXBatteryLevel(_result)

/**
 * MSRCXPoll function.
 * Send the Poll command to an RCX to read a signed 2-byte value at the
 * specified source and value combination.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 * \param _result The value read from the specified port and value.
 */
#define MSRCXPoll(_src, _value, _result) __MSRCXPoll(_src, _value, _result)

/**
 * MSRCXPollMemory function.
 * Send the PollMemory command to an RCX.
 *
 * \param _memaddress The RCX memory address.
 * \param _result The value read from the specified address.
 */
#define MSRCXPollMemory(_memaddress, _result) __MSRCXPollMemory(_memaddress, _result)

/**
 * MSRCXAbsVar function.
 * Send the AbsVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXAbsVar(_varnum, _src, _value) __MSRCXVarOp(RCX_AbsVarOp, _varnum, _src, _value)

/**
 * MSRCXAddToDatalog function.
 * Send the AddToDatalog command to an RCX.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXAddToDatalog(_src, _value) __MSRCXAddToDatalog(_src, _value)

/**
 * MSRCXAndVar function.
 * Send the AndVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXAndVar(_varnum, _src, _value) __MSRCXVarOp(RCX_AndVarOp, _varnum, _src, _value)

/**
 * MSRCXBoot function.
 * Send the Boot command to an RCX.
 */
#define MSRCXBoot() __MSRCXBoot()

/**
 * MSRCXCalibrateEvent function.
 * Send the CalibrateEvent command to an RCX.
 *
 * \param _evt The event number.
 * \param _low The low threshold.
 * \param _hi The high threshold.
 * \param _hyst The hysterisis value.
 */
#define MSRCXCalibrateEvent(_evt, _low, _hi, _hyst) __MSRCXCalibrateEvent(_evt, _low, _hi, _hyst)

/**
 * MSRCXClearAllEvents function.
 * Send the ClearAllEvents command to an RCX.
 */
#define MSRCXClearAllEvents() __MSRCXOpNoArgs(RCX_ClearAllEventsOp)

/**
 * MSRCXClearCounter function.
 * Send the ClearCounter command to an RCX.
 *
 * \param _counter The counter to clear.
 */
#define MSRCXClearCounter(_counter) __MSRCXClearCounter(_counter)

/**
 * MSRCXClearMsg function.
 * Send the ClearMsg command to an RCX.
 */
#define MSRCXClearMsg() __MSRCXOpNoArgs(RCX_ClearMsgOp)

/**
 * MSRCXClearSensor function.
 * Send the ClearSensor command to an RCX.
 *
 * \param _port The RCX port number.
 */
#define MSRCXClearSensor(_port) __MSRCXClearSensor(_port)

/**
 * MSRCXClearSound function.
 * Send the ClearSound command to an RCX.
 */
#define MSRCXClearSound() __MSRCXOpNoArgs(RCX_ClearSoundOp)

/**
 * MSRCXClearTimer function.
 * Send the ClearTimer command to an RCX.
 *
 * \param _timer The timer to clear.
 */
#define MSRCXClearTimer(_timer) __MSRCXClearTimer(_timer)

/**
 * MSRCXCreateDatalog function.
 * Send the CreateDatalog command to an RCX.
 *
 * \param _size The new datalog size.
 */
#define MSRCXCreateDatalog(_size) __MSRCXCreateDatalog(_size)

/**
 * MSRCXDecCounter function.
 * Send the DecCounter command to an RCX.
 *
 * \param _counter The counter to decrement.
 */
#define MSRCXDecCounter(_counter) __MSRCXDecCounter(_counter)

/**
 * MSRCXDeleteSub function.
 * Send the DeleteSub command to an RCX.
 *
 * \param _s The subroutine number to delete.
 */
#define MSRCXDeleteSub(_s) __MSRCXDeleteSub(_s)

/**
 * MSRCXDeleteSubs function.
 * Send the DeleteSubs command to an RCX.
 */
#define MSRCXDeleteSubs() __MSRCXOpNoArgs(RCX_DeleteSubsOp)

/**
 * MSRCXDeleteTask function.
 * Send the DeleteTask command to an RCX.
 *
 * \param _t The task number to delete.
 */
#define MSRCXDeleteTask(_t) __MSRCXDeleteTask(_t)

/**
 * MSRCXDeleteTasks function.
 * Send the DeleteTasks command to an RCX.
 */
#define MSRCXDeleteTasks() __MSRCXOpNoArgs(RCX_DeleteTasksOp)

/**
 * MSRCXDisableOutput function.
 * Send the DisableOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to disable. See \ref RCXOutputConstants.
 */
#define MSRCXDisableOutput(_outputs) __MSRCXSetGlobalOutput(_outputs, RCX_OUT_OFF)

/**
 * MSRCXDivVar function.
 * Send the DivVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXDivVar(_varnum, _src, _value) __MSRCXVarOp(RCX_DivVarOp, _varnum, _src, _value)

/**
 * MSRCXEnableOutput function.
 * Send the EnableOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to enable. See \ref RCXOutputConstants.
 */
#define MSRCXEnableOutput(_outputs) __MSRCXSetGlobalOutput(_outputs, RCX_OUT_ON)

/**
 * MSRCXEvent function.
 * Send the Event command to an RCX.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXEvent(_src, _value) __MSRCXEvent(_src, _value)

/**
 * MSRCXFloat function.
 * Send commands to an RCX to float the specified outputs.
 *
 * \param _outputs The RCX output(s) to float. See \ref RCXOutputConstants.
 */
#define MSRCXFloat(_outputs) __MSRCXSetOutput(_outputs, RCX_OUT_FLOAT)

/**
 * MSRCXFwd function.
 * Send commands to an RCX to set the specified outputs to the forward direction.
 *
 * \param _outputs The RCX output(s) to set forward. See \ref RCXOutputConstants.
 */
#define MSRCXFwd(_outputs) __MSRCXSetDirection(_outputs, RCX_OUT_FWD)

/**
 * MSRCXIncCounter function.
 * Send the IncCounter command to an RCX.
 *
 * \param _counter The counter to increment.
 */
#define MSRCXIncCounter(_counter) __MSRCXIncCounter(_counter)

/**
 * MSRCXInvertOutput function.
 * Send the InvertOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to invert. See \ref RCXOutputConstants.
 */
#define MSRCXInvertOutput(_outputs) __MSRCXSetGlobalDirection(_outputs, RCX_OUT_REV)

/**
 * MSRCXMulVar function.
 * Send the MulVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXMulVar(_varnum, _src, _value) __MSRCXVarOp(RCX_MulVarOp, _varnum, _src, _value)

/**
 * MSRCXMuteSound function.
 * Send the MuteSound command to an RCX.
 */
#define MSRCXMuteSound() __MSRCXOpNoArgs(RCX_MuteSoundOp)

/**
 * MSRCXObvertOutput function.
 * Send the ObvertOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to obvert. See \ref RCXOutputConstants.
 */
#define MSRCXObvertOutput(_outputs) __MSRCXSetGlobalDirection(_outputs, RCX_OUT_FWD)

/**
 * MSRCXOff function.
 * Send commands to an RCX to turn off the specified outputs.
 *
 * \param _outputs The RCX output(s) to turn off. See \ref RCXOutputConstants.
 */
#define MSRCXOff(_outputs) __MSRCXSetOutput(_outputs, RCX_OUT_OFF)

/**
 * MSRCXOn function.
 * Send commands to an RCX to turn on the specified outputs.
 *
 * \param _outputs The RCX output(s) to turn on. See \ref RCXOutputConstants.
 */
#define MSRCXOn(_outputs) __MSRCXSetOutput(_outputs, RCX_OUT_ON)

/**
 * MSRCXOnFor function.
 * Send commands to an RCX to turn on the specified outputs in the forward
 * direction for the specified duration.
 *
 * \param _outputs The RCX output(s) to turn on. See \ref RCXOutputConstants.
 * \param _ms The number of milliseconds to leave the outputs on
 */
#define MSRCXOnFor(_outputs, _ms) __MSRCXOnFor(_outputs, _ms)

/**
 * MSRCXOnFwd function.
 * Send commands to an RCX to turn on the specified outputs in the forward
 * direction.
 *
 * \param _outputs The RCX output(s) to turn on in the forward direction. See \ref RCXOutputConstants.
 */
#define MSRCXOnFwd(_outputs) __MSRCXOnFwd(_outputs)

/**
 * MSRCXOnRev function.
 * Send commands to an RCX to turn on the specified outputs in the reverse direction.
 *
 * \param _outputs The RCX output(s) to turn on in the reverse direction. See \ref RCXOutputConstants.
 */
#define MSRCXOnRev(_outputs) __MSRCXOnRev(_outputs)

/**
 * MSRCXOrVar function.
 * Send the OrVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXOrVar(_varnum, _src, _value) __MSRCXVarOp(RCX_OrVarOp, _varnum, _src, _value)

/**
 * MSRCXPBTurnOff function.
 * Send the PBTurnOff command to an RCX.
 */
#define MSRCXPBTurnOff() __MSRCXOpNoArgs(RCX_PBTurnOffOp)

/**
 * MSRCXPing function.
 * Send the Ping command to an RCX.
 */
#define MSRCXPing() __MSRCXOpNoArgs(RCX_PingOp)

/**
 * MSRCXPlaySound function.
 * Send the PlaySound command to an RCX.
 *
 * \param _snd The sound number to play.
 */
#define MSRCXPlaySound(_snd) __MSRCXPlaySound(_snd)

/**
 * MSRCXPlayTone function.
 * Send the PlayTone command to an RCX.
 *
 * \param _freq The frequency of the tone to play.
 * \param _duration The duration of the tone to play.
 */
#define MSRCXPlayTone(_freq, _duration) __MSRCXPlayTone(_freq, _duration)

/**
 * MSRCXPlayToneVar function.
 * Send the PlayToneVar command to an RCX.
 *
 * \param _varnum The variable containing the tone frequency to play.
 * \param _duration The duration of the tone to play.
 */
#define MSRCXPlayToneVar(_varnum, _duration) __MSRCXPlayToneVar(_varnum, _duration)

/**
 * MSRCXRemote function.
 * Send the Remote command to an RCX.
 *
 * \param _cmd The RCX IR remote command to send. See \ref RCXRemoteConstants.
 */
#define MSRCXRemote(_cmd) __MSRCXRemote(_cmd)

/**
 * MSRCXReset function.
 * Send the Reset command to an RCX.
 */
#define MSRCXReset() __MSRCXReset()

/**
 * MSRCXRev function.
 * Send commands to an RCX to set the specified outputs to the reverse direction.
 *
 * \param _outputs The RCX output(s) to reverse direction. See \ref RCXOutputConstants.
 */
#define MSRCXRev(_outputs) __MSRCXSetDirection(_outputs, RCX_OUT_REV)

/**
 * MSRCXSelectDisplay function.
 * Send the SelectDisplay command to an RCX.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXSelectDisplay(_src, _value) __MSRCXSelectDisplay(_src, _value)

/**
 * MSRCXSelectProgram function.
 * Send the SelectProgram command to an RCX.
 *
 * \param _prog The program number to select.
 */
#define MSRCXSelectProgram(_prog) __MSRCXSelectProgram(_prog)

/**
 * MSRCXSendSerial function.
 * Send the SendSerial command to an RCX.
 *
 * \param _first The first byte address.
 * \param _count The number of bytes to send.
 */
#define MSRCXSendSerial(_first, _count) __MSRCXSendSerial(_first, _count)

/**
 * MSRCXSet function.
 * Send the Set command to an RCX.
 *
 * \param _dstsrc The RCX destination source.  See \ref RCXSourceConstants.
 * \param _dstval The RCX destination value.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXSet(_dstsrc, _dstval, _src, _value) __MSRCXSet(_dstsrc, _dstval, _src, _value)

/**
 * MSRCXSetDirection function.
 * Send the SetDirection command to an RCX to configure the direction of the specified outputs.
 *
 * \param _outputs The RCX output(s) to set direction. See \ref RCXOutputConstants.
 * \param _dir The RCX output direction. See \ref RCXOutputDirection.
 */
#define MSRCXSetDirection(_outputs, _dir) __MSRCXSetDirection(_outputs, _dir)

/**
 * MSRCXSetEvent function.
 * Send the SetEvent command to an RCX.
 *
 * \param _evt The event number to set.
 * \param _src The RCX source. See \ref RCXSourceConstants.
 * \param _type The event type.
 */
#define MSRCXSetEvent(_evt, _src, _type) __MSRCXSetEvent(_evt, _src, _type)

/**
 * MSRCXSetGlobalDirection function.
 * Send the SetGlobalDirection command to an RCX.
 *
 * \param _outputs The RCX output(s) to set global direction. See \ref RCXOutputConstants.
 * \param _dir The RCX output direction. See \ref RCXOutputDirection.
 */
#define MSRCXSetGlobalDirection(_outputs, _dir) __MSRCXSetGlobalDirection(_outputs, _dir)

/**
 * MSRCXSetGlobalOutput function.
 * Send the SetGlobalOutput command to an RCX.
 *
 * \param _outputs The RCX output(s) to set global mode. See \ref RCXOutputConstants.
 * \param _mode The RCX output mode. See \ref RCXOutputMode.
 */
#define MSRCXSetGlobalOutput(_outputs, _mode) __MSRCXSetGlobalOutput(_outputs, _mode)

/**
 * MSRCXSetMaxPower function.
 * Send the SetMaxPower command to an RCX.
 *
 * \param _outputs The RCX output(s) to set max power. See \ref RCXOutputConstants.
 * \param _pwrsrc The RCX source.  See \ref RCXSourceConstants.
 * \param _pwrval The RCX value.
 */
#define MSRCXSetMaxPower(_outputs, _pwrsrc, _pwrval) __MSRCXSetMaxPower(_outputs, _pwrsrc, _pwrval)

/**
 * MSRCXSetMessage function.
 * Send the SetMessage command to an RCX.
 *
 * \param _msg The numeric message to send.
 */
#define MSRCXSetMessage(_msg) __MSRCXSetMessage(_msg)

/**
 * MSRCXSetOutput function.
 * Send the SetOutput command to an RCX to configure the mode of the specified outputs
 *
 * \param _outputs The RCX output(s) to set mode. See \ref RCXOutputConstants.
 * \param _mode The RCX output mode. See \ref RCXOutputMode.
 */
#define MSRCXSetOutput(_outputs, _mode) __MSRCXSetOutput(_outputs, _mode)

/**
 * MSRCXSetPower function.
 * Send the SetPower command to an RCX to configure the power level of the specified outputs.
 *
 * \param _outputs The RCX output(s) to set power. See \ref RCXOutputConstants.
 * \param _pwrsrc The RCX source.  See \ref RCXSourceConstants.
 * \param _pwrval The RCX value.
 */
#define MSRCXSetPower(_outputs, _pwrsrc, _pwrval) __MSRCXSetPower(_outputs, _pwrsrc, _pwrval)

/**
 * MSRCXSetPriority function.
 * Send the SetPriority command to an RCX.
 *
 * \param _p The new task priority.
 */
#define MSRCXSetPriority(_p) __MSRCXSetPriority(_p)

/**
 * MSRCXSetSensorMode function.
 * Send the SetSensorMode command to an RCX.
 *
 * \param _port The RCX sensor port.
 * \param _mode The RCX sensor mode.
 */
#define MSRCXSetSensorMode(_port, _mode) __MSRCXSetSensorMode(_port, _mode)

/**
 * MSRCXSetSensorType function.
 * Send the SetSensorType command to an RCX.
 *
 * \param _port The RCX sensor port.
 * \param _type The RCX sensor type.
 */
#define MSRCXSetSensorType(_port, _type) __MSRCXSetSensorType(_port, _type)

/**
 * MSRCXSetSleepTime function.
 * Send the SetSleepTime command to an RCX.
 *
 * \param _t The new sleep time value.
 */
#define MSRCXSetSleepTime(_t) __MSRCXSetSleepTime(_t)

/**
 * MSRCXSetTxPower function.
 * Send the SetTxPower command to an RCX.
 *
 * \param _pwr The IR transmit power level.
 */
#define MSRCXSetTxPower(_pwr) __MSRCXSetTxPower(_pwr)

/**
 * MSRCXSetUserDisplay function.
 * Send the SetUserDisplay command to an RCX.
 *
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 * \param _precision The number of digits of precision.
 */
#define MSRCXSetUserDisplay(_src, _value, _precision) __MSRCXSetUserDisplay(_src, _value, _precision)

/**
 * MSRCXSetVar function.
 * Send the SetVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXSetVar(_varnum, _src, _value) __MSRCXVarOp(RCX_SetVarOp, _varnum, _src, _value)

/**
 * MSRCXSetWatch function.
 * Send the SetWatch command to an RCX.
 *
 * \param _hours The new watch time hours value.
 * \param _minutes The new watch time minutes value.
 */
#define MSRCXSetWatch(_hours, _minutes) __MSRCXSetWatch(_hours, _minutes)

/**
 * MSRCXSgnVar function.
 * Send the SgnVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXSgnVar(_varnum, _src, _value) __MSRCXVarOp(RCX_SgnVarOp, _varnum, _src, _value)

/**
 * MSRCXStartTask function.
 * Send the StartTask command to an RCX.
 *
 * \param _t The task number to start.
 */
#define MSRCXStartTask(_t) __MSRCXStartTask(_t)

/**
 * MSRCXStopAllTasks function.
 * Send the StopAllTasks command to an RCX.
 */
#define MSRCXStopAllTasks() __MSRCXOpNoArgs(RCX_StopAllTasksOp)

/**
 * MSRCXStopTask function.
 * Send the StopTask command to an RCX.
 *
 * \param _t The task number to stop.
 */
#define MSRCXStopTask(_t) __MSRCXStopTask(_t)

/**
 * MSRCXSubVar function.
 * Send the SubVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXSubVar(_varnum, _src, _value) __MSRCXVarOp(RCX_SubVarOp, _varnum, _src, _value)

/**
 * MSRCXSumVar function.
 * Send the SumVar command to an RCX.
 *
 * \param _varnum The variable number to change.
 * \param _src The RCX source.  See \ref RCXSourceConstants.
 * \param _value The RCX value.
 */
#define MSRCXSumVar(_varnum, _src, _value) __MSRCXVarOp(RCX_SumVarOp, _varnum, _src, _value)

/**
 * MSRCXToggle function.
 * Send commands to an RCX to toggle the direction of the specified outputs.
 *
 * \param _outputs The RCX output(s) to toggle. See \ref RCXOutputConstants.
 */
#define MSRCXToggle(_outputs) __MSRCXSetDirection(_outputs, RCX_OUT_TOGGLE)

/**
 * MSRCXUnlock function.
 * Send the Unlock command to an RCX.
 */
#define MSRCXUnlock() __MSRCXUnlock()

/**
 * MSRCXUnmuteSound function.
 * Send the UnmuteSound command to an RCX.
 */
#define MSRCXUnmuteSound() __MSRCXOpNoArgs(RCX_UnmuteSoundOp)

/**
 * MSScoutCalibrateSensor function.
 * Send the CalibrateSensor command to a Scout.
 */
#define MSScoutCalibrateSensor() __MSRCXOpNoArgs(RCX_LSCalibrateOp)

/**
 * MSScoutMuteSound function.
 * Send the MuteSound command to a Scout.
 */
#define MSScoutMuteSound() __MSScoutMuteSound()

/**
 * MSScoutSelectSounds function.
 * Send the SelectSounds command to a Scout.
 *
 * \param _grp The Scout sound group to select.
 */
#define MSScoutSelectSounds(_grp) __MSScoutSelectSounds(_grp)

/**
 * MSScoutSendVLL function.
 * Send the SendVLL command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define MSScoutSendVLL(_src, _value) __MSScoutSendVLL(_src, _value)

/**
 * MSScoutSetCounterLimit function.
 * Send the SetCounterLimit command to a Scout.
 *
 * \param _ctr The counter for which to set the limit.
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define MSScoutSetCounterLimit(_ctr, _src, _value) __MSScoutSetCounterLimit(_ctr, _src, _value)

/**
 * MSScoutSetEventFeedback function.
 * Send the SetEventFeedback command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define MSScoutSetEventFeedback(_src, _value) __MSScoutSetEventFeedback(_src, _value)

/**
 * MSScoutSetLight function.
 * Send the SetLight command to a Scout.
 *
 * \param _x Set the light on or off using this value. See \ref ScoutLightConstants.
 */
#define MSScoutSetLight(_x) __MSScoutSetLight(_x)

/**
 * MSScoutSetScoutMode function.
 * Send the SetScoutMode command to a Scout.
 *
 * \param _mode Set the scout mode. See \ref ScoutModeConstants.
*/
#define MSScoutSetScoutMode(_mode) __MSScoutSetScoutMode(_mode)

/**
 * MSScoutSetScoutRules function.
 * Send the SetScoutRules command to a Scout.
 *
 * \param _m Scout motion rule. See \ref ScoutMotionRuleConstants.
 * \param _t Scout touch rule. See \ref ScoutTouchRuleConstants.
 * \param _l Scout light rule. See \ref ScoutLightRuleConstants.
 * \param _tm Scout transmit rule. See \ref ScoutTransmitRuleConstants.
 * \param _fx Scout special effects rule. See \ref ScoutSpecialEffectConstants.
 */
#define MSScoutSetScoutRules(_m, _t, _l, _tm, _fx) __MSScoutSetScoutRules(_m, _t, _l, _tm, _fx)

/**
 * MSScoutSetSensorClickTime function.
 * Send the SetSensorClickTime command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define MSScoutSetSensorClickTime(_src, _value) __MSScoutSetSensorClickTime(_src, _value)

/**
 * MSScoutSetSensorHysteresis function.
 * Send the SetSensorHysteresis command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define MSScoutSetSensorHysteresis(_src, _value) __MSScoutSetSensorHysteresis(_src, _value)

/**
 * MSScoutSetSensorLowerLimit function.
 * Send the SetSensorLowerLimit command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define MSScoutSetSensorLowerLimit(_src, _value) __MSScoutSetSensorLowerLimit(_src, _value)

/**
 * MSScoutSetSensorUpperLimit function.
 * Send the SetSensorUpperLimit command to a Scout.
 *
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define MSScoutSetSensorUpperLimit(_src, _value) __MSScoutSetSensorUpperLimit(_src, _value)

/**
 * MSScoutSetTimerLimit function.
 * Send the SetTimerLimit command to a Scout.
 *
 * \param _tmr The timer for which to set a limit.
 * \param _src The Scout source.  See \ref RCXSourceConstants.
 * \param _value The Scout value.
 */
#define MSScoutSetTimerLimit(_tmr, _src, _value) __MSScoutSetTimerLimit(_tmr, _src, _value)

/**
 * MSScoutUnmuteSound function.
 * Send the UnmuteSound command to a Scout.
 */
#define MSScoutUnmuteSound() __MSScoutUnmuteSound()

/** @} */ // end of MindSensorsAPI group

/** @addtogroup CodatexAPI
 * @{
 */

// Codatex RFID functions

/**
 * RFIDInit function.
 * Initialize the Codatex RFID sensor.
 *
 * \param _port The port to which the Codatex RFID sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The boolean function call result.
 */
#define RFIDInit(_port, _result) __RFIDInit(_port, _result)

/**
 * RFIDMode function.
 * Configure the Codatex RFID sensor mode.
 *
 * \param _port The port to which the Codatex RFID sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _mode The RFID sensor mode.  See the \ref CTRFIDModeConstants group.
 * \param _result The boolean function call result.
 */
#define RFIDMode(_port, _mode, _result) __RFIDMode(_port, _mode, _result)

/**
 * RFIDStatus function.
 * Read the Codatex RFID sensor status.
 *
 * \param _port The port to which the Codatex RFID sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The RFID sensor status.
 */
#define RFIDStatus(_port, _result) __RFIDStatus(_port, _result)

/**
 * RFIDRead function.
 * Read the Codatex RFID sensor value.
 *
 * \param _port The port to which the Codatex RFID sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _output The five bytes of RFID data.
 * \param _result The boolean function call result.
 */
#define RFIDRead(_port, _output, _result) __RFIDRead(_port, _output, _result)

/**
 * RFIDStop function.
 * Stop the Codatex RFID sensor.
 *
 * \param _port The port to which the Codatex RFID sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The boolean function call result.
 */
#define RFIDStop(_port, _result) __RFIDStop(_port, _result)

/**
 * RFIDReadSingle function.
 * Set the Codatex RFID sensor into single mode and read the RFID data.
 *
 * \param _port The port to which the Codatex RFID sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _output The five bytes of RFID data.
 * \param _result The boolean function call result.
 */
#define RFIDReadSingle(_port, _output, _result) __RFIDReadSingle(_port, _output, _result)

/**
 * RFIDReadContinuous function.
 * Set the Codatex RFID sensor into continuous mode, if necessary, and read
 * the RFID data.
 *
 * \param _port The port to which the Codatex RFID sensor is attached. See the
 * \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _output The five bytes of RFID data.
 * \param _result The boolean function call result.
 */
#define RFIDReadContinuous(_port, _output, _result) __RFIDReadContinuous(_port, _output, _result)

/** @} */  // end of CodatexAPI group

/** @addtogroup DexterIndustriesAPI
 * @{
 */

// Dexter Industries GPS functions

/**
 * ReadSensorDIGPSStatus function.
 * Read the status of the GPS satellite link.
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _status The GPS status
 */
#define ReadSensorDIGPSStatus(_port, _status) __ReadSensorDIGPSStatus(_port, _status)

/**
 * ReadSensorDIGPSTime function.
 * Read the current time reported by the GPS in UTC.
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The current time in UTC
 */
#define ReadSensorDIGPSTime(_port, _result) __ReadSensorDIGPSTime(_port, _result)

/**
 * ReadSensorDIGPSLatitude function.
 * Read the integer latitude reported by the GPS
 * (dddddddd; Positive = North; Negative = South).
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The integer latitude
 */
#define ReadSensorDIGPSLatitude(_port, _result) __ReadSensorDIGPSLatitude(_port, _result)

/**
 * ReadSensorDIGPSLongitude function.
 * Read the integer longitude reported by the GPS
 * (ddddddddd; Positive = East; Negative = West).
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The integer longitude
 */
#define ReadSensorDIGPSLongitude(_port, _result) __ReadSensorDIGPSLongitude(_port, _result)

/**
 * ReadSensorDIGPSVelocity function.
 * Read the current velocity in cm/s.
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The current velocity in cm/s
 */
#define ReadSensorDIGPSVelocity(_port, _result) __ReadSensorDIGPSVelocity(_port, _result)

/**
 * ReadSensorDIGPSHeading function.
 * Read the current heading in degrees.
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The current heading in degrees
 */
#define ReadSensorDIGPSHeading(_port, _result) __ReadSensorDIGPSHeading(_port, _result)

/**
 * ReadSensorDIGPSDistanceToWaypoint function.
 * Read the distance remaining to reach the current waypoint in meters.
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The distance to the waypoint in meters
 */
#define ReadSensorDIGPSDistanceToWaypoint(_port, _result) __ReadSensorDIGPSDistanceToWaypoint(_port, _result)

/**
 * ReadSensorDIGPSHeadingToWaypoint function.
 * Read the heading required to reach the current waypoint.
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The heading to the waypoint in degrees
 */
#define ReadSensorDIGPSHeadingToWaypoint(_port, _result) __ReadSensorDIGPSHeadingToWaypoint(_port, _result)

/**
 * ReadSensorDIGPSRelativeHeading function.
 * Read the angle travelled since last request. Resets the request coordinates
 * on the GPS sensor. Sends the angle of travel since the last call.
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The relative heading in degrees
 */
#define ReadSensorDIGPSRelativeHeading(_port, _result) __ReadSensorDIGPSRelativeHeading(_port, _result)

/**
 * SetSensorDIGPSWaypoint function.
 * Set the coordinates of the waypoint destination. The GPS sensor uses
 * this to calculate the heading and distance required to reach
 * the waypoint.
 *
 * \param _port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _lat The latitude of the waypoint.
 * \param _long The longitude of the waypoint.
 * \param _result The boolean function call result.
 */
#define SetSensorDIGPSWaypoint(_port, _lat, _long, _result) __SetSensorDIGPSWaypoint(_port, _lat, _long, _result)

/**
 * SetSensorDIGyroEx function.
 * Configure DIGyro device on the specified port with the specified scale,
 * output data rate, and bandwidth.
 *
 * \param _port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _scale The full scale of the device (250dps, 500dps, or 2000dps).
 * See the \ref DIIMUGyroCtrl4Constants group. You may use a constant or a variable.
 * \param _odr The output data rate of the device (100hz, 200hz, 400hz, or 800hz).
 * See the \ref DIIMUGyroCtrl1Constants group. You may use a constant or a variable.
 * \param _bw The bandwidth of the device.
 * See the \ref DIIMUGyroCtrl1Constants group. You may use a constant or a variable.
 * \param _result The boolean function call result.
 */
#define SetSensorDIGyroEx(_port, _scale, _odr, _bw, _result) __SetSensorDIGyro(_port, _scale, _odr, _bw, _result)

/**
 * SetSensorDIGyro function.
 * Configure DIGyro device on the specified port with default scale of 500dps,
 * output data rate of 100hz, and bandwidth level 1.
 *
 * \param _port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The boolean function call result.
 */
#define SetSensorDIGyro(_port, _result) __SetSensorDIGyro(_port, DIGYRO_CTRL4_SCALE_500, DIGYRO_CTRL1_DATARATE_100, DIGYRO_CTRL1_BANDWIDTH_1, _result)

/**
 * ReadSensorDIGyroRaw function.
 * Read the raw Dexter Industries IMU Gyro X, Y, and Z axis values.
 *
 * \param _port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _vector A variable of type TVector which will contain the raw X, Y, anx Z values.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIGyroRaw(_port, _vector, _result) __ReadSensorDIGyroRaw(_port, _vector, _result)

/**
 * ReadSensorDIGyro function.
 * Read the scaled Dexter Industries IMU Gyro X, Y, and Z axis values.
 *
 * \param _port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _vector A variable of type TVector which will contain the scaled X, Y, anx Z values.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIGyro(_port, _vector, _result) __ReadSensorDIGyro(_port, _vector, _result)

/**
 * ReadSensorDIGyroTemperature function.
 * Read the Dexter Industries IMU Gyro temperature value.
 *
 * \param _port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _out The output temperature value.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIGyroTemperature(_port, _out, _result) __ReadSensorDIGyroTemperature(_port, _out, _result)

/**
 * ReadSensorDIGyroStatus function.
 * Read the Dexter Industries IMU Gyro status value.
 *
 * \param _port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _out The output status value.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIGyroStatus(_port, _out, _result) __ReadSensorDIGyroStatus(_port, _out, _result)


/**
 * SetSensorDIAcclEx function.
 * Configure DIAccl device on the specified port with the specified mode.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _mode The mode of the device (2G, 4G, or 8G).
 * See the \ref DIIMUAccelModeConstants group. You may use a constant or a variable.
 * \param _result The boolean function call result.
 */
#define SetSensorDIAcclEx(_port, _mode, _result) __SetSensorDIAccl(_port, _mode, _result)

/**
 * SetSensorDIAccl function.
 * Configure DIAccl device on the specified port with default mode of 2G.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _result The boolean function call result.
 */
#define SetSensorDIAccl(_port, _result) __SetSensorDIAccl(_port, DIACCL_MODE_GLVL2, _result)

/**
 * ReadSensorDIAcclRaw function.
 * Read the raw Dexter Industries IMU Accl X, Y, and Z axis 10-bit values.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _vector A variable of type TVector which will contain the raw X, Y, anx Z values.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIAcclRaw(_port, _vector, _result) __ReadSensorDIAcclRaw(_port, DIACCL_REG_XLOW, _vector, _result)

/**
 * ReadSensorDIAccl function.
 * Read the scaled Dexter Industries IMU Accl X, Y, and Z axis 10-bit values.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _vector A variable of type TVector which will contain the scaled X, Y, anx Z values.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIAccl(_port, _vector, _result) __ReadSensorDIAccl(_port, _vector, _result)

/**
 * ReadSensorDIAccl8Raw function.
 * Read the raw Dexter Industries IMU Accl X, Y, and Z axis 8-bit values.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _vector A variable of type TVector which will contain the raw X, Y, anx Z values.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIAccl8Raw(_port, _vector, _result) __ReadSensorDIAccl8Raw(_port, _vector, _result)

/**
 * ReadSensorDIAccl8 function.
 * Read the scaled Dexter Industries IMU Accl X, Y, and Z axis 8-bit values.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _vector A variable of type TVector which will contain the scaled X, Y, anx Z values.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIAccl8(_port, _vector, _result) __ReadSensorDIAccl8(_port, _vector, _result)

/**
 * ReadSensorDIAcclStatus function.
 * Read the Dexter Industries IMU Accl status value.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _out The output status value.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIAcclStatus(_port, _out, _result) __ReadSensorDIAcclStatus(_port, _out, _result)

/**
 * ReadSensorDIAcclDrift function.
 * Read the Dexter Industries IMU Accl X, Y, and Z axis 10-bit drift values.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _x The X axis 10-bit drift value.
 * \param _y The Y axis 10-bit drift value.
 * \param _z The Z axis 10-bit drift value.
 * \param _result The boolean function call result.
 */
#define ReadSensorDIAcclDrift(_port, _x, _y, _z, _result) __ReadSensorDIAcclDrift(_port, _x, _y, _z, _result)

/**
 * SetSensorDIAcclDrift function.
 * Set the Dexter Industries IMU Accl X, Y, and Z axis 10-bit drift values.
 *
 * \param _port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref NBCInputPortConstants group. You may use a constant or a variable.
 * \param _x The X axis 10-bit drift value.
 * \param _y The Y axis 10-bit drift value.
 * \param _z The Z axis 10-bit drift value.
 * \param _result The boolean function call result.
 */
#define SetSensorDIAcclDrift(_port, _x, _y, _z, _result) __SetSensorDIAcclDrift(_port, _x, _y, _z, _result)


/** @} */  // end of DexterIndustriesAPI group


/** @addtogroup MicroinfinityAPI
 * @{
 */

// Microinfinity functions

/**
 * ResetMIXG1300L function.
 * Reset the Microinfinity CruizCore XG1300L device.
 *
 * During reset, the XG1300L will recomputed the bias drift value, therefore
 * it must remain stationary. The bias drift value will change randomly over
 * time due to temperature variations, however the internal algorithm in
 * the XG1300L will compensate for these changes. We strongly recommend
 * issuing a reset command to the XG1300L at the beginning of the program.
 *
 * The reset function also resets the accumulate angle value to a zero. Since
 * the accelerometers measurements are taken with respect to the sensor
 * reference frame the reset function will have no effect in the accelerometer
 * measurements.
 *
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _result The function call result.
 */
#define ResetMIXG1300L(_port, _result) __ResetMIXG1300L(_port, _result)

/**
 * ReadSensorMIXG1300LScale function.
 * Read the Microinfinity CruizCore XG1300L accelerometer scale.
 * The accelerometer in the CruizCore XG1300L can be set to operate with a
 * scale ranging from +/-2G, +/-4G, or +/-8G.
 * Returns the scale value that the device is currently configured to use.
 * The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _result The current scale value.
 */
#define ReadSensorMIXG1300LScale(_port, _result) __ReadSensorMIXG1300LScale(_port, _result)

/**
 * SetSensorMIXG1300LScale function.
 * Set the Microinfinity CruizCore XG1300L accelerometer scale factor.
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _scale This value must be a constant.  See \ref XG1300LScaleConstants.
 * \param _result The function call result.
 */
#define SetSensorMIXG1300LScale(_port, _scale, _result) __SetSensorMIXG1300LScale(_port, _scale, _result)

/**
 * ReadSensorMIXG1300L function.
 * Read Microinfinity CruizCore XG1300L values.
 * Read accumulated angle, turn rate, and X, Y, and Z axis acceleration values
 * from the Microinfinity CruizCore XG1300L sensor.
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param _port The sensor port. See \ref NBCInputPortConstants.
 * \param _packet The output XK1300L data structure.  See \ref TXGPacket.
 * \param _result The function call result.
 */
#define ReadSensorMIXG1300L(_port, _packet, _result) \
  compchktype _packet, TXGPacket \
  __ReadSensorMIXG1300L(_port, _packet, _result)

/** @} */  // end of MicroinfinityAPI group

/** @} */ // end of ThirdPartyDevices group


/** @addtogroup GraphicsLibrary
 * @{
 */

//------------------------------------------------------------------------------
// File          : nbcGL.nbc
// Description   : Data and subroutines for a very simple 3D engine.
// Programmed by : Arno van der Vegt, legoasimo@gmail.com
//------------------------------------------------------------------------------

/**
 * Initialize graphics library.
 * Setup all the necessary data for the graphics library to function. Call this
 * function before any other graphics library routine.
 */
#define glInit() __glInit()

/**
 * Set graphics library options.
 * Adjust graphic library settings for circle size and cull mode.
 *
 * \param _glType The setting type.  See \ref GLConstantsSettings.
 * \param _glValue The setting value. For culling modes see \ref GLConstantsCullMode.
 */
#define glSet(_glType, _glValue) __glSet(_glType, _glValue)

/**
 * Begin defining an object.
 * Start the process of defining a graphics library object using low level
 * functions such as \ref glBegin, \ref glAddVertex, and \ref glEnd.
 *
 * \param _glObjId The object index of the new object being created.
 */
#define glBeginObject(_glObjId) __glBeginObject(_glObjId)

/**
 * Stop defining an object.
 * Finish the process of defining a graphics library object.  Call this function
 * after you have completed the object definition.
 */
#define glEndObject() __glEndObject()

/**
 * Perform an object action.
 * Execute the specified action on the specified object.
 *
 * \param _glObjectId The object id.
 * \param _glAction The action to perform on the object. See \ref GLConstantsActions.
 * \param _glValue The setting value.
 */
#define glObjectAction(_glObjectId, _glAction, _glValue) __glObjectAction(_glObjectId, _glAction, _glValue)

/**
 * Add a vertex to an object.
 * Add a vertex to an object currently being defined.  This function should
 * only be used between \ref glBegin and \ref glEnd which are themselves
 * nested within a \ref glBeginObject and \ref glEndObject pair.
 *
 * \param _glX The X axis coordinate.
 * \param _glY The Y axis coordinate.
 * \param _glZ The Z axis coordinate.
 */
#define glAddVertex(_glX, _glY, _glZ) __glAddVertex(_glX, _glY, _glZ)

/**
 * Begin a new polygon for the current object.
 * Start defining a polygon surface for the current graphics object using
 * the specified begin mode.
 *
 * \param _glBeginMode The desired mode.  See \ref GLConstantsBeginModes.
 */
#define glBegin(_glBeginMode) __glBegin(_glBeginMode)

/**
 * Finish a polygon for the current object.
 * Stop defining a polgyon surface for the current graphics object.
 */
#define glEnd() __glEnd()

/**
 * Begin a new render.
 * Start the process of rendering the existing graphic objects.
 */
#define glBeginRender() __glBeginRender()

/**
 * Call a graphic object.
 * Tell the graphics library that you want it to include the specified
 * object in the render.
 *
 * \param _glObjectId The desired object id.
 */
#define glCallObject(_glObjectId) __glCallObject(_glObjectId)

/**
 * Finish the current render.
 * Rotate the vertex list, clear the screen, and draw the rendered objects
 * to the LCD.
 */
#define glFinishRender() __glFinishRender()

/**
 * Set the X axis angle.
 * Set the X axis angle to the specified value.
 *
 * \param _glValue The new X axis angle.
 */
#define glSetAngleX(_glValue) __glSetAngleX(_glValue)

/**
 * Add to the X axis angle.
 * Add the specified value to the existing X axis angle.
 *
 * \param _glValue The value to add to the X axis angle.
 */
#define glAddToAngleX(_glValue) __glAddToAngleX(_glValue)

/**
 * Set the Y axis angle.
 * Set the Y axis angle to the specified value.
 *
 * \param _glValue The new Y axis angle.
 */
#define glSetAngleY(_glValue) __glSetAngleY(_glValue)

/**
 * Add to the Y axis angle.
 * Add the specified value to the existing Y axis angle.
 *
 * \param _glValue The value to add to the Y axis angle.
 */
#define glAddToAngleY(_glValue) __glAddToAngleY(_glValue)

/**
 * Set the Z axis angle.
 * Set the Z axis angle to the specified value.
 *
 * \param _glValue The new Z axis angle.
 */
#define glSetAngleZ(_glValue) __glSetAngleZ(_glValue)

/**
 * Add to the Z axis angle.
 * Add the specified value to the existing Z axis angle.
 *
 * \param _glValue The value to add to the Z axis angle.
 */
#define glAddToAngleZ(_glValue) __glAddToAngleZ(_glValue)

/**
 * Table-based sine scaled by 32768.
 * Return the sine of the specified angle in degrees.  The result is scaled
 * by 32768.
 *
 * \param _glAngle The angle in degrees.
 * \param _glResult The sine value scaled by 32768.
 */
#define glSin32768(_glAngle, _glResult) __glSin32768(_glAngle, _glResult)

/**
 * Table-based cosine scaled by 32768.
 * Return the cosine of the specified angle in degrees.  The result is scaled
 * by 32768.
 *
 * \param _glAngle The angle in degrees.
 * \param _glResult The cosine value scaled by 32768.
 */
#define glCos32768(_glAngle, _glResult) __glCos32768(_glAngle, _glResult)

/**
 * Create a 3D box.
 * Define a 3D box using the specified begin mode for all faces. The center
 * of the box is at the origin of the XYZ axis with width, height, and depth
 * specified via the glSizeX, glSizeY, and glSizeZ parameters.
 *
 * \param _glMode The begin mode for each surface.  See \ref GLConstantsBeginModes.
 * \param _glSizeX The X axis size (width).
 * \param _glSizeY The Y axis size (height).
 * \param _glSizeZ The Z axis size (depth).
 * \param _glObjId The object ID of the new object.
 */
#define glBox(_glMode, _glSizeX, _glSizeY, _glSizeZ, _glObjId) __glBox(_glMode, _glSizeX, _glSizeY, _glSizeZ, _glObjId)

/**
 * Create a 3D cube.
 * Define a 3D cube using the specified begin mode for all faces. The center
 * of the box is at the origin of the XYZ axis with equal width, height, and depth
 * specified via the glSize parameter.
 *
 * \param _glMode The begin mode for each surface.  See \ref GLConstantsBeginModes.
 * \param _glSize The cube's width, height, and depth.
 * \param _glObjId The object ID of the new object.
 */
#define glCube(_glMode, _glSize, _glObjId) __glBox(_glMode, _glSize, _glSize, _glSize, _glObjId)

/**
 * Create a 3D pyramid.
 * Define a 3D pyramid using the specified begin mode for all faces. The center
 * of the pyramid is at the origin of the XYZ axis with width, height, and depth
 * specified via the glSizeX, glSizeY, and glSizeZ parameters.
 *
 * \param _glMode The begin mode for each surface.  See \ref GLConstantsBeginModes.
 * \param _glSizeX The X axis size (width).
 * \param _glSizeY The Y axis size (height).
 * \param _glSizeZ The Z axis size (depth).
 * \param _glObjId The object ID of the new object.
 */
#define glPyramid(_glMode, _glSizeX, _glSizeY, _glSizeZ, _glObjId) __glPyramid(_glMode, _glSizeX, _glSizeY, _glSizeZ, _glObjId)

/** @} */ // end of GraphicsLibrary group


#endif // NXTDEFS__H/** \file NXCDefs.h
 * \brief Constants, macros, and API functions for NXC
 *
 * NXCDefs.h contains declarations for the NXC NXT API resources
 *
 * License:
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Initial Developer of this code is John Hansen.
 * Portions created by John Hansen are Copyright (C) 2009-2012 John Hansen.
 * All Rights Reserved.
 *
 * ----------------------------------------------------------------------------
 *
 * \author John Hansen (bricxcc_at_comcast.net)
 * \date 2012-02-06
 * \version 105
 */
#ifndef NXCDEFS_H
#define NXCDEFS_H

#include "NBCCommon.h"

/** @addtogroup MiscConstants
 * @{
 */
/** @defgroup TypeAliases Type aliases
 *  Short type aliases indicating signed/unsigned and bit count for each type.
 *  @{
 */
#define u8 unsigned char  /*!< Unsigned 8 bit type */
#define s8 char           /*!< Signed 8 bit type */
#define u16 unsigned int  /*!< Unsigned 16 bit type */
#define s16 int           /*!< Signed 16 bit type */
#define u32 unsigned long /*!< Unsigned 32 bit type */
#define s32 long          /*!< Signed 32 bit type */
/** @} */  // end of TypeAliases group
/** @} */  // end of MiscConstants group


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// INPUT MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup InputModule
 * @{
 */
/** @addtogroup InputModuleConstants
 * @{
 */
/** @defgroup InPorts Input port constants
 * Input port constants are used when calling NXC sensor control API functions.
 * @{
 */
#define S1 0 /*!< Input port 1 */
#define S2 1 /*!< Input port 2 */
#define S3 2 /*!< Input port 3 */
#define S4 3 /*!< Input port 4 */
/** @} */ // end of InPorts group

/** @addtogroup InputModuleTypesAndModes
 * @{
 */
/** @defgroup SensorTypes Sensor type constants
 *  Use sensor type constants to configure an input port for a specific type
 *  of sensor.
 *  \sa SetSensorType()
 *  @{
 */
#define SENSOR_TYPE_NONE            IN_TYPE_NO_SENSOR      /*!< No sensor configured */
#define SENSOR_TYPE_TOUCH           IN_TYPE_SWITCH         /*!< NXT or RCX touch sensor */
#define SENSOR_TYPE_TEMPERATURE     IN_TYPE_TEMPERATURE    /*!< RCX temperature sensor */
#define SENSOR_TYPE_LIGHT           IN_TYPE_REFLECTION     /*!< RCX light sensor */
#define SENSOR_TYPE_ROTATION        IN_TYPE_ANGLE          /*!< RCX rotation sensor */
#define SENSOR_TYPE_LIGHT_ACTIVE    IN_TYPE_LIGHT_ACTIVE   /*!< NXT light sensor with light */
#define SENSOR_TYPE_LIGHT_INACTIVE  IN_TYPE_LIGHT_INACTIVE /*!< NXT light sensor without light */
#define SENSOR_TYPE_SOUND_DB        IN_TYPE_SOUND_DB       /*!< NXT sound sensor with dB scaling */
#define SENSOR_TYPE_SOUND_DBA       IN_TYPE_SOUND_DBA      /*!< NXT sound sensor with dBA scaling */
#define SENSOR_TYPE_CUSTOM          IN_TYPE_CUSTOM         /*!< NXT custom sensor */
#define SENSOR_TYPE_LOWSPEED        IN_TYPE_LOWSPEED       /*!< NXT I2C digital sensor */
#define SENSOR_TYPE_LOWSPEED_9V     IN_TYPE_LOWSPEED_9V    /*!< NXT I2C digital sensor with 9V power */
#define SENSOR_TYPE_HIGHSPEED       IN_TYPE_HISPEED        /*!< NXT Hi-speed port (only S4) */
#if __FIRMWARE_VERSION > 107
#define SENSOR_TYPE_COLORFULL       IN_TYPE_COLORFULL      /*!< NXT 2.0 color sensor in full color mode */
#define SENSOR_TYPE_COLORRED        IN_TYPE_COLORRED       /*!< NXT 2.0 color sensor with red light */
#define SENSOR_TYPE_COLORGREEN      IN_TYPE_COLORGREEN     /*!< NXT 2.0 color sensor with green light */
#define SENSOR_TYPE_COLORBLUE       IN_TYPE_COLORBLUE      /*!< NXT 2.0 color sensor with blue light */
#define SENSOR_TYPE_COLORNONE       IN_TYPE_COLORNONE      /*!< NXT 2.0 color sensor with no light */
#endif
/** @} */ // end of SensorTypes group

/** @defgroup SensorModes Sensor mode constants
 * Use sensor mode constants to configure an input port for the desired
 * sensor mode.
 * \sa SetSensorMode()
 * @{
 */
#define SENSOR_MODE_RAW         IN_MODE_RAW           /*!< Raw value from 0 to 1023 */
#define SENSOR_MODE_BOOL        IN_MODE_BOOLEAN       /*!< Boolean value (0 or 1) */
#define SENSOR_MODE_EDGE        IN_MODE_TRANSITIONCNT /*!< Counts the number of boolean transitions */
#define SENSOR_MODE_PULSE       IN_MODE_PERIODCOUNTER /*!< Counts the number of boolean periods */
#define SENSOR_MODE_PERCENT     IN_MODE_PCTFULLSCALE  /*!< Scaled value from 0 to 100 */
#define SENSOR_MODE_CELSIUS     IN_MODE_CELSIUS       /*!< RCX temperature sensor value in degrees celcius */
#define SENSOR_MODE_FAHRENHEIT  IN_MODE_FAHRENHEIT    /*!< RCX temperature sensor value in degrees fahrenheit */
#define SENSOR_MODE_ROTATION    IN_MODE_ANGLESTEP     /*!< RCX rotation sensor (16 ticks per revolution) */
/** @} */ // end of SensorModes group

/** @defgroup SensorTypeModes Combined sensor type and mode constants
 * Use the combined sensor type and mode constants to configure both
 * the sensor mode and type in a single function call.
 * \sa SetSensor()
 * @{
 */
#define _SENSOR_CFG(_type,_mode)	(((_type)<<8)+(_mode))                               /*!< Macro for defining \ref SetSensor combined type and mode constants */
#define SENSOR_TOUCH		_SENSOR_CFG(SENSOR_TYPE_TOUCH, SENSOR_MODE_BOOL)             /*!< Touch sensor in boolean mode */
#define SENSOR_LIGHT		_SENSOR_CFG(SENSOR_TYPE_LIGHT, SENSOR_MODE_PERCENT)          /*!< RCX Light sensor in percent mode */
#define SENSOR_ROTATION		_SENSOR_CFG(SENSOR_TYPE_ROTATION, SENSOR_MODE_ROTATION)      /*!< RCX rotation sensor in rotation mode */
#define SENSOR_CELSIUS		_SENSOR_CFG(SENSOR_TYPE_TEMPERATURE, SENSOR_MODE_CELSIUS)    /*!< RCX temperature sensor in celcius mode */
#define SENSOR_FAHRENHEIT	_SENSOR_CFG(SENSOR_TYPE_TEMPERATURE, SENSOR_MODE_FAHRENHEIT) /*!< RCX temperature sensor in fahrenheit mode */
#define	SENSOR_PULSE		_SENSOR_CFG(SENSOR_TYPE_TOUCH, SENSOR_MODE_PULSE)            /*!< Touch sensor in pulse mode */
#define SENSOR_EDGE         _SENSOR_CFG(SENSOR_TYPE_TOUCH, SENSOR_MODE_EDGE)             /*!< Touch sensor in edge mode */
#define SENSOR_NXTLIGHT		_SENSOR_CFG(SENSOR_TYPE_LIGHT_ACTIVE, SENSOR_MODE_PERCENT)   /*!< NXT light sensor in active mode */
#define SENSOR_SOUND		_SENSOR_CFG(SENSOR_TYPE_SOUND_DB, SENSOR_MODE_PERCENT)       /*!< NXT sound sensor (dB) in percent mode */
#define SENSOR_LOWSPEED_9V  _SENSOR_CFG(SENSOR_TYPE_LOWSPEED_9V, SENSOR_MODE_RAW)        /*!< NXT I2C sensor with 9V power in raw mode */
#define SENSOR_LOWSPEED     _SENSOR_CFG(SENSOR_TYPE_LOWSPEED, SENSOR_MODE_RAW)           /*!< NXT I2C sensor without 9V power in raw mode */
#if __FIRMWARE_VERSION > 107
#define SENSOR_COLORFULL	_SENSOR_CFG(SENSOR_TYPE_COLORFULL, SENSOR_MODE_RAW)          /*!< NXT 2.0 color sensor (full) in raw mode */
#define SENSOR_COLORRED		_SENSOR_CFG(SENSOR_TYPE_COLORRED, SENSOR_MODE_PERCENT)       /*!< NXT 2.0 color sensor (red) in percent mode */
#define SENSOR_COLORGREEN	_SENSOR_CFG(SENSOR_TYPE_COLORGREEN, SENSOR_MODE_PERCENT)     /*!< NXT 2.0 color sensor (green) in percent mode */
#define SENSOR_COLORBLUE	_SENSOR_CFG(SENSOR_TYPE_COLORBLUE, SENSOR_MODE_PERCENT)      /*!< NXT 2.0 color sensor (blue) in percent mode */
#define SENSOR_COLORNONE	_SENSOR_CFG(SENSOR_TYPE_COLORNONE, SENSOR_MODE_PERCENT)      /*!< NXT 2.0 color sensor (none) in percent mode */
#endif
/** @} */ // end of SensorModes group
/** @} */ // end of InputModuleTypesAndModes group
/** @} */ // end of InputModuleConstants group

/** @defgroup InputModuleTypes Input module types
 * Types used by various input module functions.
 * @{
 */
#if __FIRMWARE_VERSION > 107
/**
 * Parameters for the ColorSensorRead system call.
 * This structure is used when calling the \ref SysColorSensorRead system call function.
 * Choose the sensor port (\ref InPorts) and after calling the function
 * read the sensor values from the ColorValue field or the raw, normalized, or
 * scaled value arrays.
 * \sa SysColorSensorRead()
 */
struct ColorSensorReadType {
 char Result;                    /*!< The function call result. \ref NO_ERR means it succeeded. */
 byte Port;                      /*!< The sensor port. See the constants in the \ref InPorts group. */
 int ColorValue;                 /*!< The color value returned by the sensor. See the \ref InputColorValueConstants group. */
 unsigned int RawArray[];        /*!< Raw color values returned by the sensor. See the \ref InputColorIdxConstants group. */
 unsigned int NormalizedArray[]; /*!< Normalized color values returned by the sensor. See the \ref InputColorIdxConstants group. */
 int ScaledArray[];              /*!< Scaled color values returned by the sensor. See the \ref InputColorIdxConstants group. */
 bool Invalid;                   /*!< Are the sensor values valid? */
};
#endif

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Parameters for the \ref RemoteGetInputValues function.
 * This structure is used when calling the \ref RemoteGetInputValues function.
 * Choose the sensor port (\ref InPorts) and after calling the function
 * read the sensor values from the various structure fields.
 */
struct InputValuesType {
  byte Port;                    /*!< The sensor port. See the \ref InPorts group. */
  bool Valid;                   /*!< Is the sensor value valid? */
  bool Calibrated;              /*!< Is the sensor calibrated? */
  byte SensorType;              /*!< The sensor type. See the \ref SensorTypes group. */
  byte SensorMode;              /*!< The sensor mode. See the \ref SensorModes group. */
  unsigned int RawValue;        /*!< The raw value. */
  unsigned int NormalizedValue; /*!< The normalized value. */
  int ScaledValue;              /*!< The scaled value. */
  int CalibratedValue;          /*!< The calibrated value. */
};

/*
struct InputType {
  unsigned int CustomZeroOffset;
  unsigned int ADRaw;
  unsigned int SensorRaw;
  int SensorValue;
  byte SensorType;
  byte SensorMode;
  bool SensorBoolean;
  byte DigiPinsDir;
  byte DigiPinsIn;
  byte DigiPinsOut;
  byte CustomPctFullScale;
  byte CustomActiveStatus;
  bool InvalidData;
};
*/

/**
 * Parameters for the InputPinFunction system call.
 * This structure is used when calling the \ref SysInputPinFunction system call
 * function.
 * \sa SysInputPinFunction()
 */
struct InputPinFunctionType {
  unsigned int Result; /*!< The function call result. Possible return values are
                            ERR_INVALID_PORT or NO_ERR. */
  byte Cmd;            /*!< The command to execute. See \ref InputPinFuncConstants.
                            You can add a microsecond wait after the command by
                            ORing INPUT_PINCMD_WAIT(usec) with the command value.
                            Wait times can range from 1 to 63 microseconds. */
  byte Port;           /*!< The input port. See \ref InPorts. */
  byte Pin;            /*!< The digital pin(s). See \ref InputDigiPinConstants.
                            When setting pin direction you must OR the desired
                            direction constant into this field.  See
                            INPUT_PINDIR_INPUT and INPUT_PINDIR_OUTPUT
                            from the \ref InputPinFuncConstants group. You
                            can OR together the digital pin constants to
                            operate on both in a single call. */
  byte Data;           /*!< The pin value(s). This field is only used by the
                            INPUT_PINCMD_READ command. */
};


#endif

/** @} */ // end of InputModuleTypes group

/** @defgroup InputModuleFunctions Input module functions
 * Functions for accessing and modifying input module features.
 * @{
 */

/** @defgroup BasicSensorValues Basic analog sensor value names
 * Read analog sensor values using these names.  Returns the current scaled value
 * of the sensor on the specified port.
 * @{
 */
#define SENSOR_1 Sensor(S1) /*!< Read the value of the analog sensor on port S1 */
#define SENSOR_2 Sensor(S2) /*!< Read the value of the analog sensor on port S2 */
#define SENSOR_3 Sensor(S3) /*!< Read the value of the analog sensor on port S3 */
#define SENSOR_4 Sensor(S4) /*!< Read the value of the analog sensor on port S4 */
/** @} */ // end of BasicSensorValues group

/**
 * Set sensor type.
 * Set a sensor's type, which must be one of the predefined sensor type
 * constants.  After changing the type or the mode of a sensor
 * port you must call \ref ResetSensor to give the firmware time to reconfigure
 * the sensor port.
 * \sa SetSensorMode(), SetSensor()
 * \param port The port to configure. See \ref InPorts.
 * \param type The desired sensor type.  See \ref SensorTypes.
 */
inline void SetSensorType(const byte & port, byte type) { asm { setin type, port, TypeField } }

/**
 * Set sensor mode.
 * Set a sensor's mode, which should be one of the predefined sensor mode
 * constants. A slope parameter for boolean conversion, if desired, may be
 * added to the mode. After changing the type or the mode of a sensor
 * port you must call \ref ResetSensor to give the firmware time to reconfigure
 * the sensor port.
 * \sa SetSensorType(), SetSensor()
 * \param port The port to configure. See \ref InPorts.
 * \param mode The desired sensor mode. See \ref SensorModes.
 */
inline void SetSensorMode(const byte & port, byte mode) { asm { setin mode, port, InputModeField } }

/**
 * Clear a sensor value.
 * Clear the value of a sensor - only affects sensors that are configured
 * to measure a cumulative quantity such as rotation or a pulse count.
 * \param port The port to clear. See \ref InPorts.
 */
inline void ClearSensor(const byte & port) { asm { setin 0, port, ScaledValueField } }

/**
 * Reset the sensor port.
 * Sets the invalid data flag on the specified port and waits for it to
 * become valid again. After changing the type or the mode of a sensor
 * port you must call this function to give the firmware time to reconfigure
 * the sensor port.
 * \param port The port to reset. See \ref InPorts.
 */
inline void ResetSensor(const byte & port) { asm { __ResetSensor(port) } }

/**
 * Set sensor configuration.
 * Set the type and mode of the given sensor to the specified configuration,
 * which must be a special constant containing both type and mode information.
 * \sa SetSensorType(), SetSensorMode(), and ResetSensor()
 * \param port The port to configure. See \ref InPorts.
 * \param config The configuration constant containing both the type and mode.
 * See \ref SensorTypeModes.
 */
inline void SetSensor(const byte & port, const unsigned int config) {
  asm {
    setin config>>8, port, TypeField
    setin config&0xff, port, InputModeField
    __ResetSensor(port)
  }
}

/**
 * Configure a touch sensor.
 * Configure the sensor on the specified port as a touch sensor.
 * \param port The port to configure. See \ref InPorts.
 */
inline void SetSensorTouch(const byte & port) { asm { __SetSensorTouch(port) } }

/**
 * Configure a light sensor.
 * Configure the sensor on the specified port as an NXT light sensor.
 * \param port The port to configure. See \ref InPorts.
 * \param bActive A boolean flag indicating whether to configure the port
 * as an active or inactive light sensor.  The default value for this
 * optional parameter is true.
 */
inline void SetSensorLight(const byte & port, bool bActive = true) {
  SetSensorType(port, bActive ? SENSOR_TYPE_LIGHT_ACTIVE : SENSOR_TYPE_LIGHT_INACTIVE);
  SetSensorMode(port, SENSOR_MODE_PERCENT);
  ResetSensor(port);
}

/**
 * Configure a sound sensor.
 * Configure the sensor on the specified port as a sound sensor.
 * \param port The port to configure. See \ref InPorts.
 * \param bdBScaling A boolean flag indicating whether to configure the port
 * as a sound sensor with dB or dBA scaling.  The default value for this
 * optional parameter is true, meaning dB scaling.
 */
inline void SetSensorSound(const byte & port, bool bdBScaling = true) {
  SetSensorType(port, bdBScaling ? SENSOR_TYPE_SOUND_DB : SENSOR_TYPE_SOUND_DBA);
  SetSensorMode(port, SENSOR_MODE_PERCENT);
  ResetSensor(port);
}

/**
 * Configure an I2C sensor.
 * Configure the sensor on the specified port as an I2C digital sensor
 * for either powered (9 volt) or unpowered devices.
 * \param port The port to configure. See \ref InPorts.
 * \param bIsPowered A boolean flag indicating whether to configure the port
 * for powered or unpowered I2C devices.  The default value for this
 * optional parameter is true.
 */
inline void SetSensorLowspeed(const byte & port, bool bIsPowered = true) {
  SetSensorType(port, bIsPowered ? SENSOR_TYPE_LOWSPEED_9V : SENSOR_TYPE_LOWSPEED);
  SetSensorMode(port, SENSOR_MODE_RAW);
  ResetSensor(port);
}

/**
 * Configure an ultrasonic sensor.
 * Configure the sensor on the specified port as an ultrasonic sensor.
 * \param port The port to configure. See \ref InPorts.
 */
inline void SetSensorUltrasonic(const byte & port) { SetSensorLowspeed(port); }

/**
 * Configure an EMeter sensor.
 * Configure the sensor on the specified port as an EMeter sensor.
 * \param port The port to configure. See \ref InPorts.
 */
inline void SetSensorEMeter(const byte & port) { SetSensorLowspeed(port); }

/**
 * Configure a temperature sensor.
 * Configure the sensor on the specified port as a temperature sensor. Use this
 * to setup the temperature sensor rather than \ref SetSensorLowspeed so that
 * the sensor is properly configured in 12-bit conversion mode.
 * \param port The port to configure. See \ref InPorts.
 */
inline void SetSensorTemperature(const byte & port) {
  SetSensorLowspeed(port);
  asm {
    __MSWriteToRegister(port, LEGO_ADDR_TEMP, TEMP_REG_CONFIG, TEMP_RES_12BIT, __WDSC_LSStatus)
  }
}


#if __FIRMWARE_VERSION > 107

/**
 * Configure an NXT 2.0 full color sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in full color mode. Requires an NXT 2.0 compatible firmware.
 * \param port The port to configure. See \ref InPorts.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SetSensorColorFull(const byte & port) { asm { __SetSensorColorFull(port) } }

/**
 * Configure an NXT 2.0 red light sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in red light mode. Requires an NXT 2.0 compatible firmware.
 * \param port The port to configure. See \ref InPorts.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SetSensorColorRed(const byte & port) { asm { __SetSensorColorRed(port) } }

/**
 * Configure an NXT 2.0 green light sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in green light mode. Requires an NXT 2.0 compatible firmware.
 * \param port The port to configure. See \ref InPorts.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SetSensorColorGreen(const byte & port) { asm { __SetSensorColorGreen(port) } }

/**
 * Configure an NXT 2.0 blue light sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in blue light mode. Requires an NXT 2.0 compatible firmware.
 * \param port The port to configure. See \ref InPorts.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SetSensorColorBlue(const byte & port) { asm { __SetSensorColorBlue(port) } }

/**
 * Configure an NXT 2.0 no light sensor.
 * Configure the sensor on the specified port as an NXT 2.0 color sensor
 * in no light mode. Requires an NXT 2.0 compatible firmware.
 * \param port The port to configure. See \ref InPorts.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SetSensorColorNone(const byte & port) { asm { __SetSensorColorNone(port) } }

#endif

#ifdef __DOXYGEN_DOCS

/**
 * Get an input field value.
 * Return the value of the specified field of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts.  A constant or a variable may
 * be used (no expressions).
 * \param field An input field constant.  See \ref InputFieldConstants.
 * \return The input field value.
 */
inline variant GetInput(const byte & port, const byte field);

/**
 * Set an input field value.
 * Set the specified field of the sensor on the specified port to the value
 * provided.
 *
 * \param port The sensor port. See \ref InPorts. A constant or a variable
 * may be used (no expressions).
 * \param field An input field constant. See \ref InputFieldConstants.
 * \param value The new value, which may be any valid expression.
 */
inline void SetInput(const byte & port, const int field, variant value);

/**
 * Read sensor scaled value.
 * Return the processed sensor reading for a sensor on the specified port.
 * This is the same value that is returned by the sensor value names
 * (e.g. \ref SENSOR_1).
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's scaled value.
 */
inline unsigned int Sensor(const byte & port);

/**
 * Read sensor boolean value.
 * Return the boolean value of a sensor on the specified port. Boolean
 * conversion is either done based on preset cutoffs, or a slope parameter
 * specified by calling SetSensorMode.
 *
 * \param port The sensor port. See \ref InPorts. Must be a constant.
 * \return The sensor's boolean value.
 */
inline bool SensorBoolean(const byte port);

/**
 * Read sensor digital pins direction.
 * Return the digital pins direction value of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. Must be a constant.
 * \return The sensor's digital pins direction.
 */
inline byte SensorDigiPinsDirection(const byte port);

/**
 * Read sensor digital pins output level.
 * Return the digital pins output level value of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. Must be a constant.
 * \return The sensor's digital pins output level.
 */
inline byte SensorDigiPinsOutputLevel(const byte port);

/**
 * Read sensor digital pins status.
 * Return the digital pins status value of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. Must be a constant.
 * \return The sensor's digital pins status.
 */
inline byte SensorDigiPinsStatus(const byte port);

/**
 * Read sensor invalid data flag.
 * Return the value of the InvalidData flag of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's invalid data flag.
 */
inline bool SensorInvalid(const byte & port);

/**
 * Read sensor mode.
 * Return the mode of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's mode. See \ref SensorModes.
 */
inline byte SensorMode(const byte & port);

/**
 * Read sensor normalized value.
 * Return the normalized value of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's normalized value.
 */
inline unsigned int SensorNormalized(const byte & port);

/**
 * Read sensor raw value.
 * Return the raw value of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's raw value.
 */
inline unsigned int SensorRaw(const byte & port);

/**
 * Read sensor scaled value.
 * Return the processed sensor reading for a sensor on the specified port.
 * This is the same value that is returned by the sensor value names
 * (e.g. \ref SENSOR_1) or the \ref Sensor function.
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's scaled value.
 */
inline unsigned int SensorScaled(const byte & port);

/**
 * Read sensor type.
 * Return the type of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's type. See \ref SensorTypes.
 */
inline byte SensorType(const byte & port);

/**
 * Read sensor scaled value.
 * Return the processed sensor reading for a sensor on the specified port.
 * This is the same value that is returned by the sensor value names
 * (e.g. \ref SENSOR_1) or the \ref Sensor function.
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's scaled value.
 */
inline unsigned int SensorValue(const byte & port);

/**
 * Read sensor boolean value.
 * Return the boolean value of a sensor on the specified port. Boolean
 * conversion is either done based on preset cutoffs, or a slope parameter
 * specified by calling SetSensorMode.
 *
 * \param port The sensor port. See \ref InPorts. Must be a constant.
 * \return The sensor's boolean value.
 */
inline bool SensorValueBool(const byte port);

/**
 * Read sensor raw value.
 * Return the raw value of a sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts. A variable whose value is
 * the desired sensor port may also be used.
 * \return The sensor's raw value.
 */
inline unsigned int SensorValueRaw(const byte & port);

/**
 * Get the custom sensor active status.
 * Return the custom sensor active status value of a sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The custom sensor active status.
*/
inline byte CustomSensorActiveStatus(byte port);

/**
 * Get the custom sensor percent full scale.
 * Return the custom sensor percent full scale value of a sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The custom sensor percent full scale.
 */
inline byte CustomSensorPercentFullScale(byte port);

/**
 * Get the custom sensor zero offset.
 * Return the custom sensor zero offset value of a sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The custom sensor zero offset.
 */
inline unsigned int CustomSensorZeroOffset(byte port);

/**
 * Set active status.
 * Sets the active status value of a custom sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param activeStatus The new active status value.
 */
inline void SetCustomSensorActiveStatus(byte port, byte activeStatus);

/**
 * Set percent full scale.
 * Sets the percent full scale value of a custom sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param pctFullScale The new percent full scale value.
 */
inline void SetCustomSensorPercentFullScale(byte port, byte pctFullScale);

/**
 * Set custom zero offset.
 * Sets the zero offset value of a custom sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param zeroOffset The new zero offset value.
 */
inline void SetCustomSensorZeroOffset(byte port, int zeroOffset);

/**
 * Set sensor boolean value.
 * Sets the boolean value of a sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param value The new boolean value.
 */
inline void SetSensorBoolean(byte port, bool value);

/**
 * Set digital pins direction.
 * Sets the digital pins direction value of a sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param direction The new digital pins direction value.
 */
inline void SetSensorDigiPinsDirection(byte port, byte direction);

/**
 * Set digital pins output level.
 * Sets the digital pins output level value of a sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param outputLevel The new digital pins output level value.
 */
inline void SetSensorDigiPinsOutputLevel(byte port, byte outputLevel);

/**
 * Set digital pins status.
 * Sets the digital pins status value of a sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param status The new digital pins status value.
 */
inline void SetSensorDigiPinsStatus(byte port, byte status);


#if __FIRMWARE_VERSION > 107
/**
 * Read LEGO color sensor.
 * This function lets you read the LEGO color sensor given the parameters you
 * pass in via the \ref ColorSensorReadType structure.
 *
 * \param args The ColorSensorReadType structure containing the required parameters.
 * 
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysColorSensorRead(ColorSensorReadType & args);

/**
 * Read LEGO color sensor extra.
 * This function lets you read the LEGO color sensor. It returns the color value,
 * and three arrays containing raw, normalized, and scaled color values for
 * red, green, blue, and none indices.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param colorval The color value. See \ref InputColorValueConstants.
 * \param raw An array containing four raw color values. See \ref InputColorIdxConstants.
 * \param norm An array containing four normalized color values. See \ref InputColorIdxConstants.
 * \param scaled An array containing four scaled color values. See \ref InputColorIdxConstants.
 * \return The function call result.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline int ReadSensorColorEx(const byte & port, int & colorval, unsigned int & raw[], unsigned int & norm[], int & scaled[]);

/**
 * Read LEGO color sensor raw values.
 * This function lets you read the LEGO color sensor. It returns an array
 * containing raw color values for red, green, blue, and none indices.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param rawVals An array containing four raw color values. See \ref InputColorIdxConstants.
 * \return The function call result.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline int ReadSensorColorRaw(const byte & port, unsigned int & rawVals[]);

/**
 * Read a LEGO color sensor AD raw value.
 * This function lets you directly access a specific LEGO color sensor AD raw value. Both the
 * port and the color index must be constants.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param color The color index. See \ref InputColorIdxConstants.
 * \return The AD raw value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline unsigned int ColorADRaw(byte port, byte color);

/**
 * Read a LEGO color sensor boolean value.
 * This function lets you directly access a specific LEGO color sensor boolean value. Both the
 * port and the color index must be constants.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param color The color index. See \ref InputColorIdxConstants.
 * \return The boolean value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline bool ColorBoolean(byte port, byte color);

/**
 * Read a LEGO color sensor calibration point value.
 * This function lets you directly access a specific LEGO color calibration point value.
 * The port, point, and color index must be constants.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param point The calibration point. See \ref InputColorCalibrationConstants.
 * \param color The color index. See \ref InputColorIdxConstants.
 * \return The calibration point value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline long ColorCalibration(byte port, byte point, byte color);

/**
 * Read LEGO color sensor calibration state.
 * This function lets you directly access the LEGO color calibration state.
 * The port must be a constant.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The calibration state.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline byte ColorCalibrationState(byte port);

/**
 * Read a LEGO color sensor calibration limit value.
 * This function lets you directly access a specific LEGO color calibration limit value.
 * The port and the point must be constants.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param point The calibration point. See \ref InputColorCalibrationConstants.
 * \return The calibration limit value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline unsigned int ColorCalLimits(byte port, byte point);

/**
 * Read a LEGO color sensor raw value.
 * This function lets you directly access a specific LEGO color sensor raw value. Both the
 * port and the color index must be constants.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param color The color index. See \ref InputColorIdxConstants.
 * \return The raw value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline unsigned int ColorSensorRaw(byte port, byte color);

/**
 * Read a LEGO color sensor scaled value.
 * This function lets you directly access a specific LEGO color sensor scaled value. Both the
 * port and the color index must be constants.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param color The color index. See \ref InputColorIdxConstants.
 * \return The scaled value.
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline unsigned int ColorSensorValue(byte port, byte color);

#ifdef __ENHANCED_FIRMWARE
/**
 * Execute the Input module pin function.
 * This function lets you execute the Input module's pin function using the
 * values specified via the \ref InputPinFunctionType structure.
 *
 * \param args The InputPinFunctionType structure containing the required parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SysInputPinFunction(InputPinFunctionType & args);
#endif

#endif

#else

enum InputFieldNames {
  Type,
  InputMode,
  RawValue,
  NormalizedValue,
  ScaledValue,
  InvalidData
};

// input fields
#define Sensor(_p) asm { ReadSensor(_p, __RETVAL__) }
#define SensorValue(_p) Sensor(_p)
#define SensorType(_p) GetInput(_p, TypeField)
#define SensorMode(_p) GetInput(_p, InputModeField)
#define SensorRaw(_p) GetInput(_p, RawValueField)
#define SensorNormalized(_p) GetInput(_p, NormalizedValueField)
#define SensorScaled(_p) GetInput(_p, ScaledValueField)
#define SensorInvalid(_p) GetInput(_p, InvalidDataField)
#define SensorValueBool(_p) SensorBoolean(_p)
#define SensorValueRaw(_p) SensorRaw(_p)

#define CustomSensorZeroOffset(_p) asm { GetInCustomZeroOffset(_p, __TMPWORD__) __RETURN__ __TMPWORD__ }
#define CustomSensorPercentFullScale(_p) asm { GetInCustomPercentFullScale(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define CustomSensorActiveStatus(_p) asm { GetInCustomActiveStatus(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SensorBoolean(_p) asm { GetInSensorBoolean(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SensorDigiPinsDirection(_p) asm { GetInDigiPinsDirection(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SensorDigiPinsStatus(_p) asm { GetInDigiPinsStatus(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SensorDigiPinsOutputLevel(_p) asm { GetInDigiPinsOutputLevel(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }

#define SetCustomSensorZeroOffset(_p, _n) asm { __setInCustomZeroOffset(_p, _n) }
#define SetCustomSensorPercentFullScale(_p, _n) asm { __setInCustomPercentFullScale(_p, _n) }
#define SetCustomSensorActiveStatus(_p, _n) asm { __setInCustomActiveStatus(_p, _n) }
#define SetSensorBoolean(_p, _n) asm { __setInSensorBoolean(_p, _n) }
#define SetSensorDigiPinsDirection(_p, _n) asm { __setInDigiPinsDirection(_p, _n) }
#define SetSensorDigiPinsStatus(_p, _n) asm { __setInDigiPinsStatus(_p, _n) }
#define SetSensorDigiPinsOutputLevel(_p, _n) asm { __setInDigiPinsOutputLevel(_p, _n) }


#if __FIRMWARE_VERSION > 107

#define SysColorSensorRead(_args) asm { \
  compchktype _args, ColorSensorReadType \
  syscall ColorSensorRead, _args \
}

#define ReadSensorColorRaw(_port, _rawVals) asm { __ReadSensorColorRaw(_port, _rawVals, __RETVAL__) }
#define ReadSensorColorEx(_port, _colorval, _raw, _norm, _scaled) asm { __ReadSensorColorEx(_port, _colorval, _raw, _norm, _scaled, __RETVAL__) }

#define ColorCalibration(_p, _np, _nc) asm { GetInColorCalibration(_p, _np, _nc, __TMPLONG__) __RETURN__ __TMPLONG__ }
#define ColorCalLimits(_p, _np) asm { GetInColorCalLimits(_p, _np, __TMPWORD__) __RETURN__ __TMPWORD__ }
#define ColorADRaw(_p, _nc) asm { GetInColorADRaw(_p, _nc, __TMPWORD__) __RETURN__ __TMPWORD__ }
#define ColorSensorRaw(_p, _nc) asm { GetInColorSensorRaw(_p, _nc, __TMPWORD__) __RETURN__ __TMPWORD__ }
#define ColorSensorValue(_p, _nc) asm { GetInColorSensorValue(_p, _nc, __TMPWORD__) __RETURN__ __TMPWORD__ }
#define ColorBoolean(_p, _nc) asm { GetInColorBoolean(_p, _nc, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define ColorCalibrationState(_p) asm { GetInColorCalibrationState(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }

#ifdef __ENHANCED_FIRMWARE
#define SysInputPinFunction(_args) asm { \
  compchktype _args, InputPinFunctionType \
  syscall InputPinFunction, _args \
}
#endif

#endif

#endif
/** @} */ // end of InputModuleFunctions group
/** @} */ // end of InputModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// OUTPUT MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup OutputModule
 * @{
 */
/** @defgroup OutputModuleTypes Output module types
 * Types used by various output module functions.
 * @{
 */

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Parameters for the \ref RemoteGetOutputState function.
 * This structure is used when calling the \ref RemoteGetOutputState function.
 * Choose the sensor port (\ref OutputPortConstants) and after calling the function
 * read the output status values from the various structure fields.
 */
struct OutputStateType {
  byte Port;                /*!< The output port. See the \ref OutputPortConstants group. */
  char Power;               /*!< The output power level (-100..100). */
  byte Mode;                /*!< The output mode. See \ref OutModeConstants group. */
  byte RegMode;             /*!< The output regulation mode. See \ref OutRegModeConstants group. */
  char TurnRatio;           /*!< The output turning ratio (-100..100). */
  byte RunState;            /*!< The output run state. See \ref OutRunStateConstants group. */
  unsigned long TachoLimit; /*!< The tachometer limit. */
  long TachoCount;          /*!< The current tachometer count. */
  long BlockTachoCount;     /*!< The current block tachometer count. */
  long RotationCount;       /*!< The current rotation count. */
};

#endif

/** @} */ // end of OutputModuleTypes group

/** @defgroup OutputModuleFunctions Output module functions
 * Functions for accessing and modifying output module features.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Set motor regulation frequency.
 * Set the motor regulation frequency in milliseconds. By default this is set
 * to 100ms.
 * \param n The motor regulation frequency.
 */
inline void SetMotorPwnFreq(byte n);

/**
 * Set regulation time.
 * Set the motor regulation time in milliseconds. By default this is set
 * to 100ms.
 *
 *
 * \param n The motor regulation time.
 */
inline void SetMotorRegulationTime(byte n);

/**
 * Set regulation options.
 * Set the motor regulation options.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \param n The motor regulation options.
 */
inline void SetMotorRegulationOptions(byte n);

/**
 * Run motors forward synchronised with PID factors.
 * Run the specified outputs forward with regulated synchronization using the
 * specified turn ratio.
 * Specify proportional, integral, and derivative factors.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void OnFwdSyncPID(byte outputs, char pwr, char turnpct, byte p, byte i, byte d);

/**
 * Run motors forward synchronised and reset counters with PID factors.
 * Run the specified outputs forward with regulated synchronization using the
 * specified turn ratio.
 * Specify proportional, integral, and derivative factors.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void OnFwdSyncExPID(byte outputs, char pwr, char turnpct, const byte reset, byte p, byte i, byte d);

/**
 * Run motors backward synchronised with PID factors.
 * Run the specified outputs in reverse with regulated synchronization using
 * the specified turn ratio.
 * Specify proportional, integral, and derivative factors.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void OnRevSyncPID(byte outputs, char pwr, char turnpct, byte p, byte i, byte d);

/**
 * Run motors backward synchronised and reset counters with PID factors.
 * Run the specified outputs in reverse with regulated synchronization using
 * the specified turn ratio.
 * Specify proportional, integral, and derivative factors.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void OnRevSyncExPID(byte outputs, char pwr, char turnpct, const byte reset, byte p, byte i, byte d);

/**
 * Run motors forward regulated with PID factors.
 * Run the specified outputs forward using the specified regulation mode.
 * Specify proportional, integral, and derivative factors.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param regmode Regulation mode, see \ref OutRegModeConstants.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void OnFwdRegPID(byte outputs, char pwr, byte regmode, byte p, byte i, byte d);

/**
 * Run motors forward regulated and reset counters with PID factors.
 * Run the specified outputs forward using the specified regulation mode.
 * Specify proportional, integral, and derivative factors.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param regmode Regulation mode, see \ref OutRegModeConstants.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void OnFwdRegExPID(byte outputs, char pwr, byte regmode, const byte reset, byte p, byte i, byte d);

/**
 * Run motors reverse regulated with PID factors.
 * Run the specified outputs in reverse using the specified regulation mode.
 * Specify proportional, integral, and derivative factors.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param regmode Regulation mode, see \ref OutRegModeConstants.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void OnRevRegPID(byte outputs, char pwr, byte regmode, byte p, byte i, byte d);

/**
 * Run motors backward regulated and reset counters with PID factors.
 * Run the specified outputs in reverse using the specified regulation mode.
 * Specify proportional, integral, and derivative factors.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param regmode Regulation mode, see \ref OutRegModeConstants.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void OnRevRegExPID(byte outputs, char pwr, byte regmode, const byte reset, byte p, byte i, byte d);

/**
 * Turn motors off.
 * Turn the specified outputs off (with braking).
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 */
inline void Off(byte outputs);

/**
 * Turn motors off and reset counters.
 * Turn the specified outputs off (with braking).
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
inline void OffEx(byte outputs, const byte reset);

/**
 * Coast motors.
 * Turn off the specified outputs, making them coast to a stop.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 */
inline void Coast(byte outputs);

/**
 * Coast motors and reset counters.
 * Turn off the specified outputs, making them coast to a stop.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
inline void CoastEx(byte outputs, const byte reset);

/**
 * Float motors.
 * Make outputs float. Float is an alias for Coast.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 */
inline void Float(byte outputs);

/**
 * Run motors forward.
 * Set outputs to forward direction and turn them on.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 */
inline void OnFwd(byte outputs, char pwr);

/**
 * Run motors forward and reset counters.
 * Set outputs to forward direction and turn them on.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
inline void OnFwdEx(byte outputs, char pwr, const byte reset);

/**
 * Run motors backward.
 * Set outputs to reverse direction and turn them on.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 */
inline void OnRev(byte outputs, char pwr);

/**
 * Run motors backward and reset counters.
 * Set outputs to reverse direction and turn them on.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
inline void OnRevEx(byte outputs, char pwr, const byte reset);

/**
 * Run motors forward regulated.
 * Run the specified outputs forward using the specified regulation mode.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param regmode Regulation mode, see \ref OutRegModeConstants.
 */
inline void OnFwdReg(byte outputs, char pwr, byte regmode);

/**
 * Run motors forward regulated and reset counters.
 * Run the specified outputs forward using the specified regulation mode.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param regmode Regulation mode, see \ref OutRegModeConstants.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
inline void OnFwdRegEx(byte outputs, char pwr, byte regmode, const byte reset);

/**
 * Run motors forward regulated.
 * Run the specified outputs in reverse using the specified regulation mode.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param regmode Regulation mode, see \ref OutRegModeConstants.
 */
inline void OnRevReg(byte outputs, char pwr, byte regmode);

/**
 * Run motors backward regulated and reset counters.
 * Run the specified outputs in reverse using the specified regulation mode.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param regmode Regulation mode, see \ref OutRegModeConstants.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
inline void OnRevRegEx(byte outputs, char pwr, byte regmode, const byte reset);

/**
 * Run motors forward synchronised.
 * Run the specified outputs forward with regulated synchronization using the
 * specified turn ratio.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 */
inline void OnFwdSync(byte outputs, char pwr, char turnpct);

/**
 * Run motors forward synchronised and reset counters.
 * Run the specified outputs forward with regulated synchronization using the
 * specified turn ratio.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
inline void OnFwdSyncEx(byte outputs, char pwr, char turnpct, const byte reset);

/**
 * Run motors backward synchronised.
 * Run the specified outputs in reverse with regulated synchronization using
 * the specified turn ratio.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 */
inline void OnRevSync(byte outputs, char pwr, char turnpct);

/**
 * Run motors backward synchronised and reset counters.
 * Run the specified outputs in reverse with regulated synchronization using
 * the specified turn ratio.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param reset Position counters reset control. It must be a constant, see
 * \ref TachoResetConstants.
 */
inline void OnRevSyncEx(byte outputs, char pwr, char turnpct, const byte reset);

/**
 * Rotate motor.
 * Run the specified outputs forward for the specified number of degrees.
 * 
 * The motor API functions are thread-safe and blocking on the motor resource(s) 
 * requested. If you call RotateMotor(OUT_AB, 75, 3600) then no other thread will be able 
 * to control motors A and B until the already executing RotateMotor function finishes. 
 * But now you can safely call RotateMotor(OUT_A, 75, 3600) on one thread and 
 * RotateMotor(OUT_B, 75, 720) on another simultaneously executing thread without having 
 * program errors or erratic motor behavior. 
 * 
 * Since the functions do not know at compile time which port is being utilized when you 
 * use a variable as the port parameter, the RotateMotor functions acquire all three 
 * motor port resources for the duration of their operation in that case. So you can 
 * safely call RotateMotor using a variable for the port parameter on two 
 * simultaneously executing threads but one of the two calls will be blocked until
 * the first one has completed executing.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param angle Angle limit, in degree. Can be negative to reverse direction.
 */
inline void RotateMotor(byte outputs, char pwr, long angle);

/**
 * Rotate motor with PID factors.
 * Run the specified outputs forward for the specified number of degrees.
 * Specify proportional, integral, and derivative factors.
 * 
 * The motor API functions are thread-safe and blocking on the motor resource(s) 
 * requested. If you call RotateMotor(OUT_AB, 75, 3600) then no other thread will be able 
 * to control motors A and B until the already executing RotateMotor function finishes. 
 * But now you can safely call RotateMotor(OUT_A, 75, 3600) on one thread and 
 * RotateMotor(OUT_B, 75, 720) on another simultaneously executing thread without having 
 * program errors or erratic motor behavior. 
 * 
 * Since the functions do not know at compile time which port is being utilized when you 
 * use a variable as the port parameter, the RotateMotor functions acquire all three 
 * motor port resources for the duration of their operation in that case. So you can 
 * safely call RotateMotor using a variable for the port parameter on two 
 * simultaneously executing threads but one of the two calls will be blocked until
 * the first one has completed executing.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param angle Angle limit, in degree. Can be negative to reverse direction.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void RotateMotorPID(byte outputs, char pwr, long angle, byte p, byte i, byte d);

/**
 * Rotate motor Ex.
 * Run the specified outputs forward for the specified number of degrees. Also specify
 * synchronization, turn percentage, and braking options.  Use this function primarily
 * with more than one motor specified via the outputs parameter.
 * 
 * The motor API functions are thread-safe and blocking on the motor resource(s) 
 * requested. If you call RotateMotor(OUT_AB, 75, 3600) then no other thread will be able 
 * to control motors A and B until the already executing RotateMotor function finishes. 
 * But now you can safely call RotateMotor(OUT_A, 75, 3600) on one thread and 
 * RotateMotor(OUT_B, 75, 720) on another simultaneously executing thread without having 
 * program errors or erratic motor behavior. 
 * 
 * Since the functions do not know at compile time which port is being utilized when you 
 * use a variable as the port parameter, the RotateMotor functions acquire all three 
 * motor port resources for the duration of their operation in that case. So you can 
 * safely call RotateMotor using a variable for the port parameter on two 
 * simultaneously executing threads but one of the two calls will be blocked until
 * the first one has completed executing.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param angle Angle limit, in degree. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param sync Synchronise two motors. Should be set to true if a non-zero
 * turn percent is specified or no turning will occur.
 * \param stop Specify whether the motor(s) should brake at the end of the
 * rotation.
 */
inline void RotateMotorEx(byte outputs, char pwr, long angle, char turnpct, bool sync, bool stop);

/**
 * Rotate motor Ex with PID factors.
 * Run the specified outputs forward for the specified number of degrees.
 * Specify proportional, integral, and derivative factors. Also specify
 * synchronization, turn percentage, and braking options.  Use this function primarily
 * with more than one motor specified via the outputs parameter.
 * 
 * The motor API functions are thread-safe and blocking on the motor resource(s) 
 * requested. If you call RotateMotor(OUT_AB, 75, 3600) then no other thread will be able 
 * to control motors A and B until the already executing RotateMotor function finishes. 
 * But now you can safely call RotateMotor(OUT_A, 75, 3600) on one thread and 
 * RotateMotor(OUT_B, 75, 720) on another simultaneously executing thread without having 
 * program errors or erratic motor behavior. 
 * 
 * Since the functions do not know at compile time which port is being utilized when you 
 * use a variable as the port parameter, the RotateMotor functions acquire all three 
 * motor port resources for the duration of their operation in that case. So you can 
 * safely call RotateMotor using a variable for the port parameter on two 
 * simultaneously executing threads but one of the two calls will be blocked until
 * the first one has completed executing.
 * 
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. If you use a variable and want to control multiple
 * outputs in a single call you need to use a byte array rather than a byte and
 * store the output port values in the byte array before passing it into this function.
 * \param pwr Output power, 0 to 100. Can be negative to reverse direction.
 * \param angle Angle limit, in degree. Can be negative to reverse direction.
 * \param turnpct Turn ratio, -100 to 100. The direction of your vehicle will
 * depend on its construction.
 * \param sync Synchronise two motors. Should be set to true if a non-zero
 * turn percent is specified or no turning will occur.
 * \param stop Specify whether the motor(s) should brake at the end of the
 * rotation.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants.
 */
inline void RotateMotorExPID(byte outputs, char pwr, long angle, char turnpct, bool sync, bool stop, byte p, byte i, byte d);

/**
 * Reset tachometer counter.
 * Reset the tachometer count and tachometer limit goal for the specified
 * outputs.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 */
inline void ResetTachoCount(byte outputs);

/**
 * Reset block-relative counter.
 * Reset the block-relative position counter for the specified outputs.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 */
inline void ResetBlockTachoCount(byte outputs);

/**
 * Reset program-relative counter.
 * Reset the program-relative position counter for the specified outputs.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 */
inline void ResetRotationCount(byte outputs);

/**
 * Reset all tachometer counters.
 * Reset all three position counters and reset the current tachometer limit
 * goal for the specified outputs.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 */
inline void ResetAllTachoCounts(byte outputs);

/**
 * Set output fields.
 * Set the specified field of the outputs to the value provided. The field
 * must be a valid output field constant. This function takes a variable
 * number of field/value pairs.
 *
 * \param outputs Desired output ports. Can be a constant or a variable, see
 * \ref OutputPortConstants. For multiple outputs at the same time
 * you need to add single output port values into a byte array and pass the array
 * instead of a single numeric value.
 * \param field1 The 1st output port field to access, this should be a constant, see
 * \ref OutputFieldConstants.
 * \param val1 Value to set for the 1st field.
 * \param fieldN The Nth output port field to access, this should be a constant, see
 * \ref OutputFieldConstants.
 * \param valN The value to set for the Nth field.
 */
inline void SetOutput(byte outputs, byte field1, variant val1, ..., byte fieldN, variant valN);

/**
 * Get output field value.
 * Get the value of the specified field for the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \param field Output port field to access, this should be a constant, see
 * \ref OutputFieldConstants.
 * \return The requested output field value.
 */
inline variant GetOutput(byte output, const byte field);

/**
 * Get motor mode.
 * Get the mode of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The mode of the specified output.
 */
inline byte MotorMode(byte output);

/**
 * Get motor power level.
 * Get the power level of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The power level of the specified output.
 */
inline char MotorPower(byte output);

/**
 * Get motor actual speed.
 * Get the actual speed value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The actual speed value of the specified output.
 */
inline char MotorActualSpeed(byte output);

/**
 * Get motor tachometer counter.
 * Get the tachometer count value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The tachometer count value of the specified output.
 */
inline long MotorTachoCount(byte output);

/**
 * Get motor tachometer limit.
 * Get the tachometer limit value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The tachometer limit value of the specified output.
 */
inline long MotorTachoLimit(byte output);

/**
 * Get motor run state.
 * Get the RunState value of the specified output, see \ref
 * OutRunStateConstants.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The RunState value of the specified output.
 */
inline byte MotorRunState(byte output);

/**
 * Get motor turn ratio.
 * Get the turn ratio value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The turn ratio value of the specified output.
 */
inline char MotorTurnRatio(byte output);

/**
 * Get motor regulation mode.
 * Get the regulation value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The regulation value of the specified output.
 */
inline byte MotorRegulation(byte output);

/**
 * Get motor overload status.
 * Get the overload value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The overload value of the specified output.
 */
inline bool MotorOverload(byte output);

/**
 * Get motor P value.
 * Get the proportional PID value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The proportional PID value of the specified output.
 */
inline byte MotorRegPValue(byte output);

/**
 * Get motor I value.
 * Get the integral PID value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The integral PID value of the specified output.
 */
inline byte MotorRegIValue(byte output);

/**
 * Get motor D value.
 * Get the derivative PID value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The derivative PID value of the specified output.
 */
inline byte MotorRegDValue(byte output);

/**
 * Get motor block-relative counter.
 * Get the block-relative position counter value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The block-relative position counter value of the specified output.
 */
inline long MotorBlockTachoCount(byte output);

/**
 * Get motor program-relative counter.
 * Get the program-relative position counter value of the specified output.
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The program-relative position counter value of the specified output.
 */
inline long MotorRotationCount(byte output);

/**
 * Get motor options.
 * Get the options value of the specified output.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The options value of the specified output.
 */
inline byte MotorOutputOptions(byte output);

/**
 * Get motor max speed.
 * Get the max speed value of the specified output.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The max speed value of the specified output.
 */
inline byte MotorMaxSpeed(byte output);

/**
 * Get motor max acceleration.
 * Get the max acceleration value of the specified output.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \param output Desired output port. Can be \ref OUT_A, \ref OUT_B, \ref
 * OUT_C or a variable containing one of these values, see \ref
 * OutputPortConstants.
 * \return The max acceleration value of the specified output.
 */
inline byte MotorMaxAcceleration(byte output);

/**
 * Get motor regulation frequency.
 * Get the current motor regulation frequency in milliseconds.
 * \return The motor regulation frequency.
 */
inline byte MotorPwnFreq();

/**
 * Get motor regulation time.
 * Get the current motor regulation time in milliseconds.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \return The motor regulation time.
 */
inline byte MotorRegulationTime();

/**
 * Get motor regulation options.
 * Get the current motor regulation options.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \return The motor regulation options.
 */
inline byte MotorRegulationOptions();

#else

enum OutputFieldNames {
  UpdateFlags,
  OutputMode,
  Power,
  ActualSpeed,
  TachoCount,
  TachoLimit,
  RunState,
  TurnRatio,
  RegMode,
  Overload,
  RegPValue,
  RegIValue,
  RegDValue,
  BlockTachoCount,
  RotationCount,
  OutputOptions,
  MaxSpeed,
  MaxAcceleration
};

// output fields
#define MotorMode(_p) GetOutput(_p, OutputMode)
#define MotorPower(_p) GetOutput(_p, Power)
#define MotorActualSpeed(_p) GetOutput(_p, ActualSpeed)
#define MotorTachoCount(_p) GetOutput(_p, TachoCount)
#define MotorTachoLimit(_p) GetOutput(_p, TachoLimit)
#define MotorRunState(_p) GetOutput(_p, RunState)
#define MotorTurnRatio(_p) GetOutput(_p, TurnRatio)
#define MotorRegulation(_p) GetOutput(_p, RegMode)
#define MotorOverload(_p) GetOutput(_p, Overload)
#define MotorRegPValue(_p) GetOutput(_p, RegPValue)
#define MotorRegIValue(_p) GetOutput(_p, RegIValue)
#define MotorRegDValue(_p) GetOutput(_p, RegDValue)
#define MotorBlockTachoCount(_p) GetOutput(_p, BlockTachoCount)
#define MotorRotationCount(_p) GetOutput(_p, RotationCount)

#define MotorPwnFreq() asm { GetOutPwnFreq(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SetMotorPwnFreq(_n) asm { __setOutPwnFreq(_n) }
#define MotorRegulationTime() asm { GetOutRegulationTime(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SetMotorRegulationTime(_n) asm { __setOutRegulationTime(_n) }

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
#define MotorOutputOptions(_p) GetOutput(_p, OutputOptions)
#define MotorMaxSpeed(_p) GetOutput(_p, MaxSpeed)
#define MotorMaxAcceleration(_p) GetOutput(_p, MaxAcceleration)
#define MotorRegulationOptions() asm { GetOutRegulationOptions(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SetMotorRegulationOptions(_n) asm { __setOutRegulationOptions(_n) }
#endif

#endif

/** @} */ // end of OutputModuleFunctions group
/** @} */ // end of OutputModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// DISPLAY MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup DisplayModule
 * @{
 */
/** @defgroup DisplayModuleTypes Display module types
 * Types used by various display module functions.
 * @{
 */
/**
 * A point on the NXT LCD screen.
 * This structure is by other system call structures to specify an X, Y
 * LCD screen coordinate.
 * \sa DrawTextType, DrawPointType, DrawLineType, DrawCircleType, DrawRectType,
 * DrawGraphicType, DrawGraphicArrayType, DrawPolygonType, DrawEllipseType,
 * DrawFontType
 */
struct LocationType {
  int X;  /*!< The X coordinate. Valid range is from 0 to 99 inclusive.  */
  int Y;  /*!< The Y coordinate. Valid range is from 0 to 63 inclusive.
               For text drawing this value must be a multiple of 8. */
};

/**
 * Width and height dimensions for the DrawRect system call.
 * This structure is by the \ref DrawRectType to specify a width and
 * height for a rectangle.
 * \sa DrawRectType
 */
struct SizeType {
  int Width;  /*!< The rectangle width. */
  int Height; /*!< The rectangle height. */
};

/**
 * Parameters for the DrawText system call.
 * This structure is used when calling the \ref SysDrawText system call function.
 * It lets you specify the text to draw, the LCD line and horizontal position using the
 * \ref LocationType structure member, as well as drawing options defined
 * in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawText()
 */
struct DrawTextType {
  char Result;             /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType Location;   /*!< The location in X, LCD line number coordinates. */
  string Text;             /*!< The text to draw on the LCD. */
  unsigned long Options;   /*!< The options to use when writing to the LCD.
                             \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the DrawPoint system call.
 * This structure is used when calling the \ref SysDrawPoint system call
 * function.
 * It lets you specify the pixel to draw using the
 * \ref LocationType structure member, as well as drawing options defined
 * in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawPoint()
 */
struct DrawPointType {
  char Result;             /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType Location;   /*!< The point location on screen. */
  unsigned long Options;   /*!< The options to use when writing to the LCD.
                             \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the DrawLine system call.
 * This structure is used when calling the \ref SysDrawLine system call
 * function.
 * It lets you specify the end points of the line to draw using two
 * \ref LocationType structure member, as well as drawing options defined
 * in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawLine()
 */
struct DrawLineType {
  char Result;             /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType StartLoc;   /*!< The location of the starting point. */
  LocationType EndLoc;     /*!< The location of the ending point. */
  unsigned long Options;   /*!< The options to use when writing to the LCD.
                             \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the DrawCircle system call.
 * This structure is used when calling the \ref SysDrawCircle system call
 * function.
 * It lets you specify the center of the circle to draw using the
 * \ref LocationType structure member, the radius, as well as drawing options defined
 * in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawCircle()
 */
struct DrawCircleType {
  char Result;             /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType Center;     /*!< The location of the circle center. */
  byte Size;               /*!< The circle radius. */
  unsigned long Options;   /*!< The options to use when writing to the LCD.
                             \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the DrawRect system call.
 * This structure is used when calling the \ref SysDrawRect system call
 * function.
 * It lets you specify the corner of the rectangle using the \ref LocationType structure member,
 * the width and height of the rectangle using the \ref SizeType structure member,
 * as well as drawing options defined in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawRect()
 */
struct DrawRectType {
  char Result;             /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType Location;   /*!< The top left corner location. */
  SizeType Size;           /*!< The width and height of the rectangle. */
  unsigned long Options;   /*!< The options to use when writing to the LCD.
                             \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the DrawGraphic system call.
 * This structure is used when calling the \ref SysDrawGraphic system call
 * function.
 * It lets you specify the screen location at which to draw the image using the
 * \ref LocationType structure member, the filename of the graphic image, the
 * image parameters (if needed), as well as drawing options defined
 * in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawGraphic()
 */
struct DrawGraphicType {
  char Result;             /*!< The function call result. Possible values include
                             \ref LoaderErrors, \ref ERR_FILE, and \ref NO_ERR. */
  LocationType Location;   /*!< The location on screen. */
  string Filename;         /*!< The RIC file name. */
  long Variables[];         /*!< The variables passed as RIC arguments. */
  unsigned long Options;   /*!< The options to use when writing to the LCD.
                             \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the SetScreenMode system call.
 * This structure is used when calling the \ref SysSetScreenMode system call
 * function.
 * \sa SysSetScreenMode()
 */
struct SetScreenModeType {
  char Result;                /*!< The function call result, always \ref NO_ERR. */
  unsigned long ScreenMode;   /*!< The requested screen mode.

                                The standard NXT firmware only supports
                                setting the ScreenMode to \ref SCREEN_MODE_RESTORE.

                                If you install the NBC/NXC enhanced standard
                                NXT firmware this system function also
                                supports setting the ScreenMode to
                                \ref SCREEN_MODE_CLEAR. */
};

#ifdef __ENHANCED_FIRMWARE
/**
 * Parameters for the DisplayExecuteFunction system call.
 * This structure is used when calling the \ref SysDisplayExecuteFunction
 * system call function.
 *
 * The fields usage depends on the requested command and are documented in the
 * table below. If a field member is shown as 'x' it is ignored by the
 * specified display command.
 *
 * <table>
 * <tr><td>Cmd</td>
 *     <td>Meaning</td><td>Expected parameters</td></tr>
 * <tr><td>DISPLAY_ERASE_ALL</td>
 *     <td>erase entire screen</td><td>()</td></tr>
 * <tr><td>DISPLAY_PIXEL</td>
 *     <td>set pixel (on/off)</td><td>(true/false,X1,Y1,x,x)</td></tr>
 * <tr><td>DISPLAY_HORIZONTAL_LINE</td>
 *     <td>draw horizontal line</td><td>(true/false,X1,Y1,X2,x)</td></tr>
 * <tr><td>DISPLAY_VERTICAL_LINE</td>
 *     <td>draw vertical line</td><td>(true/false,X1,Y1,x,Y2)</td></tr>
 * <tr><td>DISPLAY_CHAR</td>
 *     <td>draw char (actual font)</td><td>(true/false,X1,Y1,Char,x)</td></tr>
 * <tr><td>DISPLAY_ERASE_LINE</td>
 *     <td>erase a single line</td><td>(x,LINE,x,x,x)</td></tr>
 * <tr><td>DISPLAY_FILL_REGION</td>
 *     <td>fill screen region</td><td>(true/false,X1,Y1,X2,Y2)</td></tr>
 * <tr><td>DISPLAY_FILLED_FRAME</td>
 *     <td>draw a frame (on / off)</td><td>(true/false,X1,Y1,X2,Y2)</td></tr>
 * </table>
 *
 * \sa SysDisplayExecuteFunction()
 */
struct DisplayExecuteFunctionType {
  byte Status;   /*!< The function call result, always \ref NO_ERR. */
  byte Cmd;      /*!< The command to execute. */
  bool On;       /*!< The On parameter, see table. */
  byte X1;       /*!< The X1 parameter, see table. */
  byte Y1;       /*!< The Y1 parameter, see table. */
  byte X2;       /*!< The X2 parameter, see table. */
  byte Y2;       /*!< The Y2 parameter, see table. */
};

#if __FIRMWARE_VERSION > 107
/**
 * Parameters for the DrawGraphicArray system call.
 * This structure is used when calling the \ref SysDrawGraphicArray system call
 * function.
 * It lets you specify the screen location at which to draw the image using the
 * \ref LocationType structure member, the graphic image data array, the
 * image parameters (if needed), as well as drawing options defined
 * in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawGraphicArray()
 */
struct DrawGraphicArrayType {
  char Result;            /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType Location;  /*!< The location on screen. */
  byte Data[];            /*!< A byte array containing the RIC opcodes. \ref RICMacros */
  long Variables[];       /*!< The variables passed as RIC arguments. */
  unsigned long Options;  /*!< The options to use when writing to the LCD. \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the DrawPolygon system call.
 * This structure is used when calling the \ref SysDrawPolygon system call
 * function.
 * It lets you specify the points of the polygon to draw using the
 * \ref LocationType array structure member, as well as drawing options defined
 * in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawPolygon()
 */
struct DrawPolygonType {
  char Result;            /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType Points[];  /*!< An array of LocationType structures which define the polygon's shape. */
  unsigned long Options;  /*!< The options to use when writing to the LCD. \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the DrawEllipse system call.
 * This structure is used when calling the \ref SysDrawEllipse system call
 * function.
 * It lets you specify the center of the ellipse using the
 * \ref LocationType structure member, the x and y axis radii,
 * as well as drawing options defined in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawEllipse()
 */
struct DrawEllipseType {
  char Result;            /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType Center;    /*!< The location of the ellipse center. */
  byte SizeX;             /*!< The horizontal ellipse radius. */
  byte SizeY;             /*!< The vertical ellipse radius. */
  unsigned long Options;  /*!< The options to use when writing to the LCD. \ref DisplayDrawOptionConstants */
};

/**
 * Parameters for the DrawFont system call.
 * This structure is used when calling the \ref SysDrawFont system call function.
 * It lets you specify the text to draw, the LCD line and horizontal position using the
 * \ref LocationType structure member, as well as drawing options defined
 * in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawFont()
 */
struct DrawFontType {
  char Result;             /*!< The function call result. \ref NO_ERR means it succeeded. */
  LocationType Location;   /*!< The location in X, LCD line number coordinates. */
  string Filename;         /*!< The filename of the RIC-based font file. */
  string Text;             /*!< The text to draw on the LCD. */
  unsigned long Options;   /*!< The options to use when writing to the LCD.
                             \ref DisplayDrawOptionConstants */
};
#endif
#endif
/** @} */ // end of DisplayModuleTypes group

/** @defgroup DisplayModuleFunctions Display module functions
 * Functions for accessing and modifying display module features.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Reset LCD screen.
 * This function lets you restore the standard NXT running program screen.
 */
inline void ResetScreen();

/**
 * Draw a circle.
 * This function lets you draw a circle on the screen with its center at the
 * specified x and y location, using the specified radius. Optionally specify
 * drawing options. If this argument is not specified it defaults to \ref DRAW_OPT_NORMAL.
 * Valid display option constants are listed in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawCircle, DrawCircleType
 *
 * \param x The x value for the center of the circle.
 * \param y The y value for the center of the circle.
 * \param radius The radius of the circle.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char CircleOut(int x, int y, byte radius, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a line.
 * This function lets you draw a line on the screen from x1, y1 to x2, y2.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawLine, DrawLineType
 *
 * \param x1 The x value for the start of the line.
 * \param y1 The y value for the start of the line.
 * \param x2 The x value for the end of the line.
 * \param y2 The y value for the end of the line.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char LineOut(int x1, int y1, int x2, int y2, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a point.
 * This function lets you draw a point on the screen at x, y.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawPoint, DrawPointType
 *
 * \param x The x value for the point.
 * \param y The y value for the point.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char PointOut(int x, int y, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a rectangle.
 * This function lets you draw a rectangle on the screen at x, y with the
 * specified width and height.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawRect, DrawRectType
 *
 * \param x The x value for the top left corner of the rectangle.
 * \param y The y value for the top left corner of the rectangle.
 * \param width The width of the rectangle.
 * \param height The height of the rectangle.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char RectOut(int x, int y, int width, int height, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw text.
 * Draw a text value on the screen at the specified x and y location. The y
 * value must be a multiple of 8.  Valid line number constants are listed in
 * the \ref LineConstants group.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawText, DrawTextType
 *
 * \param x The x value for the start of the text output.
 * \param y The text line number for the text output.
 * \param str The text to output to the LCD screen.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char TextOut(int x, int y, string str, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a number.
 * Draw a numeric value on the screen at the specified x and y location. The y
 * value must be a multiple of 8.  Valid line number constants are listed in
 * the \ref LineConstants group.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawText, DrawTextType
 *
 * \param x The x value for the start of the number output.
 * \param y The text line number for the number output.
 * \param value The value to output to the LCD screen. Any numeric type is supported.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char NumOut(int x, int y, variant value, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw an ellipse.
 * This function lets you draw an ellipse on the screen with its center at the
 * specified x and y location, using the specified radii. Optionally specify
 * drawing options. If this argument is not specified it defaults to \ref DRAW_OPT_NORMAL.
 * Valid display option constants are listed in the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawEllipse, DrawEllipseType
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param x The x value for the center of the ellipse.
 * \param y The y value for the center of the ellipse.
 * \param radiusX The x axis radius.
 * \param radiusY The y axis radius.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char EllipseOut(int x, int y, byte radiusX, byte radiusY, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a polygon.
 * This function lets you draw a polygon on the screen using an array of points.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group.
 * \sa SysDrawPolygon, DrawPolygonType
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param points An array of LocationType points that define the polygon.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char PolyOut(LocationType points[], unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw text with font.
 * Draw a text value on the screen at the specified x and y location using
 * a custom RIC font. Optionally specify drawing options. If this argument is
 * not specified it defaults to \ref DRAW_OPT_NORMAL. Valid display option
 * constants are listed in the \ref DisplayDrawOptionConstants group.  See the
 * \ref DisplayFontDrawOptionConstants for options specific to the font
 * drawing functions.
 * \sa FontNumOut, SysDrawFont, DrawFontType
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param x The x value for the start of the text output.
 * \param y The y value for the start of the text output.
 * \param filename The filename of the RIC font.
 * \param str The text to output to the LCD screen.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char FontTextOut(int x, int y, string filename, string str, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a number with font.
 * Draw a numeric value on the screen at the specified x and y location using
 * a custom RIC font. Optionally specify drawing options. If this argument is
 * not specified it defaults to \ref DRAW_OPT_NORMAL. Valid display option
 * constants are listed in the \ref DisplayDrawOptionConstants group.  See the
 * \ref DisplayFontDrawOptionConstants for options specific to the font
 * drawing functions.
 * \sa FontTextOut, SysDrawFont, DrawFontType
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param x The x value for the start of the number output.
 * \param y The y value for the start of the number output.
 * \param filename The filename of the RIC font.
 * \param value The value to output to the LCD screen. Any numeric type is supported.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char FontNumOut(int x, int y, string filename, variant value, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a graphic image.
 * Draw a graphic image file on the screen at the specified x and y location.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group. If the file cannot be found then
 * nothing will be drawn and no errors will be reported.
 * \sa SysDrawGraphic, DrawGraphicType
 *
 * \param x The x value for the position of the graphic image.
 * \param y The y value for the position of the graphic image.
 * \param filename The filename of the RIC graphic image.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char GraphicOut(int x, int y, string filename, unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a graphic image from byte array.
 * Draw a graphic image byte array on the screen at the specified x and y location.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group. If the file cannot be found then
 * nothing will be drawn and no errors will be reported.
 * \sa SysDrawGraphicArray, DrawGraphicArrayType
 *
 * \param x The x value for the position of the graphic image.
 * \param y The y value for the position of the graphic image.
 * \param data The byte array of the RIC graphic image.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char GraphicArrayOut(int x, int y, byte data[], unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a graphic image with parameters.
 * Draw a graphic image file on the screen at the specified x and y location using
 * an array of parameters.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group. If the file cannot be found then
 * nothing will be drawn and no errors will be reported.
 * \sa SysDrawGraphic, DrawGraphicType
 *
 * \param x The x value for the position of the graphic image.
 * \param y The y value for the position of the graphic image.
 * \param filename The filename of the RIC graphic image.
 * \param vars The byte array of parameters.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char GraphicOutEx(int x, int y, string filename, byte vars[], unsigned long options=DRAW_OPT_NORMAL);

/**
 * Draw a graphic image from byte array with parameters.
 * Draw a graphic image byte array on the screen at the specified x and y location
 * using an array of parameters.
 * Optionally specify drawing options. If this argument is not specified it
 * defaults to \ref DRAW_OPT_NORMAL. Valid display option constants are listed in
 * the \ref DisplayDrawOptionConstants group. If the file cannot be found then
 * nothing will be drawn and no errors will be reported.
 * \sa SysDrawGraphicArray, DrawGraphicArrayType
 *
 * \param x The x value for the position of the graphic image.
 * \param y The y value for the position of the graphic image.
 * \param data The byte array of the RIC graphic image.
 * \param vars The byte array of parameters.
 * \param options The optional drawing options.
 * \return The result of the drawing operation.
 */
inline char GraphicArrayOutEx(int x, int y, byte data[], byte vars[], unsigned long options=DRAW_OPT_NORMAL);

/**
 * Read pixel data from the normal display buffer.
 * Read "cnt" bytes from the normal display memory into the data array. Start
 * reading from the specified x, line coordinate. Each byte of data read from
 * screen memory is a vertical strip of 8 bits at the desired location. Each
 * bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through
 * TEXTLINE_8 for the "line" parameter.
 *
 * \param x The desired x position from which to read pixel data.
 * \param line The desired line from which to read pixel data.
 * \param cnt The number of bytes of pixel data to read.
 * \param data The array of bytes into which pixel data is read.
 */
inline void GetDisplayNormal(const byte x, const byte line, unsigned int cnt, byte & data[]);

/**
 * Write pixel data to the normal display buffer.
 * Write "cnt" bytes to the normal display memory from the data array. Start
 * writing at the specified x, line coordinate. Each byte of data is a
 * vertical strip of 8 bits at the desired location. Each
 * bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through
 * TEXTLINE_8 for the "line" parameter.
 *
 * \param x The desired x position where you wish to write pixel data.
 * \param line The desired line where you wish to write pixel data.
 * \param cnt The number of bytes of pixel data to write.
 * \param data The array of bytes from which pixel data is read.
 */
inline void SetDisplayNormal(const byte x, const byte line, unsigned int cnt, byte data[]);

/**
 * Read pixel data from the popup display buffer.
 * Read "cnt" bytes from the popup display memory into the data array. Start
 * reading from the specified x, line coordinate. Each byte of data read from
 * screen memory is a vertical strip of 8 bits at the desired location. Each
 * bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through
 * TEXTLINE_8 for the "line" parameter.
 *
 * \param x The desired x position from which to read pixel data.
 * \param line The desired line from which to read pixel data.
 * \param cnt The number of bytes of pixel data to read.
 * \param data The array of bytes into which pixel data is read.
 */
inline void GetDisplayPopup(const byte x, const byte line, unsigned int cnt, byte & data[]);

/**
 * Write pixel data to the popup display buffer.
 * Write "cnt" bytes to the popup display memory from the data array. Start
 * writing at the specified x, line coordinate. Each byte of data is a
 * vertical strip of 8 bits at the desired location. Each
 * bit represents a single pixel on the LCD screen. Use TEXTLINE_1 through
 * TEXTLINE_8 for the "line" parameter.
 *
 * \param x The desired x position where you wish to write pixel data.
 * \param line The desired line where you wish to write pixel data.
 * \param cnt The number of bytes of pixel data to write.
 * \param data The array of bytes from which pixel data is read.
 */
inline void SetDisplayPopup(const byte x, const byte line, unsigned int cnt, byte data[]);

/**
 * Read the display erase mask value.
 * This function lets you read the current display erase mask value.
 * \return The current display erase mask value.
 */
inline unsigned long DisplayEraseMask();


/**
 * Read the display update mask value.
 * This function lets you read the current display update mask value.
 * \return The current display update mask.
 */
inline unsigned long DisplayUpdateMask();

/**
 * Read the display font memory address.
 * This function lets you read the current display font memory address.
 * \return The current display font memory address.
 */
inline unsigned long DisplayFont();

/**
 * Read the display memory address.
 * This function lets you read the current display memory address.
 * \return The current display memory address.
 */
inline unsigned long DisplayDisplay();

/**
 * Read the display flags.
 * This function lets you read the current display flags.
 * Valid flag values are listed in the \ref DisplayFlagsGroup group.
 * \return The current display flags.
 */
inline byte DisplayFlags();

/**
 * Read the display text lines center flags.
 * This function lets you read the current display text lines center flags.
 * \return The current display text lines center flags.
 */
inline byte DisplayTextLinesCenterFlags();

/**
 * Draw text.
 * This function lets you draw text on the NXT LCD given the parameters you
 * pass in via the \ref DrawTextType structure.
 *
 * \param args The DrawTextType structure containing the drawing parameters.
 */
inline void SysDrawText(DrawTextType & args);

/**
 * Draw a point.
 * This function lets you draw a pixel on the NXT LCD given the parameters you
 * pass in via the \ref DrawPointType structure.
 *
 * \param args The DrawPointType structure containing the drawing parameters.
 */
inline void SysDrawPoint(DrawPointType & args);

/**
 * Draw a line.
 * This function lets you draw a line on the NXT LCD given the parameters you
 * pass in via the \ref DrawLineType structure.
 *
 * \param args The DrawLineType structure containing the drawing parameters.
 */
inline void SysDrawLine(DrawLineType & args);

/**
 * Draw a circle.
 * This function lets you draw a circle on the NXT LCD given the parameters you pass
 * in via the \ref DrawCircleType structure.
 *
 * \param args The DrawCircleType structure containing the drawing parameters.
 */
inline void SysDrawCircle(DrawCircleType & args);

/**
 * Draw a rectangle.
 * This function lets you draw a rectangle on the NXT LCD given the parameters
 * you pass in via the \ref DrawRectType structure.
 *
 * \param args The DrawRectType structure containing the drawing parameters.
 */
inline void SysDrawRect(DrawRectType & args);

/**
 * Draw a graphic (RIC file).
 * This function lets you draw a graphic image (RIC file) on the NXT LCD given
 * the parameters you pass in via the \ref DrawGraphicType structure.
 *
 * \param args The DrawGraphicType structure containing the drawing parameters.
 */
inline void SysDrawGraphic(DrawGraphicType & args);

/**
 * Set the screen mode.
 * This function lets you set the screen mode of the NXT LCD given the
 * parameters you pass in via the \ref DrawTextType structure.
 *
 * \param args The SetScreenModeType structure containing the screen mode parameters.
 */
inline void SysSetScreenMode(SetScreenModeType & args);

#ifdef __ENHANCED_FIRMWARE

/**
 * Execute any Display module command.
 * This function lets you directly execute the Display module's primary
 * drawing function using the values specified via the \ref
 * DisplayExecuteFunctionType structure.
 *
 * \param args The DisplayExecuteFunctionType structure containing the drawing parameters.
 */
inline void SysDisplayExecuteFunction(DisplayExecuteFunctionType & args);


#if __FIRMWARE_VERSION > 107

/**
 * Read the display contrast setting.
 * This function lets you read the current display contrast setting.
 * \return The current display contrast (byte).
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline byte DisplayContrast();

/**
 * Draw a graphic image from a byte array.
 * This function lets you draw a graphic image on the NXT LCD given the parameters you pass
 * in via the \ref DrawGraphicArrayType structure.
 *
 * \param args The DrawGraphicArrayType structure containing the drawing parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SysDrawGraphicArray(DrawGraphicArrayType & args);

/**
 * Draw a polygon.
 * This function lets you draw a polygon on the NXT LCD given the parameters you pass
 * in via the \ref DrawPolygonType structure.
 *
 * \param args The DrawPolygonType structure containing the drawing parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SysDrawPolygon(DrawPolygonType & args);

/**
 * Draw an ellipse.
 * This function lets you draw an ellipse on the NXT LCD given the parameters you pass
 * in via the \ref DrawEllipseType structure.
 *
 * \param args The DrawEllipseType structure containing the drawing parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SysDrawEllipse(DrawEllipseType & args);

/**
 * Draw text using a custom font.
 * This function lets you draw text on the NXT LCD using a custom font
 * with parameters you pass in via the \ref DrawFontType structure.
 *
 * \param args The DrawFontType structure containing the drawing parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SysDrawFont(DrawFontType & args);

#endif
#endif

#else

#define GetDisplayNormal(_x, _line, _cnt, _data) asm { __getDisplayNormal(_x, _line, _cnt, _data) }
#define GetDisplayPopup(_x, _line, _cnt, _data) asm { __getDisplayPopup(_x, _line, _cnt, _data) }

#define DisplayEraseMask() asm { GetDisplayEraseMask(__TMPLONG__) __RETURN__ __TMPLONG__ }
#define DisplayUpdateMask() asm { GetDisplayUpdateMask(__TMPLONG__) __RETURN__ __TMPLONG__ }
#define DisplayFont() asm { GetDisplayFont(__TMPLONG__) __RETURN__ __TMPLONG__ }
#define DisplayDisplay() asm { GetDisplayDisplay(__TMPLONG__) __RETURN__ __TMPLONG__ }
#define DisplayFlags() asm { GetDisplayFlags(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define DisplayTextLinesCenterFlags() asm { GetDisplayTextLinesCenterFlags(__TMPBYTE__) __RETURN__ __TMPBYTE__ }

#define SetDisplayNormal(_x, _line, _cnt, _data) asm { __setDisplayNormal(_x, _line, _cnt, _data) }
#define SetDisplayPopup(_x, _line, _cnt, _data) asm { __setDisplayPopup(_x, _line, _cnt, _data) }

#define SysDrawText(_args) asm { \
  compchktype _args, DrawTextType \
  syscall DrawText, _args \
}
#define SysDrawPoint(_args) asm { \
  compchktype _args, DrawPointType \
  syscall DrawPoint, _args \
}
#define SysDrawLine(_args) asm { \
  compchktype _args, DrawLineType \
  syscall DrawLine, _args \
}
#define SysDrawCircle(_args) asm { \
  compchktype _args, DrawCircleType \
  syscall DrawCircle, _args \
}
#define SysDrawRect(_args) asm { \
  compchktype _args, DrawRectType \
  syscall DrawRect, _args \
}
#define SysDrawGraphic(_args) asm { \
  compchktype _args, DrawGraphicType \
  syscall DrawGraphic, _args \
}
#define SysSetScreenMode(_args) asm { \
  compchktype _args, SetScreenModeType \
  syscall SetScreenMode, _args \
}

#ifdef __ENHANCED_FIRMWARE

#define SysDisplayExecuteFunction(_args) asm { \
  compchktype _args, DisplayExecuteFunctionType \
  syscall DisplayExecuteFunction, _args \
}

#if __FIRMWARE_VERSION > 107

#define DisplayContrast() asm { GetDisplayContrast(__TMPBYTE__) __RETURN__ __TMPBYTE__ }

#define SysDrawGraphicArray(_args) asm { \
  compchktype _args, DrawGraphicArrayType \
  syscall DrawGraphicArray, _args \
}
#define SysDrawPolygon(_args) asm { \
  compchktype _args, DrawPolygonType \
  syscall DrawPolygon, _args \
}
#define SysDrawEllipse(_args) asm { \
  compchktype _args, DrawEllipseType \
  syscall DrawEllipse, _args \
}
#define SysDrawFont(_args) asm { \
  compchktype _args, DrawFontType \
  syscall DrawFont, _args \
}
#endif
#endif
#endif

/**
 * Clear LCD screen.
 * This function lets you clear the NXT LCD to a blank screen.
 */
inline void ClearScreen() { asm { PointOutEx(200, 200, TRUE) } }

/**
 * Clear a line on the LCD screen.
 * This function lets you clear a single line on the NXT LCD.
 * \param line The line you want to clear. See \ref LineConstants.
 */
inline void ClearLine(byte line) { asm { TextOutEx(0, line, __BlankLine, 0) } }

/**
 * Set the display font memory address.
 * This function lets you set the current display font memory address.
 * 
 * \param fontaddr The new display font memory address.
 */
inline void SetDisplayFont(unsigned long fontaddr) { asm { __setDisplayFont(fontaddr) } }

/**
 * Set the display memory address.
 * This function lets you set the current display memory address.
 * 
 * \param dispaddr The new display memory address.
 */
inline void SetDisplayDisplay(unsigned long dispaddr) { asm { __setDisplayDisplay(dispaddr) } }

/**
 * Set the display erase mask.
 * This function lets you set the current display erase mask.
 * 
 * \param eraseMask The new display erase mask.
 */
inline void SetDisplayEraseMask(unsigned long eraseMask) { asm { __setDisplayEraseMask(eraseMask) } }

/**
 * Set the display flags.
 * This function lets you set the current display flags.
 *
 * \param flags The new display flags. See \ref DisplayFlagsGroup.
 */
inline void SetDisplayFlags(byte flags) { asm { __setDisplayFlags(flags) } }

/**
 * Set the display text lines center flags.
 * This function lets you set the current display text lines center flags.
 *
 * \param ctrFlags The new display text lines center flags.
 */
inline void SetDisplayTextLinesCenterFlags(byte ctrFlags) { asm { __setDisplayTextLinesCenterFlags(ctrFlags) } }

/**
 * Set the display update mask.
 * This function lets you set the current display update mask.
 *
 * \param updateMask The new display update mask.
 */
inline void SetDisplayUpdateMask(unsigned long updateMask) { asm { __setDisplayUpdateMask(updateMask) } }

#if (__FIRMWARE_VERSION > 107) && defined(__ENHANCED_FIRMWARE)
/**
 * Set the display contrast.
 * This function lets you set the display contrast setting.
 *
 * \param contrast The desired display contrast.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SetDisplayContrast(byte contrast) { asm { __setDisplayContrast(contrast) } }

#endif

/** @} */ // end of DisplayModuleFunctions group
/** @} */ // end of DisplayModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SOUND MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup SoundModule
 * @{
 */
/** @defgroup SoundModuleTypes Sound module types
 * Types used by various sound module functions.
 * @{
 */

/**
 * Type used with the PlayTones API function.
 * An array of this structure is used when calling the \ref PlayTones
 * API function.
 * \sa PlayTones()
 */
struct Tone {
  unsigned int Frequency; /*!< The tone frequency. See the \ref ToneConstants group. */
  unsigned int Duration;  /*!< The tone duration in milliseconds. See the \ref TimeConstants group. */
};

/**
 * Parameters for the SoundPlayFile system call.
 * This structure is used when calling the \ref SysSoundPlayFile system call
 * function.
 * \sa SysSoundPlayFile()
 */
struct SoundPlayFileType {
  char Result;       /*!< The function call result, always \ref NO_ERR. */
  string Filename;   /*!< The name of the file to play. */
  bool Loop;         /*!< If true, loops at end of file. */
  byte SoundLevel;   /*!< The sound level. Valid values range from 0 to 4. */
};

/**
 * Parameters for the SoundPlayTone system call.
 * This structure is used when calling the \ref SysSoundPlayTone system call
 * function.
 * \sa SysSoundPlayTone()
 */
struct SoundPlayToneType {
  char Result;              /*!< The function call result, always \ref NO_ERR. */
  unsigned int Frequency;   /*!< The tone frequency. See the \ref ToneConstants group. */
  unsigned int Duration;    /*!< The tone duration in milliseconds. See the \ref TimeConstants group. */
  bool Loop;                /*!< If true, loops forever. */
  byte SoundLevel;          /*!< The sound level. Valid values range from 0 to 4. */
};

/**
 * Parameters for the SoundGetState system call.
 * This structure is used when calling the \ref SysSoundGetState system call
 * function.
 * \sa SysSoundGetState()
 */
struct SoundGetStateType {
  byte State;   /*!< The returned sound state. See the \ref SoundStateConstants group. */
  byte Flags;   /*!< The returned sound flags. See the \ref SoundFlagsConstants group. */
};

/**
 * Parameters for the SoundSetState system call.
 * This structure is used when calling the \ref SysSoundSetState system call
 * function.
 * \sa SysSoundSetState()
 */
struct SoundSetStateType {
  byte Result;   /*!< The function call result, same as State. */
  byte State;    /*!< The new sound state. See the \ref SoundStateConstants group. */
  byte Flags;    /*!< The new sound flags. See the \ref SoundFlagsConstants group. */
};

/** @} */ // end of SoundModuleTypes group

/** @defgroup SoundModuleFunctions Sound module functions
 * Functions for accessing and modifying sound module features.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Play a file.
 * Play the specified file. The filename may be any valid string expression.
 * The sound file can either be an RSO file containing PCM or compressed ADPCM
 * samples or it can be an NXT melody (RMD) file containing frequency and
 * duration values.
 *
 * \param filename The name of the sound or melody file to play.
 */
inline char PlayFile(string filename);

/**
 * Play a file with extra options.
 * Play the specified file. The filename may be any valid string expression.
 * Volume should be a number from 0 (silent) to 4 (loudest). Play the file
 * repeatedly if loop is true.
 * The sound file can either be an RSO file containing PCM or compressed ADPCM
 * samples or it can be an NXT melody (RMD) file containing frequency and
 * duration values.
 *
 * \param filename The name of the sound or melody file to play.
 * \param volume The desired tone volume.
 * \param loop A boolean flag indicating whether to play the file repeatedly.
 */
inline char PlayFileEx(string filename, byte volume, bool loop);

/**
 * Play a tone.
 * Play a single tone of the specified frequency and duration. The frequency is
 * in Hz (see the \ref ToneConstants group). The duration is in 1000ths of a
 * second (see the \ref TimeConstants group). The tone is played at the loudest
 * sound level supported by the firmware and it is not looped.
 *
 * \param frequency The desired tone frequency, in Hz.
 * \param duration The desired tone duration, in ms.
 */
inline char PlayTone(unsigned int frequency, unsigned int duration);

/**
 * Play a tone with extra options.
 * Play a single tone of the specified frequency, duration, and volume. The
 * frequency is in Hz (see the \ref ToneConstants group). The duration is in
 * 1000ths of a second (see the \ref TimeConstants group). Volume should be a
 * number from 0 (silent) to 4 (loudest). Play the tone repeatedly if loop is
 * true.
 *
 * \param frequency The desired tone frequency, in Hz.
 * \param duration The desired tone duration, in ms.
 * \param volume The desired tone volume.
 * \param loop A boolean flag indicating whether to play the tone repeatedly.
 */
inline char PlayToneEx(unsigned int frequency, unsigned int duration, byte volume, bool loop);

/**
 * Get sound module state.
 * Return the current sound module state. See the \ref SoundStateConstants group.
 *
 * \sa SetSoundModuleState(), SysSoundSetState(), SysSoundGetState()
 * \return The current sound module state.
 */
inline byte SoundState();

/**
 * Get sound module flags.
 * Return the current sound module flags. See the \ref SoundFlagsConstants group.
 *
 * \sa SetSoundFlags(), SysSoundSetState(), SysSoundGetState()
 * \return The current sound module flags.
 */
inline byte SoundFlags();

/**
 * Stop sound.
 * Stop playing of the current tone or file.
 *
 * \return The result \todo ?.
 */
inline byte StopSound();

/**
 * Get sound frequency.
 * Return the current sound frequency.
 *
 * \sa SetSoundFrequency()
 * \return The current sound frequency.
 */
inline unsigned int SoundFrequency();

/**
 * Get sound duration.
 * Return the current sound duration.
 *
 * \sa SetSoundDuration()
 * \return The current sound duration.
 */
inline unsigned int SoundDuration();

/**
 * Get sample rate.
 * Return the current sound sample rate.
 *
 * \sa SetSoundSampleRate()
 * \return The current sound sample rate.
 */
inline unsigned int SoundSampleRate();

/**
 * Get sound mode.
 * Return the current sound mode.  See the \ref SoundModeConstants group.
 *
 * \sa SetSoundMode()
 * \return The current sound mode.
 */
inline byte SoundMode();

/**
 * Get volume.
 * Return the current sound volume.
 *
 * \sa SetSoundVolume()
 * \return The current sound volume.
 */
inline byte SoundVolume();

/**
 * Set sound duration.
 * Set the sound duration.
 *
 * \sa SoundDuration()
 * \param duration The new sound duration
 */
inline void SetSoundDuration(unsigned int duration);

/**
 * Set sound module flags.
 * Set the sound module flags. See the \ref SoundFlagsConstants group.
 *
 * \sa SetSoundFlags(), SysSoundSetState(), SysSoundGetState()
 * \param flags The new sound module flags
 */
inline void SetSoundFlags(byte flags);

/**
 * Set sound frequency.
 * Set the sound frequency.
 *
 * \sa SoundFrequency()
 * \param frequency The new sound frequency
 */
inline void SetSoundFrequency(unsigned int frequency);

/**
 * Set sound mode.
 * Set the sound mode.  See the \ref SoundModeConstants group.
 *
 * \sa SoundMode()
 * \param mode The new sound mode
 */
inline void SetSoundMode(byte mode);

/**
 * Set sound module state.
 * Set the sound module state. See the \ref SoundStateConstants group.
 *
 * \sa SoundState(), SysSoundSetState(), SysSoundGetState()
 * \param state The new sound state
 */
inline void SetSoundModuleState(byte state);

/**
 * Set sample rate.
 * Set the sound sample rate.
 *
 * \sa SoundSampleRate()
 * \param sampleRate The new sample rate
 */
inline void SetSoundSampleRate(unsigned int sampleRate);

/**
 * Set sound volume.
 * Set the sound volume.
 *
 * \sa SoundVolume()
 * \param volume The new volume
 */
inline void SetSoundVolume(byte volume);

/**
 * Play sound file.
 * This function lets you play a sound file given the parameters you pass in
 * via the \ref SoundPlayFileType structure. The sound file can either be an
 * RSO file containing PCM or compressed ADPCM samples or it can be an NXT
 * melody (RMD) file containing frequency and duration values.
 *
 * \param args The SoundPlayFileType structure containing the needed
 * parameters.
 */
inline void SysSoundPlayFile(SoundPlayFileType & args);

/**
 * Play tone.
 * This function lets you play a tone given the parameters you pass in via the
 * \ref SoundPlayToneType structure.
 *
 * \param args The SoundPlayToneType structure containing the needed
 * parameters.
 */
inline void SysSoundPlayTone(SoundPlayToneType & args);

/**
 * Get sound state.
 * This function lets you retrieve information about the sound module state
 * via the \ref SoundGetStateType structure.
 *
 * \param args The SoundGetStateType structure containing the needed
 * parameters.
 */
inline void SysSoundGetState(SoundGetStateType & args);

/**
 * Set sound state.
 * This function lets you set sound module state settings via the \ref
 * SoundSetStateType structure.
 *
 * \param args The SoundSetStateType structure containing the needed
 * parameters.
 */
inline void SysSoundSetState(SoundSetStateType & args);

#else

#define PlayTone(_f, _d) PlayToneEx(_f, _d, 4, 0)
#define PlayFile(_f) PlayFileEx(_f, 4, 0)

#define SoundState() asm { GetSoundState(__RETVAL__, __TMPBYTE__) }
#define SoundFlags() asm { GetSoundState(__TMPBYTE__, __RETVAL__) }
#define StopSound() asm { __setSoundState(SOUND_STATE_STOP, 0, __RETVAL__) }

#define SoundFrequency() asm { GetSoundFrequency(__TMPWORD__) __RETURN__ __TMPWORD__ }
#define SoundDuration() asm { GetSoundDuration(__TMPWORD__) __RETURN__ __TMPWORD__ }
#define SoundSampleRate() asm { GetSoundSampleRate(__TMPWORD__) __RETURN__ __TMPWORD__ }
#define SoundMode() asm { GetSoundMode(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SoundVolume() asm { GetSoundVolume(__TMPBYTE__) __RETURN__ __TMPBYTE__ }

#define SetSoundFrequency(_n) asm { __setSoundFrequency(_n) }
#define SetSoundDuration(_n) asm { __setSoundDuration(_n) }
#define SetSoundSampleRate(_n) asm { __setSoundSampleRate(_n) }
#define SetSoundFlags(_n) asm { __setSoundFlags(_n) }
#define SetSoundModuleState(_n) asm { __setSoundModuleState(_n) }
#define SetSoundMode(_n) asm { __setSoundMode(_n) }
#define SetSoundVolume(_n) asm { __setSoundVolume(_n) }

#define SysSoundPlayFile(_args) asm { \
  compchktype _args, SoundPlayFileType \
  syscall SoundPlayFile, _args \
}
#define SysSoundPlayTone(_args) asm { \
  compchktype _args, SoundPlayToneType \
  syscall SoundPlayTone, _args \
}
#define SysSoundGetState(_args) asm { \
  compchktype _args, SoundGetStateType \
  syscall SoundGetState, _args \
}
#define SysSoundSetState(_args) asm { \
  compchktype _args, SoundSetStateType \
  syscall SoundSetState, _args \
}

#endif

/**
 * Play a system sound.
 * Play a sound that mimics the RCX system sounds using one of the
 * \ref RCXSoundConstants.
 * <TABLE BORDER=1>
 * <TR><TH>aCode</TH><TH>Resulting Sound</TH></TR>
 * <TR><TD>\ref SOUND_CLICK</TD><TD>key click sound</TD></TR>
 * <TR><TD>\ref SOUND_DOUBLE_BEEP</TD><TD>double beep</TD></TR>
 * <TR><TD>\ref SOUND_DOWN</TD><TD>sweep down</TD></TR>
 * <TR><TD>\ref SOUND_UP</TD><TD>sweep up</TD></TR>
 * <TR><TD>\ref SOUND_LOW_BEEP</TD><TD>error sound</TD></TR>
 * <TR><TD>\ref SOUND_FAST_UP</TD><TD>fast sweep up</TD></TR>
 * </TABLE>
 * \param aCode The system sound to play.  See \ref RCXSoundConstants.
 */
void PlaySound(const int &aCode)
{
    if (aCode == SOUND_CLICK)
        PlayTone(600, MS_200);
    else if (aCode == SOUND_DOUBLE_BEEP)
    {
        PlayTone(600, MS_150);
        asm { wait MS_200 };
        PlayTone(600, MS_150);
        asm { wait MS_150 };
    }
    else if (aCode == SOUND_UP)
        for (int i = 4; i < 8; i++)
        {
            PlayTone(TONE_C5 * i / 4, MS_100);
            asm { wait MS_100 };
        }
    else if (aCode == SOUND_DOWN)
        for (int i = 7; i > 3; i--)
        {
            PlayTone(TONE_C5 * i / 4, MS_100);
            asm { wait MS_100 };
        }
    else if (aCode == SOUND_LOW_BEEP)
    {
        PlayTone(100, MS_500);
        asm { wait MS_500 };
    }
    else if (aCode == SOUND_FAST_UP)
        for (int i = 4; i < 8; i++)
        {
            PlayTone(TONE_C5 * i / 4, MS_50);
            asm { wait MS_50 };
        }
}

/**
 * Play multiple tones.
 * Play a series of tones contained in the tones array.  Each element
 * in the array is an instance of the \ref Tone structure, containing
 * a frequency and a duration.
 *
 * \param tones The array of tones to play.
 */
void PlayTones(Tone tones[])
{
  for (int i = 0; i <  asm { arrsize __RETVAL__, tones }; i++) {
    Tone tmp = tones[i];
    PlayTone(tmp.Frequency, tmp.Duration);
    asm { waitv tmp.Duration };
  }
}

/** @} */ // end of SoundModuleFunctions group
/** @} */ // end of SoundModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LOWSPEED MODULE ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup LowSpeedModule
 * @{
 */
/** @defgroup LowSpeedModuleTypes LowSpeed module types
 * Types used by various low speed module functions.
 * @{
 */
/**
 * Parameters for the CommLSWrite system call.
 * This structure is used when calling the \ref SysCommLSWrite system call
 * function.
 * \sa SysCommLSWrite()
 */
struct CommLSWriteType {
  char Result;      /*!< The function call result. Possible values include
                      \ref ERR_COMM_CHAN_INVALID, \ref ERR_COMM_CHAN_NOT_READY,
                      \ref ERR_INVALID_SIZE, and \ref NO_ERR. */
  byte Port;        /*!< The port to which the I2C device is connected. */
  byte Buffer[];    /*!< The buffer containing data to be written to the I2C device. */
  byte ReturnLen;   /*!< The number of bytes that you want to read from the I2C device
                      after writing the data.  If no read is planned set this to zero. */
};

/**
 * Parameters for the CommLSRead system call.
 * This structure is used when calling the \ref SysCommLSRead system call
 * function.
 * \sa SysCommLSRead()
 */
struct CommLSReadType {
  char Result;      /*!< The function call result. Possible values include
                      \ref ERR_COMM_BUS_ERR, \ref ERR_COMM_CHAN_INVALID,
                      \ref ERR_COMM_CHAN_NOT_READY, \ref ERR_INVALID_SIZE,
                      \ref STAT_COMM_PENDING, and \ref NO_ERR. */
  byte Port;        /*!< The port to which the I2C device is connected. */
  byte Buffer[];    /*!< The buffer used to store the bytes read from the I2C device. */
  byte BufferLen;   /*!< The size of the output buffer on input.  This field is not updated during the function call. */
};

/**
 * Parameters for the CommLSCheckStatus system call.
 * This structure is used when calling the \ref SysCommLSCheckStatus system
 * call function.
 * \sa SysCommLSCheckStatus()
 */
struct CommLSCheckStatusType {
  char Result;       /*!< The function call result. Possible values include
                       \ref ERR_COMM_BUS_ERR, \ref ERR_COMM_CHAN_INVALID,
                       \ref ERR_COMM_CHAN_NOT_READY, \ref STAT_COMM_PENDING,
                       and \ref NO_ERR. */
  byte Port;         /*!< The port to which the I2C device is connected. */
  byte BytesReady;   /*!< The number of bytes ready to read from the specified port. */
};

#ifdef __ENHANCED_FIRMWARE
/**
 * Parameters for the CommLSWriteEx system call.
 * This structure is used when calling the \ref SysCommLSWriteEx system call
 * function.
 * \sa SysCommLSWriteEx()
 */
struct CommLSWriteExType {
  char Result;          /*!< The function call result. Possible values include
                      \ref ERR_COMM_CHAN_INVALID, \ref ERR_COMM_CHAN_NOT_READY,
                      \ref ERR_INVALID_SIZE, and \ref NO_ERR. */
  byte Port;            /*!< The port to which the I2C device is connected. */
  byte Buffer[];        /*!< The buffer written to the I2C device. */
  byte ReturnLen;       /*!< The number of bytes that you want to read from the I2C device. */
  bool NoRestartOnRead; /*!< Should a restart occur before reading from the device? */
};
#endif

/** @} */ // end of LowSpeedModuleTypes group

/** @defgroup LowSpeedModuleFunctions LowSpeed module functions
 * Functions for accessing and modifying low speed module features.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Read ultrasonic sensor value.
 * Return the ultrasonic sensor distance value. Since an
 * ultrasonic sensor is an I2C digital sensor its value cannot be read using
 * the standard Sensor(n) value.
 * The port must be configured as a Lowspeed port before using this function.
 * \param port The port to which the ultrasonic sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \return The ultrasonic sensor distance value (0..255)
 */
inline byte SensorUS(const byte port);

/**
 * Read multiple ultrasonic sensor values.
 * Return eight ultrasonic sensor distance values.
 * \param port The port to which the ultrasonic sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param values An array of bytes that will contain the 8 distance values
 * read from the ultrasonic sensor.
 * \return A status code indicating whether the read completed successfully or not.
 * See \ref CommLSReadType for possible result values.
 */
inline char ReadSensorUSEx(const byte port, byte & values[]);

/**
 * Read the LEGO EMeter values.
 * Read all the LEGO EMeter register values.
 * They must all be read at once to ensure data coherency.
 *
 * \param port The port to which the LEGO EMeter sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param vIn Input voltage
 * \param aIn Input current
 * \param vOut Output voltage
 * \param aOut Output current
 * \param joules The number of joules stored in the EMeter
 * \param wIn The number of watts generated
 * \param wOut The number of watts consumed
 * \return A status code indicating whether the read completed successfully or not.
 * See \ref CommLSReadType for possible result values.
 */
inline char ReadSensorEMeter(const byte & port, float &vIn, float &aIn, float &vOut, float &aOut, int &joules, float &wIn, float &wOut);

/**
 * Configure LEGO Temperature sensor options.
 * Set various LEGO Temperature sensor options.
 *
 * \param port The port to which the temperature sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param config The temperature sensor configuration settings.  See
 * \ref TempI2CConstants for configuration constants that can be ORed or added
 * together.
 * \return A status code indicating whether the read completed successfully or not.
 * See \ref CommLSReadType for possible Result values.
 */
inline char ConfigureTemperatureSensor(const byte & port, const byte & config);

/**
 * Read the LEGO Temperature sensor value.
 * Return the temperature sensor value in degrees celcius. Since a
 * temperature sensor is an I2C digital sensor its value cannot be read using
 * the standard Sensor(n) value.
 * The port must be configured as a temperature sensor port before using this
 * function. Use \ref SetSensorTemperature to configure the port.
 * \param port The port to which the temperature sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \return The temperature sensor value in degrees celcius.
 */
inline float SensorTemperature(const byte & port);

/**
 * Get lowspeed status.
 * This method checks the status of the I2C communication on the specified
 * port. If the last operation on this port was a successful LowspeedWrite
 * call that requested response data from the device then bytesready will
 * be set to the number of bytes in the internal read buffer.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param bytesready The number of bytes available to be read from the internal I2C buffer.
 * The maximum number of bytes that can be read is 16.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * Avoid calls to \ref LowspeedRead or \ref LowspeedWrite while LowspeedStatus returns
 * \ref STAT_COMM_PENDING.
 * \sa I2CStatus, I2CRead, I2CWrite, I2CCheckStatus, I2CBytesReady, LowspeedRead,
 * LowspeedWrite, and LowspeedCheckStatus
 */
inline long LowspeedStatus(const byte port, byte & bytesready);

/**
 * Check lowspeed status.
 * This method checks the status of the I2C communication on the specified
 * port.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * Avoid calls to \ref LowspeedRead or \ref LowspeedWrite while LowspeedCheckStatus returns
 * \ref STAT_COMM_PENDING.
 * \sa I2CCheckStatus, I2CRead, I2CWrite, I2CStatus, I2CBytesReady, LowspeedRead,
 * LowspeedWrite, and LowspeedStatus
 */
inline long LowspeedCheckStatus(const byte port);

/**
 * Get lowspeed bytes ready.
 * This method checks the number of bytes that are ready to be read on the
 * specified port. If the last operation on this port was a successful
 * LowspeedWrite call that requested response data from the device then the
 * return value will be the number of bytes in the internal read buffer.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \return The number of bytes available to be read from the internal I2C buffer.
 * The maximum number of bytes that can be read is 16.
 * \sa I2CCheckStatus, I2CRead, I2CWrite, I2CStatus, I2CBytesReady, LowspeedRead,
 * LowspeedWrite, and LowspeedStatus
 */
inline byte LowspeedBytesReady(const byte port);

/**
 * Write lowspeed data.
 * This method starts a transaction to write the bytes contained in the array
 * buffer to the I2C device on the specified port. It also tells the I2C device
 * the number of bytes that should be included in the response. The maximum
 * number of bytes that can be written or read is 16.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param retlen The number of bytes that should be returned by the I2C device.
 * \param buffer A byte array containing the address of the I2C device, the I2C
 * device register at which to write data, and up to 14 bytes of data to be
 * written at the specified register.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSWriteType for possible result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * \sa I2CCheckStatus, I2CRead, I2CWrite, I2CStatus, I2CBytesReady, LowspeedRead,
 * LowspeedCheckStatus, LowspeedBytesReady, and LowspeedStatus
 */
inline long LowspeedWrite(const byte port, byte retlen, byte buffer[]);

/**
 * Read lowspeed data.
 * Read the specified number of bytes from the I2C device on the specified
 * port and store the bytes read in the byte array buffer provided.  The maximum
 * number of bytes that can be written or read is 16.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param buflen The initial size of the output buffer.
 * \param buffer A byte array that contains the data read from the internal I2C
 * buffer.  If the return value is negative then the output buffer will be empty.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSReadType for possible result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * \sa I2CCheckStatus, I2CRead, I2CWrite, I2CStatus, I2CBytesReady, LowspeedWrite,
 * LowspeedCheckStatus, LowspeedBytesReady, and LowspeedStatus
 */
inline long LowspeedRead(const byte port, byte buflen, byte & buffer[]);

/**
 * Get I2C status.
 * This method checks the status of the I2C communication on the specified
 * port. If the last operation on this port was a successful I2CWrite
 * call that requested response data from the device then bytesready will
 * be set to the number of bytes in the internal read buffer.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param bytesready The number of bytes available to be read from the internal I2C buffer.
 * The maximum number of bytes that can be read is 16.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSCheckStatusType for possible return values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * Avoid calls to \ref I2CRead or \ref I2CWrite while I2CStatus returns
 * \ref STAT_COMM_PENDING.
 * \sa I2CCheckStatus, I2CRead, I2CWrite, LowspeedStatus, LowspeedRead,
 * LowspeedWrite, and LowspeedCheckStatus
 */
inline long I2CStatus(const byte port, byte & bytesready);

/**
 * Check I2C status.
 * This method checks the status of the I2C communication on the specified
 * port.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * Avoid calls to \ref I2CRead or \ref I2CWrite while this function returns
 * \ref STAT_COMM_PENDING.
 * \sa I2CStatus, I2CRead, I2CWrite, LowspeedStatus, LowspeedRead,
 * LowspeedWrite, and LowspeedCheckStatus
 */
inline long I2CCheckStatus(const byte port);

/**
 * Get I2C bytes ready.
 * This method checks the number of bytes that are ready to be read on the
 * specified port. If the last operation on this port was a successful
 * I2CWrite call that requested response data from the device then the
 * return value will be the number of bytes in the internal read buffer.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \return The number of bytes available to be read from the internal I2C buffer.
 * The maximum number of bytes that can be read is 16.
 * \sa I2CCheckStatus, I2CRead, I2CWrite, I2CStatus, LowspeedBytesReady, LowspeedRead,
 * LowspeedWrite, and LowspeedStatus
 */
inline byte I2CBytesReady(const byte port);

/**
 * Write I2C data.
 * This method starts a transaction to write the bytes contained in the array
 * buffer to the I2C device on the specified port. It also tells the I2C device
 * the number of bytes that should be included in the response. The maximum
 * number of bytes that can be written or read is 16.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param retlen The number of bytes that should be returned by the I2C device.
 * \param buffer A byte array containing the address of the I2C device, the I2C
 * device register at which to write data, and up to 14 bytes of data to be
 * written at the specified register.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSWriteType for possible result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * \sa I2CCheckStatus, I2CRead, I2CStatus, I2CBytesReady, LowspeedRead, LowspeedWrite,
 * LowspeedCheckStatus, LowspeedBytesReady, and LowspeedStatus
 */
inline long I2CWrite(const byte port, byte retlen, byte buffer[]);

/**
 * Read I2C data.
 * Read the specified number of bytes from the I2C device on the specified
 * port and store the bytes read in the byte array buffer provided.  The maximum
 * number of bytes that can be written or read is 16.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param buflen The initial size of the output buffer.
 * \param buffer A byte array that contains the data read from the internal I2C
 * buffer.  If the return value is negative then the output buffer will be empty.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSReadType for possible result values. If the return
 * value is \ref NO_ERR then the last operation did not cause any errors.
 * \sa I2CCheckStatus, I2CWrite, I2CStatus, I2CBytesReady, LowspeedRead, LowspeedWrite,
 * LowspeedCheckStatus, LowspeedBytesReady, and LowspeedStatus
 */
inline long I2CRead(const byte port, byte buflen, byte & buffer[]);

/**
 * Perform an I2C write/read transaction.
 * This method writes the bytes contained in the input buffer (inbuf) to the
 * I2C device on the specified port, checks for the specified number of bytes
 * to be ready for reading, and then tries to read the specified number (count)
 * of bytes from the I2C device into the output buffer (outbuf).
 *
 * This is a higher-level wrapper around the three main I2C functions. It also
 * maintains a "last good read" buffer and returns values from that buffer if
 * the I2C communication transaction fails.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param inbuf A byte array containing the address of the I2C device, the I2C
 * device register at which to write data, and up to 14 bytes of data to be
 * written at the specified register.
 * \param count The number of bytes that should be returned by the I2C device.
 * On output count is set to the number of bytes in outbuf.
 * \param outbuf A byte array that contains the data read from the internal I2C
 * buffer.
 * \return Returns true or false indicating whether the I2C transaction
 * succeeded or failed.
 * \sa I2CCheckStatus, I2CWrite, I2CStatus, I2CBytesReady, I2CRead, LowspeedRead, LowspeedWrite,
 * LowspeedCheckStatus, LowspeedBytesReady, and LowspeedStatus
 */
inline long I2CBytes(const byte port, byte inbuf[], byte & count, byte & outbuf[]);

/**
 * Read I2C register.
 * Read a single byte from an I2C device register.
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param i2caddr The I2C device address.
 * \param reg The I2C device register from which to read a single byte.
 * \param out The single byte read from the I2C device.
 * \return A status code indicating whether the read completed successfully or not.
 * See \ref CommLSReadType for possible result values.
 */
inline char ReadI2CRegister(byte port, byte i2caddr, byte reg, byte & out);

/**
 * Write I2C register.
 * Write a single byte to an I2C device register.
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param i2caddr The I2C device address.
 * \param reg The I2C device register to which to write a single byte.
 * \param val The byte to write to the I2C device.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char WriteI2CRegister(byte port, byte i2caddr, byte reg, byte val);

/**
 * Read I2C device information.
 * Read standard I2C device information: version, vendor, and device ID. The
 * I2C device uses the specified address.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param i2caddr The I2C device address.
 * \param info A value indicating the type of device information you are requesting.
 * See \ref GenericI2CConstants.
 * \return A string containing the requested device information.
 */
inline string I2CDeviceInfo(byte port, byte i2caddr, byte info);

/**
 * Read I2C device version.
 * Read standard I2C device version. The I2C device uses the specified address.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param i2caddr The I2C device address.
 * \return A string containing the device version.
 */
inline string I2CVersion(byte port, byte i2caddr);

/**
 * Read I2C device vendor.
 * Read standard I2C device vendor. The I2C device uses the specified address.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param i2caddr The I2C device address.
 * \return A string containing the device vendor.
 */
inline string I2CVendorId(byte port, byte i2caddr);

/**
 * Read I2C device identifier.
 * Read standard I2C device identifier. The I2C device uses the specified address.
 *
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param i2caddr The I2C device address.
 * \return A string containing the device identifier.
 */
inline string I2CDeviceId(byte port, byte i2caddr);

/**
 * Send an I2C command.
 * Send a command to an I2C device at the standard command register: \ref I2C_REG_CMD.
 * The I2C device uses the specified address.
 * \param port The port to which the I2C device is attached. See the
 * \ref InPorts group. You may use a constant or a variable. Constants should
 * be used where possible to avoid blocking access to I2C devices on other
 * ports by code running on other threads.
 * \param i2caddr The I2C device address.
 * \param cmd The command to send to the I2C device.
 * \return A status code indicating whether the write completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline long I2CSendCommand(byte port, byte i2caddr, byte cmd);

/** @defgroup LowLevelLowSpeedModuleFunctions Low level LowSpeed module functions
 * Low level functions for accessing low speed module features.
 * @{
 */

/**
 * Get I2C input buffer data.
 * This method reads count bytes of data from the I2C input buffer for the
 * specified port and writes it to the buffer provided.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \param offset A constant offset into the I2C input buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the I2C input buffer.
 */
inline void GetLSInputBuffer(const byte port, const byte offset, byte cnt, byte & data[]);

/**
 * Get I2C output buffer data.
 * This method reads cnt bytes of data from the I2C output buffer for the
 * specified port and writes it to the buffer provided.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \param offset A constant offset into the I2C output buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the I2C output buffer.
 */
inline void GetLSOutputBuffer(const byte port, const byte offset, byte cnt, byte & data[]);

/**
 * Get I2C input buffer in-pointer.
 * This method returns the value of the input pointer of the I2C input
 * buffer for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C input buffer's in-pointer value.
 */
inline byte LSInputBufferInPtr(const byte port);

/**
 * Get I2C input buffer out-pointer.
 * This method returns the value of the output pointer of the I2C input
 * buffer for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C input buffer's out-pointer value.
 */
inline byte LSInputBufferOutPtr(const byte port);

/**
 * Get I2C input buffer bytes to rx.
 * This method returns the value of the bytes to rx field of the I2C input
 * buffer for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C input buffer's bytes to rx value.
 */
inline byte LSInputBufferBytesToRx(const byte port);

/**
 * Get I2C output buffer in-pointer.
 * This method returns the value of the input pointer of the I2C output
 * buffer for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C output buffer's in-pointer value.
 */
inline byte LSOutputBufferInPtr(const byte port);

/**
 * Get I2C output buffer out-pointer.
 * This method returns the value of the output pointer of the I2C output
 * buffer for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C output buffer's out-pointer value.
 */
inline byte LSOutputBufferOutPtr(const byte port);

/**
 * Get I2C output buffer bytes to rx.
 * This method returns the value of the bytes to rx field of the I2C output
 * buffer for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C output buffer's bytes to rx value.
 */
inline byte LSOutputBufferBytesToRx(const byte port);

/**
 * Get I2C mode.
 * This method returns the value of the I2C mode for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C port mode. See \ref LowSpeedModeConstants.
 */
inline byte LSMode(const byte port);

/**
 * Get I2C channel state.
 * This method returns the value of the I2C channel state for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C port channel state. See \ref LowSpeedChannelStateConstants.
 */
inline byte LSChannelState(const byte port);

/**
 * Get I2C error type.
 * This method returns the value of the I2C error type for the specified port.
 * \param port A constant port number (S1..S4). See \ref InPorts.
 * \return The I2C port error type. See \ref LowSpeedErrorTypeConstants.
 */
inline byte LSErrorType(const byte port);

/**
 * Get I2C state.
 * This method returns the value of the I2C state.
 * \return The I2C state. See \ref LowSpeedStateConstants.
 */
inline byte LSState();

/**
 * Get I2C speed.
 * This method returns the value of the I2C speed.
 * \return The I2C speed.
 * \warning This function is unimplemented within the firmware.
 */
inline byte LSSpeed();

#ifdef __ENHANCED_FIRMWARE
/**
 * Get I2C no restart on read setting.
 * This method returns the value of the I2C no restart on read field.
 * \return The I2C no restart on read field. See \ref LowSpeedNoRestartConstants.
 */
inline byte LSNoRestartOnRead();

#endif

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Set I2C options.
 * This method lets you modify I2C options. Use this function to turn on
 * or off the fast I2C mode and also control whether the standard I2C mode
 * performs a restart prior to the read operation.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \param port The port whose I2C options you wish to change. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param options The new option value.  See \ref I2COptionConstants.
 */
inline void SetI2COptions(byte port, byte options);
#endif


/*
// these low speed module IOMap fields are essentially read-only
inline void SetLSInputBuffer(const byte port, const byte offset, byte cnt, byte data[]);
inline void SetLSInputBufferInPtr(const byte port, byte n);
inline void SetLSInputBufferOutPtr(const byte port, byte n);
inline void SetLSInputBufferBytesToRx(const byte port, byte n);
inline void SetLSOutputBuffer(const byte port, const byte offset, byte cnt, byte data[]);
inline void SetLSOutputBufferInPtr(const byte port, byte n);
inline void SetLSOutputBufferOutPtr(const byte port, n);
inline void SetLSOutputBufferBytesToRx(const byte port, byte n);
inline void SetLSMode(const byte port, const byte mode);
inline void SetLSChannelState(const byte port, const byte chState);
inline void SetLSErrorType(const byte port, const byte errType);
inline void SetLSState(const byte lsState);
inline void SetLSSpeed(const byte lsSpeed);
#ifdef __ENHANCED_FIRMWARE
inline void SetLSNoRestartOnRead(const byte lsNoRestart);
#endif
*/

/** @} */ // end of LowLevelLowSpeedModuleFunctions group

/** @defgroup LowSpeedModuleSystemCallFunctions LowSpeed module system call functions
 * System call functions for accessing low speed module features.
 * @{
 */

/**
 * Write to a Lowspeed sensor.
 * This function lets you write to an I2C (Lowspeed) sensor using the values
 * specified via the \ref CommLSWriteType structure.
 *
 * \param args The CommLSWriteType structure containing the needed parameters.
 */
inline void SysCommLSWrite(CommLSWriteType & args);

/**
 * Read from a Lowspeed sensor.
 * This function lets you read from an I2C (Lowspeed) sensor using the values
 * specified via the \ref CommLSReadType structure.
 *
 * \param args The CommLSReadType structure containing the needed parameters.
 */
inline void SysCommLSRead(CommLSReadType & args);

/**
 * Check Lowspeed sensor status.
 * This function lets you check the status of an I2C (Lowspeed) sensor
 * transaction using the values specified via the \ref CommLSCheckStatusType
 * structure.
 *
 * \param args The CommLSCheckStatusType structure containing the needed
 * parameters.
 */
inline void SysCommLSCheckStatus(CommLSCheckStatusType & args);

#ifdef __ENHANCED_FIRMWARE
/**
 * Write to a Lowspeed sensor (extra).
 * This function lets you write to an I2C (Lowspeed) sensor using the values
 * specified via the \ref CommLSWriteExType structure. This is the same as the
 * SysCommLSWrite function except that you also can specify whether or not the
 * Lowspeed module should issue a restart command to the I2C device before
 * beginning to read data from the device.
 *
 * \param args The CommLSWriteExType structure containing the desired parameters.
 */
inline void SysCommLSWriteEx(CommLSWriteExType & args);

#endif

/** @} */ // end of LowSpeedModuleSystemCallFunctions group

#else

// ultrasonic sensor
#define SensorUS(_p) asm { ReadSensorUS(_p, __RETVAL__) }
#define ReadSensorUSEx(_port, _values) asm { __ReadSensorUSEx(_port, _values, __RETVAL__) }

#define ReadSensorEMeter(_port, _vIn, _aIn, _vOut, _aOut, _joules, _wIn, _wOut) asm { __ReadSensorEMeter(_port, _vIn, _aIn, _vOut, _aOut, _joules, _wIn, _wOut, __RETVAL__) }

#define ConfigureTemperatureSensor(_port, _config) asm { __TempSendCmd(_port, _config, __RETVAL__) }
#if __FIRMWARE_VERSION > 107
#define SensorTemperature(_port) asm { __ReadSensorTemperature(_port, __FLTRETVAL__) }
#else
#define SensorTemperature(_port) asm { __ReadSensorTemperature(_port, __RETVAL__) }
#endif

#define ReadI2CRegister(_port, _i2caddr, _reg, _out) asm { __MSReadValue(_port, _i2caddr, _reg, 1, _out, __RETVAL__) }
#define WriteI2CRegister(_port, _i2caddr, _reg, _val) asm { __MSWriteToRegister(_port, _i2caddr, _reg, _val, __RETVAL__) }

#define LowspeedStatus(_port, _bready) asm { __lowspeedStatus(_port, _bready, __RETVAL__) }
#define LowspeedCheckStatus(_port) asm { __lowspeedStatus(_port, __TMPBYTE__, __RETVAL__) }
#define LowspeedBytesReady(_port) asm { __lowspeedStatus(_port, __RETVAL__, __TMPBYTE__) }
#define LowspeedWrite(_port, _retlen, _buffer) asm { __lowspeedWrite(_port, _retlen, _buffer, __RETVAL__) }
#define LowspeedRead(_port, _buflen, _buffer) asm { __lowspeedRead(_port, _buflen, _buffer, __RETVAL__) }

#define I2CStatus(_port, _bready) LowspeedStatus(_port, _bready)
#define I2CCheckStatus(_port) LowspeedCheckStatus(_port)
#define I2CBytesReady(_port) LowspeedBytesReady(_port)
#define I2CWrite(_port, _retlen, _buffer) LowspeedWrite(_port, _retlen, _buffer)
#define I2CRead(_port, _buflen, _buffer) LowspeedRead(_port, _buflen, _buffer)

#define I2CBytes(_port, _inbuf, _count, _outbuf) asm { ReadI2CBytes(_port, _inbuf, _count, _outbuf, __RETVAL__) }

#define I2CDeviceInfo(_port, _i2caddr, _info) asm { ReadI2CDeviceInfo(_port, _i2caddr, _info, __STRRETVAL__) }
#define I2CVersion(_port, _i2caddr) asm { ReadI2CDeviceInfo(_port, _i2caddr, I2C_REG_VERSION, __STRRETVAL__) }
#define I2CVendorId(_port, _i2caddr) asm { ReadI2CDeviceInfo(_port, _i2caddr, I2C_REG_VENDOR_ID, __STRRETVAL__) }
#define I2CDeviceId(_port, _i2caddr) asm { ReadI2CDeviceInfo(_port, _i2caddr, I2C_REG_DEVICE_ID, __STRRETVAL__) }

#define I2CSendCommand(_port, _i2caddr, _cmd) asm { __I2CSendCmd(_port, _i2caddr, _cmd, __RETVAL__) }

#define GetLSInputBuffer(_p, _offset, _cnt, _data) asm { __getLSInputBuffer(_p, _offset, _cnt, _data) }
#define GetLSOutputBuffer(_p, _offset, _cnt, _data) asm { __getLSOutputBuffer(_p, _offset, _cnt, _data) }

#define LSInputBufferInPtr(_p) asm { GetLSInputBufferInPtr(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSInputBufferOutPtr(_p) asm { GetLSInputBufferOutPtr(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSInputBufferBytesToRx(_p) asm { GetLSInputBufferBytesToRx(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSOutputBufferInPtr(_p) asm { GetLSOutputBufferInPtr(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSOutputBufferOutPtr(_p) asm { GetLSOutputBufferOutPtr(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSOutputBufferBytesToRx(_p) asm { GetLSOutputBufferBytesToRx(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSMode(_p) asm { GetLSMode(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSChannelState(_p) asm { GetLSChannelState(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSErrorType(_p) asm { GetLSErrorType(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSState() asm { GetLSState(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LSSpeed() asm { GetLSSpeed(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#ifdef __ENHANCED_FIRMWARE
#define LSNoRestartOnRead(_n) asm { GetLSNoRestartOnRead(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#endif

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
#define SetI2COptions(_port, _options) asm { __setI2COptions(_port, _options) }
#endif

#define SetLSInputBuffer(_p, _offset, _cnt, _data) asm { __setLSInputBuffer(_p, _offset, _cnt, _data) }

#define SetLSInputBufferInPtr(_p, _n) asm { __setLSInputBufferInPtr(_p, _n) }
#define SetLSInputBufferOutPtr(_p, _n) asm { __setLSInputBufferOutPtr(_p, _n) }
#define SetLSInputBufferBytesToRx(_p, _n) asm { __setLSInputBufferBytesToRx(_p, _n) }

#define SetLSOutputBuffer(_p, _offset, _cnt, _data) asm { __setLSOutputBuffer(_p, _offset, _cnt, _data) }

#define SetLSOutputBufferInPtr(_p, _n) asm { __setLSOutputBufferInPtr(_p, _n) }
#define SetLSOutputBufferOutPtr(_p, _n) asm { __setLSOutputBufferOutPtr(_p, _n) }
#define SetLSOutputBufferBytesToRx(_p, _n) asm { __setLSOutputBufferBytesToRx(_p, _n) }
#define SetLSMode(_p, _n) asm { __setLSMode(_p, _n) }
#define SetLSChannelState(_p, _n) asm { __setLSChannelState(_p, _n) }
#define SetLSErrorType(_p, _n) asm { __setLSErrorType(_p, _n) }
#define SetLSState(_n) asm { __setLSState(_n) }
#define SetLSSpeed(_n) asm { __setLSSpeed(_n) }
#ifdef __ENHANCED_FIRMWARE
#define SetLSNoRestartOnRead(_n) asm { __setLSNoRestartOnRead(_n) }
#endif

#define SysCommLSWrite(_args) asm { \
  compchktype _args, CommLSWriteType \
  syscall CommLSWrite, _args \
}
#define SysCommLSRead(_args) asm { \
  compchktype _args, CommLSReadType \
  syscall CommLSRead, _args \
}
#define SysCommLSCheckStatus(_args) asm { \
  compchktype _args, CommLSCheckStatusType \
  syscall CommLSCheckStatus, _args \
}
#ifdef __ENHANCED_FIRMWARE
#define SysCommLSWriteEx(_args) asm { \
  compchktype _args, CommLSWriteExType \
  syscall CommLSWriteEx, _args \
}
#endif

#endif

/** @} */ // end of LowSpeedModuleFunctions group
/** @} */ // end of LowSpeedModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// COMMAND MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup CommandModule
 * @{
 */
/** @defgroup CommandModuleTypes Command module types
 * Types used by various Command module functions.
 * @{
 */

/**
 * Parameters for the GetStartTick system call.
 * This structure is used when calling the \ref SysGetStartTick system call
 * function.
 * \sa SysGetStartTick()
 */
struct GetStartTickType {
  unsigned long Result;   /*!< The returned tick value. */
};

/**
 * Parameters for the KeepAlive system call.
 * This structure is used when calling the \ref SysKeepAlive system call
 * function.
 * \sa SysKeepAlive()
 */
struct KeepAliveType {
  unsigned long Result;   /*!< The current sleep timeout in milliseconds. */
};

/**
 * Parameters for the IOMapRead system call.
 * This structure is used when calling the \ref SysIOMapRead system call
 * function.
 * \sa SysIOMapRead()
 */
struct IOMapReadType {
  char Result;           /*!< The function call result. \ref NO_ERR means it succeeded. */
  string ModuleName;     /*!< The name of the module to read from. See the \ref ModuleNameConstants group. */
  unsigned int Offset;   /*!< The offset in the module IOMap where to start reading. */
  unsigned int Count;    /*!< The number of bytes to read. */
  byte Buffer[];         /*!< The buffer used to store read bytes. */
};

/**
 * Parameters for the IOMapWrite system call.
 * This structure is used when calling the \ref SysIOMapWrite system call
 * function.
 * \sa SysIOMapWrite()
 */
struct IOMapWriteType {
  char Result;           /*!< The function call result. \ref NO_ERR means it succeeded. */
  string ModuleName;     /*!< The name of the module to write to. See the \ref ModuleNameConstants group. */
  unsigned int Offset;   /*!< The offset in the module IOMap where to start writing. */
  byte Buffer[];         /*!< The buffer containing bytes to write. */
};

#ifdef __ENHANCED_FIRMWARE
/**
 * Parameters for the IOMapReadByID system call.
 * This structure is used when calling the \ref SysIOMapReadByID system call
 * function.
 * \sa SysIOMapReadByID()
 */
struct IOMapReadByIDType {
  char Result;            /*!< The function call result. \ref NO_ERR means it succeeded. */
  unsigned long ModuleID; /*!< The identifier of the module to read from. See the \ref ModuleIDConstants group. */
  unsigned int Offset;    /*!< The offset in the module IOMap where to start reading. */
  unsigned int Count;     /*!< The number of bytes to read. */
  byte Buffer[];          /*!< The buffer used to store read bytes. */
};

/**
 * Parameters for the IOMapWriteByID system call.
 * This structure is used when calling the \ref SysIOMapWriteByID system call
 * function.
 * \sa SysIOMapWriteByID()
 */
struct IOMapWriteByIDType {
  char Result;            /*!< The function call result. \ref NO_ERR means it succeeded. */
  unsigned long ModuleID; /*!< The identifier of the module to write to. See the \ref ModuleIDConstants group. */
  unsigned int Offset;    /*!< The offset in the module IOMap where to start writing. */
  byte Buffer[];          /*!< The buffer containing bytes to write. */
};

#endif

#if __FIRMWARE_VERSION > 107

/**
 * Parameters for the DatalogWrite system call.
 * This structure is used when calling the \ref SysDatalogWrite system call
 * function.
 * \sa SysDatalogWrite()
 */
struct DatalogWriteType {
 char Result;     /*!< The function call result. \ref NO_ERR means it succeeded. */
 byte Message[];  /*!< A buffer containing data to write to the datalog. */
};

/**
 * Parameters for the DatalogGetTimes system call.
 * This structure is used when calling the \ref SysDatalogGetTimes system call
 * function.
 * \sa SysDatalogGetTimes()
 */
struct DatalogGetTimesType {
 unsigned long SyncTime;  /*!< The datalog synchronized time. */
 unsigned long SyncTick;  /*!< The datalog synchronized tick. */
};

/**
 * Parameters for the ReadSemData system call.
 * This structure is used when calling the \ref SysReadSemData system call
 * function.
 * \sa SysReadSemData()
 */
struct ReadSemDataType {
  byte SemData;  /*!< The semaphore data returned by the function call. */
  bool Request;  /*!< Which semaphore am I reading from, usage or request? */
};

/**
 * Parameters for the WriteSemData system call.
 * This structure is used when calling the \ref SysWriteSemData system call
 * function.
 * \sa SysWriteSemData()
 */
struct WriteSemDataType {
  byte SemData;   /*!< The modified semaphore data returned by the function call. */
  bool Request;   /*!< Which semaphore am I writing to, usage or request? */
  byte NewVal;    /*!< The new semaphore data. */
  bool ClearBits; /*!< Should I clear existing bits? */
};

/**
 * Parameters for the UpdateCalibCacheInfo system call.
 * This structure is used when calling the \ref SysUpdateCalibCacheInfo system call
 * function.
 * \sa SysUpdateCalibCacheInfo()
 */
struct UpdateCalibCacheInfoType {
  byte Result;          /*!< The function call result. \todo ?. */
  string Name;          /*!< The name of the sensor calibration cache. \todo ?. */
  unsigned int MinVal;  /*!< The minimum calibrated value. */
  unsigned int MaxVal;  /*!< The maximum calibrated value. */
};

/**
 * Parameters for the ComputeCalibValue system call.
 * This structure is used when calling the \ref SysComputeCalibValue system call
 * function.
 * \sa SysComputeCalibValue()
 */
struct ComputeCalibValueType {
  byte Result;          /*!< The function call result. \todo ?. */
  string Name;          /*!< The name of the sensor calibration cache. \todo ?. */
  unsigned int RawVal;  /*!< The raw value. \todo ?. */
};

#ifdef __ENHANCED_FIRMWARE
/**
 * Parameters for the MemoryManager system call.
 * This structure is used when calling the \ref SysMemoryManager system call
 * function.
 * \sa SysMemoryManager()
 */
struct MemoryManagerType {
  char Result;                /*!< The returned status value. */
  bool Compact;               /*!< Should the dataspace be compacted or not. */
  unsigned int PoolSize;      /*!< The returned pool size. */
  unsigned int DataspaceSize; /*!< The returned dataspace size. */
};

/**
 * Parameters for the ReadLastResponse system call.
 * This structure is used when calling the \ref SysReadLastResponse system call
 * function.
 * \sa SysReadLastResponse()
 */
struct ReadLastResponseType {
  char Result;   /*!< The response packet status value. */
  bool Clear;    /*!< Clear the response after reading it or not. */
  byte Length;   /*!< The response packet length. */
  byte Command;  /*!< The response packet command byte. */
  byte Buffer[]; /*!< The response packet buffer. */
};
#endif

#endif
/** @} */ // end of CommandModuleTypes group

/** @defgroup CommandModuleFunctions Command module functions
 * Functions for accessing and modifying Command module features.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Read the current system tick.
 * This function lets you current system tick count.
 *
 * \return The current system tick count.
 */
inline unsigned long CurrentTick();

/**
 * Get the first tick.
 * Return an unsigned 32-bit value, which is the system timing value
 * (called a "tick") in milliseconds at the time that the program began
 * running.
 *
 * \return The tick count at the start of program execution.
 */
inline unsigned long FirstTick();

/**
 * Reset the sleep timer.
 * This function lets you reset the sleep timer.
 *
 * \return The result of resetting the sleep timer.
 */
inline long ResetSleepTimer();

//inline void SpawnProgram(string fname); // not ready to be documented

/**
 * Call any system function.
 * This generic macro can be used to call any system function. No type
 * checking is performed so you need to make sure you use the correct
 * structure type given the selected system function ID. This is, however, the
 * fastest possible way to call a system function in NXC.
 *
 * Valid function ID constants are defined in the \ref SysCallConstants group.
 *
 * \param funcID The function ID constant corresponding to the function to be
 * called.
 * \param args The structure containing the needed parameters.
 */
inline void SysCall(byte funcID, variant & args);

/**
 * Get start tick.
 * This function lets you obtain the tick value at the time your program began
 * executing via the \ref GetStartTickType structure.
 *
 * \param args The GetStartTickType structure receiving results.
 */
inline void SysGetStartTick(GetStartTickType & args);

/**
 * Keep alive.
 * This function lets you reset the sleep timer via the \ref KeepAliveType
 * structure.
 *
 * \param args The KeepAliveType structure receiving results.
 */
inline void SysKeepAlive(KeepAliveType & args);

/**
 * Read from IOMap by name.
 * This function lets you read data from a firmware module's IOMap using the
 * values specified via the \ref IOMapReadType structure.
 *
 * \param args The IOMapReadType structure containing the needed parameters.
 */
inline void SysIOMapRead(IOMapReadType & args);

/**
 * Write to IOMap by name.
 * This function lets you write data to a firmware module's IOMap using the
 * values specified via the \ref IOMapWriteType structure.
 *
 * \param args The IOMapWriteType structure containing the needed parameters.
 */
inline void SysIOMapWrite(IOMapWriteType & args);

#ifdef __ENHANCED_FIRMWARE
/**
 * Read from IOMap by identifier.
 * This function lets you read data from a firmware module's IOMap using the
 * values specified via the \ref IOMapReadByIDType structure. This function
 * can be as much as three times faster than using SysIOMapRead since it does
 * not have to do a string lookup using the ModuleName.
 *
 * \param args The IOMapReadByIDType structure containing the needed
 * parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SysIOMapReadByID(IOMapReadByIDType & args);

/**
 * Write to IOMap by identifier.
 * This function lets you write data to a firmware module's IOMap using the
 * values specified via the \ref IOMapWriteByIDType structure. This function
 * can be as much as three times faster than using SysIOMapWrite since it does
 * not have to do a string lookup using the ModuleName.
 *
 * \param args The IOMapWriteByIDType structure containing the needed
 * parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SysIOMapWriteByID(IOMapWriteByIDType & args);

#endif

#if __FIRMWARE_VERSION > 107

/**
 * Write to the datalog.
 * This function lets you write to the datalog using the
 * values specified via the \ref DatalogWriteType structure.
 *
 * \todo figure out what this function is intended for
 * \param args The DatalogWriteType structure containing the needed parameters.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysDatalogWrite(DatalogWriteType & args);

/**
 * Get datalog times.
 * This function lets you get datalog times using the
 * values specified via the \ref DatalogGetTimesType structure.
 *
 * \todo figure out what this function is intended for
 * \param args The DatalogGetTimesType structure containing the needed parameters.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysDatalogGetTimes(DatalogGetTimesType & args);

/**
 * Read semaphore data.
 * This function lets you read global motor semaphore data using the
 * values specified via the \ref ReadSemDataType structure.
 *
 * \param args The ReadSemDataType structure containing the needed parameters.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysReadSemData(ReadSemDataType & args);

/**
 * Write semaphore data.
 * This function lets you write global motor semaphore data using the
 * values specified via the \ref WriteSemDataType structure.
 *
 * \param args The WriteSemDataType structure containing the needed parameters.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysWriteSemData(WriteSemDataType & args);

/**
 * Update calibration cache information.
 * This function lets you update calibration cache information using the
 * values specified via the \ref UpdateCalibCacheInfoType structure.
 *
 * \todo figure out what this function is intended for
 * \param args The UpdateCalibCacheInfoType structure containing the needed parameters.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysUpdateCalibCacheInfo(UpdateCalibCacheInfoType & args);

/**
 * Compute calibration values.
 * This function lets you compute calibration values using the
 * values specified via the \ref ComputeCalibValueType structure.
 *
 * \todo figure out what this function is intended for
 * \param args The ComputeCalibValueType structure containing the needed parameters.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysComputeCalibValue(ComputeCalibValueType & args);

#endif

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Read memory information.
 * Read the current pool size and dataspace size.  Optionally compact the
 * dataspace before returning the information. Running programs have a maximum
 * of 32k bytes of memory available.  The amount of free RAM can be calculated
 * by subtracting the value returned by this function from \ref POOL_MAX_SIZE.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param Compact A boolean value indicating whether to compact the dataspace or not.
 * \param PoolSize The current pool size.
 * \param DataspaceSize The current dataspace size.
 * \return The function call result. It will be \ref NO_ERR if the compact
 * operation is not performed.  Otherwise it will be the result of the compact
 * operation.
 */
inline char GetMemoryInfo(bool Compact, unsigned int & PoolSize, unsigned int & DataspaceSize);

/**
 * Read memory information.
 * This function lets you read memory information using the
 * values specified via the \ref MemoryManagerType structure.
 *
 * \param args The MemoryManagerType structure containing the required parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SysMemoryManager(MemoryManagerType & args);

/**
 * Read last response information.
 * Read the last direct or system command response packet received by the NXT.
 * Optionally clear the response after retrieving the information.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+.
 *
 * \param Clear A boolean value indicating whether to clear the response or not.
 * \param Length The response packet length.
 * \param Command The original command byte.
 * \param Buffer The response packet buffer.
 * \return The response status code.
 */
inline char GetLastResponseInfo(bool Clear, byte & Length, byte & Command, byte & Buffer[]);

/**
 * Read last response information.
 * This function lets you read the last system or direct command response
 * received by the NXT using the values specified via the
 * \ref ReadLastResponseType structure.
 *
 * \param args The ReadLastResponseType structure containing the required parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+.
 */
inline void SysReadLastResponse(ReadLastResponseType & args);

#endif


#else

#define CurrentTick() asm { gettick __URETVAL__ }
#define FirstTick() asm { GetFirstTick(__URETVAL__) }
#define ResetSleepTimer() asm { acquire __KeepAliveMutex \
  syscall KeepAlive, __KeepAliveArgs \
  mov __RETVAL__, __KeepAliveArgs.Result \
  release __KeepAliveMutex }

#define SpawnProgram(_fname) asm { __spawnProgram(_fname) }

#define SysCall(_func, _args) asm { syscall _func, _args }

#define SysGetStartTick(_args) asm { \
  compchktype _args, GetStartTickType \
  syscall GetStartTick, _args \
}

#define SysKeepAlive(_args) asm { \
  compchktype _args, KeepAliveType \
  syscall KeepAlive, _args \
}

#define SysIOMapRead(_args) asm { \
  compchktype _args, IOMapReadType \
  syscall IOMapRead, _args \
}
#define SysIOMapWrite(_args) asm { \
  compchktype _args, IOMapWriteType \
  syscall IOMapWrite, _args \
}

#ifdef __ENHANCED_FIRMWARE
#define SysIOMapReadByID(_args) asm { \
  compchktype _args, IOMapReadByIDType \
  syscall IOMapReadByID, _args \
}
#define SysIOMapWriteByID(_args) asm { \
  compchktype _args, IOMapWriteByIDType \
  syscall IOMapWriteByID, _args \
}
#endif
#if __FIRMWARE_VERSION > 107

#define SysDatalogWrite(_args) asm { \
  compchktype _args, DatalogWriteType \
  syscall DatalogWrite, _args \
}
#define SysDatalogGetTimes(_args) asm { \
  compchktype _args, DatalogGetTimesType \
  syscall DatalogGetTimes, _args \
}
#define SysReadSemData(_args) asm { \
  compchktype _args, ReadSemDataType \
  syscall ReadSemData, _args \
}
#define SysWriteSemData(_args) asm { \
  compchktype _args, WriteSemDataType \
  syscall WriteSemData, _args \
}
#define SysUpdateCalibCacheInfo(_args) asm { \
  compchktype _args, UpdateCalibCacheInfoType \
  syscall UpdateCalibCacheInfo, _args \
}
#define SysComputeCalibValue(_args) asm { \
  compchktype _args, ComputeCalibValueType \
  syscall ComputeCalibValue, _args \
}
#endif

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)

#define GetMemoryInfo(_Compact,_PoolSize,_DataspaceSize) asm { __GetMemoryInfo(_Compact,_PoolSize,_DataspaceSize,__RETVAL__) }

#define SysMemoryManager(_args) asm { \
  compchktype _args, MemoryManagerType \
  syscall MemoryManager, _args \
}

#define GetLastResponseInfo(_Clear,_Length,_Command,_Buffer) asm { __GetLastResponseInfo(_Clear,_Length,_Command,_Buffer,__RETVAL__) }

#define SysReadLastResponse(_args) asm { \
  compchktype _args, ReadLastResponseType \
  syscall ReadLastResponse, _args \
}

#endif

#define until(_c) while(!(_c))

#endif

/**
 * Wait some milliseconds.
 * Make a task sleep for specified amount of time (in 1000ths of a second).
 *
 * \param ms The number of milliseconds to sleep.
 */
inline void Wait(unsigned long ms) { asm { waitv ms } }

/**
 * Yield to another task.
 * Make a task yield to another concurrently running task.
 */
inline void Yield() { asm { wait 1 } }

/**
 * Stop all tasks.
 * Stop all currently running tasks. This will halt the program completely,
 * so any code following this command will be ignored.
 */
inline void StopAllTasks() { Stop(true); }


#ifdef __DOXYGEN_DOCS
/**
 * Stop the running program.
 * Stop the running program if bvalue is true. This will halt the program
 * completely, so any code following this command will be ignored.
 * \param bvalue If this value is true the program will stop executing.
 */
inline void Stop(bool bvalue);

/**
 * Exit to another task.
 * Immediately exit the current task and start executing the specified task.
 * \param newTask The task to start executing after exiting the current task.
 */
inline void ExitTo(task newTask);

/**
 * Declare tasks that this task precedes.
 * Schedule the listed tasks for execution once the current task has
 * completed executing. The tasks will all execute simultaneously unless other
 * dependencies prevent them from doing so. This statement should be used once
 * within a task - preferably at the start of the task definition. Any number
 * of tasks may be listed in the Precedes statement.
 * \param task1 The first task to start executing after the current task ends.
 * \param task2 The second task to start executing after the current task ends.
 * \param taskN The last task to start executing after the current task ends.
 */
inline void Precedes(task task1, task task2, ..., task taskN);

/**
 * Declare tasks that this task follows.
 * Schedule this task to follow the specified tasks so that it will execute
 * once any of the specified tasks has completed executing. This statement
 * should occur once within a task - preferably at the start of the task
 * definition. If multiple tasks declare that they follow the same task then
 * they will all execute simultaneously unless other dependencies prevent them
 * from doing so. Any number of tasks may be listed in the Follows statement.
 * \param task1 The first task that this task follows.
 * \param task2 The second task that this task follows.
 * \param taskN The last task that this task follows.
 */
inline void Follows(task task1, task task2, ..., task taskN);

/**
 * Acquire a mutex.
 * Acquire the specified mutex variable. If another task already has acquired
 * the mutex then the current task will be suspended until the mutex is
 * released by the other task. This function is used to ensure that the current
 * task has exclusive access to a shared resource, such as the display or a
 * motor. After the current task has finished using the shared resource the
 * program should call Release to allow other tasks to acquire the mutex.
 * \param m The mutex to acquire.
 */
inline void Acquire(mutex m);

/**
 * Acquire a mutex.
 * Release the specified mutex variable. Use this to relinquish a mutex so
 * that it can be acquired by another task. Release should always be called
 * after a matching call to Acquire and as soon as possible after a shared
 * resource is no longer needed.
 * \param m The mutex to release.
 */
inline void Release(mutex m);

/**
 * Start a task.
 * Start the specified task.
 * \param t The task to start.
 */
inline void StartTask(task t);

/**
 * Stop a task.
 * Stop the specified task.
 * \param t The task to stop.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void StopTask(task t);

/** @defgroup cmpconst Comparison Constants
 * Logical comparison operators for use in BranchTest and BranchComp.
 * @{
 */
#define LT   0x00 /*!< The first value is less than the second. */
#define GT   0x01 /*!< The first value is greater than the second. */
#define LTEQ 0x02 /*!< The first value is less than or equal to the second. */
#define GTEQ 0x03 /*!< The first value is greater than or equal to the second. */
#define EQ   0x04 /*!< The first value is equal to the second. */
#define NEQ  0x05 /*!< The first value is not equal to the second. */
/** @} */  // end of cmpconst group

/**
 * Branch if test is true.
 * Branch to the specified label if the variable compares to zero with a true
 * result.
 * \param cmp The constant comparison code. See the \ref cmpconst for valid values.
 * \param lbl The name of the label where code should continue executing if
 * the test is true.
 * \param value The value that you want to compare against zero.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void BranchTest(const byte cmp, constant void lbl, variant value);

/**
 * Branch if compare is true.
 * Branch to the specified label if the two values compare with a true result.
 * \param cmp The constant comparison code. See the \ref cmpconst for valid values.
 * \param lbl The name of the label where code should continue executing if
 * the comparison is true.
 * \param v1 The first value that you want to compare.
 * \param v2 The second value that you want to compare.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void BranchComp(const byte cmp, constant void lbl, variant v1, variant v2);

/** @defgroup ArrayFunctions Array API functions
 * Functions for use with NXC array types.
 * @{
 */

/**
 * Build an array.
 * Build a new array from the specified source(s). The sources can be of any
 * type so long as the number of dimensions is equal to or one less than the
 * number of dimensions in the output array and the type is compatible with
 * the type of the output array. If a source is an array with the same number
 * of dimensions as the output array then all of its elements are added to
 * the output array.
 * \param aout The output array to build.
 * \param src1 The first source to build into the output array.
 * \param src2 The second source to build into the output array.
 * \param srcN The first source to build into the output array.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void ArrayBuild(variant & aout[], variant src1, variant src2, ..., variant srcN);

/**
 * Get array length.
 * Return the length of the specified array. Any type of array of up to four
 * dimensions can be passed into this function.
 * \param data The array whose length you need to read.
 * \return The length of the specified array.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline unsigned int ArrayLen(variant data[]);

/**
 * Initialize an array.
 * Initialize the array to contain count elements with each element equal to
 * the value provided. To initialize a multi-dimensional array, the value
 * should be an array of N-1 dimensions, where N is the number of dimensions
 * in the array being initialized.
 * \param aout The output array to initialize.
 * \param value The value to initialize each element to.
 * \param count The number of elements to create in the output array.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void ArrayInit(variant & aout[], variant value, unsigned int count);

/**
 * Copy an array subset.
 * Copy a subset of the source array starting at the specified index and
 * containing the specified number of elements into the destination array.
 * \param aout The output array containing the subset.
 * \param asrc The input array from which to copy a subset.
 * \param idx The start index of the array subset.
 * \param len The length of the array subset.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void ArraySubset(variant & aout[], variant asrc[], unsigned int idx, unsigned int len);

/**
 * Extract item from an array.
 * Extract one element from an array.  The output type depends on the type of
 * the source array.
 * \param out The output value.
 * \param asrc The input array from which to extract an item.
 * \param idx The index of the item to extract.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void ArrayIndex(variant & out, variant asrc[], unsigned int idx);

/**
 * Replace items in an array.
 * Replace one or more items in the specified source array.  The items are
 * replaced starting at the specified index.  If the value provided has the
 * same number of dimensions as the source array then multiple items in the
 * source are replaced.  If the value provided has one less dimension than
 * the source array then one item will be replaced.  Other differences between
 * the source array and the new value dimensionality are not supported.
 * \param asrc The input array to be modified
 * \param idx The index of the item to replace.
 * \param value The new value or values to put into the source array.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void ArrayReplace(variant & asrc[], unsigned int idx, variant value);

#ifdef __ENHANCED_FIRMWARE

/**
 * Calculate the sum of the elements in a numeric array.
 * This function calculates the sum of all or a subset of the elements in the
 * numeric src array.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source numeric array.
 * \param idx The index of the start of the array subset to process. Pass
 * \ref NA to start with the first element.
 * \param len The number of elements to include in the calculation. Pass
 * \ref NA to include the rest of the elements in the src array (from idx to
 * the end of the array).
 * \return The sum of len elements from the src numeric array (starting from idx).
 *
 * \warning You cannot use NXC expressions with this function
 */
inline variant ArraySum(const variant & src[], unsigned int idx, unsigned int len);

/**
 * Calculate the mean of the elements in a numeric array.
 * This function calculates the mean of all or a subset of the elements in the
 * numeric src array.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source numeric array.
 * \param idx The index of the start of the array subset to process. Pass
 * \ref NA to start with the first element.
 * \param len The number of elements to include in the calculation. Pass
 * \ref NA to include the rest of the elements in the src array (from idx to
 * the end of the array).
 * \return The mean value of len elements from the src numeric array (starting from idx).
 *
 * \warning You cannot use NXC expressions with this function
 */
inline variant ArrayMean(const variant & src[], unsigned int idx, unsigned int len);

/**
 * Calculate the sum of the squares of the elements in a numeric array.
 * This function calculates the sum of the squares of all or a subset of the elements in the
 * numeric src array.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source numeric array.
 * \param idx The index of the start of the array subset to process. Pass
 * \ref NA to start with the first element.
 * \param len The number of elements to include in the calculation. Pass
 * \ref NA to include the rest of the elements in the src array (from idx to
 * the end of the array).
 * \return The sum of the squares of len elements from the src numeric array (starting from idx).
 *
 * \warning You cannot use NXC expressions with this function
 */
inline variant ArraySumSqr(const variant & src[], unsigned int idx, unsigned int len);

/**
 * Calculate the standard deviation of the elements in a numeric array.
 * This function calculates the standard deviation of all or a subset of the elements in the
 * numeric src array.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source numeric array.
 * \param idx The index of the start of the array subset to process. Pass
 * \ref NA to start with the first element.
 * \param len The number of elements to include in the calculation. Pass
 * \ref NA to include the rest of the elements in the src array (from idx to
 * the end of the array).
 * \return The standard deviation of len elements from the src numeric array (starting from idx).
 *
 * \warning You cannot use NXC expressions with this function
 */
inline variant ArrayStd(const variant & src[], unsigned int idx, unsigned int len);

/**
 * Calculate the minimum of the elements in a numeric array.
 * This function calculates the minimum of all or a subset of the elements in the
 * numeric src array.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source numeric array.
 * \param idx The index of the start of the array subset to process. Pass
 * \ref NA to start with the first element.
 * \param len The number of elements to include in the calculation. Pass
 * \ref NA to include the rest of the elements in the src array (from idx to
 * the end of the array).
 * \return The minimum of len elements from the src numeric array (starting from idx).
 *
 * \warning You cannot use NXC expressions with this function
 */
inline variant ArrayMin(const variant & src[], unsigned int idx, unsigned int len);

/**
 * Calculate the maximum of the elements in a numeric array.
 * This function calculates the maximum of all or a subset of the elements in the
 * numeric src array.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source numeric array.
 * \param idx The index of the start of the array subset to process. Pass
 * \ref NA to start with the first element.
 * \param len The number of elements to include in the calculation. Pass
 * \ref NA to include the rest of the elements in the src array (from idx to
 * the end of the array).
 * \return The maximum of len elements from the src numeric array (starting from idx).
 *
 * \warning You cannot use NXC expressions with this function
 */
inline variant ArrayMax(const variant & src[], unsigned int idx, unsigned int len);

/**
 * Sort the elements in a numeric array.
 * This function sorts all or a subset of the elements in the
 * numeric src array in ascending order and saves the results in the
 * numeric dest array.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param dest The destination numeric array.
 * \param src The source numeric array.
 * \param idx The index of the start of the array subset to process. Pass
 * \ref NA to start with the first element.
 * \param len The number of elements to include in the sorting process. Pass
 * \ref NA to include the rest of the elements in the src array (from idx to
 * the end of the array).
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void ArraySort(variant & dest[], const variant & src[], unsigned int idx, unsigned int len);

/**
 * Uppercase the characters in a string.
 * This function uppercases all of the characters in the src string.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source string.
 * \return The uppercased string.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline string UpperCase(string src);

/**
 * Lowercase the characters in a string.
 * This function lowercases all of the characters in the src string.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source string.
 * \return The lowercased string.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline string LowerCase(string src);

/**
 * Uppercase some of the characters in a string.
 * This function uppercases all or a subset of the characters in the
 * src string.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source string.
 * \param idx The index of the start of the string subset to process. Pass
 * \ref NA to start with the first character.
 * \param len The number of characters to uppercase. Pass
 * \ref NA to include the rest of the characters in the src string (from idx to
 * the end of the string).
 * \return The uppercased string.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline string UpperCaseEx(string src, unsigned int idx, unsigned int len);

/**
 * Lowercase some of the characters in a string.
 * This function lowercases all or a subset of the characters in the
 * src string.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param src The source string.
 * \param idx The index of the start of the string subset to process. Pass
 * \ref NA to start with the first character.
 * \param len The number of characters to lowercase. Pass
 * \ref NA to include the rest of the characters in the src string (from idx to
 * the end of the string).
 * \return The lowercased string.
 *
 * \warning You cannot use NXC expressions with this function
 */
inline string LowerCaseEx(string src, unsigned int idx, unsigned int len);

/**
 * Operate on numeric arrays.
 * This function lets you perform various operations on numeric arrays.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 *
 * \param op  The array operation. See \ref ArrayOpConstants.
 * \param dest The destination variant type (scalar or array, depending on the operation).
 * \param src The source numeric array.
 * \param idx The index of the start of the array subset to process. Pass
 * \ref NA to start with the first element.
 * \param len The number of elements to include in the specified process. Pass
 * \ref NA to include the rest of the elements in the src array (from idx to
 * the end of the array).
 *
 * \warning You cannot use NXC expressions with this function
 */
inline void ArrayOp(const byte op, variant & dest, const variant & src[], unsigned int idx, unsigned int len);

#endif

/** @} */ // end of ArrayFunctions group

#else

#define StartTask(_t) start _t
#define StopTask(_t) stop _t

#define BranchTest(_cmp, _lbl, _v1) asm{ brtst _cmp, _lbl, _v1 }
#define BranchComp(_cmp, _lbl, _v1, _v2) asm{ brcmp _cmp, _lbl, _v1, _v2 }

#if __FIRMWARE_VERSION <= 107
#define IOMA(_n) asm { mov __RETVAL__, _n }
#define SetIOMA(_n, _val) asm { mov _n, _val }
#endif

#define ArrayBuild(_aout, ...) asm { arrbuild _aout, __VA_ARGS__ }
#define ArrayLen(_asrc) asm { arrsize __GENRETVAL__, _asrc }
#define ArrayInit(_aout, _val, _cnt) asm { arrinit _aout, _val, _cnt }
#define ArraySubset(_aout, _asrc, _idx, _len) asm { arrsubset _aout, _asrc, _idx, _len }

#define ArrayIndex(_out, _A, _i) asm { index _out, _A, _i }
#define ArrayReplace(_A, _i, _new) asm { replace _A, _A, _i, _new }

#ifdef __ENHANCED_FIRMWARE
#define ArraySum(_src, _idx, _len) asm { arrop OPARR_SUM, __GENRETVAL__, _src, _idx, _len }
#define ArrayMean(_src, _idx, _len) asm { arrop OPARR_MEAN, __GENRETVAL__, _src, _idx, _len }
#define ArraySumSqr(_src, _idx, _len) asm { arrop OPARR_SUMSQR, __GENRETVAL__, _src, _idx, _len }
#define ArrayStd(_src, _idx, _len) asm { arrop OPARR_STD, __GENRETVAL__, _src, _idx, _len }
#define ArrayMin(_src, _idx, _len) asm { arrop OPARR_MIN, __GENRETVAL__, _src, _idx, _len }
#define ArrayMax(_src, _idx, _len) asm { arrop OPARR_MAX, __GENRETVAL__, _src, _idx, _len }
#define ArraySort(_dest, _src, _idx, _len) asm { arrop OPARR_SORT, _dest, _src, _idx, _len }
#define UpperCase(_src) asm { arrop OPARR_TOUPPER, __STRRETVAL__, _src, NA, NA }
#define LowerCase(_src) asm { arrop OPARR_TOLOWER, __STRRETVAL__, _src, NA, NA }
#define UpperCaseEx(_src, _idx, _len) asm { arrop OPARR_TOUPPER, __STRRETVAL__, _src, _idx, _len }
#define LowerCaseEx(_src, _idx, _len) asm { arrop OPARR_TOLOWER, __STRRETVAL__, _src, _idx, _len }
#define ArrayOp(_op, _dest, _src, _idx, _len) asm { arrop _op, _dest, _src, _idx, _len }
#endif

#endif


#ifdef __DOXYGEN_DOCS

/**
 * Set IOMap bytes by name.
 * Modify one or more bytes of data in an IOMap structure. The IOMap
 * structure is specified by its module name. You also provide the offset into
 * the IOMap structure where you want to start writing, the number of bytes to
 * write at that location, and a byte array containing the new data.
 * \param moduleName The module name of the IOMap to modify. See \ref ModuleNameConstants.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the data should be written
 * \param count The number of bytes to write at the specified IOMap
 * offset.
 * \param data The byte array containing the data to write to the IOMap
 */
inline void SetIOMapBytes(string moduleName, unsigned int offset, unsigned int count, byte data[]);

/**
 * Set IOMap value by name.
 * Set one of the fields of an IOMap structure to a new value.  The IOMap
 * structure is specified by its module name. You also provide the offset into
 * the IOMap structure where you want to write the value along with a variable
 * containing the new value.
 * \param moduleName The module name of the IOMap to modify. See \ref ModuleNameConstants.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the new value should be written
 * \param value A variable containing the new value to write to the IOMap
 */
inline void SetIOMapValue(string moduleName, unsigned int offset, variant value);

/**
 * Get IOMap bytes by name.
 * Read one or more bytes of data from an IOMap structure. The IOMap
 * structure is specified by its module name. You also provide the offset into
 * the IOMap structure where you want to start reading, the number of bytes to
 * read from that location, and a byte array where the data will be stored.
 * \param moduleName The module name of the IOMap. See \ref ModuleNameConstants.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the data should be read
 * \param count The number of bytes to read from the specified IOMap
 * offset.
 * \param data A byte array that will contain the data read from the IOMap
 */
inline void GetIOMapBytes(string moduleName, unsigned int offset, unsigned int count, byte & data[]);

/**
 * Get IOMap value by name.
 * Read a value from an IOMap structure.  The IOMap
 * structure is specified by its module name. You also provide the offset into
 * the IOMap structure where you want to read the value along with a variable
 * that will contain the IOMap value.
 * \param moduleName The module name of the IOMap. See \ref ModuleNameConstants.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read
 * \param value A variable that will contain the value read from the IOMap
 */
inline void GetIOMapValue(string moduleName, unsigned int offset, variant & value);

/**
 * Get Lowspeed module IOMap bytes.
 * Read one or more bytes of data from Lowspeed module IOMap structure.
 * You provide the offset into the Lowspeed module IOMap structure where you
 * want to start reading, the number of bytes to read from that location, and
 * a byte array where the data will be stored.
 * \param offset The number of bytes offset from the start of the Lowspeed
 * module IOMap structure where the data should be read. See \ref LowSpeedIOMAP.
 * \param count The number of bytes to read from the specified Lowspeed module
 * IOMap offset.
 * \param data A byte array that will contain the data read from the Lowspeed
 * module IOMap.
 */
inline void GetLowSpeedModuleBytes(unsigned int offset, unsigned int count, byte & data[]);

/**
 * Get Display module IOMap bytes.
 * Read one or more bytes of data from Display module IOMap structure.
 * You provide the offset into the Display module IOMap structure where you
 * want to start reading, the number of bytes to read from that location, and
 * a byte array where the data will be stored.
 * \param offset The number of bytes offset from the start of the Display
 * module IOMap structure where the data should be read. See \ref DisplayIOMAP.
 * \param count The number of bytes to read from the specified Display module
 * IOMap offset.
 * \param data A byte array that will contain the data read from the Display
 * module IOMap.
 */
inline void GetDisplayModuleBytes(unsigned int offset, unsigned int count, byte & data[]);

/**
 * Get Comm module IOMap bytes.
 * Read one or more bytes of data from Comm module IOMap structure.
 * You provide the offset into the Comm module IOMap structure where you
 * want to start reading, the number of bytes to read from that location, and
 * a byte array where the data will be stored.
 * \param offset The number of bytes offset from the start of the Comm module
 * IOMap structure where the data should be read. See \ref CommIOMAP.
 * \param count The number of bytes to read from the specified Comm module
 * IOMap offset.
 * \param data A byte array that will contain the data read from the Comm
 * module IOMap.
 */
inline void GetCommModuleBytes(unsigned int offset, unsigned int count, byte & data[]);

/**
 * Get Command module IOMap bytes.
 * Read one or more bytes of data from Command module IOMap structure.
 * You provide the offset into the Command module IOMap structure where you
 * want to start reading, the number of bytes to read from that location, and
 * a byte array where the data will be stored.
 * \param offset The number of bytes offset from the start of the Command module
 * IOMap structure where the data should be read. See \ref CommandIOMAP.
 * \param count The number of bytes to read from the specified Command module
 * IOMap offset.
 * \param data A byte array that will contain the data read from the Command
 * module IOMap.
 */
inline void GetCommandModuleBytes(unsigned int offset, unsigned int count, byte & data[]);

/**
 * Set Command module IOMap bytes.
 * Modify one or more bytes of data in the Command module IOMap structure. You
 * provide the offset into the Command module IOMap structure where you want
 * to start writing, the number of bytes to write at that location, and a byte
 * array containing the new data.
 * \param offset The number of bytes offset from the start of the Command module
 * IOMap structure where the data should be written. See \ref CommandIOMAP.
 * \param count The number of bytes to write at the specified Command module
 * IOMap offset.
 * \param data The byte array containing the data to write to the Command
 * module IOMap.
 */
inline void SetCommandModuleBytes(unsigned int offset, unsigned int count, byte data[]);

/**
 * Set Lowspeed module IOMap bytes.
 * Modify one or more bytes of data in the Lowspeed module IOMap structure. You
 * provide the offset into the Lowspeed module IOMap structure where you want
 * to start writing, the number of bytes to write at that location, and a byte
 * array containing the new data.
 * \param offset The number of bytes offset from the start of the Lowspeed
 * module IOMap structure where the data should be written. See \ref LowSpeedIOMAP.
 * \param count The number of bytes to write at the specified Lowspeed module
 * IOMap offset.
 * \param data The byte array containing the data to write to the Lowspeed
 * module IOMap.
 */
inline void SetLowSpeedModuleBytes(unsigned int offset, unsigned int count, byte data[]);

/**
 * Set Display module IOMap bytes.
 * Modify one or more bytes of data in the Display module IOMap structure. You
 * provide the offset into the Display module IOMap structure where you want to
 * start writing, the number of bytes to write at that location, and a byte
 * array containing the new data.
 * \param offset The number of bytes offset from the start of the Display module
 * IOMap structure where the data should be written. See \ref DisplayIOMAP.
 * \param count The number of bytes to write at the specified Display module
 * IOMap offset.
 * \param data The byte array containing the data to write to the Display
 * module IOMap.
 */
inline void SetDisplayModuleBytes(unsigned int offset, unsigned int count, byte data[]);

/**
 * Set Comm module IOMap bytes.
 * Modify one or more bytes of data in an IOMap structure. You provide the
 * offset into the Comm module IOMap structure where you want to start writing,
 * the number of bytes to write at that location, and a byte array containing
 * the new data.
 * \param offset The number of bytes offset from the start of the Comm module
 * IOMap structure where the data should be written. See \ref CommIOMAP.
 * \param count The number of bytes to write at the specified Comm module IOMap
 * offset.
 * \param data The byte array containing the data to write to the Comm module
 * IOMap.
 */
inline void SetCommModuleBytes(unsigned int offset, unsigned int count, byte data[]);


#ifdef __ENHANCED_FIRMWARE
/**
 * Set IOMap bytes by ID.
 * Modify one or more bytes of data in an IOMap structure. The IOMap
 * structure is specified by its Module ID. You also provide the offset into
 * the IOMap structure where you want to start writing, the number of bytes to
 * write at that location, and a byte array containing the new data.
 * \param moduleId The module ID of the IOMap to modify. See \ref ModuleIDConstants.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the data should be written.
 * \param count The number of bytes to write at the specified IOMap
 * offset.
 * \param data The byte array containing the data to write to the IOMap.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SetIOMapBytesByID(unsigned long moduleId, unsigned int offset, unsigned int count, byte data[]);

/**
 * Set IOMap value by ID.
 * Set one of the fields of an IOMap structure to a new value.  The IOMap
 * structure is specified by its Module ID. You also provide the offset into
 * the IOMap structure where you want to write the value along with a variable
 * containing the new value.
 * \param moduleId The module ID of the IOMap to modify. See \ref ModuleIDConstants.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the new value should be written.
 * \param value A variable containing the new value to write to the IOMap.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SetIOMapValueByID(unsigned long moduleId, unsigned int offset, variant value);

/**
 * Get IOMap bytes by ID.
 * Read one or more bytes of data from an IOMap structure. The IOMap
 * structure is specified by its Module ID. You also provide the offset into
 * the IOMap structure where you want to start reading, the number of bytes to
 * read from that location, and a byte array where the data will be stored.
 * \param moduleId The module ID of the IOMap. See \ref ModuleIDConstants.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the data should be read.
 * \param count The number of bytes to read from the specified IOMap
 * offset.
 * \param data A byte array that will contain the data read from the IOMap.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void GetIOMapBytesByID(unsigned long moduleId, unsigned int offset, unsigned int count, byte & data[]);

/**
 * Get IOMap value by ID.
 * Read a value from an IOMap structure.  The IOMap
 * structure is specified by its Module ID. You also provide the offset into
 * the IOMap structure where you want to read the value along with a variable
 * that will contain the IOMap value.
 * \param moduleId The module ID of the IOMap. See \ref ModuleIDConstants.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read.
 * \param value A variable that will contain the value read from the IOMap.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void GetIOMapValueByID(unsigned long moduleId, unsigned int offset, variant & value);

#endif

/**
 * Set Command module IOMap value.
 * Set one of the fields of the Command module IOMap structure to a new value.
 * You provide the offset into the Command module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Command
 * module IOMap structure where the new value should be written. See \ref CommandIOMAP.
 * \param value A variable containing the new value to write to the Command
 * module IOMap.
 */
inline void SetCommandModuleValue(unsigned int offset, variant value);

/**
 * Set IOCtrl module IOMap value.
 * Set one of the fields of the IOCtrl module IOMap structure to a new value.
 * You provide the offset into the IOCtrl module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the IOCtrl
 * module IOMap structure where the new value should be written. See \ref IOCtrlIOMAP.
 * \param value A variable containing the new value to write to the IOCtrl
 * module IOMap.
 */
inline void SetIOCtrlModuleValue(unsigned int offset, variant value);

/**
 * Set Loader module IOMap value.
 * Set one of the fields of the Loader module IOMap structure to a new value.
 * You provide the offset into the Loader module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Loader
 * module IOMap structure where the new value should be written. See \ref LoaderIOMAP.
 * \param value A variable containing the new value to write to the Loader
 * module IOMap.
 */
inline void SetLoaderModuleValue(unsigned int offset, variant value);

/**
 * Set Ui module IOMap value.
 * Set one of the fields of the Ui module IOMap structure to a new value.
 * You provide the offset into the Ui module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Ui
 * module IOMap structure where the new value should be written. See \ref UiIOMAP.
 * \param value A variable containing the new value to write to the Ui
 * module IOMap.
 */
inline void SetUIModuleValue(unsigned int offset, variant value);

/**
 * Set Sound module IOMap value.
 * Set one of the fields of the Sound module IOMap structure to a new value.
 * You provide the offset into the Sound module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Sound
 * module IOMap structure where the new value should be written. See \ref SoundIOMAP.
 * \param value A variable containing the new value to write to the Sound
 * module IOMap.
 */
inline void SetSoundModuleValue(unsigned int offset, variant value);

/**
 * Set Button module IOMap value.
 * Set one of the fields of the Button module IOMap structure to a new value.
 * You provide the offset into the Button module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Button
 * module IOMap structure where the new value should be written. See \ref ButtonIOMAP.
 * \param value A variable containing the new value to write to the Button
 * module IOMap.
 */
inline void SetButtonModuleValue(unsigned int offset, variant value);

/**
 * Set Input module IOMap value.
 * Set one of the fields of the Input module IOMap structure to a new value.
 * You provide the offset into the Input module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Input
 * module IOMap structure where the new value should be written. See \ref InputIOMAP.
 * \param value A variable containing the new value to write to the Input
 * module IOMap.
 */
inline void SetInputModuleValue(unsigned int offset, variant value);

/**
 * Set Output module IOMap value.
 * Set one of the fields of the Output module IOMap structure to a new value.
 * You provide the offset into the Output module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Output
 * module IOMap structure where the new value should be written. See \ref OutputIOMAP.
 * \param value A variable containing the new value to write to the Output
 * module IOMap.
 */
inline void SetOutputModuleValue(unsigned int offset, variant value);

/**
 * Set Lowspeed module IOMap value.
 * Set one of the fields of the Lowspeed module IOMap structure to a new value.
 * You provide the offset into the Lowspeed module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Lowspeed
 * module IOMap structure where the new value should be written. See \ref LowSpeedIOMAP.
 * \param value A variable containing the new value to write to the Lowspeed
 * module IOMap.
 */
inline void SetLowSpeedModuleValue(unsigned int offset, variant value);

/**
 * Set Display module IOMap value.
 * Set one of the fields of the Display module IOMap structure to a new value.
 * You provide the offset into the Display module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Display
 * module IOMap structure where the new value should be written. See \ref DisplayIOMAP.
 * \param value A variable containing the new value to write to the Display
 * module IOMap.
 */
inline void SetDisplayModuleValue(unsigned int offset, variant value);

/**
 * Set Comm module IOMap value.
 * Set one of the fields of the Comm module IOMap structure to a new value.
 * You provide the offset into the Comm module IOMap structure where you
 * want to write the value along with a variable containing the new value.
 * \param offset The number of bytes offset from the start of the Comm
 * module IOMap structure where the new value should be written. See \ref CommIOMAP.
 * \param value A variable containing the new value to write to the Comm
 * module IOMap.
 */
inline void SetCommModuleValue(unsigned int offset, variant value);

/**
 * Get Command module IOMap value.
 * Read a value from the Command module IOMap structure.  You provide the
 * offset into the Command module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref CommandIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetCommandModuleValue(unsigned int offset, variant & value);

/**
 * Get Loader module IOMap value.
 * Read a value from the Loader module IOMap structure.  You provide the
 * offset into the Loader module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref LoaderIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetLoaderModuleValue(unsigned int offset, variant & value);

/**
 * Get Sound module IOMap value.
 * Read a value from the Sound module IOMap structure.  You provide the
 * offset into the Sound module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref SoundIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetSoundModuleValue(unsigned int offset, variant & value);

/**
 * Get Button module IOMap value.
 * Read a value from the Button module IOMap structure.  You provide the
 * offset into the Button module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref ButtonIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetButtonModuleValue(unsigned int offset, variant & value);

/**
 * Get Ui module IOMap value.
 * Read a value from the Ui module IOMap structure.  You provide the
 * offset into the Ui module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref UiIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetUIModuleValue(unsigned int offset, variant & value);

/**
 * Get Input module IOMap value.
 * Read a value from the Input module IOMap structure.  You provide the
 * offset into the Input module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref InputIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetInputModuleValue(unsigned int offset, variant & value);

/**
 * Get Output module IOMap value.
 * Read a value from the Output module IOMap structure.  You provide the
 * offset into the Output module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref OutputIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetOutputModuleValue(unsigned int offset, variant & value);

/**
 * Get LowSpeed module IOMap value.
 * Read a value from the LowSpeed module IOMap structure.  You provide the
 * offset into the Command module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref LowSpeedIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetLowSpeedModuleValue(unsigned int offset, variant & value);

/**
 * Get Display module IOMap value.
 * Read a value from the Display module IOMap structure.  You provide the
 * offset into the Display module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref DisplayIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetDisplayModuleValue(unsigned int offset, variant & value);

/**
 * Get Comm module IOMap value.
 * Read a value from the Comm module IOMap structure.  You provide the
 * offset into the Comm module IOMap structure where you want to read
 * the value from along with a variable that will store the value. The type
 * of the variable determines how many bytes are read from the IOMap.
 * \param offset The number of bytes offset from the start of the IOMap
 * structure where the value should be read. See \ref CommIOMAP.
 * \param value A variable that will contain the value read from the IOMap.
 */
inline void GetCommModuleValue(unsigned int offset, variant & value);


#else

#define SetIOMapBytes(_modName, _offset, _cnt, _arrIn) asm { __SetIOMapBytes(_modName, _offset, _cnt, _arrIn) }
#define SetIOMapValue(_modName, _offset, _n) asm { __SetIOMapValue(_modName, _offset, _n) }

#define GetIOMapBytes(_modName, _offset, _cnt, _arrOut) asm { __getIOMapBytes(_modName, _offset, _cnt, _arrOut) }
#define GetIOMapValue(_modName, _offset, _n) asm { __getIOMapValue(_modName, _offset, _n) }

#define GetLowSpeedModuleBytes(_offset, _cnt, _arrOut) asm { __getLowSpeedModuleBytes(_offset, _cnt, _arrOut) }
#define GetDisplayModuleBytes(_offset, _cnt, _arrOut) asm { __getDisplayModuleBytes(_offset, _cnt, _arrOut) }
#define GetCommModuleBytes(_offset, _cnt, _arrOut) asm { __getCommModuleBytes(_offset, _cnt, _arrOut) }

#ifdef __ENHANCED_FIRMWARE

#define SetIOMapBytesByID(_modID, _offset, _cnt, _arrIn) asm { __SetIOMapBytesByID(_modID, _offset, _cnt, _arrIn) }
#define SetIOMapValueByID(_modID, _offset, _n) asm { __SetIOMapValueByID(_modID, _offset, _n) }

#define GetIOMapBytesByID(_modID, _offset, _cnt, _arrOut) asm { __getIOMapBytesByID(_modID, _offset, _cnt, _arrOut) }
#define GetIOMapValueByID(_modID, _offset, _n) asm { __getIOMapValueByID(_modID, _offset, _n) }

#define SetCommandModuleValue(_offset, _n) SetIOMapValueByID(CommandModuleID, _offset, _n)
#define SetIOCtrlModuleValue(_offset, _n) SetIOMapValueByID(IOCtrlModuleID, _offset, _n)
#define SetLoaderModuleValue(_offset, _n) SetIOMapValueByID(LoaderModuleID, _offset, _n)
#define SetUIModuleValue(_offset, _n) SetIOMapValueByID(UIModuleID, _offset, _n)
#define SetSoundModuleValue(_offset, _n) SetIOMapValueByID(SoundModuleID, _offset, _n)
#define SetButtonModuleValue(_offset, _n) SetIOMapValueByID(ButtonModuleID, _offset, _n)
#define SetInputModuleValue(_offset, _n) SetIOMapValueByID(InputModuleID, _offset, _n)
#define SetOutputModuleValue(_offset, _n) SetIOMapValueByID(OutputModuleID, _offset, _n)
#define SetLowSpeedModuleValue(_offset, _n) SetIOMapValueByID(LowSpeedModuleID, _offset, _n)
#define SetDisplayModuleValue(_offset, _n) SetIOMapValueByID(DisplayModuleID, _offset, _n)
#define SetCommModuleValue(_offset, _n) SetIOMapValueByID(CommModuleID, _offset, _n)

#define SetCommandModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytesByID(CommandModuleID, _offset, _cnt, _arrIn)
#define SetLowSpeedModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytesByID(LowSpeedModuleID, _offset, _cnt, _arrIn)
#define SetDisplayModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytesByID(DisplayModuleID, _offset, _cnt, _arrIn)
#define SetCommModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytesByID(CommModuleID, _offset, _cnt, _arrIn)

#define GetCommandModuleValue(_offset, _n) GetIOMapValueByID(CommandModuleID, _offset, _n)
#define GetLoaderModuleValue(_offset, _n) GetIOMapValueByID(LoaderModuleID, _offset, _n)
#define GetSoundModuleValue(_offset, _n) GetIOMapValueByID(SoundModuleID, _offset, _n)
#define GetButtonModuleValue(_offset, _n) GetIOMapValueByID(ButtonModuleID, _offset, _n)
#define GetUIModuleValue(_offset, _n) GetIOMapValueByID(UIModuleID, _offset, _n)
#define GetInputModuleValue(_offset, _n) GetIOMapValueByID(InputModuleID, _offset, _n)
#define GetOutputModuleValue(_offset, _n) GetIOMapValueByID(OutputModuleID, _offset, _n)
#define GetLowSpeedModuleValue(_offset, _n) GetIOMapValueByID(LowSpeedModuleID, _offset, _n)
#define GetDisplayModuleValue(_offset, _n) GetIOMapValueByID(DisplayModuleID, _offset, _n)
#define GetCommModuleValue(_offset, _n) GetIOMapValueByID(CommModuleID, _offset, _n)

#else

#define SetCommandModuleValue(_offset, _n) SetIOMapValue(CommandModuleName, _offset, _n)
#define SetIOCtrlModuleValue(_offset, _n) SetIOMapValue(IOCtrlModuleName, _offset, _n)
#define SetLoaderModuleValue(_offset, _n) SetIOMapValue(LoaderModuleName, _offset, _n)
#define SetUIModuleValue(_offset, _n) SetIOMapValue(UIModuleName, _offset, _n)
#define SetSoundModuleValue(_offset, _n) SetIOMapValue(SoundModuleName, _offset, _n)
#define SetButtonModuleValue(_offset, _n) SetIOMapValue(ButtonModuleName, _offset, _n)
#define SetInputModuleValue(_offset, _n) SetIOMapValue(InputModuleName, _offset, _n)
#define SetOutputModuleValue(_offset, _n) SetIOMapValue(OutputModuleName, _offset, _n)
#define SetLowSpeedModuleValue(_offset, _n) SetIOMapValue(LowSpeedModuleName, _offset, _n)
#define SetDisplayModuleValue(_offset, _n) SetIOMapValue(DisplayModuleName, _offset, _n)
#define SetCommModuleValue(_offset, _n) SetIOMapValue(CommModuleName, _offset, _n)

#define SetCommandModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytes(CommandModuleName, _offset, _cnt, _arrIn)
#define SetLowSpeedModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytes(LowSpeedModuleName, _offset, _cnt, _arrIn)
#define SetDisplayModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytes(DisplayModuleName, _offset, _cnt, _arrIn)
#define SetCommModuleBytes(_offset, _cnt, _arrIn) SetIOMapBytes(CommModuleName, _offset, _cnt, _arrIn)

#define GetCommandModuleValue(_offset, _n) GetIOMapValue(CommandModuleName, _offset, _n)
#define GetLoaderModuleValue(_offset, _n) GetIOMapValue(LoaderModuleName, _offset, _n)
#define GetSoundModuleValue(_offset, _n) GetIOMapValue(SoundModuleName, _offset, _n)
#define GetButtonModuleValue(_offset, _n) GetIOMapValue(ButtonModuleName, _offset, _n)
#define GetUIModuleValue(_offset, _n) GetIOMapValue(UIModuleName, _offset, _n)
#define GetInputModuleValue(_offset, _n) GetIOMapValue(InputModuleName, _offset, _n)
#define GetOutputModuleValue(_offset, _n) GetIOMapValue(OutputModuleName, _offset, _n)
#define GetLowSpeedModuleValue(_offset, _n) GetIOMapValue(LowSpeedModuleName, _offset, _n)
#define GetDisplayModuleValue(_offset, _n) GetIOMapValue(DisplayModuleName, _offset, _n)
#define GetCommModuleValue(_offset, _n) GetIOMapValue(CommModuleName, _offset, _n)

#endif

#endif


/** @} */ // end of CommandModuleFunctions group
/** @} */ // end of CommandModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// IOCTRL MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup IOCtrlModule
 * @{
 */
/** @defgroup IOCtrlModuleTypes IOCtrl module types
 * Types used by various IOCtrl module functions.
 * @{
 */
/** @} */ // end of IOCtrlModuleTypes group
/** @defgroup IOCtrlModuleFunctions IOCtrl module functions
 * Functions for accessing and modifying IOCtrl module features.
 * @{
 */

/**
 * Power down the NXT.
 * This function powers down the NXT.
 * The running program will terminate as a result of this action.
 */
inline void PowerDown() {
  SetIOCtrlModuleValue(IOCtrlOffsetPowerOn, IOCTRL_POWERDOWN);
}

/**
 * Put the brick to sleep immediately.
 * This function lets you immediately put the NXT to sleep.
 * The running program will terminate as a result of this action.
 */
inline void SleepNow() {
  SetIOCtrlModuleValue(IOCtrlOffsetPowerOn, IOCTRL_POWERDOWN);
}

/**
 * Reboot the NXT in firmware download mode.
 * This function lets you reboot the NXT into SAMBA or firmware download mode.
 * The running program will terminate as a result of this action.
 */
inline void RebootInFirmwareMode() {
  SetIOCtrlModuleValue(IOCtrlOffsetPowerOn, IOCTRL_BOOT);
}

/** @} */ // end of IOCtrlModuleFunctions group
/** @} */ // end of IOCtrlModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// COMM MODULE /////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup CommModule
 * @{
 */
/** @defgroup CommModuleTypes Comm module types
 * Types used by various Comm module functions.
 * @{
 */
/**
 * Parameters for the MessageWrite system call.
 * This structure is used when calling the \ref SysMessageWrite system call
 * function.
 * \sa SysMessageWrite()
 */
struct MessageWriteType {
  char Result;      /*!< The function call result. \ref NO_ERR means it succeeded. */
  byte QueueID;     /*!< The queue identifier. See the \ref MailboxConstants group. */
  string Message;   /*!< The message to write. */
};

/**
 * Parameters for the MessageRead system call.
 * This structure is used when calling the \ref SysMessageRead system call
 * function.
 * \sa SysMessageRead()
 */
struct MessageReadType {
  char Result;       /*!< The function call result. \ref NO_ERR means it succeeded. */
  byte QueueID;     /*!< The queue identifier. See the \ref MailboxConstants group. */
  bool Remove;      /*!< If true, remove the read message from the queue. */
  string Message;   /*!< The contents of the mailbox/queue. */
};

/**
 * Parameters for the CommBTCheckStatus system call.
 * This structure is used when calling the \ref SysCommBTCheckStatus system
 * call function.
 * \sa SysCommBTCheckStatus()
 */
struct CommBTCheckStatusType {
  char Result;       /*!< The function call result. Possible values include
                       \ref ERR_INVALID_PORT, \ref STAT_COMM_PENDING,
                       \ref ERR_COMM_CHAN_NOT_READY, and \ref LDR_SUCCESS. */
  byte Connection;   /*!< The connection to check. */
};

/**
 * Parameters for the CommBTWrite system call.
 * This structure is used when calling the \ref SysCommBTWrite system call
 * function.
 * \sa SysCommBTWrite()
 */
struct CommBTWriteType {
  char Result;       /*!< The function call result.  Possible values include
                       \ref ERR_COMM_CHAN_NOT_READY
                       and \ref STAT_COMM_PENDING (write accepted). */
  byte Connection;   /*!< The connection to use. */
  byte Buffer[];     /*!< The data to write to the connection. */
};

/**
 * The JoystickMessageType structure.
 * This structure is used to contain Joystick values read via the
 * \ref JoystickMessageRead API function.
 */
struct JoystickMessageType {
  byte JoystickDir;      /*!< The joystick direction or position. Ranges from 1 to 9, with the values representing numeric keypad buttons.  8 is up, 2 is down, 5 is center, etc. */
  byte LeftMotor;        /*!< The left motor. See \ref RCXOutputConstants for possible values. */
  byte RightMotor;       /*!< The right motor. See \ref RCXOutputConstants for possible values. */
  byte BothMotors;       /*!< The left and right motors. See \ref RCXOutputConstants for possible values. */
  char LeftSpeed;        /*!< The left motor speed (-100 to 100). */
  char RightSpeed;       /*!< The right motor speed (-100 to 100). */
  unsigned long Buttons; /*!< The joystick buttons pressed state. */
};

#ifdef __ENHANCED_FIRMWARE
/**
 * Parameters for the CommExecuteFunction system call.
 * This structure is used when calling the \ref SysCommExecuteFunction system
 * call function.
 *
 * The fields usage depends on the requested command and are documented in the
 * table below. If a field member is shown as 'x' it is ignored by the
 * specified command.
 *
 * <table>
 * <tr><td>Cmd</td>
 *     <td>Meaning</td><td>(Param1,Param2,Param3,Name)</td></tr>
 * <tr><td>INTF_SENDFILE</td>
 *     <td>Send a file over a Bluetooth connection</td><td>(Connection,x,x,Filename)</td></tr>
 * <tr><td>INTF_SEARCH</td>
 *     <td>Search for Bluetooth devices</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_STOPSEARCH</td>
 *     <td>Stop searching for Bluetooth devices</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_CONNECT</td>
 *     <td>Connect to a Bluetooth device</td><td>(DeviceIndex,Connection,x,x)</td></tr>
 * <tr><td>INTF_DISCONNECT</td>
 *     <td>Disconnect a Bluetooth device</td><td>(Connection,x,x,x)</td></tr>
 * <tr><td>INTF_DISCONNECTALL</td>
 *     <td>Disconnect all Bluetooth devices</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_REMOVEDEVICE</td>
 *     <td>Remove device from My Contacts</td><td>(DeviceIndex,x,x,x)</td></tr>
 * <tr><td>INTF_VISIBILITY</td>
 *     <td>Set Bluetooth visibility</td><td>(true/false,x,x,x)</td></tr>
 * <tr><td>INTF_SETCMDMODE</td>
 *     <td>Set command mode</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_OPENSTREAM</td>
 *     <td>Open a stream</td><td>(x,Connection,x,x)</td></tr>
 * <tr><td>INTF_SENDDATA</td>
 *     <td>Send data</td><td>(Length, Connection, WaitForIt, Buffer)</td></tr>
 * <tr><td>INTF_FACTORYRESET</td>
 *     <td>Bluetooth factory reset</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_BTON</td>
 *     <td>Turn Bluetooth on</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_BTOFF</td>
 *     <td>Turn Bluetooth off</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_SETBTNAME</td>
 *     <td>Set Bluetooth name</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_EXTREAD</td>
 *     <td>Handle external? read</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_PINREQ</td>
 *     <td>Handle Blueooth PIN request</td><td>(x,x,x,x)</td></tr>
 * <tr><td>INTF_CONNECTREQ</td>
 *     <td>Handle Bluetooth connect request</td><td>(x,x,x,x)</td></tr>
 * </table>
 *
 * \sa SysCommExecuteFunction()
 */
struct CommExecuteFunctionType {
  unsigned int Result;   /*!< The function call result. Possible values
                              include \ref LoaderErrors. */
  byte Cmd;              /*!< The command to execute. */
  byte Param1;           /*!< The first parameter, see table. */
  byte Param2;           /*!< The second parameter, see table. */
  byte Param3;           /*!< The third parameter, see table. */
  string Name;           /*!< The name parameter, see table. */
  unsigned int RetVal;   /*!< The function call return value. Possible values
                              include \ref LoaderErrors. */
};

/**
 * Parameters for the CommHSControl system call.
 * This structure is used when calling the \ref SysCommHSControl system call
 * function.
 * \sa SysCommHSControl()
 */
struct CommHSControlType {
 char Result;             /*!< The function call result. \todo values? */
 byte Command;            /*!< The hi-speed port configuration command.
                               See \ref CommHiSpeedCtrlConstants. */
 byte BaudRate;           /*!< The hi-speed port baud rate. See \ref CommHiSpeedBaudConstants. */
#if __FIRMWARE_VERSION > 107
 unsigned int Mode;       /*!< The hi-speed port mode. See \ref CommHiSpeedDataBitsConstants,
                               \ref CommHiSpeedStopBitsConstants, \ref CommHiSpeedParityConstants,
                               and \ref CommHiSpeedCombinedConstants. */
#endif
};

/**
 * Parameters for the CommHSCheckStatus system call.
 * This structure is used when calling the \ref SysCommHSCheckStatus system call
 * function.
 * \sa SysCommHSCheckStatus()
 */
struct CommHSCheckStatusType {
 byte SendingData;     /*!< Number of bytes of data currently being sent. */
 byte DataAvailable;   /*!< Number of bytes of data available for reading. */
};

/**
 * Parameters for the CommHSReadWrite system call.
 * This structure is used when calling the \ref SysCommHSRead and
 * \ref SysCommHSWrite system call functions.
 * \sa SysCommHSRead(), SysCommHSWrite()
 */
struct CommHSReadWriteType {
 char Status;    /*!< The result of the function call. */
 byte Buffer[];  /*!< The buffer of data to write or to contain the data read
                      from the hi-speed port. */
#if __FIRMWARE_VERSION > 107
 byte BufferLen; /*!< The size of the output buffer on input.  Determines the
                      maximum number of bytes read from the hi-speed port.
                      This field is not updated during the function call and
                      it is only used for the Read operation. */
#endif
};
#endif

#if __FIRMWARE_VERSION > 107
/**
 * Parameters for the CommBTOnOff system call.
 * This structure is used when calling the \ref SysCommBTOnOff system call
 * function.
 * \sa SysCommBTOnOff()
 */
struct CommBTOnOffType {
#ifdef __ENHANCED_FIRMWARE
 unsigned int Result; /*!< The function call result. */
#else
 char Result;         /*!< The function call result. */
#endif
 bool PowerState;     /*!< If true then turn on bluetooth, otherwise, turn it off. */
};

/**
 * Parameters for the CommBTConnection system call.
 * This structure is used when calling the \ref SysCommBTConnection system call
 * function.
 * \sa SysCommBTConnection()
 */
struct CommBTConnectionType {
#ifdef __ENHANCED_FIRMWARE
 unsigned int Result; /*!< The function call result. */
#else
 char Result;         /*!< The function call result. */
#endif
 byte Action;         /*!< The connection action (connect or disconnect). */
 string Name;         /*!< The name of the device to connect or disconnect. */
 byte ConnectionSlot; /*!< The connection slot to connect or disconnect. */
};
#endif

/** @} */ // end of CommModuleTypes group
/** @defgroup CommModuleFunctions Comm module functions
 * Functions for accessing and modifying Comm module features.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Read a joystick message from a queue/mailbox.
 * Read a joystick message from a queue/mailbox.
 *
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param msg The joystick message that is read from the mailbox. See
 * \ref JoystickMessageType for details.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char JoystickMessageRead(byte queue, JoystickMessageType & msg);

/**
 * Send a message to a queue/mailbox.
 * Write a message into a local mailbox.
 * 
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param msg The message to write to the mailbox.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char SendMessage(byte queue, string msg);

/**
 * Read a message from a queue/mailbox.
 * Read a message from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.
 *
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param msg The message that is read from the mailbox.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char ReceiveMessage(byte queue, bool clear, string & msg);

/**
 * Check bluetooth status.
 * Check the status of the bluetooth subsystem for the specified connection slot.
 * 
 * \param conn The connection slot (0..3). Connections 0 through 3 are for
 * bluetooth connections.  See \ref CommConnectionConstants.
 * \return The bluetooth status for the specified connection.
 */
inline char BluetoothStatus(byte conn);

/**
 * Write to a bluetooth connection.
 * This method tells the NXT firmware to write the data in the buffer to the
 * device on the specified Bluetooth connection. Use \ref BluetoothStatus to
 * determine when this write request is completed.
 *
 * \param conn The connection slot (0..3). Connections 0 through 3 are for
 * bluetooth connections.  See \ref CommConnectionConstants.
 * \param buffer The data to be written (up to 128 bytes)
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char BluetoothWrite(byte conn, byte buffer[]);

/**
 * Write to a remote connection.
 * This method tells the NXT firmware to write the data in the buffer to the
 * device on the specified connection.  Use \ref RemoteConnectionIdle to determine
 * when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param buffer The data to be written (up to 128 bytes)
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning Writing to the RS485 hi-speed connection requires the enhanced
 * NBC/NXC firmware
 */
inline char RemoteConnectionWrite(byte conn, byte buffer[]);

/**
 * Check if remote connection is idle.
 * Check whether a Bluetooth or RS485 hi-speed port connection is idle,
 * i.e., not currently sending data.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \return A boolean value indicating whether the connection is idle or busy.
 *
 * \warning Checking the status of the RS485 hi-speed connection requires the
 * enhanced NBC/NXC firmware
 */
inline bool RemoteConnectionIdle(byte conn);

/**
 * Send a boolean value to a remote mailbox.
 * Send a boolean value on the specified connection to the
 * specified remote mailbox number.  Use \ref RemoteConnectionIdle to determine
 * when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param bval The boolean value to send.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char SendRemoteBool(byte conn, byte queue, bool bval);

/**
 * Send a numeric value to a remote mailbox.
 * Send a numeric value on the specified connection to the
 * specified remote mailbox number.  Use \ref RemoteConnectionIdle to determine
 * when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param val The numeric value to send.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char SendRemoteNumber(byte conn, byte queue, long val);

/**
 * Send a string value to a remote mailbox.
 * Send a string value on the specified connection to the
 * specified remote mailbox number.  Use \ref RemoteConnectionIdle to determine
 * when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param str The string value to send.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char SendRemoteString(byte conn, byte queue, string str);

/**
 * Write a boolean value to a local response mailbox.
 * Write a boolean value to a response mailbox (the mailbox number + 10).
 *
 * \param queue The mailbox number. See \ref MailboxConstants. This function
 * shifts the specified value into the range of response mailbox numbers by
 * adding 10.
 * \param bval The boolean value to write.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char SendResponseBool(byte queue, bool bval);

/**
 * Write a numeric value to a local response mailbox.
 * Write a numeric value to a response mailbox (the mailbox number + 10).
 *
 * \param queue The mailbox number. See \ref MailboxConstants. This function
 * shifts the specified value into the range of response mailbox numbers by
 * adding 10.
 * \param val The numeric value to write.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char SendResponseNumber(byte queue, long val);

/**
 * Write a string value to a local response mailbox.
 * Write a string value to a response mailbox (the mailbox number + 10).
 *
 * \param queue The mailbox number. See \ref MailboxConstants. This function
 * shifts the specified value into the range of response mailbox numbers by
 * adding 10.
 * \param str The string value to write.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char SendResponseString(byte queue, string str);

/**
 * Read a boolean value from a queue/mailbox.
 * Read a boolean value from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.
 *
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param bval The boolean value that is read from the mailbox.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char ReceiveRemoteBool(byte queue, bool clear, bool & bval);

/**
 * Read a value from a queue/mailbox.
 * Read a value from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.  Output the value in string, number, and
 * boolean form.
 *
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param str The string value that is read from the mailbox.
 * \param val The numeric value that is read from the mailbox.
 * \param bval The boolean value that is read from the mailbox.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char ReceiveRemoteMessageEx(byte queue, bool clear, string & str, long & val, bool & bval);

/**
 * Read a numeric value from a queue/mailbox.
 * Read a numeric value from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.
 *
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param val The numeric value that is read from the mailbox.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char ReceiveRemoteNumber(byte queue, bool clear, long & val);

/**
 * Read a string value from a queue/mailbox.
 * Read a string value from a mailbox and optionally remove it.  If the local mailbox
 * is empty and this NXT is the master then it attempts to poll one of its
 * slave NXTs for a message from the response mailbox that corresponds to the
 * specified local mailbox number.
 *
 * \param queue The mailbox number. See \ref MailboxConstants.
 * \param clear A flag indicating whether to remove the message from the mailbox
 * after it has been read.
 * \param str The string value that is read from the mailbox.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char ReceiveRemoteString(byte queue, bool clear, string & str);

/** @defgroup CommModuleDCFunctions Direct Command functions
 * Functions for sending direct commands to another NXT.
 * @{
 */

/**
 * Send a KeepAlive message.
 * This method sends a KeepAlive direct command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteKeepAlive(byte conn);

/**
 * Send a MessageRead message.
 * This method sends a MessageRead direct command to the device on the
 * specified connection. Use \ref RemoteConnectionIdle to determine when this write
 * request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param queue The mailbox to read. See \ref MailboxConstants.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteMessageRead(byte conn, byte queue);

/**
 * Send a MessageWrite message.
 * This method sends a MessageWrite direct command to the device on the
 * specified connection. Use \ref RemoteConnectionIdle to determine when this write
 * request is completed.
 * 
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param queue The mailbox to write. See \ref MailboxConstants.
 * \param msg The message to write to the mailbox.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteMessageWrite(byte conn, byte queue, string msg);

/**
 * Send a PlaySoundFile message.
 * Send the PlaySoundFile direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param filename The name of the sound file to play.
 * \param bloop A boolean value indicating whether to loop the sound file or not.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemotePlaySoundFile(byte conn, string filename, bool bloop);

/**
 * Send a PlayTone message.
 * Send the PlayTone direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param frequency The frequency of the tone.
 * \param duration The duration of the tone.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemotePlayTone(byte conn, unsigned int frequency, unsigned int duration);

/**
 * Send a ResetMotorPosition message.
 * Send the ResetMotorPosition direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param port The output port to reset.
 * \param brelative A flag indicating whether the counter to reset is relative.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteResetMotorPosition(byte conn, byte port, bool brelative);

/**
 * Send a ResetScaledValue message.
 * Send the ResetScaledValue direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param port The input port to reset.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteResetScaledValue(byte conn, byte port);

/**
 * Send a SetInputMode message.
 * Send the SetInputMode direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param port The input port to configure. See \ref InPorts.
 * \param type The sensor type. See \ref SensorTypes.
 * \param mode The sensor mode. See \ref SensorModes.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteSetInputMode(byte conn, byte port, byte type, byte mode);

/**
 * Send a SetOutputMode message.
 * Send the SetOutputMode direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param port The output port to configure. See \ref OutputPortConstants.
 * \param speed The motor speed. (-100..100)
 * \param mode The motor mode. See \ref OutModeConstants.
 * \param regmode The motor regulation mode. See \ref OutRegModeConstants.
 * \param turnpct The motor synchronized turn percentage. (-100..100)
 * \param runstate The motor run state. See \ref OutRunStateConstants.
 * \param tacholimit The motor tachometer limit.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteSetOutputState(byte conn, byte port, char speed, byte mode, byte regmode, char turnpct, byte runstate, unsigned long tacholimit);

/**
 * Send a StartProgram message.
 * Send the StartProgram direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param filename The name of the program to start running.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteStartProgram(byte conn, string filename);

/**
 * Send a StopProgram message.
 * Send the StopProgram direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteStopProgram(byte conn);

/**
 * Send a StopSound message.
 * Send the StopSound direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteStopSound(byte conn);

#ifdef __ENHANCED_FIRMWARE

/**
 * Send a GetOutputState message.
 * Send the GetOutputState direct command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param params The input and output parameters for the function call. See \ref OutputStateType.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetOutputState(byte conn, OutputStateType & params);

/**
 * Send a GetInputValues message.
 * Send the GetInputValues direct command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param params The input and output parameters for the function call. See \ref InputValuesType.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetInputValues(byte conn, InputValuesType & params);

/**
 * Send a GetBatteryLevel message.
 * Send the GetBatteryLevel direct command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param value The battery level value.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetBatteryLevel(byte conn, int & value);

/**
 * Send a LowspeedGetStatus message.
 * This method sends a LowspeedGetStatus direct command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param value The count of available bytes to read.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteLowspeedGetStatus(byte conn, byte & value);

/**
 * Send a LowspeedRead message.
 * Send the LowspeedRead direct command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param port The input port from which to read I2C data. See \ref InPorts.
 * \param bread The number of bytes read.
 * \param data A byte array containing the data read from the I2C device.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteLowspeedRead(byte conn, byte port, byte & bread, byte & data[]);

/**
 * Send a GetCurrentProgramName message.
 * This method sends a GetCurrentProgramName direct command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param name The current program name.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetCurrentProgramName(byte conn, string & name);

/**
 * Send a DatalogRead message.
 * Send the DatalogRead direct command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param remove Remove the datalog message from the queue after reading it (true or false).
 * \param cnt The number of bytes read from the datalog.
 * \param log A byte array containing the datalog contents.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteDatalogRead(byte conn, bool remove, byte & cnt, byte & log[]);

/**
 * Send a GetContactCount message.
 * This method sends a GetContactCount direct command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param cnt The number of contacts.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetContactCount(byte conn, byte & cnt);

/**
 * Send a GetContactName message.
 * Send the GetContactName direct command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param idx The index of the contact.
 * \param name The name of the specified contact.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetContactName(byte conn, byte idx, string & name);

/**
 * Send a GetConnectionCount message.
 * This method sends a GetConnectionCount direct command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param cnt The number of connections.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetConnectionCount(byte conn, byte & cnt);

/**
 * Send a GetConnectionName message.
 * Send the GetConnectionName direct command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param idx The index of the connection.
 * \param name The name of the specified connection.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetConnectionName(byte conn, byte idx, string & name);

/**
 * Send a GetProperty message.
 * Send the GetProperty direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param property The property to read. See \ref RCPropertyConstants.
 * \param value The property value.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetProperty(byte conn, byte property, variant & value);

#endif

/**
 * Send a ResetTachoCount message.
 * Send the ResetTachoCount direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param port The output port to reset the tachometer count on. See \ref OutputPortConstants.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteResetTachoCount(byte conn, byte port);

/**
 * Send a DatalogSetTimes message.
 * Send the DatalogSetTimes direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param synctime The datalog sync time.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteDatalogSetTimes(byte conn, long synctime);

/**
 * Send a SetProperty message.
 * Send the SetProperty direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param prop The property to set. See \ref RCPropertyConstants.
 * \param value The new property value.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteSetProperty(byte conn, byte prop, variant value);

/**
 * Send a LowspeedWrite message.
 * Send the LowspeedWrite direct command on the specified connection slot.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param port The I2C port. See \ref InPorts.
 * \param txlen The number of bytes you are writing to the I2C device.
 * \param rxlen The number of bytes want to read from the I2C device.
 * \param data A byte array containing the data you are writing to the device.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteLowspeedWrite(byte conn, byte port, byte txlen, byte rxlen, byte data[]);

/** @} */ // end of CommModuleDCFunctions group

/** @defgroup CommModuleSCFunctions System Command functions
 * Functions for sending system commands to another NXT.
 * @{
 */

#ifdef __ENHANCED_FIRMWARE

/**
 * Send an OpenRead message.
 * Send the OpenRead system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param filename The name of the file to open for reading.
 * \param handle The handle of the file.
 * \param size The size of the file.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteOpenRead(byte conn, string filename, byte & handle, long & size);

/**
 * Send an OpenAppendData message.
 * Send the OpenAppendData system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param filename The name of the file to open for appending.
 * \param handle The handle of the file.
 * \param size The size of the file.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteOpenAppendData(byte conn, string filename, byte & handle, long & size);

/**
 * Send a DeleteFile message.
 * Send the DeleteFile system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param filename The name of the file to delete.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteDeleteFile(byte conn, string filename);

/**
 * Send a FindFirstFile message.
 * Send the FindFirstFile system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param mask The filename mask for the files you want to find.
 * \param handle The handle of the found file.
 * \param name The name of the found file.
 * \param size The size of the found file.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteFindFirstFile(byte conn, string mask, byte & handle, string & name, long & size);

/**
 * Send a GetFirmwareVersion message.
 * This method sends a GetFirmwareVersion system command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param pmin The protocol minor version byte.
 * \param pmaj The protocol major version byte.
 * \param fmin The firmware minor version byte.
 * \param fmaj The firmware major version byte.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetFirmwareVersion(byte conn, byte & pmin, byte & pmaj, byte & fmin, byte & fmaj);

/**
 * Send a GetBluetoothAddress message.
 * This method sends a GetBluetoothAddress system command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param btaddr The bluetooth address of the remote device.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetBluetoothAddress(byte conn, byte & btaddr[]);

/**
 * Send a GetDeviceInfo message.
 * This method sends a GetDeviceInfo system command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param name The name of the remote device.
 * \param btaddr The bluetooth address of the remote device.
 * \param btsignal The signal strength of each connection on the remote device.
 * \param freemem The number of bytes of free flash memory on the remote device.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteGetDeviceInfo(byte conn, string & name, byte & btaddr[], byte & btsignal[], long & freemem);

/**
 * Send a DeleteUserFlash message.
 * This method sends a DeleteUserFlash system command to the device on the specified
 * connection.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteDeleteUserFlash(byte conn);

/**
 * Send an OpenWrite message.
 * Send the OpenWrite system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param filename The name of the file to open for writing (i.e., create the file).
 * \param size The size for the new file.
 * \param handle The handle of the new file.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteOpenWrite(byte conn, string filename, long size, byte & handle);

/**
 * Send an OpenWriteLinear message.
 * Send the OpenWriteLinear system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param filename The name of the file to open for writing (i.e., create the file).
 * \param size The size for the new file.
 * \param handle The handle of the new file.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteOpenWriteLinear(byte conn, string filename, long size, byte & handle);

/**
 * Send an OpenWriteData message.
 * Send the OpenWriteData system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param filename The name of the file to open for writing (i.e., create the file).
 * \param size The size for the new file.
 * \param handle The handle of the new file.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteOpenWriteData(byte conn, string filename, long size, byte & handle);

/**
 * Send a CloseFile message.
 * Send the CloseFile system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param handle The handle of the file to close.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteCloseFile(byte conn, byte handle);

/**
 * Send a FindNextFile message.
 * Send the FindNextFile system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param handle The handle returned by the last \ref FindFirstFile or FindNextFile call.
 * \param name The name of the next found file.
 * \param size The size of the next found file.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteFindNextFile(byte conn, byte & handle, string & name, long & size);

/**
 * Send a PollCommandLength message.
 * Send the PollCommandLength system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param bufnum The poll buffer you want to query (0=USBPoll, 1=HiSpeed).
 * \param length The number of bytes available for polling.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemotePollCommandLength(byte conn, byte bufnum, byte & length);

/**
 * Send a Write message.
 * Send the Write system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param handle The handle of the file you are writing to.
 * \param numbytes The number of bytes actually written.
 * \param data A byte array containing the data you are writing.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteWrite(byte conn, byte & handle, int & numbytes, byte data[]);

/**
 * Send a Read message.
 * Send the Read system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param handle The handle of the file you are reading from.
 * \param numbytes The number of bytes you want to read. Returns the number of
 * bytes actually read.
 * \param data A byte array containing the response data.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteRead(byte conn, byte & handle, int & numbytes, byte & data[]);

/**
 * Send an IOMapRead message.
 * Send the IOMapRead system command on the specified connection slot.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param id The ID of the module from which to read data.
 * \param offset The offset into the IOMap structure from which to read.
 * \param numbytes The number of bytes of data to read. Returns the number of
 * bytes actually read.
 * \param data A byte array containing the response data.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteIOMapRead(byte conn, long id, int offset, int & numbytes, byte & data[]);

/**
 * Send a PollCommand message.
 * Send the PollCommand system command on the specified connection slot to
 * write the data provided.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param bufnum The buffer from which to read data (0=USBPoll, 1=HiSpeed).
 * \param len The number of bytes to read.  Returns the number of
 * bytes actually read.
 * \param data A byte array containing the response data.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemotePollCommand(byte conn, byte bufnum, byte & len, byte & data[]);

/**
 * Send a RenameFile message.
 * Send the RenameFile system command on the specified connection slot to
 * write the data provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param oldname The old filename.
 * \param newname The new filename.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteRenameFile(byte conn, string oldname, string newname);

#endif

/**
 * Send a BluetoothFactoryReset message.
 * This method sends a BluetoothFactoryReset system command to the device on the specified
 * connection. Use \ref RemoteConnectionIdle to determine when this write request is
 * completed.  This command cannot be sent over a bluetooth connection.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteBluetoothFactoryReset(byte conn);

/**
 * Send an IOMapWrite value message.
 * Send the IOMapWrite system command on the specified connection slot to
 * write the value provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param id The ID of the module to which to write data.
 * \param offset The offset into the IOMap structure to which to write.
 * \param value A scalar variable containing the value you are writing to the IOMap structure.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteIOMapWriteValue(byte conn, long id, int offset, variant value);

/**
 * Send an IOMapWrite bytes message.
 * Send the IOMapWrite system command on the specified connection slot to
 * write the data provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param id The ID of the module to which to write data.
 * \param offset The offset into the IOMap structure to which to write.
 * \param data A byte array containing the data you are writing to the IOMap structure.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteIOMapWriteBytes(byte conn, long id, int offset, byte data[]);

/**
 * Send a SetBrickName message.
 * Send the SetBrickName system command on the specified connection slot to
 * write the data provided.
 * Use \ref RemoteConnectionIdle to determine when this write request is completed.
 *
 * \param conn The connection slot (0..4). Connections 0 through 3 are for
 * bluetooth connections.  Connection 4 refers to the RS485 hi-speed port.
 * See \ref CommConnectionConstants.
 * \param name The new brick name.
 * \return A char value indicating whether the function call succeeded or not.
 */
inline char RemoteSetBrickName(byte conn, string name);

/** @} */ // end of CommModuleSCFunctions group


/**
 * Use the RS485 port.
 * Configure port 4 for RS485 usage.
 *
 */
inline void UseRS485(void);

#ifdef __ENHANCED_FIRMWARE

/**
 * Control the RS485 port.
 * Control the RS485 hi-speed port using the specified parameters.
 *
 * \param cmd The control command to send to the port. See \ref CommHiSpeedCtrlConstants.
 * \param baud The baud rate for the RS485 port. See \ref CommHiSpeedBaudConstants.
 * \param mode The RS485 port mode (data bits, stop bits, parity).  See \ref
 * CommHiSpeedDataBitsConstants, \ref CommHiSpeedStopBitsConstants, \ref
 * CommHiSpeedParityConstants, and \ref CommHiSpeedCombinedConstants.
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char RS485Control(byte cmd, byte baud, unsigned int mode);

/**
 * Check for RS485 available data.
 * Check the RS485 hi-speed port for available data.
 *
 * \return The number of bytes of data available for reading.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline byte RS485DataAvailable(void);

/**
 * Initialize RS485 port.
 * Initialize the RS485 UART port to its default values.  The baud rate is
 * set to 921600 and the mode is set to 8N1 (8 data bits, no parity, 1 stop bit).
 * Data cannot be sent or received over the RS485 port until the port is
 * configured as as a hi-speed port, the port is turned on, and the UART is
 * initialized.
 *
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char RS485Initialize(void);

/**
 * Disable RS485.
 * Turn off the RS485 port.
 *
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char RS485Disable(void);

/**
 * Enable RS485.
 * Turn on the RS485 hi-speed port so that it can be used.
 *
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char RS485Enable(void);

/**
 * Read RS485 data.
 * Read data from the RS485 hi-speed port.
 *
 * \param buffer A byte array that will contain the data read from the RS485 port.
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char RS485Read(byte & buffer[]);

/**
 * Read limited RS485 data.
 * Read a limited number of bytes of data from the RS485 hi-speed port.
 *
 * \param buffer A byte array that will contain the data read from the RS485 port.
 * \param buflen The number of bytes you want to read.
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+.
 */
inline char RS485ReadEx(byte & buffer[], byte buflen);

/**
 * Is RS485 sending data.
 * Check whether the RS485 is actively sending data.
 *
 * \return The number of bytes of data being sent.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline byte RS485SendingData(void);

/**
 * Check RS485 status.
 * Check the status of the RS485 hi-speed port.
 *
 * \param sendingData The number of bytes of data being sent.
 * \param dataAvail The number of bytes of data available for reading.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void RS485Status(byte & sendingData, byte & dataAvail);

/**
 * Configure RS485 UART.
 * Configure the RS485 UART parameters, including baud rate, data bits,
 * stop bits, and parity.
 *
 * \param baud The baud rate for the RS485 port. See \ref CommHiSpeedBaudConstants.
 * \param mode The RS485 port mode (data bits, stop bits, parity).  See \ref
 * CommHiSpeedDataBitsConstants, \ref CommHiSpeedStopBitsConstants, \ref
 * CommHiSpeedParityConstants, and \ref CommHiSpeedCombinedConstants.
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char RS485Uart(byte baud, unsigned int mode);

/**
 * Write RS485 data.
 * Write data to the RS485 hi-speed port.
 *
 * \param buffer A byte array containing the data to write to the RS485 port.
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char RS485Write(byte buffer[]);

/**
 * Write RS485 boolean.
 * Write a boolean value to the RS485 hi-speed port.
 *
 * \param bval A boolean value to write over the RS485 port.
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char SendRS485Bool(bool bval);

/**
 * Write RS485 numeric.
 * Write a numeric value to the RS485 hi-speed port.
 *
 * \param val A numeric value to write over the RS485 port.
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char SendRS485Number(long val);

/**
 * Write RS485 string.
 * Write a string value to the RS485 hi-speed port.
 *
 * \param str A string value to write over the RS485 port.
 * \return A char value indicating whether the function call succeeded or not.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline char SendRS485String(string str);

#endif

/**
 * Get bluetooth input buffer data.
 * This method reads count bytes of data from the Bluetooth input buffer and
 * writes it to the buffer provided.
 *
 * \param offset A constant offset into the bluetooth input buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the bluetooth input buffer.
 */
inline void GetBTInputBuffer(const byte offset, byte cnt, byte & data[]);

/**
 * Get bluetooth output buffer data.
 * This method reads count bytes of data from the Bluetooth output buffer and
 * writes it to the buffer provided.
 * 
 * \param offset A constant offset into the bluetooth output buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the bluetooth output buffer.
 */
inline void GetBTOutputBuffer(const byte offset, byte cnt, byte & data[]);

/**
 * Get hi-speed port input buffer data.
 * This method reads count bytes of data from the hi-speed port input buffer and
 * writes it to the buffer provided.
 * 
 * \param offset A constant offset into the hi-speed port input buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the hi-speed port input buffer.
 */
inline void GetHSInputBuffer(const byte offset, byte cnt, byte & data[]);

/**
 * Get hi-speed port output buffer data.
 * This method reads count bytes of data from the hi-speed port output buffer and
 * writes it to the buffer provided.
 * 
 * \param offset A constant offset into the hi-speed port output buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the hi-speed port output buffer.
 */
inline void GetHSOutputBuffer(const byte offset, byte cnt, byte & data[]);

/**
 * Get usb input buffer data.
 * This method reads count bytes of data from the usb input buffer and
 * writes it to the buffer provided.
 * 
 * \param offset A constant offset into the usb input buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the usb input buffer.
 */
inline void GetUSBInputBuffer(const byte offset, byte cnt, byte & data[]);

/**
 * Get usb output buffer data.
 * This method reads count bytes of data from the usb output buffer and
 * writes it to the buffer provided.
 * \param offset A constant offset into the usb output buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the usb output buffer.
 */
inline void GetUSBOutputBuffer(const byte offset, byte cnt, byte & data[]);

/**
 * Get usb poll buffer data.
 * This method reads count bytes of data from the usb poll buffer and
 * writes it to the buffer provided.
 * \param offset A constant offset into the usb poll buffer.
 * \param cnt The number of bytes to read.
 * \param data The byte array reference which will contain the data read from
 * the usb poll buffer.
 */
inline void GetUSBPollBuffer(const byte offset, byte cnt, byte & data[]);

/**
 * Get bluetooth device name.
 * This method returns the name of the device at the specified index in the
 * Bluetooth device table.
 * \param devidx The device table index.
 * \return The device name of the specified bluetooth device.
 */
inline string BTDeviceName(const byte devidx);

/**
 * Get bluetooth device name.
 * This method returns the name of the device at the specified index in the
 * Bluetooth connection table.
 * \param conn The connection slot (0..3).
 * \return The name of the bluetooth device at the specified connection slot.
 */
inline string BTConnectionName(const byte conn);

/**
 * Get bluetooth device pin code.
 * This method returns the pin code of the device at the specified index in the
 * Bluetooth connection table.
 * \param conn The connection slot (0..3).
 * \return The pin code for the bluetooth device at the specified connection slot.
 */
inline string BTConnectionPinCode(const byte conn);

/**
 * Get NXT name.
 * This method returns the name of the NXT.
 * \return The NXT's bluetooth name.
 */
inline string BrickDataName(void);

/**
 * Get bluetooth device address.
 * This method reads the address of the device at the specified index within
 * the Bluetooth device table and stores it in the data buffer provided.
 * \param devidx The device table index.
 * \param data The byte array reference that will contain the device address.
 */
inline void GetBTDeviceAddress(const byte devidx, byte & data[]);

/**
 * Get bluetooth device address.
 * This method reads the address of the device at the specified index within
 * the Bluetooth connection table and stores it in the data buffer provided.
 * \param conn The connection slot (0..3).
 * \param data The byte array reference that will contain the device address.
 */
inline void GetBTConnectionAddress(const byte conn, byte & data[]);

/**
 * Get NXT address.
 * This method reads the address of the NXT and stores it in the data buffer
 * provided.
 * \param data The byte array reference that will contain the device address.
 */
inline void GetBrickDataAddress(byte & data[]);

/**
 * Get bluetooth device class.
 * This method returns the class of the device at the specified index within
 * the Bluetooth device table.
 * \param devidx The device table index.
 * \return The device class of the specified bluetooth device.
 */
inline long BTDeviceClass(const byte devidx);

/**
 * Get bluetooth device status.
 * This method returns the status of the device at the specified index within
 * the Bluetooth device table.
 * \param devidx The device table index.
 * \return The status of the specified bluetooth device.
 */
inline byte BTDeviceStatus(const byte devidx);

/**
 * Get bluetooth device class.
 * This method returns the class of the device at the specified index within
 * the Bluetooth connection table.
 * \param conn The connection slot (0..3).
 * \return The class of the bluetooth device at the specified connection slot.
 */
inline long BTConnectionClass(const byte conn);

/**
 * Get bluetooth device handle number.
 * This method returns the handle number of the device at the specified index within
 * the Bluetooth connection table.
 * \param conn The connection slot (0..3).
 * \return The handle number of the bluetooth device at the specified connection slot.
 */
inline byte BTConnectionHandleNum(const byte conn);

/**
 * Get bluetooth device stream status.
 * This method returns the stream status of the device at the specified index within
 * the Bluetooth connection table.
 * \param conn The connection slot (0..3).
 * \return The stream status of the bluetooth device at the specified connection slot.
 */
inline byte BTConnectionStreamStatus(const byte conn);

/**
 * Get bluetooth device link quality.
 * This method returns the link quality of the device at the specified index within
 * the Bluetooth connection table.
 * \param conn The connection slot (0..3).
 * \return The link quality of the specified connection slot (unimplemented).
 * \warning This function is not implemented at the firmware level.
 */
inline byte BTConnectionLinkQuality(const byte conn);

/**
 * Get NXT bluecore version.
 * This method returns the bluecore version of the NXT.
 * \return The NXT's bluecore version number.
 */
inline int BrickDataBluecoreVersion(void);

/**
 * Get NXT bluetooth state status.
 * This method returns the Bluetooth state status of the NXT.
 * \return The NXT's bluetooth state status.
 */
inline byte BrickDataBtStateStatus(void);

/**
 * Get NXT bluetooth hardware status.
 * This method returns the Bluetooth hardware status of the NXT.
 * \return The NXT's bluetooth hardware status.
 */
inline byte BrickDataBtHardwareStatus(void);

/**
 * Get NXT bluetooth timeout value.
 * This method returns the Bluetooth timeout value of the NXT.
 * \return The NXT's bluetooth timeout value.
 */
inline byte BrickDataTimeoutValue(void);

/**
 * Get bluetooth input buffer in-pointer.
 * This method returns the value of the input pointer of the Bluetooth input
 * buffer.
 * \return The bluetooth input buffer's in-pointer value.
 */
inline byte BTInputBufferInPtr(void);

/**
 * Get bluetooth input buffer out-pointer.
 * This method returns the value of the output pointer of the Bluetooth input
 * buffer.
 * \return The bluetooth input buffer's out-pointer value.
 */
inline byte BTInputBufferOutPtr(void);

/**
 * Get bluetooth output buffer in-pointer.
 * This method returns the value of the input pointer of the Bluetooth output
 * buffer.
 * \return The bluetooth output buffer's in-pointer value.
 */
inline byte BTOutputBufferInPtr(void);

/**
 * Get bluetooth output buffer out-pointer.
 * This method returns the value of the output pointer of the Bluetooth output
 * buffer.
 * \return The bluetooth output buffer's out-pointer value.
 */
inline byte BTOutputBufferOutPtr(void);

/**
 * Get hi-speed port input buffer in-pointer.
 * This method returns the value of the input pointer of the hi-speed port input
 * buffer.
 * \return The hi-speed port input buffer's in-pointer value.
 */
inline byte HSInputBufferInPtr(void);

/**
 * Get hi-speed port input buffer out-pointer.
 * This method returns the value of the output pointer of the hi-speed port input
 * buffer.
 * \return The hi-speed port input buffer's out-pointer value.
 */
inline byte HSInputBufferOutPtr(void);

/**
 * Get hi-speed port output buffer in-pointer.
 * This method returns the value of the input pointer of the hi-speed port output
 * buffer.
 * \return The hi-speed port output buffer's in-pointer value.
 */
inline byte HSOutputBufferInPtr(void);

/**
 * Get hi-speed port output buffer out-pointer.
 * This method returns the value of the output pointer of the hi-speed port output
 * buffer.
 * \return The hi-speed port output buffer's out-pointer value.
 */
inline byte HSOutputBufferOutPtr(void);

/**
 * Get usb port input buffer in-pointer.
 * This method returns the value of the input pointer of the usb port input
 * buffer.
 * \return The USB port input buffer's in-pointer value.
 */
inline byte USBInputBufferInPtr(void);

/**
 * Get usb port input buffer out-pointer.
 * This method returns the value of the output pointer of the usb port input
 * buffer.
 * \return The USB port input buffer's out-pointer value.
 */
inline byte USBInputBufferOutPtr(void);

/**
 * Get usb port output buffer in-pointer.
 * This method returns the value of the input pointer of the usb port output
 * buffer.
 * \return The USB port output buffer's in-pointer value.
 */
inline byte USBOutputBufferInPtr(void);

/**
 * Get usb port output buffer out-pointer.
 * This method returns the value of the output pointer of the usb port output
 * buffer.
 * \return The USB port output buffer's out-pointer value.
 */
inline byte USBOutputBufferOutPtr(void);

/**
 * Get usb port poll buffer in-pointer.
 * This method returns the value of the input pointer of the usb port poll
 * buffer.
 * \return The USB port poll buffer's in-pointer value.
 */
inline byte USBPollBufferInPtr(void);

/**
 * Get usb port poll buffer out-pointer.
 * This method returns the value of the output pointer of the usb port poll
 * buffer.
 * \return The USB port poll buffer's out-pointer value.
 */
inline byte USBPollBufferOutPtr(void);

/**
 * Get bluetooth device count.
 * This method returns the number of devices defined within the Bluetooth
 * device table.
 * \return The count of known bluetooth devices.
 */
inline byte BTDeviceCount(void);

/**
 * Get bluetooth device name count.
 * This method returns the number of device names defined within the Bluetooth
 * device table. This usually has the same value as BTDeviceCount but it can
 * differ in some instances.
 * \return The count of known bluetooth device names.
 */
inline byte BTDeviceNameCount(void);

/**
 * Get hi-speed port flags.
 * This method returns the value of the hi-speed port flags.
 * \return The hi-speed port flags. See \ref CommHiSpeedFlagsConstants.
 */
inline byte HSFlags(void);

/**
 * Get hi-speed port speed.
 * This method returns the value of the hi-speed port speed (baud rate).
 * \return The hi-speed port speed (baud rate).  See \ref CommHiSpeedBaudConstants.
 */
inline byte HSSpeed(void);

/**
 * Get hi-speed port state.
 * This method returns the value of the hi-speed port state.
 * \return The hi-speed port state. See \ref CommHiSpeedStateConstants.
 */
inline byte HSState(void);

/**
 * Get hi-speed port address.
 * This method returns the value of the hi-speed port address.
 * \return The hi-speed port address. See \ref CommHiSpeedAddressConstants.
 */
inline byte HSAddress(void);

#if (__FIRMWARE_VERSION > 107) && defined(__ENHANCED_FIRMWARE)

/**
 * Get hi-speed port mode.
 * This method returns the value of the hi-speed port mode.
 * \return The hi-speed port mode (data bits, stop bits, parity).  See
 * \ref CommHiSpeedDataBitsConstants, \ref CommHiSpeedStopBitsConstants,
 * \ref CommHiSpeedParityConstants, and \ref CommHiSpeedCombinedConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline int HSMode(void);

/**
 * Get Bluetooth data mode.
 * This method returns the value of the Bluetooth data mode.
 * \return The Bluetooth data mode.  See \ref CommDataModeConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline int BTDataMode(void);

/**
 * Get hi-speed port datamode.
 * This method returns the value of the hi-speed port data mode.
 * \return The hi-speed port data mode.  See \ref CommDataModeConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline int HSDataMode(void);

#endif

/**
 * Get USB state.
 * This method returns the value of the USB state.
 * \return The USB state.
 */
inline byte USBState(void);

/**
 * Set bluetooth input buffer data.
 * Write cnt bytes of data to the bluetooth input buffer at offset.
 * \param offset A constant offset into the input buffer
 * \param cnt The number of bytes to write
 * \param data A byte array containing the data to write
 */
inline void SetBTInputBuffer(const byte offset, byte cnt, byte data[]);

/**
 * Set bluetooth input buffer in-pointer.
 * Set the value of the input buffer in-pointer.
 * \param n The new in-pointer value (0..127).
 */
inline void SetBTInputBufferInPtr(byte n);

/**
 * Set bluetooth input buffer out-pointer.
 * Set the value of the input buffer out-pointer.
 * \param n The new out-pointer value (0..127).
 */
inline void SetBTInputBufferOutPtr(byte n);

/**
 * Set bluetooth output buffer data.
 * Write cnt bytes of data to the bluetooth output buffer at offset.
 * \param offset A constant offset into the output buffer
 * \param cnt The number of bytes to write
 * \param data A byte array containing the data to write
 */
inline void SetBTOutputBuffer(const byte offset, byte cnt, byte data[]);

/**
 * Set bluetooth output buffer in-pointer.
 * Set the value of the output buffer in-pointer.
 * \param n The new in-pointer value (0..127).
 */
inline void SetBTOutputBufferInPtr(byte n);

/**
 * Set bluetooth output buffer out-pointer.
 * Set the value of the output buffer out-pointer.
 * \param n The new out-pointer value (0..127).
 */
inline void SetBTOutputBufferOutPtr(byte n);

/**
 * Set hi-speed port input buffer data.
 * Write cnt bytes of data to the hi-speed port input buffer at offset.
 * \param offset A constant offset into the input buffer
 * \param cnt The number of bytes to write
 * \param data A byte array containing the data to write
 */
inline void SetHSInputBuffer(const byte offset, byte cnt, byte data[]);

/**
 * Set hi-speed port input buffer in-pointer.
 * Set the value of the input buffer in-pointer.
 * \param n The new in-pointer value (0..127).
 */
inline void SetHSInputBufferInPtr(byte n);

/**
 * Set hi-speed port input buffer out-pointer.
 * Set the value of the input buffer out-pointer.
 * \param n The new out-pointer value (0..127).
 */
inline void SetHSInputBufferOutPtr(byte n);

/**
 * Set hi-speed port output buffer data.
 * Write cnt bytes of data to the hi-speed port output buffer at offset.
 * \param offset A constant offset into the output buffer
 * \param cnt The number of bytes to write
 * \param data A byte array containing the data to write
 */
inline void SetHSOutputBuffer(const byte offset, byte cnt, byte data[]);

/**
 * Set hi-speed port output buffer in-pointer.
 * Set the value of the output buffer in-pointer.
 * \param n The new in-pointer value (0..127).
 */
inline void SetHSOutputBufferInPtr(byte n);

/**
 * Set hi-speed port output buffer out-pointer.
 * Set the value of the output buffer out-pointer.
 * \param n The new out-pointer value (0..127).
 */
inline void SetHSOutputBufferOutPtr(byte n);

/**
 * Set USB input buffer data.
 * Write cnt bytes of data to the USB input buffer at offset.
 * \param offset A constant offset into the input buffer
 * \param cnt The number of bytes to write
 * \param data A byte array containing the data to write
 */
inline void SetUSBInputBuffer(const byte offset, byte cnt, byte data[]);

/**
 * Set USB input buffer in-pointer.
 * Set the value of the input buffer in-pointer.
 * \param n The new in-pointer value (0..63).
 */
inline void SetUSBInputBufferInPtr(byte n);

/**
 * Set USB input buffer out-pointer.
 * Set the value of the input buffer out-pointer.
 * \param n The new out-pointer value (0..63).
 */
inline void SetUSBInputBufferOutPtr(byte n);

/**
 * Set USB output buffer data.
 * Write cnt bytes of data to the USB output buffer at offset.
 * \param offset A constant offset into the output buffer
 * \param cnt The number of bytes to write
 * \param data A byte array containing the data to write
 */
inline void SetUSBOutputBuffer(const byte offset, byte cnt, byte data[]);

/**
 * Set USB output buffer in-pointer.
 * Set the value of the output buffer in-pointer.
 * \param n The new in-pointer value (0..63).
 */
inline void SetUSBOutputBufferInPtr(byte n);

/**
 * Set USB output buffer out-pointer.
 * Set the value of the output buffer out-pointer.
 * \param n The new out-pointer value (0..63).
 */
inline void SetUSBOutputBufferOutPtr(byte n);

/**
 * Set USB poll buffer data.
 * Write cnt bytes of data to the USB poll buffer at offset.
 * \param offset A constant offset into the poll buffer
 * \param cnt The number of bytes to write
 * \param data A byte array containing the data to write
 */
inline void SetUSBPollBuffer(const byte offset, byte cnt, byte data[]);

/**
 * Set USB poll buffer in-pointer.
 * Set the value of the poll buffer in-pointer.
 * \param n The new in-pointer value (0..63).
 */
inline void SetUSBPollBufferInPtr(byte n);

/**
 * Set USB poll buffer out-pointer.
 * Set the value of the poll buffer out-pointer.
 * \param n The new out-pointer value (0..63).
 */
inline void SetUSBPollBufferOutPtr(byte n);

/**
 * Set hi-speed port flags.
 * This method sets the value of the hi-speed port flags.
 * \param hsFlags The hi-speed port flags. See \ref CommHiSpeedFlagsConstants.
 */
inline void SetHSFlags(byte hsFlags);

/**
 * Set hi-speed port speed.
 * This method sets the value of the hi-speed port speed (baud rate).
 * \param hsSpeed The hi-speed port speed (baud rate).  See \ref CommHiSpeedBaudConstants.
 */
inline void SetHSSpeed(byte hsSpeed);

/**
 * Set hi-speed port state.
 * This method sets the value of the hi-speed port state.
 * \param hsState The hi-speed port state. See \ref CommHiSpeedStateConstants.
 */
inline void SetHSState(byte hsState);

/**
 * Set hi-speed port address.
 * This method sets the value of the hi-speed port address.
 * \param hsAddress The hi-speed port address. See \ref CommHiSpeedAddressConstants.
 */
inline void SetHSAddress(byte hsAddress);

#if (__FIRMWARE_VERSION > 107) && defined(__ENHANCED_FIRMWARE)

/**
 * Set hi-speed port mode.
 * This method sets the value of the hi-speed port mode.
 * \param hsMode The hi-speed port mode (data bits, stop bits, parity).  See
 * \ref CommHiSpeedDataBitsConstants, \ref CommHiSpeedStopBitsConstants,
 * \ref CommHiSpeedParityConstants, and \ref CommHiSpeedCombinedConstants.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SetHSMode(unsigned int hsMode) { asm { __setHSMode(_n) } }

/**
 * Set Bluetooth data mode.
 * This method sets the value of the Bluetooth data mode.
 * \param dataMode The Bluetooth data mode.  See \ref CommDataModeConstants. Must be a constant.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SetBTDataMode(const byte dataMode);

/**
 * Set hi-speed port data mode.
 * This method sets the value of the hi-speed port data mode.
 * \param dataMode The hi-speed port data mode.  See \ref CommDataModeConstants. Must be a constant.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void SetHSDataMode(const byte dataMode);

#endif

/**
 * Set USB state.
 * This method sets the value of the USB state.
 * \param usbState The USB state.
 */
inline void SetUSBState(byte usbState);

/**
 * Write message.
 * This function lets you write a message to a queue (aka mailbox) using the
 * values specified via the \ref MessageWriteType structure.
 *
 * \param args The MessageWriteType structure containing the needed parameters.
 */
void SysMessageWrite(MessageWriteType & args);

/**
 * Read message.
 * This function lets you read a message from a queue (aka mailbox) using the
 * values specified via the \ref MessageReadType structure.
 *
 * \param args The MessageReadType structure containing the needed parameters.
 */
void SysMessageRead(MessageReadType & args);

/**
 * Write data to a Bluetooth connection.
 * This function lets you write to a Bluetooth connection using the values
 * specified via the \ref CommBTWriteType structure.
 *
 * \param args The CommBTWriteType structure containing the needed parameters.
 */
void SysCommBTWrite(CommBTWriteType & args);

/**
 * Check Bluetooth connection status.
 * This function lets you check the status of a Bluetooth connection using the
 * values specified via the \ref CommBTCheckStatusType structure.
 *
 * \param args The CommBTCheckStatusType structure containing the needed
 * parameters.
 */
void SysCommBTCheckStatus(CommBTCheckStatusType & args);

#ifdef __ENHANCED_FIRMWARE
/**
 * Execute any Comm module command.
 * This function lets you directly execute the Comm module's primary function
 * using the values specified via the \ref CommExecuteFunctionType structure.
 *
 * \param args The CommExecuteFunctionType structure containing the needed
 * parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SysCommExecuteFunction(CommExecuteFunctionType & args);

/**
 * Control the hi-speed port.
 * This function lets you control the hi-speed port
 * using the values specified via the \ref CommHSControlType structure.
 *
 * \param args The CommHSControlType structure containing the needed
 * parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SysCommHSControl(CommHSControlType & args);

/**
 * Check the hi-speed port status.
 * This function lets you check the hi-speed port status
 * using the values specified via the \ref CommHSCheckStatusType structure.
 *
 * \param args The CommHSCheckStatusType structure containing the needed
 * parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SysCommHSCheckStatus(CommHSCheckStatusType & args);

/**
 * Read from the hi-speed port.
 * This function lets you read from the hi-speed port
 * using the values specified via the \ref CommHSReadWriteType structure.
 *
 * \param args The CommHSReadWriteType structure containing the needed
 * parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SysCommHSRead(CommHSReadWriteType & args);

/**
 * Write to the hi-speed port.
 * This function lets you write to the hi-speed port
 * using the values specified via the \ref CommHSReadWriteType structure.
 *
 * \param args The CommHSReadWriteType structure containing the needed
 * parameters.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SysCommHSWrite(CommHSReadWriteType & args);

#endif

#if __FIRMWARE_VERSION > 107
/**
 * Turn on or off the bluetooth subsystem.
 * This function lets you turn on or off the bluetooth subsystem
 * using the values specified via the \ref CommBTOnOffType structure.
 *
 * \param args The CommBTOnOffType structure containing the needed
 * parameters.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysCommBTOnOff(CommBTOnOffType & args);

/**
 * Connect or disconnect a bluetooth device.
 * This function lets you connect or disconnect a bluetooth device
 * using the values specified via the \ref CommBTConnectionType structure.
 *
 * \param args The CommBTConnectionType structure containing the needed
 * parameters.
 *
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysCommBTConnection(CommBTConnectionType & args);

#endif

/*
// these functions really cannot be used for any useful purpose (read-only)
inline void SetBTDeviceName(const byte devidx, string str);
inline void SetBTDeviceAddress(const byte devidx, const byte btaddr[]);
inline void SetBTConnectionName(const byte conn, string str);
inline void SetBTConnectionPinCode(const byte conn, const byte code[]);
inline void SetBTConnectionAddress(const byte conn, const byte btaddr[]);
inline void SetBrickDataName(string str);
inline void SetBrickDataAddress(const byte p, byte btaddr[]);
inline void SetBTDeviceClass(const byte devidx, unsigned long class);
inline void SetBTDeviceStatus(const byte devidx, const byte status);
inline void SetBTConnectionClass(const byte conn, unsigned long class);
inline void SetBTConnectionHandleNum(const byte conn, const byte handleNum);
inline void SetBTConnectionStreamStatus(const byte conn, const byte status);
inline void SetBTConnectionLinkQuality(const byte conn, const byte quality);
inline void SetBrickDataBluecoreVersion(int version);
inline void SetBrickDataBtStateStatus(byte status);
inline void SetBrickDataBtHardwareStatus(byte status);
inline void SetBrickDataTimeoutValue(const byte timeout);
inline void SetBTDeviceCount(byte count);
inline void SetBTDeviceNameCount(byte count);
*/

#else

#define JoystickMessageRead(_queue, _jmt) \
asm { \
  acquire __MRMutex \
  mov __MRArgs.QueueID, _queue \
  set __MRArgs.Remove, TRUE \
  syscall MessageRead, __MRArgs \
  brtst NEQ, __RRM_Err##__I__, __MRArgs.Result \
  unflatten _jmt, __RRNErr, __MRArgs.Message, _jmt \
  __RRM_Err##__I__: \
  __IncI__ \
  mov __RETVAL__, __MRArgs.Result \
  release __MRMutex \
}

#define SendMessage(_queue, _msg) asm { __sendMessage(_queue, _msg, __RETVAL__) }
#define ReceiveMessage(_queue, _clear, _msg) asm { __receiveMessage(_queue, _clear, _msg, __RETVAL__) }

#define BluetoothStatus(_conn) asm { __bluetoothStatus(_conn, __RETVAL__) }
#define BluetoothWrite(_conn, _buffer) asm { __bluetoothWrite(_conn, _buffer, __RETVAL__) }
#define RemoteConnectionWrite(_conn, _buffer) asm { __connectionRawWrite(_conn, _buffer, __RETVAL__) }
#define RemoteConnectionIdle(_conn) asm { __remoteConnectionIdle(_conn, __RETVAL__) }

#define SendRemoteBool(_conn, _queue, _bval) asm { __sendRemoteBool(_conn, _queue, _bval, __RETVAL__) }
#define SendRemoteNumber(_conn, _queue, _val) asm { __sendRemoteNumber(_conn, _queue, _val, __RETVAL__) }
#define SendRemoteString(_conn, _queue, _str) asm { __sendRemoteString(_conn, _queue, _str, __RETVAL__) }

#define SendResponseBool(_queue, _bval) asm { __sendResponseBool(_queue, _bval, __RETVAL__) }
#define SendResponseNumber(_queue, _val) asm { __sendResponseNumber(_queue, _val, __RETVAL__) }
#define SendResponseString(_queue, _msg) asm { __sendResponseString(_queue, _msg, __RETVAL__) }

#define ReceiveRemoteBool(_queue, _clear, _bval) asm { __receiveRemoteBool(_queue, _clear, _bval, __RETVAL__) }
#define ReceiveRemoteNumber(_queue, _clear, _val) asm { __receiveRemoteNumber(_queue, _clear, _val, __RETVAL__) }
#define ReceiveRemoteString(_queue, _clear, _str) asm { __receiveMessage(_queue, _clear, _str, __RETVAL__) }
#define ReceiveRemoteMessageEx(_queue, _clear, _str, _val, _bval) asm { __receiveRemoteMessageEx(_queue, _clear, _str, _val, _bval, __RETVAL__) }

#define RemoteMessageRead(_conn, _queue) asm { __remoteMessageRead(_conn, _queue, __RETVAL__) }
#define RemoteMessageWrite(_conn, _queue, _msg) asm { __sendRemoteString(_conn, _queue, _msg, __RETVAL__) }
#define RemoteStartProgram(_conn, _filename) asm { __remoteStartProgram(_conn, _filename, __RETVAL__) }
#define RemoteStopProgram(_conn) asm { __connectionSCDCWrite(_conn, __DCStopProgramPacket, __RETVAL__) }
#define RemotePlaySoundFile(_conn, _filename, _bloop) asm { __remotePlaySoundFile(_conn, _filename, _bloop, __RETVAL__) }
#define RemotePlayTone(_conn, _frequency, _duration) asm { __remotePlayTone(_conn, _frequency, _duration, __RETVAL__) }
#define RemoteStopSound(_conn) asm { __connectionSCDCWrite(_conn, __DCStopSoundPacket, __RETVAL__) }
#define RemoteKeepAlive(_conn) asm { __connectionSCDCWrite(_conn, __DCKeepAlivePacket, __RETVAL__) }
#define RemoteResetScaledValue(_conn, _port) asm { __remoteResetScaledValue(_conn, _port, __RETVAL__) }
#define RemoteResetMotorPosition(_conn, _port, _brelative) asm { __remoteResetMotorPosition(_conn, _port, _brelative, __RETVAL__) }
#define RemoteSetInputMode(_conn, _port, _type, _mode) asm { __remoteSetInputMode(_conn, _port, _type, _mode, __RETVAL__) }
#define RemoteSetOutputState(_conn, _port, _speed, _mode, _regmode, _turnpct, _runstate, _tacholimit) asm { __remoteSetOutputState(_conn, _port, _speed, _mode, _regmode, _turnpct, _runstate, _tacholimit, __RETVAL__) }
#define RemoteResetTachoCount(_conn, _port) asm { __remoteResetTachoCount(_conn, _port, __RETVAL__) }
#define RemoteDatalogSetTimes(_conn, _synctime) asm { __remoteDatalogSetTimes(_conn, _synctime, __RETVAL__) }
#define RemoteSetProperty(_conn, _prop, _value) asm { __remoteSetProperty(_conn, _prop, _value, __RETVAL__) }
#define RemoteLowspeedWrite(_conn, _port, _txlen, _rxlen, _data) asm { __remoteLowspeedWrite(_conn, _port, _txlen, _rxlen, _data, __RETVAL__) }

#ifdef __ENHANCED_FIRMWARE
#define RemoteGetOutputState(_conn, _params) asm { \
  compchktype _params, OutputStateType \
  __remoteGetOutputState(_conn, _params, __RETVAL__) \
}
#define RemoteGetInputValues(_conn, _params) asm { \
  compchktype _params, InputValuesType \
  __remoteGetInputValues(_conn, _params, __RETVAL__) \
}
#define RemoteGetBatteryLevel(_conn, _value) asm { __remoteGetBatteryLevel(_conn, _value, __RETVAL__) }
#define RemoteLowspeedGetStatus(_conn, _value) asm { __remoteLowspeedGetStatus(_conn, _value, __RETVAL__) }
#define RemoteLowspeedRead(_conn, _port, _bread, _data) asm { __remoteLowspeedRead(_conn, _port, _bread, _data, __RETVAL__) }
#define RemoteGetCurrentProgramName(_conn, _name) asm { __remoteGetCurrentProgramName(_conn, _name, __RETVAL__) }
#define RemoteDatalogRead(_conn, _remove, _cnt, _log) asm { __remoteDatalogRead(_conn, _remove, _cnt, _log, __RETVAL__) }
#define RemoteGetContactCount(_conn, _cnt) asm { __remoteGetContactCount(_conn, _cnt, __RETVAL__) }
#define RemoteGetContactName(_conn, _idx, _name) asm { __remoteGetContactName(_conn, _idx, _name, __RETVAL__) }
#define RemoteGetConnectionCount(_conn, _cnt) asm { __remoteGetConnectionCount(_conn, _cnt, __RETVAL__) }
#define RemoteGetConnectionName(_conn, _idx, _name) asm { __remoteGetConnectionName(_conn, _idx, _name, __RETVAL__) }

#define RemoteGetProperty(_conn, _property, _value) asm { __remoteGetProperty(_conn, _property, _value, __RETVAL__) }

#else

#define RemoteGetOutputState(_conn, _port) asm { __remoteGetOutputState(_conn, _port, __RETVAL__) }
#define RemoteGetInputValues(_conn, _port) asm { __remoteGetInputValues(_conn, _port, __RETVAL__) }
#define RemoteGetBatteryLevel(_conn) asm { __remoteGetBatteryLevel(_conn, __RETVAL__) }
#define RemoteLowspeedGetStatus(_conn) asm { __remoteLowspeedGetStatus(_conn, __RETVAL__) }
#define RemoteLowspeedRead(_conn, _port) asm { __remoteLowspeedRead(_conn, _port, __RETVAL__) }
#define RemoteGetCurrentProgramName(_conn) asm { __remoteGetCurrentProgramName(_conn, __RETVAL__) }
#define RemoteDatalogRead(_conn, _remove) asm { __remoteDatalogRead(_conn, _remove, __RETVAL__) }
#define RemoteGetContactCount(_conn) asm { __remoteGetContactCount(_conn, __RETVAL__) }
#define RemoteGetContactName(_conn, _idx) asm { __remoteGetContactName(_conn, _idx, __RETVAL__) }
#define RemoteGetConnectionCount(_conn) asm { __remoteGetConnectionCount(_conn, __RETVAL__) }
#define RemoteGetConnectionName(_conn, _idx) asm { __remoteGetConnectionName(_conn, _idx, __RETVAL__) }
#define RemoteGetProperty(_conn, _property) asm { __remoteGetProperty(_conn, _property, __RETVAL__) }

#endif

#ifdef __ENHANCED_FIRMWARE

#define RemoteOpenRead(_conn, _filename, _handle, _size) asm { __remoteOpenRead(_conn, _filename, _handle, _size, __RETVAL__) }
#define RemoteOpenWrite(_conn, _filename, _size, _handle) asm { __remoteOpenWrite(_conn, _filename, _size, _handle, __RETVAL__) }
#define RemoteRead(_conn, _handle, _numbytes, _data) asm { __remoteRead(_conn, _handle, _numbytes, _data, __RETVAL__) }
#define RemoteWrite(_conn, _handle, _numbytes, _data) asm { __remoteWrite(_conn, _handle, _numbytes, _data, __RETVAL__) }
#define RemoteCloseFile(_conn, _handle) asm { __remoteCloseFile(_conn, _handle, __RETVAL__) }
#define RemoteDeleteFile(_conn, _filename) asm { __remoteDeleteFile(_conn, _filename, __RETVAL__) }
#define RemoteDeleteUserFlash(_conn) asm { __remoteDeleteUserFlash(_conn, __RETVAL__) }
#define RemoteFindFirstFile(_conn, _mask, _handle, _name, _size) asm { __remoteFindFirstFile(_conn, _mask, _handle, _name, _size, __RETVAL__) }
#define RemoteFindNextFile(_conn, _handle, _name, _size) asm { __remoteFindNextFile(_conn, _handle, _name, _size, __RETVAL__) }
#define RemoteGetFirmwareVersion(_conn, _pmin, _pmaj, _fmin, _fmaj) asm { __remoteGetFirmwareVersion(_conn, _pmin, _pmaj, _fmin, _fmaj, __RETVAL__) }
#define RemoteOpenWriteLinear(_conn, _filename, _size, _handle) asm { __remoteOpenWriteLinear(_conn, _filename, _size, _handle, __RETVAL__) }
#define RemoteOpenWriteData(_conn, _filename, _size, _handle) asm { __remoteOpenWriteData(_conn, _filename, _size, _handle, __RETVAL__) }
#define RemoteOpenAppendData(_conn, _filename, _handle, _size) asm { __remoteOpenAppendData(_conn, _filename, _handle, _size, __RETVAL__) }
#define RemoteGetDeviceInfo(_conn, _name, _btaddr, _btsignal, _freemem) asm { __remoteGetDeviceInfo(_conn, _name, _btaddr, _btsignal, _freemem, __RETVAL__) }
#define RemotePollCommandLength(_conn, _bufnum, _length) asm { __remotePollCommandLength(_conn, _bufnum, _length, __RETVAL__) }
#define RemotePollCommand(_conn, _bufnum, _len, _data) asm { __remotePollCommand(_conn, _bufnum, _len, _data, __RETVAL__) }
#define RemoteIOMapRead(_conn, _id, _offset, _numbytes, _data) asm { __remoteIOMapRead(_conn, _id, _offset, _numbytes, _data, __RETVAL__) }
#define RemoteGetBluetoothAddress(_conn, _btaddr) asm { __remoteGetBluetoothAddress(_conn, _btaddr, __RETVAL__) }

#define RemoteRenameFile(_conn, _oldname, _newname) asm { __remoteRenameFile(_conn, _oldname, _newname, __RETVAL__) }

#else

#define RemoteOpenRead(_conn, _filename) asm { __remoteOpenRead(_conn, _filename, __RETVAL__) }
#define RemoteOpenWrite(_conn, _filename, _size) asm { __remoteOpenWrite(_conn, _filename, _size, __RETVAL__) }
#define RemoteRead(_conn, _handle, _numbytes) asm { __remoteRead(_conn, _handle, _numbytes, __RETVAL__) }
#define RemoteWrite(_conn, _handle, _data) asm { __remoteWrite(_conn, _handle, _data, __RETVAL__) }
#define RemoteCloseFile(_conn, _handle) asm { __remoteCloseFile(_conn, _handle, __RETVAL__) }
#define RemoteDeleteFile(_conn, _filename) asm { __remoteDeleteFile(_conn, _filename, __RETVAL__) }
#define RemoteDeleteUserFlash(_conn) asm { __connectionSCDCWrite(_conn, __SCDeleteUserFlashPacket, __RETVAL__) }
#define RemoteFindFirstFile(_conn, _mask) asm { __remoteFindFirstFile(_conn, _mask, __RETVAL__) }
#define RemoteFindNextFile(_conn, _handle) asm { __remoteFindNextFile(_conn, _handle, __RETVAL__) }
#define RemoteGetFirmwareVersion(_conn) asm { __connectionSCDCWrite(_conn, __SCGetFirmwareVerPacket, __RETVAL__) }
#define RemoteOpenWriteLinear(_conn, _filename, _size) asm { __remoteOpenWriteLinear(_conn, _filename, _size, __RETVAL__) }
#define RemoteOpenWriteData(_conn, _filename, _size) asm { __remoteOpenWriteData(_conn, _filename, _size, __RETVAL__) }
#define RemoteOpenAppendData(_conn, _filename) asm { __remoteOpenAppendData(_conn, _filename, __RETVAL__) }
#define RemoteGetDeviceInfo(_conn) asm { __connectionSCDCWrite(_conn, __SCGetDeviceInfoPacket, __RETVAL__) }
#define RemotePollCommandLength(_conn, _bufnum) asm { __remotePollCommandLength(_conn, _bufnum, __RETVAL__) }
#define RemotePollCommand(_conn, _bufnum, _len) asm { __remotePollCommand(_conn, _bufnum, _len, __RETVAL__) }
#define RemoteIOMapRead(_conn, _id, _offset, _numbytes) asm { __remoteIOMapRead(_conn, _id, _offset, _numbytes, __RETVAL__) }
#define RemoteGetBluetoothAddress(_conn) asm { __connectionSCDCWrite(_conn, __SCBTGetAddressPacket, __RETVAL__) }

#endif

#define RemoteBluetoothFactoryReset(_conn) asm { __connectionSCDCWrite(_conn, __SCBTFactoryResetPacket, __RETVAL__) }
#define RemoteIOMapWriteValue(_conn, _id, _offset, _value) asm { __remoteIOMapWriteValue(_conn, _id, _offset, _value, __RETVAL__) }
#define RemoteIOMapWriteBytes(_conn, _id, _offset, _data) asm { __remoteIOMapWriteBytes(_conn, _id, _offset, _data, __RETVAL__) }
#define RemoteSetBrickName(_conn, _name) asm { __remoteSetBrickName(_conn, _name, __RETVAL__) }

#define UseRS485() asm { __UseRS485() }

#ifdef __ENHANCED_FIRMWARE

#define RS485Status(_sendingData, _dataAvail) asm { __RS485Status(_sendingData, _dataAvail) }
#define RS485SendingData() asm { __RS485Status(__RETVAL__, __TMPBYTE__) }
#define RS485DataAvailable() asm { __RS485Status(__TMPBYTE__, __RETVAL__) }
#define RS485Write(_buffer) asm { __RS485Write(_buffer, __RETVAL__) }
#define RS485Read(_buffer) asm { __RS485Read(_buffer, __RETVAL__) }

#if __FIRMWARE_VERSION > 107

#define RS485ReadEx(_buffer, _buflen) asm { __RS485ReadEx(_buffer, _buflen, __RETVAL__) }
#define RS485Control(_cmd, _baud, _mode) asm { __RS485Control(_cmd, _baud, _mode, __RETVAL__) }
#define RS485Uart(_baud, _mode) asm { __RS485Control(HS_CTRL_UART, _baud, _mode, __RETVAL__) }
#define RS485Initialize() asm { __RS485Control(HS_CTRL_UART, HS_BAUD_DEFAULT, HS_MODE_DEFAULT, __RETVAL__) }
#define RS485Enable() asm { __RS485Control(HS_CTRL_INIT, HS_BAUD_DEFAULT, HS_MODE_DEFAULT, __RETVAL__) }
#define RS485Disable() asm { __RS485Control(HS_CTRL_EXIT, HS_BAUD_DEFAULT, HS_MODE_DEFAULT, __RETVAL__) }

#else

#define RS485Control(_cmd, _baud) asm { __RS485Control(_cmd, _baud, __RETVAL__) }
#define RS485Uart(_baud) asm { __RS485Control(HS_CTRL_UART, _baud, __RETVAL__) }
#define RS485Initialize() asm { __RS485Control(HS_CTRL_UART, HS_BAUD_DEFAULT, __RETVAL__) }
#define RS485Enable() asm { __RS485Control(HS_CTRL_INIT, HS_BAUD_DEFAULT, __RETVAL__) }
#define RS485Disable() asm { __RS485Control(HS_CTRL_EXIT, HS_BAUD_DEFAULT, __RETVAL__) }

#endif

#define SendRS485Bool(_bval) asm { __sendRS485Bool(_bval, __RETVAL__) }
#define SendRS485Number(_val) asm { __sendRS485Number(_val, __RETVAL__) }
#define SendRS485String(_str) asm { __sendRS485String(_str, __RETVAL__) }

#endif

#define GetBTInputBuffer(_offset, _cnt, _data) asm { __getBTInputBuffer(_offset, _cnt, _data) }
#define GetBTOutputBuffer(_offset, _cnt, _data) asm { __getBTOutputBuffer(_offset, _cnt, _data) }
#define GetHSInputBuffer(_offset, _cnt, _data) asm { __getHSInputBuffer(_offset, _cnt, _data) }
#define GetHSOutputBuffer(_offset, _cnt, _data) asm { __getHSOutputBuffer(_offset, _cnt, _data) }
#define GetUSBInputBuffer(_offset, _cnt, _data) asm { __getUSBInputBuffer(_offset, _cnt, _data) }
#define GetUSBOutputBuffer(_offset, _cnt, _data) asm { __getUSBOutputBuffer(_offset, _cnt, _data) }
#define GetUSBPollBuffer(_offset, _cnt, _data) asm { __getUSBPollBuffer(_offset, _cnt, _data) }

#define BTDeviceName(_p) asm { GetBTDeviceName(_p, __STRRETVAL__) }
#define BTConnectionName(_p) asm { GetBTConnectionName(_p, __STRRETVAL__) }
#define BTConnectionPinCode(_p) asm { GetBTConnectionPinCode(_p, __STRRETVAL__) }
#define BrickDataName() asm { GetBrickDataName(__STRRETVAL__) }

#define GetBTDeviceAddress(_p, _data) asm { __getBTDeviceAddress(_p, _data) }
#define GetBTConnectionAddress(_p, _data) asm { __getBTConnectionAddress(_p, _data) }
#define GetBrickDataAddress(_data) asm { __getCommModuleBytes(CommOffsetBrickDataBdAddr, 7, _data) }

#define BTDeviceClass(_p) asm { GetBTDeviceClass(_p, __TMPLONG__) __RETURN__ __TMPLONG__ }
#define BTDeviceStatus(_p) asm { GetBTDeviceStatus(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTConnectionClass(_p) asm { GetBTConnectionClass(_p, __TMPLONG__) __RETURN__ __TMPLONG__ }
#define BTConnectionHandleNum(_p) asm { GetBTConnectionHandleNum(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTConnectionStreamStatus(_p) asm { GetBTConnectionStreamStatus(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTConnectionLinkQuality(_p) asm { GetBTConnectionLinkQuality(_p, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BrickDataBluecoreVersion() asm { GetBrickDataBluecoreVersion(__TMPWORD__) __RETURN__ __TMPWORD__ }
#define BrickDataBtStateStatus() asm { GetBrickDataBtStateStatus(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BrickDataBtHardwareStatus() asm { GetBrickDataBtHardwareStatus(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BrickDataTimeoutValue() asm { GetBrickDataTimeoutValue(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTInputBufferInPtr() asm { GetBTInputBufferInPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTInputBufferOutPtr() asm { GetBTInputBufferOutPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTOutputBufferInPtr() asm { GetBTOutputBufferInPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTOutputBufferOutPtr() asm { GetBTOutputBufferOutPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSInputBufferInPtr() asm { GetHSInputBufferInPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSInputBufferOutPtr() asm { GetHSInputBufferOutPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSOutputBufferInPtr() asm { GetHSOutputBufferInPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSOutputBufferOutPtr() asm { GetHSOutputBufferOutPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define USBInputBufferInPtr() asm { GetUSBInputBufferInPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define USBInputBufferOutPtr() asm { GetUSBInputBufferOutPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define USBOutputBufferInPtr() asm { GetUSBOutputBufferInPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define USBOutputBufferOutPtr() asm { GetUSBOutputBufferOutPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define USBPollBufferInPtr() asm { GetUSBPollBufferInPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define USBPollBufferOutPtr() asm { GetUSBPollBufferOutPtr(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTDeviceCount() asm { GetBTDeviceCount(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BTDeviceNameCount() asm { GetBTDeviceNameCount(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSFlags() asm { GetHSFlags(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSSpeed() asm { GetHSSpeed(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSState() asm { GetHSState(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define USBState() asm { GetUSBState(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSAddress() asm { GetHSAddress(__TMPBYTE__) __RETURN__ __TMPBYTE__ }

#if (__FIRMWARE_VERSION > 107) && defined(__ENHANCED_FIRMWARE)
#define HSMode() asm { GetHSMode(__TMPWORD__) __RETURN__ __TMPWORD__ }
#define BTDataMode() asm { GetBTDataMode(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define HSDataMode() asm { GetHSDataMode(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#endif

#define SetBTDeviceName(_p, _str) asm { __setBTDeviceName(_p, _str) }
#define SetBTDeviceAddress(_p, _btaddr) asm { __setBTDeviceAddress(_p, _btaddr) }
#define SetBTConnectionName(_p, _str) asm { __setBTConnectionName(_p, _str) }
#define SetBTConnectionPinCode(_p, _code) asm { __setBTConnectionPinCode(_p, _code) }
#define SetBTConnectionAddress(_p, _btaddr) asm { __setBTConnectionAddress(_p, _btaddr) }
#define SetBrickDataName(_str) SetCommModuleBytes(CommOffsetBrickDataName, 16, _str)
#define SetBrickDataAddress(_btaddr) SetCommModuleBytes(CommOffsetBrickDataBdAddr, 7, _btaddr)

#define SetBTDeviceClass(_p, _n) asm { __setBTDeviceClass(_p, _n) }
#define SetBTDeviceStatus(_p, _n) asm { __setBTDeviceStatus(_p, _n) }
#define SetBTConnectionClass(_p, _n) asm { __setBTConnectionClass(_p, _n) }
#define SetBTConnectionHandleNum(_p, _n) asm { __setBTConnectionHandleNum(_p, _n) }
#define SetBTConnectionStreamStatus(_p, _n) asm { __setBTConnectionStreamStatus(_p, _n) }
#define SetBTConnectionLinkQuality(_p, _n) asm { __setBTConnectionLinkQuality(_p, _n) }
#define SetBrickDataBluecoreVersion(_n) asm { __setBrickDataBluecoreVersion(_n) }
#define SetBrickDataBtStateStatus(_n) asm { __setBrickDataBtStateStatus(_n) }
#define SetBrickDataBtHardwareStatus(_n) asm { __setBrickDataBtHardwareStatus(_n) }
#define SetBrickDataTimeoutValue(_n) asm { __setBrickDataTimeoutValue(_n) }

#define SetBTDeviceCount(_n) asm { __setBTDeviceCount(_n) }
#define SetBTDeviceNameCount(_n) asm { __setBTDeviceNameCount(_n) }

#define SetBTInputBuffer(_offset, _cnt, _data) asm { __setBTInputBuffer(_offset, _cnt, _data) }

#define SetBTInputBufferInPtr(_n) asm { __setBTInputBufferInPtr(_n) }
#define SetBTInputBufferOutPtr(_n) asm { __setBTInputBufferOutPtr(_n) }

#define SetBTOutputBuffer(_offset, _cnt, _data) asm { __setBTOutputBuffer(_offset, _cnt, _data) }

#define SetBTOutputBufferInPtr(_n) asm { __setBTOutputBufferInPtr(_n) }
#define SetBTOutputBufferOutPtr(_n) asm { __setBTOutputBufferOutPtr(_n) }

#define SetHSInputBuffer(_offset, _cnt, _data) asm { __setHSInputBuffer(_offset, _cnt, _data) }

#define SetHSInputBufferInPtr(_n) asm { __setHSInputBufferInPtr(_n) }
#define SetHSInputBufferOutPtr(_n) asm { __setHSInputBufferOutPtr(_n) }

#define SetHSOutputBuffer(_offset, _cnt, _data) asm { __setHSOutputBuffer(_offset, _cnt, _data) }

#define SetHSOutputBufferInPtr(_n) asm { __setHSOutputBufferInPtr(_n) }
#define SetHSOutputBufferOutPtr(_n) asm { __setHSOutputBufferOutPtr(_n) }

#define SetUSBInputBuffer(_offset, _cnt, _data) asm { __setUSBInputBuffer(_offset, _cnt, _data) }

#define SetUSBInputBufferInPtr(_n) asm { __setUSBInputBufferInPtr(_n) }
#define SetUSBInputBufferOutPtr(_n) asm { __setUSBInputBufferOutPtr(_n) }

#define SetUSBOutputBuffer(_offset, _cnt, _data) asm { __setUSBOutputBuffer(_offset, _cnt, _data) }

#define SetUSBOutputBufferInPtr(_n) asm { __setUSBOutputBufferInPtr(_n) }
#define SetUSBOutputBufferOutPtr(_n) asm { __setUSBOutputBufferOutPtr(_n) }

#define SetUSBPollBuffer(_offset, _cnt, _data) asm { __setUSBPollBuffer(_offset, _cnt, _data) }

#define SetUSBPollBufferInPtr(_n) asm { __setUSBPollBufferInPtr(_n) }
#define SetUSBPollBufferOutPtr(_n) asm { __setUSBPollBufferOutPtr(_n) }

#define SetHSFlags(_n) asm { __setHSFlags(_n) }
#define SetHSSpeed(_n) asm { __setHSSpeed(_n) }
#define SetHSState(_n) asm { __setHSState(_n) }
#define SetUSBState(_n) asm { __setUSBState(_n) }
#define SetHSAddress(_n) asm { __setHSAddress(_n) }

#if (__FIRMWARE_VERSION > 107) && defined(__ENHANCED_FIRMWARE)
#define SetBTDataMode(_n) asm { __setBTDataMode(_n) }
#define SetHSDataMode(_n) asm { __setHSDataMode(_n) }
#endif

#define SysMessageWrite(_args) asm { \
  compchktype _args, MessageWriteType \
  syscall MessageWrite, _args \
}
#define SysMessageRead(_args) asm { \
  compchktype _args, MessageReadType \
  syscall MessageRead, _args \
}
#define SysCommBTWrite(_args) asm { \
  compchktype _args, CommBTWriteType \
  syscall CommBTWrite, _args \
}
#define SysCommBTCheckStatus(_args) asm { \
  compchktype _args, CommBTCheckStatusType \
  syscall CommBTCheckStatus, _args \
}
#ifdef __ENHANCED_FIRMWARE
#define SysCommExecuteFunction(_args) asm { \
  compchktype _args, CommExecuteFunctionType \
  syscall CommExecuteFunction, _args \
}
#define SysCommHSControl(_args) asm { \
  compchktype _args, CommHSControlType \
  syscall CommHSControl, _args \
}
#define SysCommHSCheckStatus(_args) asm { \
  compchktype _args, CommHSCheckStatusType \
  syscall CommHSCheckStatus, _args \
}
#define SysCommHSRead(_args) asm { \
  compchktype _args, CommHSReadWriteType \
  syscall CommHSRead, _args \
}
#define SysCommHSWrite(_args) asm { \
  compchktype _args, CommHSReadWriteType \
  syscall CommHSWrite, _args \
}
#endif
#if __FIRMWARE_VERSION > 107
#define SysCommBTOnOff(_args) asm { \
  compchktype _args, CommBTOnOffType \
  syscall CommBTOnOff, _args \
}
#define SysCommBTConnection(_args) asm { \
  compchktype _args, CommBTConnectionType \
  syscall CommBTConnection, _args \
}
#endif

#endif
/** @} */ // end of CommModuleFunctions group
/** @} */ // end of CommModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// BUTTON MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup ButtonModule
 * @{
 */
/** @defgroup ButtonModuleTypes Button module types
 * Types used by various Button module functions.
 * @{
 */
/**
 * Parameters for the ReadButton system call.
 * This structure is used when calling the \ref SysReadButton system call
 * function.
 * \sa SysReadButton()
 */
struct ReadButtonType {
  char Result;   /*!< The function call result, \ref ERR_INVALID_PORT or \ref NO_ERR. */
  byte Index;    /*!< The requested button index. See the \ref ButtonNameConstants group. */
  bool Pressed;  /*!< The returned button state. */
  byte Count;    /*!< The returned button pressed count. */
  bool Reset;    /*!< If true, the count is reset after reading. */
};
/** @} */ // end of ButtonModuleTypes group
/** @defgroup ButtonModuleFunctions Button module functions
 * Functions for accessing and modifying Button module features.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Check for button press.
 * This function checks whether the specified button is pressed or not. You may
 * optionally reset the press count.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \param resetCount Whether or not to reset the press counter.
 * \return A boolean value indicating whether the button is pressed or not.
 */
inline bool ButtonPressed(const byte btn, bool resetCount = false);

/**
 * Get button press count.
 * Return the number of times the specified button has been pressed since
 * the last time the button press count was reset. Optionally clear the count
 * after reading it.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \param resetCount Whether or not to reset the press counter.
 * \return The button press count.
 */
inline byte ButtonCount(const byte btn, bool resetCount = false);

/**
 * Read button information.
 * Read the specified button. Set the pressed and count parameters with the
 * current state of the button. Optionally reset the press count after
 * reading it.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \param reset Whether or not to reset the press counter.
 * \param pressed The button pressed state.
 * \param count The button press count.
 * \return The function call result.
 */
inline char ReadButtonEx(const byte btn, bool reset, bool & pressed, unsigned int & count);

/**
 * Get button press count.
 * Return the press count of the specified button.
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \return The button press count.
 */
inline byte ButtonPressCount(const byte btn);

/**
 * Get button long press count.
 * Return the long press count of the specified button.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \return The button long press count.
 */
inline byte ButtonLongPressCount(const byte btn);

/**
 * Get button short release count.
 * Return the short release count of the specified button.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \return The button short release count.
 */
inline byte ButtonShortReleaseCount(const byte btn);

/**
 * Get button long release count.
 * Return the long release count of the specified button.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \return The button long release count.
 */
inline byte ButtonLongReleaseCount(const byte btn);

/**
 * Get button release count.
 * Return the release count of the specified button.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \return The button release count.
*/
inline byte ButtonReleaseCount(const byte btn);

/**
 * Get button state.
 * Return the state of the specified button. See \ref ButtonStateConstants.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \return The button state.
 */
inline byte ButtonState(const byte btn);

/**
 * Set button long press count.
 * Set the long press count of the specified button.
 *
 * \param btn The button number. See \ref ButtonNameConstants.
 * \param n The new long press count value.
 */
inline void SetButtonLongPressCount(const byte btn, const byte n);

/**
 * Set button long release count.
 * Set the long release count of the specified button.
 *
 * \param btn The button number. See \ref ButtonNameConstants.
 * \param n The new long release count value.
 */
inline void SetButtonLongReleaseCount(const byte btn, const byte n);

/**
 * Set button press count.
 * Set the press count of the specified button.
 *
 * \param btn The button number. See \ref ButtonNameConstants.
 * \param n The new press count value.
 */
inline void SetButtonPressCount(const byte btn, const byte n);

/**
 * Set button release count.
 * Set the release count of the specified button.
 *
 * \param btn The button number. See \ref ButtonNameConstants.
 * \param n The new release count value.
 */
inline void SetButtonReleaseCount(const byte btn, const byte n);

/**
 * Set button short release count.
 * Set the short release count of the specified button.
 *
 * \param btn The button number. See \ref ButtonNameConstants.
 * \param n The new short release count value.
 */
inline void SetButtonShortReleaseCount(const byte btn, const byte n);

/**
 * Set button state.
 * Set the state of the specified button.
 *
 * \param btn The button to check. See \ref ButtonNameConstants.
 * \param state The new button state. See \ref ButtonStateConstants.
*/
inline void SetButtonState(const byte btn, const byte state);

/**
 * Read button.
 * This function lets you read button state information via the \ref
 * ReadButtonType structure.
 *
 * \param args The ReadButtonType structure containing the needed parameters.
 */
inline void SysReadButton(ReadButtonType & args);

#else

#define ButtonPressCount(_b) asm { GetButtonPressCount(_b, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define ButtonLongPressCount(_b) asm { GetButtonLongPressCount(_b, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define ButtonShortReleaseCount(_b) asm { GetButtonShortReleaseCount(_b, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define ButtonLongReleaseCount(_b) asm { GetButtonLongReleaseCount(_b, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define ButtonReleaseCount(_b) asm { GetButtonReleaseCount(_b, __TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define ButtonState(_b) asm { GetButtonState(_b, __TMPBYTE__) __RETURN__ __TMPBYTE__ }

#define SetButtonPressCount(_b, _n) asm { __setButtonPressCount(_b, _n) }
#define SetButtonLongPressCount(_b, _n) asm { __setButtonLongPressCount(_b, _n) }
#define SetButtonShortReleaseCount(_b, _n) asm { __setButtonShortReleaseCount(_b, _n) }
#define SetButtonLongReleaseCount(_b, _n) asm { __setButtonLongReleaseCount(_b, _n) }
#define SetButtonReleaseCount(_b, _n) asm { __setButtonReleaseCount(_b, _n) }
#define SetButtonState(_b, _n) asm { __setButtonState(_b, _n) }

#define SysReadButton(_args) asm { \
  compchktype _args, ReadButtonType \
  syscall ReadButton, _args \
}
#endif
/** @} */ // end of ButtonModuleFunctions group
/** @} */ // end of ButtonModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
////////////////////////////////// UI MODULE //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup UiModule
 * @{
 */
/** @defgroup UiModuleTypes Ui module types
 * Types used by various Ui module functions.
 * @{
 */

#if __FIRMWARE_VERSION > 107
/**
 * Parameters for the SetSleepTimeout system call.
 * This structure is used when calling the \ref SysSetSleepTimeout system call
 * function.
 * \sa SysSetSleepTimeout()
 */
struct SetSleepTimeoutType {
 char Result;                     /*!< The result of the system call function. */
 unsigned long TheSleepTimeoutMS; /*!< The new sleep timeout value in milliseconds. */
};
#endif

/** @} */ // end of UiModuleTypes group
/** @defgroup UiModuleFunctions Ui module functions
 * Functions for accessing and modifying Ui module features.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Get command flags.
 * Return the command flags.
 * \return Command flags. See \ref UiFlagsConstants
 */
inline byte CommandFlags(void);

/**
 * Get UI module state.
 * Return the user interface state.
 * \return The UI module state. See \ref UiStateConstants.
 */
inline byte UIState(void);

/**
 * Read UI button.
 * Return user interface button information.
 * \return A UI button value.  See \ref UiButtonConstants.
 */
inline byte UIButton(void);

/**
 * Read VM run state.
 * Return VM run state information.
 * \return VM run state. See \ref UiVMRunStateConstants.
 */
inline byte VMRunState(void);

/**
 * Get battery state.
 * Return battery state information (0..4).
 * \return The battery state (0..4)
 */
inline byte BatteryState(void);

/**
 * Get bluetooth state.
 * Return the bluetooth state.
 * \return The bluetooth state. See \ref UiBluetoothStateConstants.
 */
inline byte BluetoothState(void);

/**
 * Get UI module USB state.
 * This method returns the UI module USB state.
 * \return The UI module USB state.  (0=disconnected, 1=connected, 2=working)
 */
inline byte UsbState(void);

/**
 * Read sleep timeout.
 * Return the number of minutes that the NXT will remain on before
 * it automatically shuts down.
 * \return The sleep timeout value
 */
inline byte SleepTimeout(void);

/**
 * Read sleep time.
 * Return the number of minutes that the NXT will remain on before
 * it automatically shuts down.
 * \return The sleep time value
 * \sa SleepTimeout
 */
inline byte SleepTime(void);

/**
 * Read sleep timer.
 * Return the number of minutes left in the countdown to zero from the
 * original SleepTimeout value. When the SleepTimer value reaches zero the
 * NXT will shutdown.
 * \return The sleep timer value
 */
inline byte SleepTimer(void);

/**
 * Read battery type.
 * Return whether the NXT has a rechargeable battery installed or not.
 * \return Whether the battery is rechargeable or not. (false = no, true = yes)
 */
inline bool RechargeableBattery(void);

/**
 * Read volume.
 * Return the user interface volume level. Valid values are from 0 to 4.
 * \return The UI module volume. (0..4)
 */
inline byte Volume(void);

/**
 * Read the on brick program pointer value.
 * Return the current OBP (on-brick program) step
 *
 * \return On brick program pointer (step).
 */
inline byte OnBrickProgramPointer(void);

/**
 * Read abort flag.
 * Return the enhanced NBC/NXC firmware's abort flag.
 *
 * \return The current abort flag value.  See \ref ButtonStateConstants.
 * \warning This function requires the enhanced NBC/NXC firmware.
*/
inline byte AbortFlag(void);

/**
 * Read long abort setting.
 * Return the enhanced NBC/NXC firmware's long abort setting.
 *
 * \sa AbortFlag
 * \return The current abort flag value.  See \ref ButtonStateConstants.
 * \warning This function requires the enhanced NBC/NXC firmware.
*/
inline byte LongAbort(void);

/**
 * Get battery Level.
 * Return the battery level in millivolts.
 * \return The battery level
 */
inline unsigned int BatteryLevel(void);

/**
 * Set command flags.
 * Set the command flags.
 *
 * \param cmdFlags The new command flags. See \ref UiFlagsConstants.
 */
inline void SetCommandFlags(const byte cmdFlags);

/**
 * Set UI button.
 * Set user interface button information.
 *
 * \param btn A user interface button value. See \ref UiButtonConstants.
 */
inline void SetUIButton(byte btn);

/**
 * Set UI state.
 * Set the user interface state.
 *
 * \param state A user interface state value. See \ref UiStateConstants.
 */
inline void SetUIState(byte state);

/**
 * Set VM run state.
 * Set VM run state information.
 *
 * \param vmRunState The desired VM run state. See \ref UiVMRunStateConstants.
 *
 * \warning It is not a good idea to change the VM run state from within a
 * running program unless you know what you are doing.
 */
inline void SetVMRunState(const byte vmRunState);

/**
 * Set battery state.
 * Set battery state information.
 *
 * \param state The desired battery state (0..4).
 */
inline void SetBatteryState(byte state);

/**
 * Set bluetooth state.
 * Set the Bluetooth state.
 *
 * \param state The desired bluetooth state. See \ref UiBluetoothStateConstants.
 */
inline void SetBluetoothState(byte state);

/**
 * Set sleep timeout.
 * Set the NXT sleep timeout value to the specified number of minutes.
 *
 * \param n The minutes to wait before sleeping.
 */
inline void SetSleepTimeout(const byte n);

/**
 * Set sleep time.
 * Set the NXT sleep timeout value to the specified number of minutes.
 *
 * \param n The minutes to wait before sleeping.
 * \sa SetSleepTimeout, SleepTimeout
 */
inline void SetSleepTime(const byte n);

/**
 * Set the sleep timer.
 * Set the system sleep timer to the specified number of minutes.
 *
 * \param n The minutes left on the timer.
 */
inline void SetSleepTimer(const byte n);

/**
 * Set volume.
 * Set the user interface volume level. Valid values are from 0 to 4.
 *
 * \param volume The new volume level.
 */
inline void SetVolume(byte volume);

/**
 * Set on-brick program pointer.
 * Set the current OBP (on-brick program) step.
 *
 * \param obpStep The new on-brick program step.
 */
inline void SetOnBrickProgramPointer(byte obpStep);

/**
 * Turn off NXT.
 * Force the NXT to turn off if the specified value is greater than zero.
 * \param num If greater than zero the NXT will turn off.
*/
inline void ForceOff(byte num);

/**
 * Set abort flag.
 * Set the enhanced NBC/NXC firmware's program abort flag. By default the
 * running program can be interrupted by a short press of the escape button.
 * You can change this to any other button state flag.
 *
 * \param abortFlag The new abort flag value. See \ref ButtonStateConstants
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SetAbortFlag(byte abortFlag);

/**
 * Set long abort.
 * Set the enhanced NBC/NXC firmware's long abort setting (true or false). If
 * set to true then a program has access the escape button. Aborting a program
 * requires a long press of the escape button.
 *
 * \param longAbort If true then require a long press of the escape button
 * to abort a program, otherwise a short press will abort it.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void SetLongAbort(bool longAbort);

#if __FIRMWARE_VERSION > 107
/**
 * Set system sleep timeout.
 * This function lets you set the system sleep timeout value given the parameters you
 * pass in via the \ref SetSleepTimeoutType structure.
 *
 * \param args The SetSleepTimeoutType structure containing the required parameters.
 * 
 * \warning This function requires an NXT 2.0 compatible firmware.
 */
inline void SysSetSleepTimeout(SetSleepTimeoutType & args);
#endif

#else

#define CommandFlags() asm { GetCommandFlags(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define UIState() asm { GetUIState(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define UIButton() asm { GetUIButton(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define VMRunState() asm { GetVMRunState(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BatteryState() asm { GetBatteryState(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define BluetoothState() asm { GetBluetoothState(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define UsbState() asm { GetUsbState(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SleepTimeout() asm { GetSleepTimeout(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define SleepTime() SleepTimeout()
#define SleepTimer() asm { GetSleepTimer(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define RechargeableBattery() asm { GetRechargeableBattery(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define Volume() asm { GetVolume(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define OnBrickProgramPointer() asm { GetOnBrickProgramPointer(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define AbortFlag() asm { GetAbortFlag(__TMPBYTE__) __RETURN__ __TMPBYTE__ }
#define LongAbort() AbortFlag()
#define BatteryLevel() asm { GetBatteryLevel(__TMPWORD__) __RETURN__ __TMPWORD__ }

#define SetCommandFlags(_n) asm { __setCommandFlags(_n) }
#define SetUIState(_n) asm { __setUIState(_n) }
#define SetUIButton(_n) asm { __setUIButton(_n) }
#define SetVMRunState(_n) asm { __setVMRunState(_n) }
#define SetBatteryState(_n) asm { __setBatteryState(_n) }
#define SetBluetoothState(_n) asm { __setBluetoothState(_n) }
#define SetUsbState(_n) asm { __setUsbState(_n) }
#define SetSleepTimeout(_n) asm { __setSleepTimeout(_n) }
#define SetSleepTime(_n) SetSleepTimeout(_n)
#define SetSleepTimer(_n) asm { __setSleepTimer(_n) }
#define SetVolume(_n) asm { __setVolume(_n) }
#define SetOnBrickProgramPointer(_n) asm { __setOnBrickProgramPointer(_n) }
#define ForceOff(_n) asm { __forceOff(_n) }
#define SetAbortFlag(_n) asm { __setAbortFlag(_n) }
#define SetLongAbort(_n) do { \
  if (_n) { \
    asm { __setAbortFlag(BTNSTATE_LONG_PRESSED_EV) } \
  } else { \
    asm { __setAbortFlag(BTNSTATE_PRESSED_EV) } \
  } \
} while(false)

#if __FIRMWARE_VERSION > 107
#define SysSetSleepTimeout(_args) asm { \
  compchktype _args, SetSleepTimeoutType \
  syscall SetSleepTimeoutVal, _args \
}
#endif

#endif
/** @} */ // end of UiModuleFunctions group
/** @} */ // end of UiModule group
/** @} */ // end of NXTFirmwareModules group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// LOADER MODULE ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup LoaderModule
 * @{
 */
/** @defgroup LoaderModuleTypes Loader module types
 * Types used by various Loader module functions.
 * @{
 */
/**
 * Parameters for the FileOpen system call.
 * This structure is used when calling the \ref SysFileOpenAppend, \ref
 * SysFileOpenRead, \ref SysFileOpenWrite, \ref SysFileOpenReadLinear,
 * \ref SysFileOpenWriteLinear and \ref SysFileOpenWriteNonLinear system call
 * functions.
 * \sa SysFileOpenAppend(), SysFileOpenRead(), SysFileOpenWrite(),
 * SysFileOpenReadLinear(), SysFileOpenWriteLinear()
 */
struct FileOpenType {
  unsigned int Result;    /*!< The function call result. Possible values
                            include \ref LoaderErrors. */
  byte FileHandle;        /*!< The returned file handle to use for subsequent
                            file operations. */
  string Filename;        /*!< The name of the file to open or create. */
  unsigned long Length;   /*!< For SysFileOpenWrite(),
                            SysFileOpenWriteLinear() and
                            SysFileOpenWriteNonLinear(): the desired maximum
                            file capacity.

                            For SysFileOpenAppend(), SysFileOpenRead() and
                            SysFileOpenReadLinear(): the returned available
                            length in the file. */
};

/**
 * Parameters for the FileReadWrite system call.
 * This structure is used when calling the \ref SysFileRead and \ref SysFileWrite
 * system call functions.
 * \sa SysFileRead() and SysFileWrite()
 */
struct FileReadWriteType {
  unsigned int Result;    /*!< The function call result. Possible values
                            include \ref LoaderErrors. */
  byte FileHandle;        /*!< The file handle to access. */
  string Buffer;          /*!< The buffer to store read bytes or containing
                            bytes to write. */
  unsigned long Length;   /*!< The number of bytes to read or the returned
                            number of bytes written. */
};

/**
 * Parameters for the FileClose system call.
 * This structure is used when calling the \ref SysFileClose system call function.
 * \sa SysFileClose()
 */
struct FileCloseType {
  unsigned int Result;   /*!< The function call result. Possible values
                           include \ref LoaderErrors. */
  byte FileHandle;       /*!< The file handle to close. */
};

/**
 * Parameters for the FileResolveHandle system call.
 * This structure is used when calling the \ref SysFileResolveHandle system
 * call function.
 * \sa SysFileResolveHandle()
 */
struct FileResolveHandleType {
  unsigned int Result;   /*!< The function call result. Possible values
                           include \ref LDR_HANDLEALREADYCLOSED and \ref LDR_SUCCESS. */
  byte FileHandle;       /*!< The returned resolved file handle. */
  bool WriteHandle;      /*!< True if the returned handle is a write handle. */
  string Filename;       /*!< The name of the file for which to resolve a handle. */
};

/**
 * Parameters for the FileRename system call.
 * This structure is used when calling the \ref SysFileRename system call
 * function.
 * \sa SysFileRename()
 */
struct FileRenameType {
  unsigned int Result;   /*!< The function call result. Possible values
                           include \ref LoaderErrors. */
  string OldFilename;    /*!< The name of the file to be renamed. */
  string NewFilename;    /*!< The new name to give to the file. */
};

/**
 * Parameters for the FileDelete system call.
 * This structure is used when calling the \ref SysFileDelete system call
 * function.
 * \sa SysFileDelete()
 */
struct FileDeleteType {
  unsigned int Result;   /*!< The function call result. Possible values
                           include \ref LoaderErrors. */
  string Filename;       /*!< The name of the file to delete. */
};

#ifdef __ENHANCED_FIRMWARE
/**
 * Parameters for the LoaderExecuteFunction system call.
 * This structure is used when calling the \ref SysLoaderExecuteFunction
 * system call function.
 *
 * The fields usage depends on the requested command and are documented in the
 * table below.
 *
 * <table>
 * <tr><td>Cmd</td>
 *     <td>Meaning</td><td>Expected Parameters</td></tr>
 * <tr><td>LDR_CMD_OPENREAD</td>
 *     <td>Open a file for reading</td><td>(Filename, Length)</td></tr>
 * <tr><td>LDR_CMD_OPENWRITE</td>
 *     <td>Create a file</td><td>(Filename, Length)</td></tr>
 * <tr><td>LDR_CMD_READ</td>
 *     <td>Read from a file</td><td>(Filename, Buffer, Length)</td></tr>
 * <tr><td>LDR_CMD_WRITE</td>
 *     <td>Write to a file</td><td>(Filename, Buffer, Length)</td></tr>
 * <tr><td>LDR_CMD_CLOSE</td>
 *     <td>Close a file</td><td>(Filename)</td></tr>
 * <tr><td>LDR_CMD_DELETE</td>
 *     <td>Delete a file</td><td>(Filename)</td></tr>
 * <tr><td>LDR_CMD_FINDFIRST</td>
 *     <td>Start iterating files</td><td>(Filename, Buffer, Length)</td></tr>
 * <tr><td>LDR_CMD_FINDNEXT</td>
 *     <td>Continue iterating files</td><td>(Filename, Buffer, Length)</td></tr>
 * <tr><td>LDR_CMD_OPENWRITELINEAR</td>
 *     <td>Create a linear file</td><td>(Filename, Length)</td></tr>
 * <tr><td>LDR_CMD_OPENREADLINEAR</td>
 *     <td>Read a linear file</td><td>(Filename, Buffer, Length)</td></tr>
 * <tr><td>LDR_CMD_OPENAPPENDDATA</td>
 *     <td>Open a file for writing</td><td>(Filename, Length)</td></tr>
 * <tr><td>LDR_CMD_FINDFIRSTMODULE</td>
 *     <td>Start iterating modules</td><td>(Filename, Buffer)</td></tr>
 * <tr><td>LDR_CMD_FINDNEXTMODULE</td>
 *     <td>Continue iterating modules</td><td>(Buffer)</td></tr>
 * <tr><td>LDR_CMD_CLOSEMODHANDLE</td>
 *     <td>Close module handle</td><td>()</td></tr>
 * <tr><td>LDR_CMD_IOMAPREAD</td>
 *     <td>Read IOMap data</td><td>(Filename, Buffer, Length)</td></tr>
 * <tr><td>LDR_CMD_IOMAPWRITE</td>
 *     <td>Write IOMap data</td><td>(Filename, Buffer, Length)</td></tr>
 * <tr><td>LDR_CMD_DELETEUSERFLASH</td>
 *     <td>Delete all files</td><td>()</td></tr>
 * <tr><td>LDR_CMD_RENAMEFILE</td>
 *     <td>Rename file</td><td>(Filename, Buffer, Length)</td></tr>
 * </table>
 *
 * \sa SysLoaderExecuteFunction()
 */
struct LoaderExecuteFunctionType {
  unsigned int Result;    /*!< The function call result. Possible values
                            include \ref LoaderErrors. */
  byte Cmd;               /*!< The command to execute. */
  string Filename;        /*!< The Filename parameter, see table. */
  byte Buffer[];          /*!< The Buffer parameter, see table. */
  unsigned long Length;   /*!< The Length parameter, see table. */
};

/**
 * Parameters for the FileFind system call.
 * This structure is used when calling the \ref SysFileFindFirst and \ref
 * SysFileFindNext system call functions.
 * \sa SysFileFindFirst() and SysFileFindNext()
 */
struct FileFindType {
  unsigned int Result;    /*!< The function call result. Possible values
                            include \ref LoaderErrors. */
  byte FileHandle;        /*!< The returned file handle to be used to continue
                            iterations. Close it after usage. */
  string Filename;        /*!< The pattern to match file name, then the
                            returned found file name. */
  unsigned long Length;   /*!< The found file length. */
};

#if __FIRMWARE_VERSION > 107
/**
 * Parameters for the FileSeek system call.
 * This structure is used when calling the \ref SysFileSeek system call function.
 * \sa SysFileSeek()
 */
struct FileSeekType {
 unsigned int Result; /*!< The function call result. Possible values include
                        \ref LoaderErrors. */
 byte FileHandle;     /*!< The handle of the file to seek in. */
 byte Origin;         /*!< The origin of the file seek operation. See \ref fseekConstants. */
 long Length;         /*!< The offset from the origin to seek to. */
};

/**
 * Parameters for the FileResize system call.
 * This structure is used when calling the \ref SysFileResize system call function.
 * \sa SysFileResize()
 */
struct FileResizeType {
 unsigned int Result;   /*!< The function call result. Possible values include
                         \ref LoaderErrors. */
 byte FileHandle;       /*!< The handle of the file to resize. */
 unsigned int NewSize;  /*!< The new file size. */
};

/**
 * Parameters for the FileTell system call.
 * This structure is used when calling the \ref SysFileTell system call function.
 * \sa SysFileTell()
 */
struct FileTellType {
 unsigned int Result;     /*!< The function call result. Possible values include
                           \ref LoaderErrors. */
 byte FileHandle;         /*!< The handle of the open file. */
 unsigned long Position;  /*!< The current file position in the open file. */
};

#endif
#endif
#if __FIRMWARE_VERSION > 107
/**
 * Parameters for the ListFiles system call.
 * This structure is used when calling the \ref SysListFiles system call function.
 * \sa SysListFiles()
 */
struct ListFilesType {
 char Result;       /*!< The function call result. Possible values include
                         \ref LoaderErrors. */
 string Pattern;    /*!< The file search pattern. */
 string FileList[]; /*!< An array of strings containing the list of filenames
                         that matched the file search pattern. */
};
#endif
/** @} */ // end of LoaderModuleTypes group
/** @defgroup LoaderModuleFunctions Loader module functions
 * Functions for accessing and modifying Loader module features.
 * @{
 */
#ifdef __DOXYGEN_DOCS

/**
 * Get free flash memory.
 * Get the number of bytes of flash memory that are available for use.
 * \return The number of bytes of unused flash memory.
 */
inline unsigned int FreeMemory(void);

/**
 * Create a file.
 * Create a new file with the specified filename and size and open it for
 * writing. The file handle is returned in the last parameter, which must be a
 * variable. The loader result code is returned as the value of the function
 * call. The filename and size parameters must be constants, constant
 * expressions, or variables. A file created with a size of zero bytes cannot
 * be written to since the NXC file writing functions do not grow the file if
 * its capacity is exceeded during a write attempt.
 *
 * \param fname The name of the file to create.
 * \param fsize The size of the file.
 * \param handle The file handle output from the function call.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int CreateFile(string fname, unsigned int fsize, byte & handle);

/**
 * Open a file for appending.
 * Open an existing file with the specified filename for writing. The file
 * size is returned in the second parameter, which must be a variable. The
 * file handle is returned in the last parameter, which must be a variable.
 * The loader result code is returned as the value of the function call.
 * The filename parameter must be a constant or a variable.
 *
 * \param fname The name of the file to open.
 * \param fsize The size of the file returned by the function.
 * \param handle The file handle output from the function call.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int OpenFileAppend(string fname, unsigned int & fsize, byte & handle);

/**
 * Open a file for reading.
 * Open an existing file with the specified filename for reading. The file
 * size is returned in the second parameter, which must be a variable. The
 * file handle is returned in the last parameter, which must be a variable.
 * The loader result code is returned as the value of the function call. The
 * filename parameter must be a constant or a variable.
 *
 * \param fname The name of the file to open.
 * \param fsize The size of the file returned by the function.
 * \param handle The file handle output from the function call.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int OpenFileRead(string fname, unsigned int & fsize, byte & handle);

/**
 * Close a file.
 * Close the file associated with the specified file handle. The loader
 * result code is returned as the value of the function call. The handle
 * parameter must be a constant or a variable.
 *
 * \param handle The file handle.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int CloseFile(byte handle);

/**
 * Resolve a handle.
 * Resolve a file handle from the specified filename. The file handle is
 * returned in the second parameter, which must be a variable. A boolean
 * value indicating whether the handle can be used to write to the file or
 * not is returned in the last parameter, which must be a variable. The
 * loader result code is returned as the value of the function call. The
 * filename parameter must be a constant or a variable.
 *
 * \param filename The name of the file for which to resolve a handle.
 * \param handle The file handle output from the function call.
 * \param writable A boolean flag indicating whether the handle is
 * to a file open for writing (true) or reading (false).
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int ResolveHandle(string filename, byte & handle, bool & writable);

/**
 * Rename a file.
 * Rename a file from the old filename to the new filename. The loader
 * result code is returned as the value of the function call. The filename
 * parameters must be constants or variables.
 *
 * \param oldname The old filename.
 * \param newname The new filename.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int RenameFile(string oldname, string newname);

/**
 * Delete a file.
 * Delete the specified file. The loader result code is returned as the
 * value of the function call. The filename parameter must be a constant or a
 * variable.
 *
 * \param fname The name of the file to delete.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int DeleteFile(string fname);

/**
 * Resize a file.
 * Resize the specified file. The loader result code is returned as the
 * value of the function call. The filename parameter must be a constant or a
 * variable.
 *
 * \param fname The name of the file to resize.
 * \param newsize The new size for the file.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int ResizeFile(string fname, const unsigned int newsize);

#ifdef __ENHANCED_FIRMWARE
/**
 * Create a linear file.
 * Create a new linear file with the specified filename and size and open it for
 * writing. The file handle is returned in the last parameter, which must be a
 * variable. The loader result code is returned as the value of the function
 * call. The filename and size parameters must be constants, constant
 * expressions, or variables. A file created with a size of zero bytes cannot
 * be written to since the NXC file writing functions do not grow the file if
 * its capacity is exceeded during a write attempt.
 *
 * \param fname The name of the file to create.
 * \param fsize The size of the file.
 * \param handle The file handle output from the function call.
 * \return The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline unsigned int CreateFileLinear(string fname, unsigned int fsize, byte & handle);

/**
 * Create a non-linear file.
 * Create a new non-linear file with the specified filename and size and open it for
 * writing. The file handle is returned in the last parameter, which must be a
 * variable. The loader result code is returned as the value of the function
 * call. The filename and size parameters must be constants, constant
 * expressions, or variables. A file created with a size of zero bytes cannot
 * be written to since the NXC file writing functions do not grow the file if
 * its capacity is exceeded during a write attempt.
 *
 * \param fname The name of the file to create.
 * \param fsize The size of the file.
 * \param handle The file handle output from the function call.
 * \return The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline unsigned int CreateFileNonLinear(string fname, unsigned int fsize, byte & handle);

/**
 * Open a linear file for reading.
 * Open an existing linear file with the specified filename for reading. The file
 * size is returned in the second parameter, which must be a variable. The
 * file handle is returned in the last parameter, which must be a variable.
 * The loader result code is returned as the value of the function call. The
 * filename parameter must be a constant or a variable.
 *
 * \param fname The name of the file to open.
 * \param fsize The size of the file returned by the function.
 * \param handle The file handle output from the function call.
 * \return The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline unsigned int OpenFileReadLinear(string fname, unsigned int & fsize, byte & handle);

/**
 * Start searching for files.
 * This function lets you begin iterating through files stored on the NXT.
 *
 * \param fname On input this contains the filename pattern you are searching
 * for. On output this contains the name of the first file found that matches
 * the pattern.
 * \param handle The search handle input to and output from the function call.
 * \return The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline unsigned int FindFirstFile(string & fname, byte & handle);

/**
 * Continue searching for files.
 * This function lets you continue iterating through files stored on the NXT.
 *
 * \param fname On output this contains the name of the next file found that
 * matches the pattern used when the search began by calling \ref FindFirstFile.
 * \param handle The search handle input to and output from the function call.
 * \return The function call result. See \ref LoaderErrors.
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline unsigned int FindNextFile(string & fname, byte & handle);

#endif

/**
 * Calculate the size of a variable.
 * Calculate the number of bytes required to store the contents of the
 * variable passed into the function.
 *
 * \param value The variable.
 * \return The number of bytes occupied by the variable.
 */
inline unsigned int SizeOf(variant & value);

/**
 * Read a value from a file.
 * Read a value from the file associated with the specified handle.
 * The handle parameter must be a variable. The value parameter must be a
 * variable. The type of the value parameter determines the number of bytes of
 * data read.
 *
 * \param handle The file handle. 
 * \param value The variable to store the data read from the file.
 * \return The function call result. See \ref LoaderErrors. 
 */
inline unsigned int Read(byte handle, variant & value);

/**
 * Read a value from a file plus line ending.
 * Read a value from the file associated with the specified handle.
 * The handle parameter must be a variable. The value parameter must be a
 * variable. The type of the value parameter determines the number of bytes
 * of data read. The ReadLn function reads two additional bytes from the
 * file which it assumes are a carriage return and line feed pair.
 *
 * \param handle The file handle.
 * \param value The variable to store the data read from the file.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int ReadLn(byte handle, variant & value);

/**
 * Read bytes from a file.
 * Read the specified number of bytes from the file associated with the
 * specified handle. The handle parameter must be a variable. The length
 * parameter must be a variable. The buf parameter must be an array or a
 * string variable. The actual number of bytes read is returned in the
 * length parameter.
 *
 * \param handle The file handle.
 * \param length The number of bytes to read. Returns the number of bytes actually read.
 * \param buf The byte array where the data is stored on output.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int ReadBytes(byte handle, unsigned int & length, byte & buf[]);

/**
 * Read a string from a file plus line ending.
 * Read a string from the file associated with the specified handle.
 * The handle parameter must be a variable. The output parameter must be a
 * variable. Appends bytes to the output variable until a line ending (CRLF)
 * is reached. The line ending is also read but it is not appended to the
 * output parameter.
 *
 * \param handle The file handle.
 * \param output The variable to store the string read from the file.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int ReadLnString(byte handle, string & output);

/**
 * Write value to file.
 * Write a value to the file associated with the specified handle.
 * The handle parameter must be a variable. The value parameter must be a
 * constant, a constant expression, or a variable. The type of the value
 * parameter determines the number of bytes of data written.
 *
 * \param handle The file handle.
 * \param value The value to write to the file.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int Write(byte handle, const variant & value);

/**
 * Write bytes to file.
 * Write the contents of the data array to the file associated with the
 * specified handle. The handle parameter must be a variable. The cnt
 * parameter must be a variable. The data parameter must be a byte array. The
 * actual number of bytes written is returned in the cnt parameter.
 *
 * \param handle The file handle.
 * \param buf The byte array or string containing the data to write.
 * \param cnt The number of bytes actually written to the file.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int WriteBytes(byte handle, const byte & buf[], unsigned int & cnt);

/**
 * Write bytes to a file with limit.
 * Write the specified number of bytes to the file associated with the
 * specified handle. The handle parameter must be a variable. The len
 * parameter must be a variable. The buf parameter must be a byte array or a
 * string variable or string constant. The actual number of bytes written is
 * returned in the len parameter.
 *
 * \param handle The file handle.
 * \param len The maximum number of bytes to write on input.  Returns the
 * actual number of bytes written.
 * \param buf The byte array or string containing the data to write.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int WriteBytesEx(byte handle, unsigned int & len, const byte & buf[]);

/**
 * Write a value and new line to a file.
 * Write a value to the file associated with the specified handle. The
 * handle parameter must be a variable. The value parameter must be a constant,
 * a constant expression, or a variable. The type of the value parameter
 * determines the number of bytes of data written. This function also
 * writes a carriage return and a line feed to the file following the numeric
 * data.
 *
 * \param handle The file handle.
 * \param value The value to write to the file.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int WriteLn(byte handle, const variant & value);

/**
 * Write string and new line to a file.
 * Write the string to the file associated with the specified handle. The
 * handle parameter must be a variable. The count parameter must be a variable.
 * The str parameter must be a string variable or string constant. This
 * function also writes a carriage return and a line feed to the file following
 * the string data. The total number of bytes written is returned in the
 * cnt parameter.
 *
 * \param handle The file handle.
 * \param str The string to write to the file.
 * \param cnt The number of bytes actually written to the file.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int WriteLnString(byte handle, const string & str, unsigned int & cnt);

/**
 * Write string to a file.
 * Write the string to the file associated with the specified handle. The
 * handle parameter must be a variable. The count parameter must be a variable.
 * The str parameter must be a string variable or string constant. The actual
 * number of bytes written is returned in the cnt parameter.
 *
 * \param handle The file handle.
 * \param str The string to write to the file.
 * \param cnt The number of bytes actually written to the file.
 * \return The function call result. See \ref LoaderErrors.
 */
inline unsigned int WriteString(byte handle, const string & str, unsigned int & cnt);

/**
 * Open file for reading.
 * This function lets you open an existing file for reading using the values
 * specified via the \ref FileOpenType structure.
 *
 * The number of bytes that can be read from the file is returned via the
 * Length member.
 *
 * \param args The FileOpenType structure containing the needed parameters.
 */
inline void SysFileOpenRead(FileOpenType & args);

/**
 * Open and create file for writing.
 * This function lets you create a file that you can write to using the values
 * specified via the \ref FileOpenType structure.
 *
 * The desired maximum file capacity in bytes is specified via the Length
 * member.
 *
 * \param args The FileOpenType structure containing the needed parameters.
 */
inline void SysFileOpenWrite(FileOpenType & args);

/**
 * Open file for writing at end of file.
 * This function lets you open an existing file that you can write to using
 * the values specified via the \ref FileOpenType structure.
 *
 * The available length remaining in the file is returned via the Length
 * member.
 *
 * \param args The FileOpenType structure containing the needed parameters.
 */
inline void SysFileOpenAppend(FileOpenType & args);

/**
 * Read from file.
 * This function lets you read from a file using the values specified via the
 * \ref FileReadWriteType structure.
 *
 * \param args The FileReadWriteType structure containing the needed
 * parameters.
 */
inline void SysFileRead(FileReadWriteType & args);

/**
 * File write.
 * This function lets you write to a file using the values specified via the
 * \ref FileReadWriteType structure.
 *
 * \param args The FileReadWriteType structure containing the needed
 * parameters.
 */
inline void SysFileWrite(FileReadWriteType & args);

/**
 * Close file handle.
 * This function lets you close a file using the values specified via the \ref
 * FileCloseType structure.
 *
 * \param args The FileCloseType structure containing the needed parameters.
 */
inline void SysFileClose(FileCloseType & args);

/**
 * File resolve handle.
 * This function lets you resolve the handle of a file using the values
 * specified via the \ref FileResolveHandleType structure.  This will find a
 * previously opened file handle.
 *
 * \param args The FileResolveHandleType structure containing the needed
 * parameters.
 */
inline void SysFileResolveHandle(FileResolveHandleType & args);

/**
 * Rename file.
 * This function lets you rename a file using the values specified via the
 * \ref FileRenameType structure.
 *
 * \param args The FileRenameType structure containing the needed parameters.
 */
inline void SysFileRename(FileRenameType & args);

/**
 * Delete file.
 * This function lets you delete a file using the values specified via the
 * \ref FileDeleteType structure.
 *
 * \param args The FileDeleteType structure containing the needed parameters.
 */
inline void SysFileDelete(FileDeleteType & args);

#ifdef __ENHANCED_FIRMWARE
/**
 * Execute any Loader module command.
 * This function lets you directly execute the Loader module's primary
 * function using the values specified via the \ref LoaderExecuteFunctionType
 * structure.
 *
 * \param args The LoaderExecuteFunctionType structure containing the needed
 * parameters.
 *
 * \warning This function requires the extended firmware.
 */
inline void SysLoaderExecuteFunction(LoaderExecuteFunctionType & args);

/**
 * Start finding files.
 * This function lets you begin iterating through files stored on the NXT.
 *
 * \param args The FileFindType structure containing the needed parameters.
 *
 * \warning This function requires the extended firmware.
 */
inline void SysFileFindFirst(FileFindType & args);

/**
 * Continue finding files.
 * This function lets you continue iterating through files stored on the NXT.
 *
 * \param args The FileFindType structure containing the needed parameters.
 *
 * \warning This function requires the extended firmware.
 */
inline void SysFileFindNext(FileFindType & args);

/**
 * Open and create linear file for writing.
 * This function lets you create a linear file that you can write to using the
 * values specified via the \ref FileOpenType structure.
 *
 * \param args The FileOpenType structure containing the needed parameters.
 *
 * \warning This function requires the extended firmware.
 */
inline void SysFileOpenWriteLinear(FileOpenType & args);

/**
 * Open and create non-linear file for writing.
 * This function lets you create a non-linear linear file that you can write
 * to using the values specified via the \ref FileOpenType structure.
 *
 * \param args The FileOpenType structure containing the needed parameters.
 *
 * \warning This function requires the extended firmware.
 */
inline void SysFileOpenWriteNonLinear(FileOpenType & args);

/**
 * Open linear file for reading.
 * This function lets you open an existing linear file for reading using the
 * values specified via the \ref FileOpenType structure.
 *
 * \param args The FileOpenType structure containing the needed parameters.
 *
 * \warning This function requires the extended firmware.
 */
inline void SysFileOpenReadLinear(FileOpenType & args);

#if __FIRMWARE_VERSION > 107
/**
 * Seek to file position.
 * This function lets you seek to a specific file position using the
 * values specified via the \ref FileSeekType structure.
 *
 * \param args The FileSeekType structure containing the needed parameters.
 *
 * \warning This function requires the extended firmware.
 */
inline void SysFileSeek(FileSeekType & args);

/**
 * Resize a file.
 * This function lets you resize a file using the
 * values specified via the \ref FileResizeType structure.
 *
 * \param args The FileResizeType structure containing the needed parameters.
 *
 * \warning This function requires the extended firmware.
 * It has not yet been implemented at the firmware level.
 */
inline void SysFileResize(FileResizeType & args);

/**
 * Return the file position.
 * This function returns the current file position in the open file
 * specified via the \ref FileTellType structure.
 *
 * \param args The FileTellType structure containing the needed parameters.
 *
 * \warning This function requires the extended firmware.
 */
inline void SysFileTell(FileTellType & args);

#endif
#endif
#if __FIRMWARE_VERSION > 107
/**
 * List files.
 * This function lets you retrieve a list of files on the NXT using the
 * values specified via the \ref ListFilesType structure.
 *
 * \param args The ListFilesType structure containing the needed parameters.
 */
inline void SysListFiles(ListFilesType & args);

#endif

#else

#define FreeMemory() asm { GetFreeMemory(__RETVAL__) }

#define CreateFile(_fname, _fsize, _handle) asm { __createFile(_fname, _fsize, _handle, __RETVAL__) }
#define OpenFileAppend(_fname, _fsize, _handle) asm { __openFileAppend(_fname, _fsize, _handle, __RETVAL__) }
#define OpenFileRead(_fname, _fsize, _handle) asm { __openFileRead(_fname, _fsize, _handle, __RETVAL__) }
#define CloseFile(_handle) asm { __closeFile(_handle, __RETVAL__) }
#define ResolveHandle(_fname, _handle, _writable) asm { __resolveHandle(_fname, _handle, _writable, __RETVAL__) }
#define RenameFile(_oldname, _newname) asm { __renameFile(_oldname, _newname, __RETVAL__) }
#define DeleteFile(_fname) asm { __deleteFile(_fname, __RETVAL__) }
#define ResizeFile(_fname, _newsize) asm { __fileResize(_fname, _newsize, __RETVAL__) }

#ifdef __ENHANCED_FIRMWARE
#define CreateFileLinear(_fname, _fsize, _handle) asm { __createFileLinear(_fname, _fsize, _handle, __RETVAL__) }
#define CreateFileNonLinear(_fname, _fsize, _handle) asm { __createFileNonLinear(_fname, _fsize, _handle, __RETVAL__) }
#define OpenFileReadLinear(_fname, _fsize, _handle) asm { __openFileReadLinear(_fname, _fsize, _handle, __RETVAL__) }
#define FindFirstFile(_fname, _handle) asm { __findFirstFile(_fname, _handle, __RETVAL__) }
#define FindNextFile(_fname, _handle) asm { __findNextFile(_fname, _handle, __RETVAL__) }
#endif

#define SizeOf(_n) asm { __sizeOF(_n, __RETVAL__) }
#define Read(_handle, _n) asm { __readValue(_handle, _n, __RETVAL__) }
#define ReadLn(_handle, _n) asm { __readLnValue(_handle, _n, __RETVAL__) }
#define ReadBytes(_handle, _len, _buf) asm { __readBytes(_handle, _len, _buf, __RETVAL__) }
#define ReadLnString(_handle, _output) asm { __readLnString(_handle, _output, __RETVAL__) }

#define Write(_handle, _n) asm { __writeValue(_handle, _n, __RETVAL__) }
#define WriteLn(_handle, _n) asm { __writeLnValue(_handle, _n, __RETVAL__) }
#define WriteString(_handle, _str, _cnt) asm { __writeString(_handle, _str, _cnt, __RETVAL__) }
#define WriteLnString(_handle, _str, _cnt) asm { __writeLnString(_handle, _str, _cnt, __RETVAL__) }
#define WriteBytes(_handle, _buf, _cnt) asm { __writeBytes(_handle, _buf, _cnt, __RETVAL__) }
#define WriteBytesEx(_handle, _len, _buf) asm { __writeBytesEx(_handle, _len, _buf, __RETVAL__) }

#define SysFileOpenRead(_args) asm { \
  compchktype _args, FileOpenType \
  syscall FileOpenRead, _args \
}
#define SysFileOpenWrite(_args) asm { \
  compchktype _args, FileOpenType \
  syscall FileOpenWrite, _args \
}
#define SysFileOpenAppend(_args) asm { \
  compchktype _args, FileOpenType \
  syscall FileOpenAppend, _args \
}
#define SysFileRead(_args) asm { \
  compchktype _args, FileReadWriteType \
  syscall FileRead, _args \
}
#define SysFileWrite(_args) asm { \
  compchktype _args, FileReadWriteType \
  syscall FileWrite, _args \
}
#define SysFileClose(_args) asm { \
  compchktype _args, FileCloseType \
  syscall FileClose, _args \
}
#define SysFileResolveHandle(_args) asm { \
  compchktype _args, FileResolveHandleType \
  syscall FileResolveHandle, _args \
}
#define SysFileRename(_args) asm { \
  compchktype _args, FileRenameType \
  syscall FileRename, _args \
}
#define SysFileDelete(_args) asm { \
  compchktype _args, FileDeleteType \
  syscall FileDelete, _args \
}

#ifdef __ENHANCED_FIRMWARE
#define SysLoaderExecuteFunction(_args) asm { \
  compchktype _args, LoaderExecuteFunctionType \
  syscall LoaderExecuteFunction, _args \
}
#define SysFileFindFirst(_args) asm { \
  compchktype _args, FileFindType \
  syscall FileFindFirst, _args \
}
#define SysFileFindNext(_args) asm { \
  compchktype _args, FileFindType \
  syscall FileFindNext, _args \
}
#define SysFileOpenWriteLinear(_args) asm { \
  compchktype _args, FileOpenType \
  syscall FileOpenWriteLinear, _args \
}
#define SysFileOpenWriteNonLinear(_args) asm { \
  compchktype _args, FileOpenType \
  syscall FileOpenWriteNonLinear, _args \
}
#define SysFileOpenReadLinear(_args) asm { \
  compchktype _args, FileOpenType \
  syscall FileOpenReadLinear, _args \
}
#if __FIRMWARE_VERSION > 107
#define SysFileSeek(_args) asm { \
  compchktype _args, FileSeekType \
  syscall FileSeek, _args \
}
#define SysFileResize(_args) asm { \
  compchktype _args, FileResizeType \
  syscall FileResize, _args \
}
#define SysFileTell(_args) asm { \
  compchktype _args, FileTellType \
  syscall FileTell, _args \
}
#endif
#endif
#if __FIRMWARE_VERSION > 107
#define SysListFiles(_args) asm { \
  compchktype _args, ListFilesType \
  syscall ListFiles, _args \
}
#endif

#endif

/** @} */ // end of LoaderModuleFunctions group
/** @} */ // end of LoaderModule group
/** @} */ // end of NXTFirmwareModules group


/** @addtogroup ThirdPartyDevices
 * @{
 */

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// HiTechnic API ////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup HiTechnicAPI
 * @{
 */

/**
 * Read HiTechnic Gyro sensor.
 * Read the HiTechnic Gyro sensor on the specified port. The offset value
 * should be calculated by averaging several readings with an offset of zero
 * while the sensor is perfectly still.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param offset The zero offset.
 * \return The Gyro sensor reading.
 */
inline int SensorHTGyro(const byte & port, int offset = 0) {
  asm {
    getin __RETVAL__, port, RawValueField
    sub __RETVAL__, __RETVAL__, 600
    sub __RETVAL__, __RETVAL__, offset
  }
}

/**
 * Read HiTechnic Magnet sensor.
 * Read the HiTechnic Magnet sensor on the specified port. The offset value
 * should be calculated by averaging several readings with an offset of zero
 * while the sensor is perfectly still.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param offset The zero offset.
 * \return The Magnet sensor reading.
 */
inline int SensorHTMagnet(const byte & port, int offset = 0) {
  asm {
    getin __RETVAL__, port, RawValueField
    sub __RETVAL__, __RETVAL__, 600
    sub __RETVAL__, __RETVAL__, offset
  }
}

/**
 * Read HiTechnic EOPD sensor.
 * Read the HiTechnic EOPD sensor on the specified port.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The EOPD sensor reading.
 */
inline int SensorHTEOPD(const byte & port) {
  asm {
    getin __RETVAL__, port, RawValueField
    sub __RETVAL__, 1023, __RETVAL__
  }
}

/**
 * Set sensor as HiTechnic EOPD.
 * Configure the sensor on the specified port as a HiTechnic EOPD sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param bStandard Configure in standard or long-range mode.
 */
inline void SetSensorHTEOPD(const byte & port, bool bStandard) {
  SetSensorType(port, bStandard ? SENSOR_TYPE_LIGHT_INACTIVE : SENSOR_TYPE_LIGHT_ACTIVE);
  SetSensorMode(port, SENSOR_MODE_RAW);
  ResetSensor(port);
}

/**
 * Set sensor as HiTechnic Gyro.
 * Configure the sensor on the specified port as a HiTechnic Gyro sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 */
inline void SetSensorHTGyro(const byte & port) {
  SetSensorType(port, SENSOR_TYPE_LIGHT_INACTIVE);
  SetSensorMode(port, SENSOR_MODE_RAW);
  ResetSensor(port);
}

/**
 * Set sensor as HiTechnic Magnet.
 * Configure the sensor on the specified port as a HiTechnic Magnet sensor.
 *
 * \param port The sensor port. See \ref InPorts.
 */
inline void SetSensorHTMagnet(const byte & port) {
  SetSensorType(port, SENSOR_TYPE_LIGHT_INACTIVE);
  SetSensorMode(port, SENSOR_MODE_RAW);
  ResetSensor(port);
}

#ifdef __DOXYGEN_DOCS

/**
 * Read HiTechnic color sensor color number.
 * Read the color number from the HiTechnic Color sensor on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The color number.
 */
inline int SensorHTColorNum(const byte & port);

/**
 * Read HiTechnic compass.
 * Read the compass heading value of the HiTechnic Compass sensor on the
 * specified port. The port must be configured as a Lowspeed port before
 * using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The compass heading.
 */
inline int SensorHTCompass(const byte & port);

/**
 * Read HiTechnic IRSeeker direction.
 * Read the direction value of the HiTechnic IR Seeker on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The IRSeeker direction.
 */
inline int SensorHTIRSeekerDir(const byte & port);

/**
 * Read HiTechnic IRSeeker2 register.
 * Read a register value from the HiTechnic IR Seeker2 on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param reg The register address. See \ref HTIRSeeker2Constants.
 * \return The IRSeeker2 register value.
 */
inline int SensorHTIRSeeker2Addr(const byte & port, const byte reg);

/**
 * Read HiTechnic IRSeeker2 DC direction.
 * Read the DC direction value from the HiTechnic IR Seeker2 on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The IRSeeker2 DC direction.
 */
inline int SensorHTIRSeeker2DCDir(const byte & port);

/**
 * Read HiTechnic IRSeeker2 AC direction.
 * Read the AC direction value from the HiTechnic IR Seeker2 on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The IRSeeker2 AC direction.
 */
inline int SensorHTIRSeeker2ACDir(const byte & port);

/**
 * Set HiTechnic Color2 mode.
 * Set the mode of the HiTechnic Color2 sensor on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param mode The Color2 mode. See \ref HTColor2Constants.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char SetHTColor2Mode(const byte & port, byte mode);

/**
 * Set HiTechnic IRSeeker2 mode.
 * Set the mode of the HiTechnic IRSeeker2 sensor on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param mode The IRSeeker2 mode. See \ref HTIRSeeker2Constants.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char SetHTIRSeeker2Mode(const byte & port, const byte mode);

/**
 * Read HiTechnic acceleration values.
 * Read X, Y, and Z axis acceleration values from the HiTechnic Accelerometer
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param x The output x-axis acceleration.
 * \param y The output y-axis acceleration.
 * \param z The output z-axis acceleration.
 * \return The function call result.
 */
inline bool ReadSensorHTAccel(const byte port, int & x, int & y, int & z);

/**
 * Read HiTechnic Color values.
 * Read color number, red, green, and blue values from the HiTechnic Color
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param ColorNum The output color number.
 * \param Red The red color value.
 * \param Green The green color value.
 * \param Blue The blue color value.
 * \return The function call result.
 */
inline bool ReadSensorHTColor(const byte port, byte & ColorNum, byte & Red, byte & Green, byte & Blue);

/**
 * Read HiTechnic IRSeeker values.
 * Read direction, and five signal strength values from the HiTechnic
 * IRSeeker sensor. Returns a boolean value indicating whether or not the
 * operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param dir The direction.
 * \param s1 The signal strength from sensor 1.
 * \param s3 The signal strength from sensor 3.
 * \param s5 The signal strength from sensor 5.
 * \param s7 The signal strength from sensor 7.
 * \param s9 The signal strength from sensor 9.
 * \return The function call result.
 */
inline bool ReadSensorHTIRSeeker(const byte port, byte & dir, byte & s1, byte & s3, byte & s5, byte & s7, byte & s9);

/**
 * Read HiTechnic Color normalized values.
 * Read the color index and the normalized red, green, and blue values from
 * the HiTechnic Color sensor. Returns a boolean value indicating whether or
 * not the operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param ColorIdx The output color index.
 * \param Red The normalized red color value.
 * \param Green The normalized green color value.
 * \param Blue The normalized blue color value.
 * \return The function call result.
 */
inline bool ReadSensorHTNormalizedColor(const byte port, byte & ColorIdx, byte & Red, byte & Green, byte & Blue);

/**
 * Read HiTechnic Color raw values.
 * Read the raw red, green, and blue values from the HiTechnic Color sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param Red The raw red color value.
 * \param Green The raw green color value.
 * \param Blue The raw blue color value.
 * \return The function call result.
 */
inline bool ReadSensorHTRawColor(const byte port, unsigned int & Red, unsigned int & Green, unsigned int & Blue);

/**
 * Read HiTechnic Color2 active values.
 * Read color number, red, green, and blue values from the HiTechnic Color2
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param ColorNum The output color number.
 * \param Red The red color value.
 * \param Green The green color value.
 * \param Blue The blue color value.
 * \param White The white color value.
 * \return The function call result.
 */
inline bool ReadSensorHTColor2Active(byte port, byte & ColorNum, byte & Red, byte & Green, byte & Blue, byte & White);

/**
 * Read HiTechnic Color2 normalized active values.
 * Read the color index and the normalized red, green, and blue values from
 * the HiTechnic Color2 sensor. Returns a boolean value indicating whether or
 * not the operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param ColorIdx The output color index.
 * \param Red The normalized red color value.
 * \param Green The normalized green color value.
 * \param Blue The normalized blue color value.
 * \return The function call result.
 */
inline bool ReadSensorHTNormalizedColor2Active(const byte port, byte & ColorIdx, byte & Red, byte & Green, byte & Blue);

/**
 * Read HiTechnic Color2 raw values.
 * Read the raw red, green, and blue values from the HiTechnic Color2 sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param Red The raw red color value.
 * \param Green The raw green color value.
 * \param Blue The raw blue color value.
 * \param White The raw white color value.
 * \return The function call result.
 */
inline bool ReadSensorHTRawColor2(const byte port, unsigned int & Red, unsigned int & Green, unsigned int & Blue, unsigned int & White);

/**
 * Read HiTechnic IRReceiver Power Function bytes.
 * Read Power Function bytes from the HiTechnic IRReceiver sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param pfdata Eight bytes of power function remote IR data.
 * \return The function call result.
 */
inline bool ReadSensorHTIRReceiver(const byte port, char & pfdata[]);

/**
 * Read HiTechnic IRReceiver Power Function value.
 * Read a Power Function byte from the HiTechnic IRReceiver sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param offset The power function data offset. See \ref HTIRReceiverConstants.
 * \param pfchar A single byte of power function remote IR data.
 * \return The function call result.
 */
inline bool ReadSensorHTIRReceiverEx(const byte port, const byte offset, char & pfchar);

/**
 * Read HiTechnic IRSeeker2 AC values.
 * Read direction, and five signal strength values from the HiTechnic
 * IRSeeker2 sensor in AC mode. Returns a boolean value indicating whether or
 * not the operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param dir The direction.
 * \param s1 The signal strength from sensor 1.
 * \param s3 The signal strength from sensor 3.
 * \param s5 The signal strength from sensor 5.
 * \param s7 The signal strength from sensor 7.
 * \param s9 The signal strength from sensor 9.
 * \return The function call result.
 */
inline bool ReadSensorHTIRSeeker2AC(const byte port, byte & dir, byte & s1, byte & s3, byte & s5, byte & s7, byte & s9);

/**
 * Read HiTechnic IRSeeker2 DC values.
 * Read direction, five signal strength, and average strength values from the
 * HiTechnic IRSeeker2 sensor. Returns a boolean value indicating whether or
 * not the operation completed successfully. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param dir The direction.
 * \param s1 The signal strength from sensor 1.
 * \param s3 The signal strength from sensor 3.
 * \param s5 The signal strength from sensor 5.
 * \param s7 The signal strength from sensor 7.
 * \param s9 The signal strength from sensor 9.
 * \param avg The average signal strength.
 * \return The function call result.
 */
inline bool ReadSensorHTIRSeeker2DC(const byte port, byte & dir, byte & s1, byte & s3, byte & s5, byte & s7, byte & s9, byte & avg);

/**
 * Reset HiTechnic Angle sensor.
 * Reset the HiTechnic Angle sensor on the specified
 * port. The port must be configured as a Lowspeed port before using this
 * function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param mode The Angle reset mode. See \ref HTAngleConstants.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char ResetSensorHTAngle(const byte port, const byte mode);

/**
 * Read HiTechnic Angle sensor values.
 * Read values from the HiTechnic Angle sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param Angle Current angle in degrees (0-359).
 * \param AccAngle Accumulated angle in degrees (-2147483648 to 2147483647).
 * \param RPM rotations per minute (-1000 to 1000).
 * \return The function call result.
 */
inline bool ReadSensorHTAngle(const byte port, int & Angle, long & AccAngle, int & RPM);

/**
 * Reset HiTechnic Barometric sensor calibration.
 * Reset the HiTechnic Barometric sensor to its factory calibration.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The function call result.
 */
inline bool ResetHTBarometricCalibration(byte port);

/**
 * Set HiTechnic Barometric sensor calibration.
 * Set the HiTechnic Barometric sensor pressure calibration value.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param cal The new pressure calibration value.
 * \return The function call result.
 */
inline bool SetHTBarometricCalibration(byte port, unsigned int cal);

/**
 * Read HiTechnic Barometric sensor values.
 * Read values from the HiTechnic Barometric sensor.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param temp Current temperature in 1/10ths of degrees Celcius.
 * \param press Current barometric pressure in 1/1000 inches of mercury.
 * \return The function call result.
 */
inline bool ReadSensorHTBarometric(const byte port, int & temp, unsigned int & press);

/**
 * Read HiTechnic Prototype board analog input value.
 * Read an analog input value from the HiTechnic prototype board.
 * The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param input The analog input. See \ref HTProtoAnalogInputConstants.
 * \return The analog input value.
 */
inline int SensorHTProtoAnalog(const byte port, const byte input);

/**
 * Read all HiTechnic Prototype board analog input values.
 * Read all 5 analog input values from the HiTechnic prototype board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param a0 The A0 analog input value.
 * \param a1 The A1 analog input value.
 * \param a2 The A2 analog input value.
 * \param a3 The A3 analog input value.
 * \param a4 The A4 analog input value.
 * \return The function call result.
 */
inline bool ReadSensorHTProtoAllAnalog(const byte port, int & a0, int & a1, int & a2, int & a3, int & a4);

/**
 * Control HiTechnic Prototype board digital pin direction.
 * Control the direction of the six digital pins on the HiTechnic prototype board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param value The digital pin control value. See \ref DigitalPinConstants.
 * OR into this value the pins that you want to be output pins.  The pins not
 * included in the value will be input pins.
 * \return The function call result.
 */
inline bool SetSensorHTProtoDigitalControl(const byte port, byte value);

/**
 * Read HiTechnic Prototype board digital control values.
 * Read digital control values from the HiTechnic prototype board.
 * The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The digital control values. See \ref DigitalPinConstants.
 */
inline byte SensorHTProtoDigitalControl(const byte port);

/**
 * Set HiTechnic Prototype board digital output values.
 * Set the digital pin output values on the HiTechnic prototype board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param value The digital pin output values. See \ref DigitalPinConstants.
 * \return The function call result.
 */
inline bool SetSensorHTProtoDigital(const byte port, byte value);

/**
 * Read HiTechnic Prototype board digital input values.
 * Read digital input values from the HiTechnic prototype board.
 * The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The digital input values. See \ref DigitalPinConstants.
 */
inline byte SensorHTProtoDigital(const byte port);

/**
 * Read HiTechnic SuperPro board analog input value.
 * Read an analog input value from the HiTechnic SuperPro board.
 * The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param input The analog input. See \ref HTSProAnalogInputConstants.
 * \return The analog input value.
 */
inline int SensorHTSuperProAnalog(const byte port, const byte input);

/**
 * Read all HiTechnic SuperPro board analog input values.
 * Read all 4 analog input values from the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param a0 The A0 analog input value.
 * \param a1 The A1 analog input value.
 * \param a2 The A2 analog input value.
 * \param a3 The A3 analog input value.
 * \return The function call result.
 */
inline bool ReadSensorHTSuperProAllAnalog(const byte port, int & a0, int & a1, int & a2, int & a3);

/**
 * Control HiTechnic SuperPro board digital pin direction.
 * Control the direction of the eight digital pins on the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param value The digital pin control value. See \ref DigitalPinConstants.
 * OR into this value the pins that you want to be output pins.  The pins not
 * included in the value will be input pins.
 * \return The function call result.
 */
inline bool SetSensorHTSuperProDigitalControl(const byte port, byte value);

/**
 * Read HiTechnic SuperPro board digital control values.
 * Read digital control values from the HiTechnic SuperPro board.
 * The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The digital input values. See \ref DigitalPinConstants.
 */
inline byte SensorHTSuperProDigitalControl(const byte port);

/**
 * Set HiTechnic SuperPro board digital output values.
 * Set the digital pin output values on the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param value The digital pin output values. See \ref DigitalPinConstants.
 * \return The function call result.
 */
inline bool SetSensorHTSuperProDigital(const byte port, byte value);

/**
 * Read HiTechnic SuperPro board digital input values.
 * Read digital input values from the HiTechnic SuperPro board.
 * The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The digital input values. See \ref DigitalPinConstants.
 */
inline byte SensorHTSuperProDigital(const byte port);

/**
 * Set HiTechnic SuperPro LED value.
 * Set the HiTechnic SuperPro LED value.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param value The LED value. See \ref LEDCtrlConstants.
 * \return The function call result.
 */
inline bool SetSensorHTSuperProLED(const byte port, byte value);

/**
 * Read HiTechnic SuperPro LED value.
 * Read the HiTechnic SuperPro LED value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The LED value. See \ref LEDCtrlConstants.
 */
inline byte SensorHTSuperProLED(const byte port);

/**
 * Set HiTechnic SuperPro strobe value.
 * Set the HiTechnic SuperPro strobe value.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param value The strobe value. See \ref StrobeCtrlConstants.
 * \return The function call result.
 */
inline bool SetSensorHTSuperProStrobe(const byte port, byte value);

/**
 * Read HiTechnic SuperPro strobe value.
 * Read the HiTechnic SuperPro strobe value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The strobe value. See \ref StrobeCtrlConstants.
 */
inline byte SensorHTSuperProStrobe(const byte port);

/**
 * Set HiTechnic SuperPro program control value.
 * Set the HiTechnic SuperPro program control value.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param value The program control value.
 * \return The function call result.
 */
inline bool SetSensorHTSuperProProgramControl(const byte port, byte value);

/**
 * Read HiTechnic SuperPro program control value.
 * Read the HiTechnic SuperPro program control value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The program control value.
 */
inline byte SensorHTSuperProProgramControl(const byte port);

/**
 * Set HiTechnic SuperPro board analog output parameters.
 * Set the analog output parameters on the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param dac The analog output index. See \ref HTSProDACIndexConstants.
 * \param mode The analog output mode. See \ref DacModeConstants.
 * \param freq The analog output frequency. Between 1 and 8191.
 * \param volt The analog output voltage level. A 10 bit value (0..1023).
 * \return The function call result.
 */
inline bool SetSensorHTSuperProAnalogOut(const byte port, const byte dac, byte mode, int freq, int volt);

/**
 * Read HiTechnic SuperPro board analog output parameters.
 * Read the analog output parameters on the HiTechnic SuperPro board.
 * Returns a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param dac The analog output index. See \ref HTSProDACIndexConstants.
 * \param mode The analog output mode. See \ref DacModeConstants.
 * \param freq The analog output frequency. Between 1 and 8191.
 * \param volt The analog output voltage level. A 10 bit value (0..1023).
 * \return The function call result.
 */
inline bool ReadSensorHTSuperProAnalogOut(const byte port, const byte dac, byte & mode, int & freq, int & volt);

/**
 * Read HiTechnic touch multiplexer.
 * Read touch sensor values from the HiTechnic touch multiplexer device.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param t1 The value of touch sensor 1.
 * \param t2 The value of touch sensor 2.
 * \param t3 The value of touch sensor 3.
 * \param t4 The value of touch sensor 4.
 */
inline void ReadSensorHTTouchMultiplexer(const byte port, byte & t1, byte & t2, byte & t3, byte & t4);

/**
 * HTIRTrain function.
 * Control an IR Train receiver set to the specified channel using the
 * HiTechnic iRLink device. Valid func values are \ref TRAIN_FUNC_STOP,
 * \ref TRAIN_FUNC_INCR_SPEED, \ref TRAIN_FUNC_DECR_SPEED, and \ref TRAIN_FUNC_TOGGLE_LIGHT.
 * Valid channel values are \ref TRAIN_CHANNEL_1 through \ref TRAIN_CHANNEL_3 and
 * \ref TRAIN_CHANNEL_ALL. The port must be configured as a Lowspeed port before
 * using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param channel The IR Train channel.  See \ref IRTrainChannels.
 * \param func The IR Train function. See \ref IRTrainFuncs
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTIRTrain(const byte port, const byte channel, const byte func);

/**
 * HTPFComboDirect function.
 * Execute a pair of Power Function motor commands on the specified channel
 * using the HiTechnic iRLink device. Commands for outa and outb are
 * \ref PF_CMD_STOP, \ref PF_CMD_REV, \ref PF_CMD_FWD, and \ref PF_CMD_BRAKE. Valid channels are
 * \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param outa The Power Function command for output A. See \ref PFCmdConstants.
 * \param outb The Power Function command for output B. See \ref PFCmdConstants.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTPFComboDirect(const byte port, const byte channel, const byte outa, const byte outb);

/**
 * HTPFComboPWM function.
 * Control the speed of both outputs on a Power Function receiver set to the
 * specified channel using the HiTechnic iRLink device. Valid output values
 * are \ref PF_PWM_FLOAT, \ref PF_PWM_FWD1, \ref PF_PWM_FWD2, \ref PF_PWM_FWD3, \ref PF_PWM_FWD4,
 * \ref PF_PWM_FWD5, \ref PF_PWM_FWD6, \ref PF_PWM_FWD7, \ref PF_PWM_BRAKE, \ref PF_PWM_REV7,
 * \ref PF_PWM_REV6, \ref PF_PWM_REV5, \ref PF_PWM_REV4, \ref PF_PWM_REV3, \ref PF_PWM_REV2, and
 * \ref PF_PWM_REV1. Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The
 * port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param outa The Power Function PWM command for output A. See \ref PFPWMOptions.
 * \param outb The Power Function PWM command for output B. See \ref PFPWMOptions.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTPFComboPWM(const byte port, const byte channel, const byte outa, const byte outb);

/**
 * HTPFRawOutput function.
 * Control a Power Function receiver set to the specified channel using the
 * HiTechnic iRLink device. Build the raw data stream using the 3 nibbles
 * (4 bit values). The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param nibble0 The first raw data nibble.
 * \param nibble1 The second raw data nibble.
 * \param nibble2 The third raw data nibble.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTPFRawOutput(const byte port, const byte nibble0, const byte nibble1, const byte nibble2);

/**
 * HTPFRepeat function.
 * Repeat sending the last Power Function command using the HiTechnic
 * IRLink device. Specify the number of times to repeat the command and the
 * number of milliseconds of delay between each repetition. The port must be
 * configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param count The number of times to repeat the command.
 * \param delay The number of milliseconds to delay between each repetition.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTPFRepeat(const byte port, const byte count, const unsigned int delay);

/**
 * HTPFSingleOutputCST function.
 * Control a single output on a Power Function receiver set to the specified
 * channel using the HiTechnic iRLink device. Select the desired output
 * using \ref PF_OUT_A or \ref PF_OUT_B. Valid functions are \ref PF_CST_CLEAR1_CLEAR2,
 * \ref PF_CST_SET1_CLEAR2, \ref PF_CST_CLEAR1_SET2, \ref PF_CST_SET1_SET2,
 * \ref PF_CST_INCREMENT_PWM, \ref PF_CST_DECREMENT_PWM, \ref PF_CST_FULL_FWD,
 * \ref PF_CST_FULL_REV, and \ref PF_CST_TOGGLE_DIR. Valid channels are
 * \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param out The Power Function output. See \ref PFOutputs.
 * \param func The Power Function CST function. See \ref PFCSTOptions.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTPFSingleOutputCST(const byte port, const byte channel, const byte out, const byte func);

/**
 * HTPFSingleOutputPWM function.
 * Control the speed of a single output on a Power Function receiver set to
 * the specified channel using the HiTechnic iRLink device. Select the
 * desired output using \ref PF_OUT_A or \ref PF_OUT_B. Valid functions are
 * \ref PF_PWM_FLOAT, \ref PF_PWM_FWD1, \ref PF_PWM_FWD2, \ref PF_PWM_FWD3, \ref PF_PWM_FWD4,
 * \ref PF_PWM_FWD5, \ref PF_PWM_FWD6, \ref PF_PWM_FWD7, \ref PF_PWM_BRAKE, \ref PF_PWM_REV7,
 * \ref PF_PWM_REV6, \ref PF_PWM_REV5, \ref PF_PWM_REV4, \ref PF_PWM_REV3, \ref PF_PWM_REV2, and
 * \ref PF_PWM_REV1. Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The
 * port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param out The Power Function output. See \ref PFOutputs.
 * \param func The Power Function PWM function. See \ref PFPWMOptions.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTPFSingleOutputPWM(const byte port, const byte channel, const byte out, const byte func);

/**
 * HTPFSinglePin function.
 * Control a single pin on a Power Function receiver set to the specified
 * channel using the HiTechnic iRLink device. Select the desired output
 * using \ref PF_OUT_A or \ref PF_OUT_B.  Select the desired pin using \ref PF_PIN_C1 or
 * \ref PF_PIN_C2. Valid functions are \ref PF_FUNC_NOCHANGE, \ref PF_FUNC_CLEAR,
 * \ref PF_FUNC_SET, and \ref PF_FUNC_TOGGLE. Valid channels are \ref PF_CHANNEL_1 through
 * \ref PF_CHANNEL_4. Specify whether the mode by passing true (continuous) or
 * false (timeout) as the final parameter. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param out The Power Function output. See \ref PFOutputs.
 * \param pin The Power Function pin. See \ref PFPinConstants.
 * \param func The Power Function single pin function. See \ref PFPinFuncs.
 * \param cont Control whether the mode is continuous or timeout.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTPFSinglePin(const byte port, const byte channel, const byte out, const byte pin, const byte func, bool cont);

/**
 * HTPFTrain function.
 * Control both outputs on a Power Function receiver set to the specified
 * channel using the HiTechnic iRLink device as if it were an IR Train
 * receiver. Valid function values are \ref TRAIN_FUNC_STOP, \ref TRAIN_FUNC_INCR_SPEED,
 * \ref TRAIN_FUNC_DECR_SPEED, and \ref TRAIN_FUNC_TOGGLE_LIGHT. Valid channels are
 * \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param func The Power Function train function. See \ref IRTrainFuncs.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char HTPFTrain(const byte port, const byte channel, const byte func);

/**
 * HTRCXSetIRLinkPort function.
 * Set the global port in advance of using the HTRCX* and HTScout* API
 * functions for sending RCX and Scout messages over the HiTechnic iRLink
 * device. The port must be configured as a Lowspeed port before using any of
 * the HiTechnic RCX and Scout iRLink functions.
 *
 * \param port The sensor port. See \ref InPorts.
 */
inline void HTRCXSetIRLinkPort(const byte port);

/**
 * HTRCXBatteryLevel function.
 * Send the BatteryLevel command to an RCX to read the current battery level.
 *
 * \return The RCX battery level.
 */
inline int HTRCXBatteryLevel(void);

/**
 * HTRCXPoll function
 * Send the Poll command to an RCX to read a signed 2-byte value at the
 * specified source and value combination.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 * \return The value read from the specified port and value.
 */
inline int HTRCXPoll(const byte src, const byte value);

/**
 * HTRCXPollMemory function.
 * Send the PollMemory command to an RCX.
 *
 * \param address The RCX memory address.
 * \return The value read from the specified address.
 */
inline int HTRCXPollMemory(const unsigned int address);

/**
 * HTRCXAddToDatalog function.
 * Send the AddToDatalog command to an RCX.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void HTRCXAddToDatalog(const byte src, const unsigned int value);

/**
 * HTRCXClearAllEvents function.
 * Send the ClearAllEvents command to an RCX.
 */
inline void HTRCXClearAllEvents(void);

/**
 * HTRCXClearCounter function.
 * Send the ClearCounter command to an RCX.
 *
 * \param counter The counter to clear.
 */
inline void HTRCXClearCounter(const byte counter);

/**
 * HTRCXClearMsg function.
 * Send the ClearMsg command to an RCX.
 */
inline void HTRCXClearMsg(void);

/**
 * HTRCXClearSensor function.
 * Send the ClearSensor command to an RCX.
 *
 * \param port The RCX port number.
 */
inline void HTRCXClearSensor(const byte port);

/**
 * HTRCXClearSound function.
 * Send the ClearSound command to an RCX.
 */
inline void HTRCXClearSound(void);

/**
 * HTRCXClearTimer function.
 * Send the ClearTimer command to an RCX.
 *
 * \param timer The timer to clear.
 */
inline void HTRCXClearTimer(const byte timer);

/**
 * HTRCXCreateDatalog function.
 * Send the CreateDatalog command to an RCX.
 *
 * \param size The new datalog size.
 */
inline void HTRCXCreateDatalog(const unsigned int size);

/**
 * HTRCXDecCounter function.
 * Send the DecCounter command to an RCX.
 *
 * \param counter The counter to decrement.
 */
inline void HTRCXDecCounter(const byte counter);

/**
 * HTRCXDeleteSub function.
 * Send the DeleteSub command to an RCX.
 *
 * \param s The subroutine number to delete.
 */
inline void HTRCXDeleteSub(const byte s);

/**
 * HTRCXDeleteSubs function.
 * Send the DeleteSubs command to an RCX.
 */
inline void HTRCXDeleteSubs(void);

/**
 * HTRCXDeleteTask function.
 * Send the DeleteTask command to an RCX.
 *
 * \param t The task number to delete.
 */
inline void HTRCXDeleteTask(const byte t);

/**
 * HTRCXDeleteTasks function.
 * Send the DeleteTasks command to an RCX.
 */
inline void HTRCXDeleteTasks(void);

/**
 * HTRCXDisableOutput function.
 * Send the DisableOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to disable. See \ref RCXOutputConstants.
 */
inline void HTRCXDisableOutput(const byte outputs);

/**
 * HTRCXEnableOutput function.
 * Send the EnableOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to enable. See \ref RCXOutputConstants.
 */
inline void HTRCXEnableOutput(const byte outputs);

/**
 * HTRCXEvent function.
 * Send the Event command to an RCX.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void HTRCXEvent(const byte src, const unsigned int value);

/**
 * HTRCXFloat function.
 * Send commands to an RCX to float the specified outputs.
 *
 * \param outputs The RCX output(s) to float. See \ref RCXOutputConstants.
 */
inline void HTRCXFloat(const byte outputs);

/**
 * HTRCXFwd function.
 * Send commands to an RCX to set the specified outputs to the forward direction.
 *
 * \param outputs The RCX output(s) to set forward. See \ref RCXOutputConstants.
 */
inline void HTRCXFwd(const byte outputs);

/**
 * HTRCXIncCounter function.
 * Send the IncCounter command to an RCX.
 *
 * \param counter The counter to increment.
 */
inline void HTRCXIncCounter(const byte counter);

/**
 * HTRCXInvertOutput function.
 * Send the InvertOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to invert. See \ref RCXOutputConstants.
 */
inline void HTRCXInvertOutput(const byte outputs);

/**
 * HTRCXMuteSound function.
 * Send the MuteSound command to an RCX.
 */
inline void HTRCXMuteSound(void);

/**
 * HTRCXObvertOutput function.
 * Send the ObvertOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to obvert. See \ref RCXOutputConstants.
 */
inline void HTRCXObvertOutput(const byte outputs);

/**
 * HTRCXOff function.
 * Send commands to an RCX to turn off the specified outputs.
 *
 * \param outputs The RCX output(s) to turn off. See \ref RCXOutputConstants.
 */
inline void HTRCXOff(const byte outputs);

/**
 * HTRCXOn function.
 * Send commands to an RCX to turn on the specified outputs.
 *
 * \param outputs The RCX output(s) to turn on. See \ref RCXOutputConstants.
 */
inline void HTRCXOn(const byte outputs);

/**
 * HTRCXOnFor function.
 * Send commands to an RCX to turn on the specified outputs in the forward
 * direction for the specified duration.
 *
 * \param outputs The RCX output(s) to turn on. See \ref RCXOutputConstants.
 * \param ms The number of milliseconds to leave the outputs on
 */
inline void HTRCXOnFor(const byte outputs, const unsigned int ms);

/**
 * HTRCXOnFwd function.
 * Send commands to an RCX to turn on the specified outputs in the forward
 * direction.
 *
 * \param outputs The RCX output(s) to turn on in the forward direction. See \ref RCXOutputConstants.
 */
inline void HTRCXOnFwd(const byte outputs);

/**
 * HTRCXOnRev function.
 * Send commands to an RCX to turn on the specified outputs in the reverse direction.
 *
 * \param outputs The RCX output(s) to turn on in the reverse direction. See \ref RCXOutputConstants.
 */
inline void HTRCXOnRev(const byte outputs);

/**
 * HTRCXPBTurnOff function.
 * Send the PBTurnOff command to an RCX.
 */
inline void HTRCXPBTurnOff(void);

/**
 * HTRCXPing function.
 * Send the Ping command to an RCX.
 */
inline void HTRCXPing(void);

/**
 * HTRCXPlaySound function.
 * Send the PlaySound command to an RCX.
 *
 * \param snd The sound number to play.
 */
inline void HTRCXPlaySound(const byte snd);

/**
 * HTRCXPlayTone function.
 * Send the PlayTone command to an RCX.
 *
 * \param freq The frequency of the tone to play.
 * \param duration The duration of the tone to play.
 */
inline void HTRCXPlayTone(const unsigned int freq, const byte duration);

/**
 * HTRCXPlayToneVar function.
 * Send the PlayToneVar command to an RCX.
 *
 * \param varnum The variable containing the tone frequency to play.
 * \param duration The duration of the tone to play.
 */
inline void HTRCXPlayToneVar(const byte varnum, const byte duration);

/**
 * HTRCXRemote function.
 * Send the Remote command to an RCX.
 *
 * \param cmd The RCX IR remote command to send. See \ref RCXRemoteConstants.
 */
inline void HTRCXRemote(unsigned int cmd);

/**
 * HTRCXRev function.
 * Send commands to an RCX to set the specified outputs to the reverse direction.
 *
 * \param outputs The RCX output(s) to reverse direction. See \ref RCXOutputConstants.
 */
inline void HTRCXRev(const byte outputs);

/**
 * HTRCXSelectDisplay function.
 * Send the SelectDisplay command to an RCX.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void HTRCXSelectDisplay(const byte src, const unsigned int value);

/**
 * HTRCXSelectProgram function.
 * Send the SelectProgram command to an RCX.
 *
 * \param prog The program number to select.
 */
inline void HTRCXSelectProgram(const byte prog);

/**
 * HTRCXSendSerial function.
 * Send the SendSerial command to an RCX.
 *
 * \param first The first byte address.
 * \param count The number of bytes to send.
 */
inline void HTRCXSendSerial(const byte first, const byte count);

/**
 * HTRCXSetDirection function.
 * Send the SetDirection command to an RCX to configure the direction of the specified outputs.
 *
 * \param outputs The RCX output(s) to set direction. See \ref RCXOutputConstants.
 * \param dir The RCX output direction. See \ref RCXOutputDirection.
 */
inline void HTRCXSetDirection(const byte outputs, const byte dir);

/**
 * HTRCXSetEvent function.
 * Send the SetEvent command to an RCX.
 *
 * \param evt The event number to set.
 * \param src The RCX source. See \ref RCXSourceConstants.
 * \param type The event type.
 */
inline void HTRCXSetEvent(const byte evt, const byte src, const byte type);

/**
 * HTRCXSetGlobalDirection function.
 * Send the SetGlobalDirection command to an RCX.
 *
 * \param outputs The RCX output(s) to set global direction. See \ref RCXOutputConstants.
 * \param dir The RCX output direction. See \ref RCXOutputDirection.
 */
inline void HTRCXSetGlobalDirection(const byte outputs, const byte dir);

/**
 * HTRCXSetGlobalOutput function.
 * Send the SetGlobalOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to set global mode. See \ref RCXOutputConstants.
 * \param mode The RCX output mode. See \ref RCXOutputMode.
 */
inline void HTRCXSetGlobalOutput(const byte outputs, const byte mode);

/**
 * HTRCXSetMaxPower function.
 * Send the SetMaxPower command to an RCX.
 *
 * \param outputs The RCX output(s) to set max power. See \ref RCXOutputConstants.
 * \param pwrsrc The RCX source.  See \ref RCXSourceConstants.
 * \param pwrval The RCX value.
 */
inline void HTRCXSetMaxPower(const byte outputs, const byte pwrsrc, const byte pwrval);

/**
 * HTRCXSetMessage function.
 * Send the SetMessage command to an RCX.
 *
 * \param msg The numeric message to send.
 */
inline void HTRCXSetMessage(const byte msg);

/**
 * HTRCXSetOutput function.
 * Send the SetOutput command to an RCX to configure the mode of the specified outputs
 *
 * \param outputs The RCX output(s) to set mode. See \ref RCXOutputConstants.
 * \param mode The RCX output mode. See \ref RCXOutputMode.
 */
inline void HTRCXSetOutput(const byte outputs, const byte mode);

/**
 * HTRCXSetPower function.
 * Send the SetPower command to an RCX to configure the power level of the specified outputs.
 *
 * \param outputs The RCX output(s) to set power. See \ref RCXOutputConstants.
 * \param pwrsrc The RCX source.  See \ref RCXSourceConstants.
 * \param pwrval The RCX value.
 */
inline void HTRCXSetPower(const byte outputs, const byte pwrsrc, const byte pwrval);

/**
 * HTRCXSetPriority function.
 * Send the SetPriority command to an RCX.
 *
 * \param p The new task priority.
 */
inline void HTRCXSetPriority(const byte p);

/**
 * HTRCXSetSensorMode function.
 * Send the SetSensorMode command to an RCX.
 *
 * \param port The RCX sensor port.
 * \param mode The RCX sensor mode.
 */
inline void HTRCXSetSensorMode(const byte port, const byte mode);

/**
 * HTRCXSetSensorType function.
 * Send the SetSensorType command to an RCX.
 *
 * \param port The RCX sensor port.
 * \param type The RCX sensor type.
 */
inline void HTRCXSetSensorType(const byte port, const byte type);

/**
 * HTRCXSetSleepTime function.
 * Send the SetSleepTime command to an RCX.
 *
 * \param t The new sleep time value.
 */
inline void HTRCXSetSleepTime(const byte t);

/**
 * HTRCXSetTxPower function.
 * Send the SetTxPower command to an RCX.
 *
 * \param pwr The IR transmit power level.
 */
inline void HTRCXSetTxPower(const byte pwr);

/**
 * HTRCXSetWatch function.
 * Send the SetWatch command to an RCX.
 *
 * \param hours The new watch time hours value.
 * \param minutes The new watch time minutes value.
 */
inline void HTRCXSetWatch(const byte hours, const byte minutes);

/**
 * HTRCXStartTask function.
 * Send the StartTask command to an RCX.
 *
 * \param t The task number to start.
 */
inline void HTRCXStartTask(const byte t);

/**
 * HTRCXStopAllTasks function.
 * Send the StopAllTasks command to an RCX.
 */
inline void HTRCXStopAllTasks(void);

/**
 * HTRCXStopTask function.
 * Send the StopTask command to an RCX.
 *
 * \param t The task number to stop.
 */
inline void HTRCXStopTask(const byte t);

/**
 * HTRCXToggle function.
 * Send commands to an RCX to toggle the direction of the specified outputs.
 *
 * \param outputs The RCX output(s) to toggle. See \ref RCXOutputConstants.
 */
inline void HTRCXToggle(const byte outputs);

/**
 * HTRCXUnmuteSound function.
 * Send the UnmuteSound command to an RCX.
 */
inline void HTRCXUnmuteSound(void);

/**
 * HTScoutCalibrateSensor function.
 * Send the CalibrateSensor command to a Scout.
 */
inline void HTScoutCalibrateSensor(void);

/**
 * HTScoutMuteSound function.
 * Send the MuteSound command to a Scout.
 */
inline void HTScoutMuteSound(void);

/**
 * HTScoutSelectSounds function.
 * Send the SelectSounds command to a Scout.
 *
 * \param grp The Scout sound group to select.
 */
inline void HTScoutSelectSounds(const byte grp);

/**
 * HTScoutSendVLL function.
 * Send the SendVLL command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void HTScoutSendVLL(const byte src, const unsigned int value);

/**
 * HTScoutSetEventFeedback function.
 * Send the SetEventFeedback command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void HTScoutSetEventFeedback(const byte src, const unsigned int value);

/**
 * HTScoutSetLight function.
 * Send the SetLight command to a Scout.
 *
 * \param x Set the light on or off using this value. See \ref ScoutLightConstants.
 */
inline void HTScoutSetLight(const byte x);

/**
 * HTScoutSetScoutMode function.
 * Send the SetScoutMode command to a Scout.
 *
 * \param mode Set the scout mode. See \ref ScoutModeConstants.
*/
inline void HTScoutSetScoutMode(const byte mode);

/**
 * HTScoutSetSensorClickTime function.
 * Send the SetSensorClickTime command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void HTScoutSetSensorClickTime(const byte src, const unsigned int value);

/**
 * HTScoutSetSensorHysteresis function.
 * Send the SetSensorHysteresis command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void HTScoutSetSensorHysteresis(const byte src, const unsigned int value);

/**
 * HTScoutSetSensorLowerLimit function.
 * Send the SetSensorLowerLimit command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void HTScoutSetSensorLowerLimit(const byte src, const unsigned int value);

/**
 * HTScoutSetSensorUpperLimit function.
 * Send the SetSensorUpperLimit command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void HTScoutSetSensorUpperLimit(const byte src, const unsigned int value);

/**
 * HTScoutUnmuteSound function.
 * Send the UnmuteSound command to a Scout.
 */
inline void HTScoutUnmuteSound(void);

#else

#define SensorHTCompass(_port) asm { __ReadSensorHTCompass(_port, __RETVAL__) }
#define ReadSensorHTAccel(_port, _x, _y, _z) asm { __ReadSensorHTAccel(_port, _x, _y, _z, __RETVAL__) }
#define ReadSensorHTColor(_port, _ColorNum, _Red, _Green, _Blue) asm { __ReadSensorHTColor(_port, _ColorNum, _Red, _Green, _Blue, __RETVAL__) }
#define ReadSensorHTRawColor(_port, _Red, _Green, _Blue) asm { __ReadSensorHTRawColor(_port, _Red, _Green, _Blue, __RETVAL__) }
#define ReadSensorHTNormalizedColor(_port, _ColorIdx, _Red, _Green, _Blue) asm { __ReadSensorHTNormalizedColor(_port, _ColorIdx, _Red, _Green, _Blue, __RETVAL__) }
#define ReadSensorHTIRSeeker(_port, _dir, _s1, _s3, _s5, _s7, _s9) asm { __ReadSensorHTIRSeeker(_port, _dir, _s1, _s3, _s5, _s7, _s9, __RETVAL__) }
#define SensorHTIRSeekerDir(_port) asm { __ReadSensorHTIRSeekerDir(_port, __RETVAL__) }
#define SensorHTColorNum(_port) asm { __ReadSensorHTColorNum(_port, __RETVAL__) }
#define ReadSensorHTTouchMultiplexer(_p, _t1, _t2, _t3, _t4) asm { __ReadSensorHTTouchMultiplexer(_p, _t1, _t2, _t3, _t4) }
#define SensorHTIRSeeker2Addr(_port, _reg) asm { __ReadSensorHTIRSeeker2Addr(_port, _reg, __RETVAL__) }
#define SensorHTIRSeeker2DCDir(_port) asm { __ReadSensorHTIRSeeker2Addr(_port, HTIR2_REG_DCDIR, __RETVAL__) }
#define SensorHTIRSeeker2ACDir(_port) asm { __ReadSensorHTIRSeeker2Addr(_port, HTIR2_REG_ACDIR, __RETVAL__) }
#define ReadSensorHTIRSeeker2DC(_port, _dir, _s1, _s3, _s5, _s7, _s9, _avg) asm { __ReadSensorHTIRSeeker2DC(_port, _dir, _s1, _s3, _s5, _s7, _s9, _avg, __RETVAL__) }
#define ReadSensorHTIRSeeker2AC(_port, _dir, _s1, _s3, _s5, _s7, _s9) asm { __ReadSensorHTIRSeeker2AC(_port, _dir, _s1, _s3, _s5, _s7, _s9, __RETVAL__) }
#define SetHTIRSeeker2Mode(_port, _mode) asm { __SetHTIRSeeker2Mode(_port, _mode, __RETVAL__) }

#define SetHTColor2Mode(_port, _mode) asm { __SetHTColor2Mode(_port, _mode, __RETVAL__) }
#define ReadSensorHTColor2Active(_port, _ColorNum, _Red, _Green, _Blue, _White) asm { __ReadSensorHTColor2Active(_port, _ColorNum, _Red, _Green, _Blue, _White, __RETVAL__) }
#define ReadSensorHTNormalizedColor2Active(_port, _ColorIdx, _Red, _Green, _Blue) asm { __ReadSensorHTNormalizedColor2Active(_port, _ColorIdx, _Red, _Green, _Blue, __RETVAL__) }
#define ReadSensorHTRawColor2(_port, _Red, _Green, _Blue, _White) asm { __ReadSensorHTRawColor2(_port, _Red, _Green, _Blue, _White, __RETVAL__) }
#define ReadSensorHTIRReceiver(_port, _pfdata) asm { __ReadSensorHTIRReceiver(_port, _pfdata, __RETVAL__) }
#define ReadSensorHTIRReceiverEx(_port, _reg, _pfchar) asm { __ReadSensorHTIRReceiverEx(_port, _reg, _pfchar, __RETVAL__) }
#define ResetSensorHTAngle(_port, _mode) asm { __ResetSensorHTAngle(_port, _mode, __RETVAL__) }
#define ReadSensorHTAngle(_port, _Angle, _AccAngle, _RPM) asm { __ReadSensorHTAngle(_port, _Angle, _AccAngle, _RPM, __RETVAL__) }
#define ReadSensorHTBarometric(_port, _temp, _press) asm { __ReadSensorHTBarometric(_port, _temp, _press, __RETVAL__) }
#define ResetHTBarometricCalibration(_port) asm { __ResetHTBarometricCalibration(_port, __RETVAL__) }
#define SetHTBarometricCalibration(_port, _cal) asm { __SetHTBarometricCalibration(_port, _cal, __RETVAL__) }

#define SensorHTProtoAnalog(_port, _input) asm { __ReadSensorHTProtoAnalog(_port, HT_ADDR_PROTOBOARD, _input, __RETVAL__, __TMPBYTE__) }
#define ReadSensorHTProtoAllAnalog(_port, _a0, _a1, _a2, _a3, _a4) asm { __ReadSensorHTProtoAllAnalog(_port, _a0, _a1, _a2, _a3, _a4, __RETVAL__) }
#define SetSensorHTProtoDigitalControl(_port, _value) asm { __SetSensorHTProtoDigitalControl(_port, HT_ADDR_PROTOBOARD, _value, __RETVAL__) }
#define SensorHTProtoDigitalControl(_port) asm { __MSReadValue(_port, HT_ADDR_PROTOBOARD, HTPROTO_REG_DCTRL, 1, __RETVAL__, __TMPBYTE__) }
#define SetSensorHTProtoDigital(_port, _value) asm { __SetSensorHTProtoDigital(_port, HT_ADDR_PROTOBOARD, _value, __RETVAL__) }
#define SensorHTProtoDigital(_port) asm { __ReadSensorHTProtoDigital(_port, HT_ADDR_PROTOBOARD, __RETVAL__, __TMPBYTE__) }

#define SensorHTSuperProAnalog(_port, _input) asm { __ReadSensorHTProtoAnalog(_port, HT_ADDR_SUPERPRO, _input, __RETVAL__, __TMPBYTE__) }
#define ReadSensorHTSuperProAllAnalog(_port, _a0, _a1, _a2, _a3) asm { __ReadSensorHTSuperProAllAnalog(_port, _a0, _a1, _a2, _a3, __RETVAL__) }
#define SetSensorHTSuperProDigitalControl(_port, _value) asm { __SetSensorHTProtoDigitalControl(_port, HT_ADDR_SUPERPRO, _value, __RETVAL__) }
#define SensorHTSuperProDigitalControl(_port) asm { __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_DCTRL, 1, __RETVAL__, __TMPBYTE__) }
#define SetSensorHTSuperProDigital(_port, _value) asm { __SetSensorHTProtoDigital(_port, HT_ADDR_SUPERPRO, _value, __RETVAL__) }
#define SensorHTSuperProDigital(_port) asm { __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_DIN, 1, __RETVAL__, __TMPBYTE__) }
#define SetSensorHTSuperProLED(_port, _value) asm { __SetSensorHTSuperProLED(_port, _value, __RETVAL__) }
#define SensorHTSuperProLED(_port) asm { __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_LED, 1, __RETVAL__, __TMPBYTE__) }
#define SetSensorHTSuperProStrobe(_port, _value) asm { __SetSensorHTSuperProStrobe(_port, _value, __RETVAL__) }
#define SensorHTSuperProStrobe(_port) asm { __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_STROBE, 1, __RETVAL__, __TMPBYTE__) }
#define SetSensorHTSuperProProgramControl(_port, _value) asm { __SetSensorHTSuperProProgramControl(_port, _value, __RETVAL__) }
#define SensorHTSuperProProgramControl(_port) asm { __MSReadValue(_port, HT_ADDR_SUPERPRO, HTSPRO_REG_CTRL, 1, __RETVAL__, __TMPBYTE__) }
#define SetSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt) asm { __SetSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt, __RETVAL__) }
#define ReadSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt) asm { __ReadSensorHTSuperProAnalogOut(_port, _dac, _mode, _freq, _volt, __RETVAL__) }

#define HTPowerFunctionCommand(_port, _channel, _outa, _outb) asm { __HTPFComboDirect(_port, _channel, _outa, _outb, __RETVAL__) }
#define HTPFComboDirect(_port, _channel, _outa, _outb) asm { __HTPFComboDirect(_port, _channel, _outa, _outb, __RETVAL__) }
#define HTPFSinglePin(_port, _channel, _out, _pin, _func, _cont) asm { __HTPFSinglePin(_port, _channel, _out, _pin, _func, _cont, __RETVAL__) }
#define HTPFSingleOutputCST(_port, _channel, _out, _func) asm { __HTPFSingleOutput(_port, _channel, _out, _func, TRUE, __RETVAL__) }
#define HTPFSingleOutputPWM(_port, _channel, _out, _func) asm { __HTPFSingleOutput(_port, _channel, _out, _func, FALSE, __RETVAL__) }
#define HTPFComboPWM(_port, _channel, _outa, _outb) asm { __HTPFComboPWM(_port, _channel, _outa, _outb, __RETVAL__) }
#define HTPFTrain(_port, _channel, _func) asm { __HTIRTrain(_port, _channel, _func, TRUE, __RETVAL__) }
#define HTIRTrain(_port, _channel, _func) asm { __HTIRTrain(_port, _channel, _func, FALSE, __RETVAL__) }
#define HTPFRawOutput(_port, _nibble0, _nibble1, _nibble2) asm { __HTPFRawOutput(_port, _nibble0, _nibble1, _nibble2, __RETVAL__) }
#define HTPFRepeat(_port, _count, _delay) asm { __HTPFRepeatLastCommand(_port, _count, _delay, __RETVAL__) }

#define HTRCXSetIRLinkPort(_port) asm { __HTRCXSetIRLinkPort(_port) }
#define HTRCXPoll(_src, _value) asm { __HTRCXPoll(_src, _value, __RETVAL__) }
#define HTRCXBatteryLevel() asm { __HTRCXBatteryLevel(__RETVAL__) }
#define HTRCXPing() asm { __HTRCXOpNoArgs(RCX_PingOp) }
#define HTRCXDeleteTasks() asm { __HTRCXOpNoArgs(RCX_DeleteTasksOp) }
#define HTRCXStopAllTasks() asm { __HTRCXOpNoArgs(RCX_StopAllTasksOp) }
#define HTRCXPBTurnOff() asm { __HTRCXOpNoArgs(RCX_PBTurnOffOp) }
#define HTRCXDeleteSubs() asm { __HTRCXOpNoArgs(RCX_DeleteSubsOp) }
#define HTRCXClearSound() asm { __HTRCXOpNoArgs(RCX_ClearSoundOp) }
#define HTRCXClearMsg() asm { __HTRCXOpNoArgs(RCX_ClearMsgOp) }
#define HTRCXMuteSound() asm { __HTRCXOpNoArgs(RCX_MuteSoundOp) }
#define HTRCXUnmuteSound() asm { __HTRCXOpNoArgs(RCX_UnmuteSoundOp) }
#define HTRCXClearAllEvents() asm { __HTRCXOpNoArgs(RCX_ClearAllEventsOp) }
#define HTRCXSetOutput(_outputs, _mode) asm { __HTRCXSetOutput(_outputs, _mode) }
#define HTRCXSetDirection(_outputs, _dir) asm { __HTRCXSetDirection(_outputs, _dir) }
#define HTRCXSetPower(_outputs, _pwrsrc, _pwrval) asm { __HTRCXSetPower(_outputs, _pwrsrc, _pwrval) }
#define HTRCXOn(_outputs) asm { __HTRCXSetOutput(_outputs, RCX_OUT_ON) }
#define HTRCXOff(_outputs) asm { __HTRCXSetOutput(_outputs, RCX_OUT_OFF) }
#define HTRCXFloat(_outputs) asm { __HTRCXSetOutput(_outputs, RCX_OUT_FLOAT) }
#define HTRCXToggle(_outputs) asm { __HTRCXSetDirection(_outputs, RCX_OUT_TOGGLE) }
#define HTRCXFwd(_outputs) asm { __HTRCXSetDirection(_outputs, RCX_OUT_FWD) }
#define HTRCXRev(_outputs) asm { __HTRCXSetDirection(_outputs, RCX_OUT_REV) }
#define HTRCXOnFwd(_outputs) asm { __HTRCXOnFwd(_outputs) }
#define HTRCXOnRev(_outputs) asm { __HTRCXOnRev(_outputs) }
#define HTRCXOnFor(_outputs, _ms) asm { __HTRCXOnFor(_outputs, _ms) }
#define HTRCXSetTxPower(_pwr) asm { __HTRCXSetTxPower(_pwr) }
#define HTRCXPlaySound(_snd) asm { __HTRCXPlaySound(_snd) }
#define HTRCXDeleteTask(_t) asm { __HTRCXDeleteTask(_t) }
#define HTRCXStartTask(_t) asm { __HTRCXStartTask(_t) }
#define HTRCXStopTask(_t) asm { __HTRCXStopTask(_t) }
#define HTRCXSelectProgram(_prog) asm { __HTRCXSelectProgram(_prog) }
#define HTRCXClearTimer(_timer) asm { __HTRCXClearTimer(_timer) }
#define HTRCXSetSleepTime(_t) asm { __HTRCXSetSleepTime(_t) }
#define HTRCXDeleteSub(_s) asm { __HTRCXDeleteSub(_s) }
#define HTRCXClearSensor(_port) asm { __HTRCXClearSensor(_port) }
#define HTRCXPlayToneVar(_varnum, _duration) asm { __HTRCXPlayToneVar(_varnum, _duration) }
#define HTRCXSetWatch(_hours, _minutes) asm { __HTRCXSetWatch(_hours, _minutes) }
#define HTRCXSetSensorType(_port, _type) asm { __HTRCXSetSensorType(_port, _type) }
#define HTRCXSetSensorMode(_port, _mode) asm { __HTRCXSetSensorMode(_port, _mode) }
#define HTRCXCreateDatalog(_size) asm { __HTRCXCreateDatalog(_size) }
#define HTRCXAddToDatalog(_src, _value) asm { __HTRCXAddToDatalog(_src, _value) }
#define HTRCXSendSerial(_first, _count) asm { __HTRCXSendSerial(_first, _count) }
#define HTRCXRemote(_cmd) asm { __HTRCXRemote(_cmd) }
#define HTRCXEvent(_src, _value) asm { __HTRCXEvent(_src, _value) }
#define HTRCXPlayTone(_freq, _duration) asm { __HTRCXPlayTone(_freq, _duration) }
#define HTRCXSelectDisplay(_src, _value) asm { __HTRCXSelectDisplay(_src, _value) }
#define HTRCXPollMemory(_memaddress) asm { __HTRCXPollMemory(_memaddress, __RETVAL__) }
#define HTRCXSetEvent(_evt, _src, _type) asm { __HTRCXSetEvent(_evt, _src, _type) }
#define HTRCXSetGlobalOutput(_outputs, _mode) asm { __HTRCXSetGlobalOutput(_outputs, _mode) }
#define HTRCXSetGlobalDirection(_outputs, _dir) asm { __HTRCXSetGlobalDirection(_outputs, _dir) }
#define HTRCXSetMaxPower(_outputs, _pwrsrc, _pwrval) asm { __HTRCXSetMaxPower(_outputs, _pwrsrc, _pwrval) }
#define HTRCXEnableOutput(_outputs) asm { __HTRCXSetGlobalOutput(_outputs, RCX_OUT_ON) }
#define HTRCXDisableOutput(_outputs) asm { __HTRCXSetGlobalOutput(_outputs, RCX_OUT_OFF) }
#define HTRCXInvertOutput(_outputs) asm { __HTRCXSetGlobalDirection(_outputs, RCX_OUT_REV) }
#define HTRCXObvertOutput(_outputs) asm { __HTRCXSetGlobalDirection(_outputs, RCX_OUT_FWD) }
#define HTRCXIncCounter(_counter) asm { __HTRCXIncCounter(_counter) }
#define HTRCXDecCounter(_counter) asm { __HTRCXDecCounter(_counter) }
#define HTRCXClearCounter(_counter) asm { __HTRCXClearCounter(_counter) }
#define HTRCXSetPriority(_p) asm { __HTRCXSetPriority(_p) }
#define HTRCXSetMessage(_msg) asm { __HTRCXSetMessage(_msg) }

#define HTScoutCalibrateSensor() asm { __HTRCXOpNoArgs(RCX_LSCalibrateOp) }
#define HTScoutMuteSound() asm { __HTScoutMuteSound() }
#define HTScoutUnmuteSound() asm { __HTScoutUnmuteSound() }
#define HTScoutSelectSounds(_grp) asm { __HTScoutSelectSounds(_grp) }
#define HTScoutSetLight(_x) asm { __HTScoutSetLight(_x) }
#define HTScoutSetSensorClickTime(_src, _value) asm { __HTScoutSetSensorClickTime(_src, _value) }
#define HTScoutSetSensorHysteresis(_src, _value) asm { __HTScoutSetSensorHysteresis(_src, _value) }
#define HTScoutSetSensorLowerLimit(_src, _value) asm { __HTScoutSetSensorLowerLimit(_src, _value) }
#define HTScoutSetSensorUpperLimit(_src, _value) asm { __HTScoutSetSensorUpperLimit(_src, _value) }
#define HTScoutSetEventFeedback(_src, _value) asm { __HTScoutSetEventFeedback(_src, _value) }
#define HTScoutSendVLL(_src, _value) asm { __HTScoutSendVLL(_src, _value) }
#define HTScoutSetScoutMode(_mode) asm { __HTScoutSetScoutMode(_mode) }

#endif
/** @} */ // end of HiTechnicAPI group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MindSensors API ///////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup MindSensorsAPI
 * @{
 */

/**
 * Configure a mindsensors pressure sensor.
 * Configure the specified port for a mindsensors pressure sensor.
 *
 * \param port The port to configure. See \ref InPorts.
 */
inline void SetSensorMSPressure(const byte & port ) {
  SetSensorType(port, SENSOR_TYPE_LIGHT);
  SetSensorMode(port, SENSOR_MODE_RAW);
  ResetSensor(port);
}

/**
 * Configure a mindsensors DROD sensor.
 * Configure the specified port for a mindsensors DROD sensor.
 *
 * \param port The port to configure. See \ref InPorts.
 * \param bActive A flag indicating whether to configure the sensor in active
 * or inactive mode.
 */
inline void SetSensorMSDROD(const byte & port, bool bActive) {
  if (bActive)
    SetSensorType(port, SENSOR_TYPE_LIGHT_ACTIVE);
  else
    SetSensorType(port, SENSOR_TYPE_LIGHT_INACTIVE);
  SetSensorMode(port, SENSOR_MODE_PERCENT);
  ResetSensor(port);
}


/**
 * Configure a mindsensors SumoEyes sensor.
 * Configure the specified port for a mindsensors SumoEyes sensor.
 *
 * \param port The port to configure. See \ref InPorts.
 * \param bLong A flag indicating whether to configure the sensor in long range
 * or short range mode.
 */
inline void SetSensorNXTSumoEyes(const byte & port, bool bLong) {
  if (bLong)
    SetSensorType(port, SENSOR_TYPE_LIGHT_INACTIVE);
  else
    SetSensorType(port, SENSOR_TYPE_LIGHT_ACTIVE);
  SetSensorMode(port, SENSOR_MODE_PERCENT);
  ResetSensor(port);
  Wait(275);
}

/**
 * Read mindsensors pressure sensor.
 * Read the pressure sensor value of the mindsensors pressure sensor on the
 * specified port.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The pressure reading.
 */
inline int SensorMSPressure(const byte & port) {
  asm {
    getin __RETVAL__, port, RawValueField
    sub __RETVAL__, 1024, __RETVAL__
    div __RETVAL__, __RETVAL__, 25
  }
}

/**
 * Read mindsensors NXTSumoEyes obstacle zone.
 * Return the Mindsensors NXTSumoEyes sensor obstacle zone value.  The port
 * should be configured for the NXTSumoEyes device using \ref SetSensorNXTSumoEyes
 * before calling this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The mindsensors NXTSumoEyes obstacle zone value.  See \ref NXTSumoEyesConstants.
 */
char SensorNXTSumoEyes(const byte & port) {
  int value;
  asm {
    getin value, port, NormalizedValueField
    mul value, value, 100
    div value, value, 1023
  }
  if (value > 30 && value < 36)
    return NXTSE_ZONE_LEFT;
  if (value > 63 && value < 69)
    return NXTSE_ZONE_RIGHT;
  if (value > 74 && value <= 80)
    return NXTSE_ZONE_FRONT;
  return NXTSE_ZONE_NONE;
}

#ifdef __DOXYGEN_DOCS

/**
 * Read mindsensors compass value.
 * Return the Mindsensors Compass sensor value.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The mindsensors compass value
 */
inline int SensorMSCompass(const byte & port, const byte i2caddr);

/**
 * Read mindsensors DROD value.
 * Return the Mindsensors DROD sensor value.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The mindsensors DROD value
 */
inline int SensorMSDROD(const byte & port);

/**
 * Read mindsensors NXTSumoEyes raw value.
 * Return the Mindsensors NXTSumoEyes raw sensor value. The port
 * should be configured for the NXTSumoEyes device using \ref SetSensorNXTSumoEyes
 * before calling this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The mindsensors NXTSumoEyes raw value
 */
inline int SensorNXTSumoEyesRaw(const byte & port);

/**
 * Read mindsensors raw pressure value.
 * Return the Mindsensors pressure sensor raw value.
 *
 * \param port The sensor port. See \ref InPorts.
 * \return The mindsensors raw pressure value
 */
inline int SensorMSPressureRaw(const byte & port);

/**
 * Read mindsensors acceleration values.
 * Read X, Y, and Z axis acceleration values from the mindsensors Accelerometer
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param x The output x-axis acceleration.
 * \param y The output y-axis acceleration.
 * \param z The output z-axis acceleration.
 * \return The function call result.
 */
inline bool ReadSensorMSAccel(const byte port, const byte i2caddr, int & x, int & y, int & z);

/**
 * Read mindsensors playstation controller values.
 * Read playstation controller values from the mindsensors playstation
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param btnset1 The button set 1 values. See \ref MSPSPNXBtnSet1.
 * \param btnset2 The button set 2 values. See \ref MSPSPNXBtnSet2.
 * \param xleft The left joystick x value.
 * \param yleft The left joystick y value.
 * \param xright The right joystick x value.
 * \param yright The right joystick y value.
 * \return The function call result.
 */
inline bool ReadSensorMSPlayStation(const byte port, const byte i2caddr, byte & btnset1, byte & btnset2, byte & xleft, byte & yleft, byte & xright, byte & yright);

/**
 * Read mindsensors RTClock values.
 * Read real-time clock values from the Mindsensors RTClock sensor. Returns
 * a boolean value indicating whether or not the operation completed
 * successfully. The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param sec The seconds.
 * \param min The minutes.
 * \param hrs The hours.
 * \param dow The day of week number.
 * \param date The day.
 * \param month The month.
 * \param year The year.
 * \return The function call result.
 */
inline bool ReadSensorMSRTClock(const byte port, byte & sec, byte & min, byte & hrs, byte & dow, byte & date, byte & month, byte & year);

/**
 * Read mindsensors tilt values.
 * Read X, Y, and Z axis tilt values from the mindsensors tilt
 * sensor. Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param x The output x-axis tilt.
 * \param y The output y-axis tilt.
 * \param z The output z-axis tilt.
 * \return The function call result.
 */
inline bool ReadSensorMSTilt(const byte & port, const byte & i2caddr, byte & x, byte & y, byte & z);

/**
 * Send PFMate command.
 * Send a PFMate command to the power function IR receiver.
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The power function IR receiver channel. See the \ref PFMateChannelConstants group.
 * \param motors The motor(s) to control. See the \ref PFMateMotorConstants group.
 * \param cmdA The power function command for motor A.
 * \param spdA The power function speed for motor A.
 * \param cmdB The power function command for motor B.
 * \param spdB The power function speed for motor B.
 * \return The function call result.
 */
inline bool PFMateSend(const byte & port, const byte & i2caddr, const byte & channel, const byte & motors, const byte & cmdA, const byte & spdA, const byte & cmdB, const byte & spdB);

/**
 * Send raw PFMate command.
 * Send a raw PFMate command to the power function IR receiver.
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The power function IR receiver channel. See the \ref PFMateChannelConstants group.
 * \param b1 Raw byte 1.
 * \param b2 Raw byte 2.
 * \return The function call result.
 */
inline bool PFMateSendRaw(const byte & port, const byte & i2caddr, const byte & channel, const byte & b1, const byte & b2);

/**
 * Read a mindsensors device value.
 * Read a one, two, or four byte value from a mindsensors sensor. The value must be
 * stored with the least signficant byte (LSB) first (i.e., little endian). Returns a boolean value
 * indicating whether or not the operation completed successfully. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param reg The device register to read.
 * \param numbytes The number of bytes to read. Only 1, 2 or 4 byte values are supported.
 * \return The function call result.
 */
inline int MSReadValue(const byte port, const byte i2caddr, const byte reg, const byte numbytes);

/**
 * Turn on power to device.
 * Turn the power on for the mindsensors device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char MSEnergize(const byte port, const byte i2caddr);

/**
 * Turn off power to device.
 * Turn power off for the mindsensors device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char MSDeenergize(const byte port, const byte i2caddr);

/**
 * Turn on mindsensors ADPA mode.
 * Turn ADPA mode on for the mindsensors device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char MSADPAOn(const byte port, const byte i2caddr);

/**
 * Turn off mindsensors ADPA mode.
 * Turn ADPA mode off for the mindsensors device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char MSADPAOff(const byte port, const byte i2caddr);

/**
 * Configure DISTNx as GP2D12.
 * Configure the mindsensors DISTNx sensor as GP2D12. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char DISTNxGP2D12(const byte port, const byte i2caddr);

/**
 * Configure DISTNx as GP2D120.
 * Configure the mindsensors DISTNx sensor as GP2D120. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char DISTNxGP2D120(const byte port, const byte i2caddr);

/**
 * Configure DISTNx as GP2YA02.
 * Configure the mindsensors DISTNx sensor as GP2YA02. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char DISTNxGP2YA02(const byte port, const byte i2caddr);

/**
 * Configure DISTNx as GP2YA21.
 * Configure the mindsensors DISTNx sensor as GP2YA21. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char DISTNxGP2YA21(const byte port, const byte i2caddr);

/**
 * Read DISTNx distance value.
 * Read the mindsensors DISTNx sensor's distance value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The distance value.
 */
inline int DISTNxDistance(const byte port, const byte i2caddr);

/**
 * Read DISTNx maximum distance value.
 * Read the mindsensors DISTNx sensor's maximum distance value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The maximum distance value.
 */
inline int DISTNxMaxDistance(const byte port, const byte i2caddr);

/**
 * Read DISTNx minimum distance value.
 * Read the mindsensors DISTNx sensor's minimum distance value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The distance value.
 */
inline int DISTNxMinDistance(const byte port, const byte i2caddr);

/**
 * Read DISTNx module type value.
 * Read the mindsensors DISTNx sensor's module type value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The module type value.
 */
inline byte DISTNxModuleType(const byte port, const byte i2caddr);

/**
 * Read DISTNx num points value.
 * Read the mindsensors DISTNx sensor's num points value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The num points value.
 */
inline byte DISTNxNumPoints(const byte port, const byte i2caddr);

/**
 * Read DISTNx voltage value.
 * Read the mindsensors DISTNx sensor's voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The voltage value.
 */
inline int DISTNxVoltage(const byte port, const byte i2caddr);

/**
 * Calibrate ACCL-Nx X-axis.
 * Calibrate the mindsensors ACCL-Nx sensor X-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char ACCLNxCalibrateX(const byte port, const byte i2caddr);

/**
 * Stop calibrating ACCL-Nx X-axis.
 * Stop calibrating the mindsensors ACCL-Nx sensor X-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char ACCLNxCalibrateXEnd(const byte port, const byte i2caddr);

/**
 * Calibrate ACCL-Nx Y-axis.
 * Calibrate the mindsensors ACCL-Nx sensor Y-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char ACCLNxCalibrateY(const byte port, const byte i2caddr);

/**
 * Stop calibrating ACCL-Nx Y-axis.
 * Stop calibrating the mindsensors ACCL-Nx sensor Y-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char ACCLNxCalibrateYEnd(const byte port, const byte i2caddr);

/**
 * Calibrate ACCL-Nx Z-axis.
 * Calibrate the mindsensors ACCL-Nx sensor Z-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char ACCLNxCalibrateZ(const byte port, const byte i2caddr);

/**
 * Stop calibrating ACCL-Nx Z-axis.
 * Stop calibrating the mindsensors ACCL-Nx sensor Z-axis. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char ACCLNxCalibrateZEnd(const byte port, const byte i2caddr);

/**
 * Reset ACCL-Nx calibration.
 * Reset the mindsensors ACCL-Nx sensor calibration to factory settings. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char ACCLNxResetCalibration(const byte port, const byte i2caddr);

/**
 * Set ACCL-Nx sensitivity.
 * Reset the mindsensors ACCL-Nx sensor calibration to factory settings. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param slevel The sensitivity level. See \ref MSACCLNxSLevel.
 * \return The function call result.
 */
inline char SetACCLNxSensitivity(const byte port, const byte i2caddr, byte slevel);

/**
 * Read ACCL-Nx sensitivity value.
 * Read the mindsensors ACCL-Nx sensitivity value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The sensitivity value.
 */
inline byte ACCLNxSensitivity(const byte port, const byte i2caddr);

/**
 * Read ACCL-Nx X offset value.
 * Read the mindsensors ACCL-Nx sensor's X offset value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The X offset value.
 */
inline int ACCLNxXOffset(const byte port, const byte i2caddr);

/**
 * Read ACCL-Nx X range value.
 * Read the mindsensors ACCL-Nx sensor's X range value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The X range value.
 */
inline int ACCLNxXRange(const byte port, const byte i2caddr);

/**
 * Read ACCL-Nx Y offset value.
 * Read the mindsensors ACCL-Nx sensor's Y offset value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The Y offset value.
 */
inline int ACCLNxYOffset(const byte port, const byte i2caddr);

/**
 * Read ACCL-Nx Y range value.
 * Read the mindsensors ACCL-Nx sensor's Y range value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The Y range value.
 */
inline int ACCLNxYRange(const byte port, const byte i2caddr);

/**
 * Read ACCL-Nx Z offset value.
 * Read the mindsensors ACCL-Nx sensor's Z offset value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The Z offset value.
 */
inline int ACCLNxZOffset(const byte port, const byte i2caddr);

/**
 * Read ACCL-Nx Z range value.
 * Read the mindsensors ACCL-Nx sensor's Z range value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The Z range value.
 */
inline int ACCLNxZRange(const byte port, const byte i2caddr);

/**
 * Configure PSPNx in digital mode.
 * Configure the mindsensors PSPNx device in digital mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char PSPNxDigital(const byte & port, const byte & i2caddr);

/**
 * Configure PSPNx in analog mode.
 * Configure the mindsensors PSPNx device in analog mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char PSPNxAnalog(const byte & port, const byte & i2caddr);

/**
 * Read NXTServo servo position value.
 * Read the mindsensors NXTServo device's servo position value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param servo The servo number. See \ref NXTServoNumbers group.
 * \return The specified servo's position value.
 */
inline unsigned int NXTServoPosition(const byte & port, const byte & i2caddr, const byte servo);

/**
 * Read NXTServo servo speed value.
 * Read the mindsensors NXTServo device's servo speed value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param servo The servo number. See \ref NXTServoNumbers group.
 * \return The specified servo's speed value.
 */
inline byte NXTServoSpeed(const byte & port, const byte & i2caddr, const byte servo);

/**
 * Read NXTServo battery voltage value.
 * Read the mindsensors NXTServo device's battery voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \result The battery level.
 */
inline byte NXTServoBatteryVoltage(const byte & port, const byte & i2caddr);

/**
 * Set NXTServo servo motor speed.
 * Set the speed of a servo motor controlled by the NXTServo device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param servo The servo number. See \ref NXTServoNumbers group.
 * \param speed The servo speed. (0..255)
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char SetNXTServoSpeed(const byte & port, const byte & i2caddr, const byte servo, const byte & speed);

/**
 * Set NXTServo servo motor quick position.
 * Set the quick position of a servo motor controlled by the NXTServo device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param servo The servo number. See \ref NXTServoNumbers group.
 * \param qpos The servo quick position. See \ref NXTServoQPos group.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char SetNXTServoQuickPosition(const byte & port, const byte & i2caddr, const byte servo, const byte & qpos);

/**
 * Set NXTServo servo motor position.
 * Set the position of a servo motor controlled by the NXTServo device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param servo The servo number. See \ref NXTServoNumbers group.
 * \param pos The servo position. See \ref NXTServoPos group.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char SetNXTServoPosition(const byte & port, const byte & i2caddr, const byte servo, const byte & pos);

/**
 * Reset NXTServo properties.
 * Reset NXTServo device properties to factory defaults.
 * Initial position = 1500.  Initial speed = 0. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char NXTServoReset(const byte & port, const byte & i2caddr);

/**
 * Halt NXTServo macro.
 * Halt a macro executing on the NXTServo device. This command re-initializes
 * the macro environment.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char NXTServoHaltMacro(const byte & port, const byte & i2caddr);

/**
 * Resume NXTServo macro.
 * Resume a macro executing on the NXTServo device. This command resumes
 * executing a macro where it was paused last, using the same environment.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char NXTServoResumeMacro(const byte & port, const byte & i2caddr);

/**
 * Pause NXTServo macro.
 * Pause a macro executing on the NXTServo device. This command will pause the
 * currently executing macro, and save the environment for subsequent resumption.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char NXTServoPauseMacro(const byte & port, const byte & i2caddr);

/**
 * Initialize NXTServo servo properties.
 * Store the initial speed and position properties of the servo motor 'n'.
 * Current speed and position values of the nth servo is read from the
 * servo speed register and servo position register and written to permanent
 * memory.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param servo The servo number. See \ref NXTServoNumbers group.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char NXTServoInit(const byte & port, const byte & i2caddr, const byte servo);

/**
 * Goto NXTServo macro address.
 * Run the macro found at the specified EEPROM macro address. This command
 * re-initializes the macro environment.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param macro The EEPROM macro address.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char NXTServoGotoMacroAddress(const byte & port, const byte & i2caddr, const byte & macro);

/**
 * Edit NXTServo macro.
 * Put the NXTServo device into macro edit mode. This operation changes the
 * I2C address of the device to 0x40.  Macros are written to EEPROM addresses
 * between 0x21 and 0xFF. Use \ref NXTServoQuitEdit to return the device to
 * its normal operation mode.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char NXTServoEditMacro(const byte & port, const byte & i2caddr);

/**
 * Quit NXTServo macro edit mode.
 * Stop editing NXTServo device macro EEPROM memory. Use \ref NXTServoEditMacro
 * to start editing a macro.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible result values.
 */
inline char NXTServoQuitEdit(const byte & port);

/**
 * Set NXTHID into ASCII data mode.
 * Set the NXTHID device into ASCII data mode. Only printable characters can be
 * transmitted in this mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTHIDAsciiMode(const byte & port, const byte & i2caddr);

/**
 * Set NXTHID into direct data mode.
 * Set the NXTHID device into direct data mode. Any character can be transmitted
 * while in this mode.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTHIDDirectMode(const byte & port, const byte & i2caddr);

/**
 * Transmit NXTHID character.
 * Transmit a single character to a computer using the NXTHID device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTHIDTransmit(const byte & port, const byte & i2caddr);

/**
 * Load NXTHID character.
 * Load a character into the NXTHID device.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param modifier The key modifier. See the \ref NXTHIDModifiers group.
 * \param character The character.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTHIDLoadCharacter(const byte & port, const byte & i2caddr, const byte & modifier, const byte & character);

/**
 * Reset NXTPowerMeter counters.
 * Reset the NXTPowerMeter counters back to zero. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTPowerMeterResetCounters(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter present current.
 * Read the mindsensors NXTPowerMeter device's present current value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter present current.
 */
inline int NXTPowerMeterPresentCurrent(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter present voltage.
 * Read the mindsensors NXTPowerMeter device's present voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter present voltage.
 */
inline int NXTPowerMeterPresentVoltage(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter capacity used.
 * Read the mindsensors NXTPowerMeter device's capacity used since the last reset command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter capacity used value.
 */
inline int NXTPowerMeterCapacityUsed(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter present power.
 * Read the mindsensors NXTPowerMeter device's present power value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter present power value.
 */
inline int NXTPowerMeterPresentPower(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter total power consumed.
 * Read the mindsensors NXTPowerMeter device's total power consumed since the last reset command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter total power consumed value.
 */
inline long NXTPowerMeterTotalPowerConsumed(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter maximum current.
 * Read the mindsensors NXTPowerMeter device's maximum current value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter maximum current value.
 */
inline int NXTPowerMeterMaxCurrent(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter minimum current.
 * Read the mindsensors NXTPowerMeter device's minimum current value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter minimum current value.
 */
inline int NXTPowerMeterMinCurrent(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter maximum voltage.
 * Read the mindsensors NXTPowerMeter device's maximum voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter maximum voltage value.
 */
inline int NXTPowerMeterMaxVoltage(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter minimum voltage.
 * Read the mindsensors NXTPowerMeter device's minimum voltage value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter minimum voltage value.
 */
inline int NXTPowerMeterMinVoltage(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter elapsed time.
 * Read the mindsensors NXTPowerMeter device's elapsed time since the last reset command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter elapsed time value.
 */
inline long NXTPowerMeterElapsedTime(const byte & port, const byte & i2caddr);

/**
 * Read NXTPowerMeter error count.
 * Read the mindsensors NXTPowerMeter device's error count value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTPowerMeter error count value.
 */
inline int NXTPowerMeterErrorCount(const byte & port, const byte & i2caddr);

/**
 * Powerdown NXTLineLeader device.
 * Put the NXTLineLeader to sleep so that it does not consume power when it is
 * not required. The device wakes up on its own when any I2C communication
 * happens or you can specifically wake it up by using the \ref NXTLineLeaderPowerUp
 * command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTLineLeaderPowerDown(const byte & port, const byte & i2caddr);

/**
 * Powerup NXTLineLeader device.
 * Wake up the NXTLineLeader device so that it can be used. The device can be
 * put to sleep using the \ref NXTLineLeaderPowerDown command.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTLineLeaderPowerUp(const byte & port, const byte & i2caddr);

/**
 * Invert NXTLineLeader colors.
 * Invert color sensing so that the device can detect a white line on a
 * black background.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTLineLeaderInvert(const byte & port, const byte & i2caddr);

/**
 * Reset NXTLineLeader color inversion.
 * Reset the NXTLineLeader color detection back to its default state (black
 * line on a white background).
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTLineLeaderReset(const byte & port, const byte & i2caddr);

/**
 * Take NXTLineLeader line snapshot.
 * Takes a snapshot of the line under the sensor and tracks that position in
 * subsequent tracking operations.  This function also will set color inversion
 * if it sees a white line on a black background.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTLineLeaderSnapshot(const byte & port, const byte & i2caddr);

/**
 * Calibrate NXTLineLeader white color.
 * Store calibration data for the white color.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTLineLeaderCalibrateWhite(const byte & port, const byte & i2caddr);

/**
 * Calibrate NXTLineLeader black color.
 * Store calibration data for the black color.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char NXTLineLeaderCalibrateBlack(const byte & port, const byte & i2caddr);

/**
 * Read NXTLineLeader steering.
 * Read the mindsensors NXTLineLeader device's steering value. This is the power
 * returned by the sensor to correct your course.  Add this value to your left
 * motor and subtract it from your right motor.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTLineLeader steering value.
 */
inline char NXTLineLeaderSteering(const byte & port, const byte & i2caddr);

/**
 * Read NXTLineLeader average.
 * Read the mindsensors NXTLineLeader device's average value. The
 * average is a weighted average of the bits set to 1 based on the position.
 * The left most bit has a weight of 10, second bit has a weight of 20, and so
 * forth. When all 8 sensors are over a black surface the average will be 45.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTLineLeader average value.
 */
inline char NXTLineLeaderAverage(const byte & port, const byte & i2caddr);

/**
 * Read NXTLineLeader result.
 * Read the mindsensors NXTLineLeader device's result value. This is a single
 * byte showing the 8 sensor's readings. Each bit corresponding to the sensor
 * where the line is seen is set to 1, otherwise it is set to 0.
 * When all 8 sensors are over a black surface the result will be 255 (b11111111).
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The NXTLineLeader result value.
 */
inline byte NXTLineLeaderResult(const byte & port, const byte & i2caddr);

/**
 * Write NXTLineLeader setpoint.
 * Write a new setpoint value to the NXTLineLeader device. The Set Point is a
 * value you can ask sensor to maintain the average to. The default value is
 * 45, whereby the line is maintained in center of the sensor. If you need to
 * maintain line towards left of the sensor, set the Set Point to
 * a lower value (minimum: 10). If you need it to be towards on the right of the
 * sensor, set it to higher value (maximum: 80). Set point is also useful while
 * tracking an edge of dark and light areas.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param value The new setpoint value (10..80).
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char SetNXTLineLeaderSetpoint(const byte & port, const byte & i2caddr, const byte & value);

/**
 * Write NXTLineLeader Kp value.
 * Write a Kp value to the NXTLineLeader device. This value divided by PID
 * Factor for Kp is the Proportional value for the PID control. Suggested value
 * is 25 with a divisor factor of 32 (which is also a factory default), start
 * with this value, and tune it to meet your needs. Value ranges
 * between 0 and 255.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param value The new Kp value (0..255).
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char SetNXTLineLeaderKpValue(const byte & port, const byte & i2caddr, const byte & value);

/**
 * Write NXTLineLeader Ki value.
 * Write a Ki value to the NXTLineLeader device. This value divided by PID
 * Factor for Ki is the Integral value for the PID control. Suggested value
 * is 0 with a divisor factor of 32 (which is also a factory default), start
 * with this value, and tune it to meet your needs. Value ranges
 * between 0 and 255.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param value The new Ki value (0..255).
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char SetNXTLineLeaderKiValue(const byte & port, const byte & i2caddr, const byte & value);

/**
 * Write NXTLineLeader Kd value.
 * Write a Kd value to the NXTLineLeader device. This value divided by PID
 * Factor for Kd is the Derivative value for the PID control. Suggested value
 * is 8 with a divisor factor of 32 (which is also a factory default), start
 * with this value, and tune it to meet your needs. Value ranges
 * between 0 and 255.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param value The new Kd value (0..255).
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char SetNXTLineLeaderKdValue(const byte & port, const byte & i2caddr, const byte & value);

/**
 * Write NXTLineLeader Kp factor.
 * Write a Kp divisor factor to the NXTLineLeader device. Value ranges between
 * 1 and 255. Change this value if you need more granularities in Kp value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param value The new Kp factor (1..255).
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char SetNXTLineLeaderKpFactor(const byte & port, const byte & i2caddr, const byte & value);

/**
 * Write NXTLineLeader Ki factor.
 * Write a Ki divisor factor to the NXTLineLeader device. Value ranges between
 * 1 and 255. Change this value if you need more granularities in Ki value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param value The new Ki factor (1..255).
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char SetNXTLineLeaderKiFactor(const byte & port, const byte & i2caddr, const byte & value);

/**
 * Write NXTLineLeader Kd factor.
 * Write a Kd divisor factor to the NXTLineLeader device. Value ranges between
 * 1 and 255. Change this value if you need more granularities in Kd value.
 * The port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref NBCInputPortConstants.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param value The new Kd factor (1..255).
 * \return A status code indicating whether the operation completed successfully or not.
 * See \ref CommLSCheckStatusType for possible Result values.
 */
inline char SetNXTLineLeaderKdFactor(const byte & port, const byte & i2caddr, const byte & value);

/**
 * Configure NRLink in 2400 baud mode.
 * Configure the mindsensors NRLink device in 2400 baud mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLink2400(const byte port, const byte i2caddr);

/**
 * Configure NRLink in 4800 baud mode.
 * Configure the mindsensors NRLink device in 4800 baud mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLink4800(const byte port, const byte i2caddr);

/**
 * Flush NRLink buffers.
 * Flush the mindsensors NRLink device buffers. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLinkFlush(const byte port, const byte i2caddr);

/**
 * Configure NRLink in IR long mode.
 * Configure the mindsensors NRLink device in IR long mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLinkIRLong(const byte port, const byte i2caddr);

/**
 * Configure NRLink in IR short mode.
 * Configure the mindsensors NRLink device in IR short mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLinkIRShort(const byte port, const byte i2caddr);

/**
 * Configure NRLink in power function mode.
 * Configure the mindsensors NRLink device in power function mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLinkSetPF(const byte port, const byte i2caddr);

/**
 * Configure NRLink in RCX mode.
 * Configure the mindsensors NRLink device in RCX mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLinkSetRCX(const byte port, const byte i2caddr);

/**
 * Configure NRLink in IR train mode.
 * Configure the mindsensors NRLink device in IR train mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLinkSetTrain(const byte port, const byte i2caddr);

/**
 * Configure NRLink in raw IR transmit mode.
 * Configure the mindsensors NRLink device in raw IR transmit mode. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The function call result.
 */
inline char NRLinkTxRaw(const byte port, const byte i2caddr);

/**
 * Read NRLink status.
 * Read the status of the mindsensors NRLink device. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \return The mindsensors NRLink status.
 */
inline byte NRLinkStatus(const byte port, const byte i2caddr);

/**
 * Run NRLink macro.
 * Run the specified mindsensors NRLink device macro. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param macro The address of the macro to execute.
 * \return The function call result.
 */
inline char RunNRLinkMacro(const byte port, const byte i2caddr, const byte macro);

/**
 * Write data to NRLink.
 * Write data to the mindsensors NRLink device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param data A byte array containing the data to write.
 * \return The function call result.
 */
inline char WriteNRLinkBytes(const byte port, const byte i2caddr, const byte data[]);

/**
 * Read data from NRLink.
 * Read data from the mindsensors NRLink device on the specified port. The port
 * must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param data A byte array that will contain the data read from the device on output.
 * \return The function call result.
 */
inline bool ReadNRLinkBytes(const byte port, const byte i2caddr, byte & data[]);

/**
 * MSIRTrain function.
 * Control an IR Train receiver set to the specified channel using the
 * mindsensors NRLink device. Valid function values are \ref TRAIN_FUNC_STOP,
 * \ref TRAIN_FUNC_INCR_SPEED, \ref TRAIN_FUNC_DECR_SPEED, and \ref TRAIN_FUNC_TOGGLE_LIGHT.
 * Valid channels are \ref TRAIN_CHANNEL_1 through \ref TRAIN_CHANNEL_3 and
 * \ref TRAIN_CHANNEL_ALL. The port must be configured as a Lowspeed port before
 * using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The IR Train channel.  See \ref IRTrainChannels.
 * \param func The IR Train function. See \ref IRTrainFuncs
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSIRTrain(const byte port, const byte i2caddr, const byte channel, const byte func);

/**
 * MSPFComboDirect function.
 * Execute a pair of Power Function motor commands on the specified channel
 * using the mindsensors NRLink device. Commands for outa and outb are
 * PF_CMD_STOP, PF_CMD_REV, PF_CMD_FWD, and \ref PF_CMD_BRAKE. Valid channels are
 * PF_CHANNEL_1 through PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param outa The Power Function command for output A. See \ref PFCmdConstants.
 * \param outb The Power Function command for output B. See \ref PFCmdConstants.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSPFComboDirect(const byte port, const byte i2caddr, const byte channel, const byte outa, const byte outb);

/**
 * MSPFComboPWM function.
 * Control the speed of both outputs on a Power Function receiver set to the
 * specified channel using the mindsensors NRLink device. Valid output values
 * are \ref PF_PWM_FLOAT, \ref PF_PWM_FWD1, \ref PF_PWM_FWD2, \ref PF_PWM_FWD3, \ref PF_PWM_FWD4,
 * \ref PF_PWM_FWD5, \ref PF_PWM_FWD6, \ref PF_PWM_FWD7, \ref PF_PWM_BRAKE, \ref PF_PWM_REV7,
 * \ref PF_PWM_REV6, \ref PF_PWM_REV5, \ref PF_PWM_REV4, \ref PF_PWM_REV3, \ref PF_PWM_REV2, and
 * \ref PF_PWM_REV1. Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The
 * port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param outa The Power Function PWM command for output A. See \ref PFPWMOptions.
 * \param outb The Power Function PWM command for output B. See \ref PFPWMOptions.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSPFComboPWM(const byte port, const byte i2caddr, const byte channel, const byte outa, const byte outb);

/**
 * MSPFRawOutput function.
 * Control a Power Function receiver set to the specified channel using the
 * mindsensors NRLink device. Build the raw data stream using the 3 nibbles
 * (4 bit values). The port must be configured as a Lowspeed port before using
 * this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param nibble0 The first raw data nibble.
 * \param nibble1 The second raw data nibble.
 * \param nibble2 The third raw data nibble.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSPFRawOutput(const byte port, const byte i2caddr, const byte nibble0, const byte nibble1, const byte nibble2);

/**
 * MSPFRepeat function.
 * Repeat sending the last Power Function command using the mindsensors
 * NRLink device. Specify the number of times to repeat the command and the
 * number of milliseconds of delay between each repetition. The port must be
 * configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param count The number of times to repeat the command.
 * \param delay The number of milliseconds to delay between each repetition.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSPFRepeat(const byte port, const byte i2caddr, const byte count, const unsigned int delay);

/**
 * MSPFSingleOutputCST function.
 * Control a single output on a Power Function receiver set to the specified
 * channel using the mindsensors NRLink device. Select the desired output
 * using \ref PF_OUT_A or \ref PF_OUT_B. Valid functions are \ref PF_CST_CLEAR1_CLEAR2,
 * \ref PF_CST_SET1_CLEAR2, \ref PF_CST_CLEAR1_SET2, \ref PF_CST_SET1_SET2,
 * \ref PF_CST_INCREMENT_PWM, \ref PF_CST_DECREMENT_PWM, \ref PF_CST_FULL_FWD,
 * \ref PF_CST_FULL_REV, and \ref PF_CST_TOGGLE_DIR. Valid channels are
 * \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param out The Power Function output. See \ref PFOutputs.
 * \param func The Power Function CST function. See \ref PFCSTOptions.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSPFSingleOutputCST(const byte port, const byte i2caddr, const byte channel, const byte out, const byte func);

/**
 * MSPFSingleOutputPWM function.
 * Control the speed of a single output on a Power Function receiver set to
 * the specified channel using the mindsensors NRLink device. Select the
 * desired output using \ref PF_OUT_A or \ref PF_OUT_B. Valid functions are
 * \ref PF_PWM_FLOAT, \ref PF_PWM_FWD1, \ref PF_PWM_FWD2, \ref PF_PWM_FWD3, \ref PF_PWM_FWD4,
 * \ref PF_PWM_FWD5, \ref PF_PWM_FWD6, \ref PF_PWM_FWD7, \ref PF_PWM_BRAKE, \ref PF_PWM_REV7,
 * \ref PF_PWM_REV6, \ref PF_PWM_REV5, \ref PF_PWM_REV4, \ref PF_PWM_REV3, \ref PF_PWM_REV2, and
 * \ref PF_PWM_REV1. Valid channels are \ref PF_CHANNEL_1 through \ref PF_CHANNEL_4. The
 * port must be configured as a Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param out The Power Function output. See \ref PFOutputs.
 * \param func The Power Function PWM function. See \ref PFPWMOptions.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSPFSingleOutputPWM(const byte port, const byte i2caddr, const byte channel, const byte out, const byte func);

/**
 * MSPFSinglePin function.
 * Control a single pin on a Power Function receiver set to the specified
 * channel using the mindsensors NRLink device. Select the desired output
 * using \ref PF_OUT_A or \ref PF_OUT_B.  Select the desired pin using \ref PF_PIN_C1 or
 * \ref PF_PIN_C2. Valid functions are \ref PF_FUNC_NOCHANGE, \ref PF_FUNC_CLEAR,
 * \ref PF_FUNC_SET, and \ref PF_FUNC_TOGGLE. Valid channels are \ref PF_CHANNEL_1 through
 * \ref PF_CHANNEL_4. Specify whether the mode by passing true (continuous) or
 * false (timeout) as the final parameter. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param out The Power Function output. See \ref PFOutputs.
 * \param pin The Power Function pin. See \ref PFPinConstants.
 * \param func The Power Function single pin function. See \ref PFPinFuncs.
 * \param cont Control whether the mode is continuous or timeout.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSPFSinglePin(const byte port, const byte i2caddr, const byte channel, const byte out, const byte pin, const byte func, bool cont);

/**
 * MSPFTrain function.
 * Control both outputs on a Power Function receiver set to the specified
 * channel using the mindsensors NRLink device as if it were an IR Train
 * receiver. Valid function values are \ref TRAIN_FUNC_STOP, \ref TRAIN_FUNC_INCR_SPEED,
 * \ref TRAIN_FUNC_DECR_SPEED, and \ref TRAIN_FUNC_TOGGLE_LIGHT. Valid channels are
 * PF_CHANNEL_1 through PF_CHANNEL_4. The port must be configured as a
 * Lowspeed port before using this function.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 * \param channel The Power Function channel.  See \ref PFChannelConstants.
 * \param func The Power Function train function. See \ref IRTrainFuncs.
 * \return The function call result. \ref NO_ERR or \ref CommandCommErrors.
 */
inline char MSPFTrain(const byte port, const byte i2caddr, const byte channel, const byte func);

/**
 * MSRCXSetIRLinkPort function.
 * Set the global port in advance of using the MSRCX* and MSScout* API
 * functions for sending RCX and Scout messages over the mindsensors NRLink
 * device. The port must be configured as a Lowspeed port before using any of
 * the mindsensors RCX and Scout NRLink functions.
 *
 * \param port The sensor port. See \ref InPorts.
 * \param i2caddr The sensor I2C address. See sensor documentation for this value.
 */
inline void MSRCXSetNRLinkPort(const byte port, const byte i2caddr);

/**
 * MSRCXBatteryLevel function.
 * Send the BatteryLevel command to an RCX to read the current battery level.
 *
 * \return The RCX battery level.
 */
inline int MSRCXBatteryLevel(void);

/**
 * MSRCXPoll function.
 * Send the Poll command to an RCX to read a signed 2-byte value at the
 * specified source and value combination.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 * \return The value read from the specified port and value.
 */
inline int MSRCXPoll(const byte src, const byte value);

/**
 * MSRCXPollMemory function.
 * Send the PollMemory command to an RCX.
 *
 * \param address The RCX memory address.
 * \return The value read from the specified address.
 */
inline int MSRCXPollMemory(const unsigned int address);

/**
 * MSRCXAbsVar function.
 * Send the AbsVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXAbsVar(const byte varnum, const byte byte src, const unsigned int value);

/**
 * MSRCXAddToDatalog function.
 * Send the AddToDatalog command to an RCX.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXAddToDatalog(const byte src, const unsigned int value);

/**
 * MSRCXAndVar function.
 * Send the AndVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXAndVar(const byte varnum, const byte src, const unsigned int value);

/**
 * MSRCXBoot function.
 * Send the Boot command to an RCX.
 */
inline void MSRCXBoot(void);

/**
 * MSRCXCalibrateEvent function.
 * Send the CalibrateEvent command to an RCX.
 *
 * \param evt The event number.
 * \param low The low threshold.
 * \param hi The high threshold.
 * \param hyst The hysterisis value.
 */
inline void MSRCXCalibrateEvent(const byte evt, const byte low, const byte hi, const byte hyst);

/**
 * MSRCXClearAllEvents function.
 * Send the ClearAllEvents command to an RCX.
 */
inline void MSRCXClearAllEvents(void);

/**
 * MSRCXClearCounter function.
 * Send the ClearCounter command to an RCX.
 *
 * \param counter The counter to clear.
 */
inline void MSRCXClearCounter(const byte counter);

/**
 * MSRCXClearMsg function.
 * Send the ClearMsg command to an RCX.
 */
inline void MSRCXClearMsg(void);

/**
 * MSRCXClearSensor function.
 * Send the ClearSensor command to an RCX.
 *
 * \param port The RCX port number.
 */
inline void MSRCXClearSensor(const byte port);

/**
 * MSRCXClearSound function.
 * Send the ClearSound command to an RCX.
 */
inline void MSRCXClearSound(void);

/**
 * MSRCXClearTimer function.
 * Send the ClearTimer command to an RCX.
 *
 * \param timer The timer to clear.
 */
inline void MSRCXClearTimer(const byte timer);

/**
 * MSRCXCreateDatalog function.
 * Send the CreateDatalog command to an RCX.
 *
 * \param size The new datalog size.
 */
inline void MSRCXCreateDatalog(const unsigned int size);

/**
 * MSRCXDecCounter function.
 * Send the DecCounter command to an RCX.
 *
 * \param counter The counter to decrement.
 */
inline void MSRCXDecCounter(const byte counter);

/**
 * MSRCXDeleteSub function.
 * Send the DeleteSub command to an RCX.
 *
 * \param s The subroutine number to delete.
 */
inline void MSRCXDeleteSub(const byte s);

/**
 * MSRCXDeleteSubs function.
 * Send the DeleteSubs command to an RCX.
 */
inline void MSRCXDeleteSubs(void);

/**
 * MSRCXDeleteTask function.
 * Send the DeleteTask command to an RCX.
 *
 * \param t The task number to delete.
 */
inline void MSRCXDeleteTask(const byte t);

/**
 * MSRCXDeleteTasks function.
 * Send the DeleteTasks command to an RCX.
 */
inline void MSRCXDeleteTasks(void);

/**
 * MSRCXDisableOutput function.
 * Send the DisableOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to disable. See \ref RCXOutputConstants.
 */
inline void MSRCXDisableOutput(const byte outputs);

/**
 * MSRCXDivVar function.
 * Send the DivVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXDivVar(const byte varnum, const byte src, const unsigned int value);

/**
 * MSRCXEnableOutput function.
 * Send the EnableOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to enable. See \ref RCXOutputConstants.
 */
inline void MSRCXEnableOutput(const byte outputs);

/**
 * MSRCXEvent function.
 * Send the Event command to an RCX.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXEvent(const byte src, const unsigned int value);

/**
 * MSRCXFloat function.
 * Send commands to an RCX to float the specified outputs.
 *
 * \param outputs The RCX output(s) to float. See \ref RCXOutputConstants.
 */
inline void MSRCXFloat(const byte outputs);

/**
 * MSRCXFwd function.
 * Send commands to an RCX to set the specified outputs to the forward direction.
 *
 * \param outputs The RCX output(s) to set forward. See \ref RCXOutputConstants.
 */
inline void MSRCXFwd(const byte outputs);

/**
 * MSRCXIncCounter function.
 * Send the IncCounter command to an RCX.
 *
 * \param counter The counter to increment.
 */
inline void MSRCXIncCounter(const byte counter);

/**
 * MSRCXInvertOutput function.
 * Send the InvertOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to invert. See \ref RCXOutputConstants.
 */
inline void MSRCXInvertOutput(const byte outputs);

/**
 * MSRCXMulVar function.
 * Send the MulVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXMulVar(const byte varnum, const byte src, unsigned int value);

/**
 * MSRCXMuteSound function.
 * Send the MuteSound command to an RCX.
 */
inline void MSRCXMuteSound(void);

/**
 * MSRCXObvertOutput function.
 * Send the ObvertOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to obvert. See \ref RCXOutputConstants.
 */
inline void MSRCXObvertOutput(const byte outputs);

/**
 * MSRCXOff function.
 * Send commands to an RCX to turn off the specified outputs.
 *
 * \param outputs The RCX output(s) to turn off. See \ref RCXOutputConstants.
 */
inline void MSRCXOff(const byte outputs);

/**
 * MSRCXOn function.
 * Send commands to an RCX to turn on the specified outputs.
 *
 * \param outputs The RCX output(s) to turn on. See \ref RCXOutputConstants.
 */
inline void MSRCXOn(const byte outputs);

/**
 * MSRCXOnFor function.
 * Send commands to an RCX to turn on the specified outputs in the forward
 * direction for the specified duration.
 *
 * \param outputs The RCX output(s) to turn on. See \ref RCXOutputConstants.
 * \param ms The number of milliseconds to leave the outputs on
 */
inline void MSRCXOnFor(const byte outputs, const unsigned int ms);

/**
 * MSRCXOnFwd function.
 * Send commands to an RCX to turn on the specified outputs in the forward
 * direction.
 *
 * \param outputs The RCX output(s) to turn on in the forward direction. See \ref RCXOutputConstants.
 */
inline void MSRCXOnFwd(const byte outputs);

/**
 * MSRCXOnRev function.
 * Send commands to an RCX to turn on the specified outputs in the reverse direction.
 *
 * \param outputs The RCX output(s) to turn on in the reverse direction. See \ref RCXOutputConstants.
 */
inline void MSRCXOnRev(const byte outputs);

/**
 * MSRCXOrVar function.
 * Send the OrVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXOrVar(const byte varnum, const byte src, const unsigned int value);

/**
 * MSRCXPBTurnOff function.
 * Send the PBTurnOff command to an RCX.
 */
inline void MSRCXPBTurnOff(void);

/**
 * MSRCXPing function.
 * Send the Ping command to an RCX.
 */
inline void MSRCXPing(void);

/**
 * MSRCXPlaySound function.
 * Send the PlaySound command to an RCX.
 *
 * \param snd The sound number to play.
 */
inline void MSRCXPlaySound(const byte snd);

/**
 * MSRCXPlayTone function.
 * Send the PlayTone command to an RCX.
 *
 * \param freq The frequency of the tone to play.
 * \param duration The duration of the tone to play.
 */
inline void MSRCXPlayTone(const unsigned int freq, const byte duration);

/**
 * MSRCXPlayToneVar function.
 * Send the PlayToneVar command to an RCX.
 *
 * \param varnum The variable containing the tone frequency to play.
 * \param duration The duration of the tone to play.
 */
inline void MSRCXPlayToneVar(const byte varnum, const byte duration);

/**
 * MSRCXRemote function.
 * Send the Remote command to an RCX.
 *
 * \param cmd The RCX IR remote command to send. See \ref RCXRemoteConstants.
 */
inline void MSRCXRemote(unsigned int cmd);

/**
 * MSRCXReset function.
 * Send the Reset command to an RCX.
 */
inline void MSRCXReset(void);

/**
 * MSRCXRev function.
 * Send commands to an RCX to set the specified outputs to the reverse direction.
 *
 * \param outputs The RCX output(s) to reverse direction. See \ref RCXOutputConstants.
 */
inline void MSRCXRev(const byte outputs);

/**
 * MSRCXSelectDisplay function.
 * Send the SelectDisplay command to an RCX.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXSelectDisplay(const byte src, const unsigned int value);

/**
 * MSRCXSelectProgram function.
 * Send the SelectProgram command to an RCX.
 *
 * \param prog The program number to select.
 */
inline void MSRCXSelectProgram(const byte prog);

/**
 * MSRCXSendSerial function.
 * Send the SendSerial command to an RCX.
 *
 * \param first The first byte address.
 * \param count The number of bytes to send.
 */
inline void MSRCXSendSerial(const byte first, const byte count);

/**
 * MSRCXSet function.
 * Send the Set command to an RCX.
 *
 * \param dstsrc The RCX destination source.  See \ref RCXSourceConstants.
 * \param dstval The RCX destination value.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXSet(const byte dstsrc, const byte dstval, const byte src, unsigned int value);

/**
 * MSRCXSetDirection function.
 * Send the SetDirection command to an RCX to configure the direction of the specified outputs.
 *
 * \param outputs The RCX output(s) to set direction. See \ref RCXOutputConstants.
 * \param dir The RCX output direction. See \ref RCXOutputDirection.
 */
inline void MSRCXSetDirection(const byte outputs, const byte dir);

/**
 * MSRCXSetEvent function.
 * Send the SetEvent command to an RCX.
 *
 * \param evt The event number to set.
 * \param src The RCX source. See \ref RCXSourceConstants.
 * \param type The event type.
 */
inline void MSRCXSetEvent(const byte evt, const byte src, const byte type);

/**
 * MSRCXSetGlobalDirection function.
 * Send the SetGlobalDirection command to an RCX.
 *
 * \param outputs The RCX output(s) to set global direction. See \ref RCXOutputConstants.
 * \param dir The RCX output direction. See \ref RCXOutputDirection.
 */
inline void MSRCXSetGlobalDirection(const byte outputs, const byte dir);

/**
 * MSRCXSetGlobalOutput function.
 * Send the SetGlobalOutput command to an RCX.
 *
 * \param outputs The RCX output(s) to set global mode. See \ref RCXOutputConstants.
 * \param mode The RCX output mode. See \ref RCXOutputMode.
 */
inline void MSRCXSetGlobalOutput(const byte outputs, const byte mode);

/**
 * MSRCXSetMaxPower function.
 * Send the SetMaxPower command to an RCX.
 *
 * \param outputs The RCX output(s) to set max power. See \ref RCXOutputConstants.
 * \param pwrsrc The RCX source.  See \ref RCXSourceConstants.
 * \param pwrval The RCX value.
 */
inline void MSRCXSetMaxPower(const byte outputs, const byte pwrsrc, const byte pwrval);

/**
 * MSRCXSetMessage function.
 * Send the SetMessage command to an RCX.
 *
 * \param msg The numeric message to send.
 */
inline void MSRCXSetMessage(const byte msg);

/**
 * MSRCXSetOutput function.
 * Send the SetOutput command to an RCX to configure the mode of the specified outputs
 *
 * \param outputs The RCX output(s) to set mode. See \ref RCXOutputConstants.
 * \param mode The RCX output mode. See \ref RCXOutputMode.
 */
inline void MSRCXSetOutput(const byte outputs, const byte mode);

/**
 * MSRCXSetPower function.
 * Send the SetPower command to an RCX to configure the power level of the specified outputs.
 *
 * \param outputs The RCX output(s) to set power. See \ref RCXOutputConstants.
 * \param pwrsrc The RCX source.  See \ref RCXSourceConstants.
 * \param pwrval The RCX value.
 */
inline void MSRCXSetPower(const byte outputs, const byte pwrsrc, const byte pwrval);

/**
 * MSRCXSetPriority function.
 * Send the SetPriority command to an RCX.
 *
 * \param p The new task priority.
 */
inline void MSRCXSetPriority(const byte p);

/**
 * MSRCXSetSensorMode function.
 * Send the SetSensorMode command to an RCX.
 *
 * \param port The RCX sensor port.
 * \param mode The RCX sensor mode.
 */
inline void MSRCXSetSensorMode(const byte port, const byte mode);

/**
 * MSRCXSetSensorType function.
 * Send the SetSensorType command to an RCX.
 *
 * \param port The RCX sensor port.
 * \param type The RCX sensor type.
 */
inline void MSRCXSetSensorType(const byte port, const byte type);

/**
 * MSRCXSetSleepTime function.
 * Send the SetSleepTime command to an RCX.
 *
 * \param t The new sleep time value.
 */
inline void MSRCXSetSleepTime(const byte t);

/**
 * MSRCXSetTxPower function.
 * Send the SetTxPower command to an RCX.
 *
 * \param pwr The IR transmit power level.
 */
inline void MSRCXSetTxPower(const byte pwr);

/**
 * MSRCXSetUserDisplay function.
 * Send the SetUserDisplay command to an RCX.
 *
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 * \param precision The number of digits of precision.
 */
inline void MSRCXSetUserDisplay(const byte src, const unsigned int value, const byte precision);

/**
 * MSRCXSetVar function.
 * Send the SetVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXSetVar(const byte varnum, const byte src, const unsigned int value);

/**
 * MSRCXSetWatch function.
 * Send the SetWatch command to an RCX.
 *
 * \param hours The new watch time hours value.
 * \param minutes The new watch time minutes value.
 */
inline void MSRCXSetWatch(const byte hours, const byte minutes);

/**
 * MSRCXSgnVar function.
 * Send the SgnVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXSgnVar(const byte varnum, const byte src, const unsigned int value);

/**
 * MSRCXStartTask function.
 * Send the StartTask command to an RCX.
 *
 * \param t The task number to start.
 */
inline void MSRCXStartTask(const byte t);

/**
 * MSRCXStopAllTasks function.
 * Send the StopAllTasks command to an RCX.
 */
inline void MSRCXStopAllTasks(void);

/**
 * MSRCXStopTask function.
 * Send the StopTask command to an RCX.
 *
 * \param t The task number to stop.
 */
inline void MSRCXStopTask(const byte t);

/**
 * MSRCXSubVar function.
 * Send the SubVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXSubVar(const byte varnum, const byte src, const unsigned int value);

/**
 * MSRCXSumVar function.
 * Send the SumVar command to an RCX.
 *
 * \param varnum The variable number to change.
 * \param src The RCX source.  See \ref RCXSourceConstants.
 * \param value The RCX value.
 */
inline void MSRCXSumVar(const byte varnum, const byte src, const unsigned int value);

/**
 * MSRCXToggle function.
 * Send commands to an RCX to toggle the direction of the specified outputs.
 *
 * \param outputs The RCX output(s) to toggle. See \ref RCXOutputConstants.
 */
inline void MSRCXToggle(const byte outputs);

/**
 * MSRCXUnlock function.
 * Send the Unlock command to an RCX.
 */
inline void MSRCXUnlock(void);

/**
 * MSRCXUnmuteSound function.
 * Send the UnmuteSound command to an RCX.
 */
inline void MSRCXUnmuteSound(void);

/**
 * MSScoutCalibrateSensor function.
 * Send the CalibrateSensor command to a Scout.
 */
inline void MSScoutCalibrateSensor(void);

/**
 * MSScoutMuteSound function.
 * Send the MuteSound command to a Scout.
 */
inline void MSScoutMuteSound(void);

/**
 * MSScoutSelectSounds function.
 * Send the SelectSounds command to a Scout.
 *
 * \param grp The Scout sound group to select.
 */
inline void MSScoutSelectSounds(const byte grp);

/**
 * MSScoutSendVLL function.
 * Send the SendVLL command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void MSScoutSendVLL(const byte src, const unsigned int value);

/**
 * MSScoutSetCounterLimit function.
 * Send the SetCounterLimit command to a Scout.
 *
 * \param ctr The counter for which to set the limit.
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void MSScoutSetCounterLimit(const byte ctr, const byte src, const unsigned int value);

/**
 * MSScoutSetEventFeedback function.
 * Send the SetEventFeedback command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void MSScoutSetEventFeedback(const byte src, const unsigned int value);

/**
 * MSScoutSetLight function.
 * Send the SetLight command to a Scout.
 *
 * \param x Set the light on or off using this value. See \ref ScoutLightConstants.
 */
inline void MSScoutSetLight(const byte x);

/**
 * MSScoutSetScoutMode function.
 * Send the SetScoutMode command to a Scout.
 *
 * \param mode Set the scout mode. See \ref ScoutModeConstants.
*/
inline void MSScoutSetScoutMode(const byte mode);

/**
 * MSScoutSetScoutRules function.
 * Send the SetScoutRules command to a Scout.
 *
 * \param m Scout motion rule. See \ref ScoutMotionRuleConstants.
 * \param t Scout touch rule. See \ref ScoutTouchRuleConstants.
 * \param l Scout light rule. See \ref ScoutLightRuleConstants.
 * \param tm Scout transmit rule. See \ref ScoutTransmitRuleConstants.
 * \param fx Scout special effects rule. See \ref ScoutSpecialEffectConstants.
 */
inline void MSScoutSetScoutRules(const byte m, const byte t, const byte l, const byte tm, const byte fx);

/**
 * MSScoutSetSensorClickTime function.
 * Send the SetSensorClickTime command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void MSScoutSetSensorClickTime(const byte src, const unsigned int value);

/**
 * MSScoutSetSensorHysteresis function.
 * Send the SetSensorHysteresis command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void MSScoutSetSensorHysteresis(const byte src, const unsigned int value);

/**
 * MSScoutSetSensorLowerLimit function.
 * Send the SetSensorLowerLimit command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void MSScoutSetSensorLowerLimit(const byte src, const unsigned int value);

/**
 * MSScoutSetSensorUpperLimit function.
 * Send the SetSensorUpperLimit command to a Scout.
 *
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void MSScoutSetSensorUpperLimit(const byte src, const unsigned int value);

/**
 * MSScoutSetTimerLimit function.
 * Send the SetTimerLimit command to a Scout.
 *
 * \param tmr The timer for which to set a limit.
 * \param src The Scout source.  See \ref RCXSourceConstants.
 * \param value The Scout value.
 */
inline void MSScoutSetTimerLimit(const byte tmr, const byte src, const unsigned int value);

/**
 * MSScoutUnmuteSound function.
 * Send the UnmuteSound command to a Scout.
 */
inline void MSScoutUnmuteSound(void);

#else

#define SensorMSDROD(_p) asm { getin __RETVAL__, _p, NormalizedValueField }
#define SensorNXTSumoEyesRaw(_p) asm { getin __RETVAL__, _p, NormalizedValueField }
#define SensorMSPressureRaw(_p) asm { getin __RETVAL__, _p, RawValueField }
#define SensorMSCompass(_port, _i2caddr) asm { ReadSensorMSCompass(_port, _i2caddr, __RETVAL__) }
#define ReadSensorMSRTClock(_port, _sec, _min, _hrs, _dow, _date, _month, _year) asm { __ReadSensorMSRTClock(_port, _sec, _min, _hrs, _dow, _date, _month, _year, __RETVAL__) }
#define ReadSensorMSTilt(_port, _i2caddr, _x, _y, _z) asm { __ReadSensorMSTilt(_port, _i2caddr, _x, _y, _z, __RETVAL__) }
#define ReadSensorMSAccel(_port, _i2caddr, _x, _y, _z) asm { __ReadSensorMSAccel(_port, _i2caddr, _x, _y, _z, __RETVAL__) }

#define MSReadValue(_port, _i2caddr, _reg, _bytes) asm { __MSReadValue(_port, _i2caddr, _reg, _bytes, __RETVAL__, __TMPBYTE__) }
#define MSEnergize(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, MS_CMD_ENERGIZED, __RETVAL__) }
#define MSDeenergize(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, MS_CMD_DEENERGIZED, __RETVAL__) }
#define MSADPAOn(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, MS_CMD_ADPA_ON, __RETVAL__) }
#define MSADPAOff(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, MS_CMD_ADPA_OFF, __RETVAL__) }

#define DISTNxGP2D12(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, DIST_CMD_GP2D12, __RETVAL__) }
#define DISTNxGP2D120(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, DIST_CMD_GP2D120, __RETVAL__) }
#define DISTNxGP2YA21(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, DIST_CMD_GP2YA21, __RETVAL__) }
#define DISTNxGP2YA02(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, DIST_CMD_GP2YA02, __RETVAL__) }
#define DISTNxDistance(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, DIST_REG_DIST, 2, __RETVAL__, __TMPBYTE__) }
#define DISTNxVoltage(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, DIST_REG_VOLT, 2, __RETVAL__, __TMPBYTE__) }
#define DISTNxModuleType(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, DIST_REG_MODULE_TYPE, 1, __RETVAL__, __TMPBYTE__) }
#define DISTNxNumPoints(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, DIST_REG_NUM_POINTS, 1, __RETVAL__, __TMPBYTE__) }
#define DISTNxMinDistance(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, DIST_REG_DIST_MIN, 2, __RETVAL__, __TMPBYTE__) }
#define DISTNxMaxDistance(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, DIST_REG_DIST_MAX, 2, __RETVAL__, __TMPBYTE__) }

#define ACCLNxCalibrateX(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, ACCL_CMD_X_CAL, __RETVAL__) }
#define ACCLNxCalibrateXEnd(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, ACCL_CMD_X_CAL_END, __RETVAL__) }
#define ACCLNxCalibrateY(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, ACCL_CMD_Y_CAL, __RETVAL__) }
#define ACCLNxCalibrateYEnd(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, ACCL_CMD_Y_CAL_END, __RETVAL__) }
#define ACCLNxCalibrateZ(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, ACCL_CMD_Z_CAL, __RETVAL__) }
#define ACCLNxCalibrateZEnd(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, ACCL_CMD_Z_CAL_END, __RETVAL__) }
#define ACCLNxResetCalibration(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, ACCL_CMD_RESET_CAL, __RETVAL__) }
#define SetACCLNxSensitivity(_port, _i2caddr, _slevel) asm { __I2CSendCmd(_port, _i2caddr, _slevel, __RETVAL__) }
#define ACCLNxSensitivity(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, ACCL_REG_sENS_LVL, 1, __RETVAL__, __TMPBYTE__) }
#define ACCLNxXOffset(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, ACCL_REG_X_OFFSET, 2, __RETVAL__, __TMPBYTE__) }
#define ACCLNxXRange(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, ACCL_REG_X_RANGE, 2, __RETVAL__, __TMPBYTE__) }
#define ACCLNxYOffset(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, ACCL_REG_Y_OFFSET, 2, __RETVAL__, __TMPBYTE__) }
#define ACCLNxYRange(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, ACCL_REG_Y_RANGE, 2, __RETVAL__, __TMPBYTE__) }
#define ACCLNxZOffset(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, ACCL_REG_Z_OFFSET, 2, __RETVAL__, __TMPBYTE__) }
#define ACCLNxZRange(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, ACCL_REG_Z_RANGE, 2, __RETVAL__, __TMPBYTE__) }

#define PFMateSend(_port, _i2caddr, _channel, _motors, _cmdA, _spdA, _cmdB, _spdB) asm { __PFMateSend(_port, _i2caddr, _channel, _motors, _cmdA, _spdA, _cmdB, _spdB, __RETVAL__) }
#define PFMateSendRaw(_port, _i2caddr, _channel, _b1, _b2) asm { __PFMateSendRaw(_port, _i2caddr, _channel, _b1, _b2, __RETVAL__) }

#define NXTServoPosition(_port, _i2caddr, _servo) asm { __MSReadValue(_port, _i2caddr, NXTSERVO_REG_S1_POS+(_servo*2), 2, __RETVAL__, __TMPBYTE__) }
#define NXTServoSpeed(_port, _i2caddr, _servo) asm { __MSReadValue(_port, _i2caddr, NXTSERVO_REG_S1_SPEED+_servo, 1, __RETVAL__, __TMPBYTE__) }
#define NXTServoBatteryVoltage(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTSERVO_REG_VOLTAGE, 1, __RETVAL__, __TMPBYTE__) }
#define SetNXTServoSpeed(_port, _i2caddr, _servo, _speed) asm { __MSWriteToRegister(_port, _i2caddr, NXTSERVO_REG_S1_SPEED+_servo, _speed, __RETVAL__) }
#define SetNXTServoQuickPosition(_port, _i2caddr, _servo, _qpos) asm { __MSWriteToRegister(_port, _i2caddr, NXTSERVO_REG_S1_QPOS+_servo, _qpos, __RETVAL__) }
#define SetNXTServoPosition(_port, _i2caddr, _servo, _pos) asm { __MSWriteLEIntToRegister(_port, _i2caddr, NXTSERVO_REG_S1_POS+(_servo*2), _pos, __RETVAL__) }
#define NXTServoReset(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_RESET, __RETVAL__) }
#define NXTServoHaltMacro(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_HALT, __RETVAL__) }
#define NXTServoResumeMacro(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_RESUME, __RETVAL__) }
#define NXTServoPauseMacro(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTSERVO_CMD_PAUSE, __RETVAL__) }
#define NXTServoInit(_port, _i2caddr, _servo) asm { __NXTServoInit(_port, _i2caddr, _servo, __RETVAL__) }
#define NXTServoGotoMacroAddress(_port, _i2caddr, _macro) asm { __NXTServoGotoMacroAddress(_port, _i2caddr, _macro, __RETVAL__) }
#define NXTServoEditMacro(_port, _i2caddr) asm { __NXTServoEditMacro(_port, _i2caddr, __RETVAL__) }
#define NXTServoQuitEdit(_port) asm { __MSWriteToRegister(_port, MS_ADDR_NXTSERVO_EM, NXTSERVO_EM_REG_CMD, NXTSERVO_EM_CMD_QUIT, __RETVAL__) }

#define NXTHIDAsciiMode(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTHID_CMD_ASCII, __RETVAL__) }
#define NXTHIDDirectMode(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTHID_CMD_DIRECT, __RETVAL__) }
#define NXTHIDTransmit(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTHID_CMD_TRANSMIT, __RETVAL__) }
#define NXTHIDLoadCharacter(_port, _i2caddr, _modifier, _character) asm { __NXTHIDLoadCharacter(_port, _i2caddr, _modifier, _character, __RETVAL__) }

#define NXTPowerMeterResetCounters(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTPM_CMD_RESET, __RETVAL__) }
#define NXTPowerMeterPresentCurrent(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_CURRENT, 2, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterPresentVoltage(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_VOLTAGE, 2, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterCapacityUsed(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_CAPACITY, 2, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterPresentPower(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_POWER, 2, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterTotalPowerConsumed(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_POWER, 4, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterMaxCurrent(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_MAXCURRENT, 2, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterMinCurrent(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_MINCURRENT, 2, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterMaxVoltage(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_MAXVOLTAGE, 2, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterMinVoltage(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_MINVOLTAGE, 2, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterElapsedTime(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_TIME, 4, __RETVAL__, __TMPBYTE__) }
#define NXTPowerMeterErrorCount(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTPM_REG_ERRORCOUNT, 2, __RETVAL__, __TMPBYTE__) }

#define NXTLineLeaderSteering(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTLL_REG_STEERING, 1, __RETVAL__, __TMPBYTE__) }
#define NXTLineLeaderAverage(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTLL_REG_AVERAGE, 1, __RETVAL__, __TMPBYTE__) }
#define NXTLineLeaderResult(_port, _i2caddr) asm { __MSReadValue(_port, _i2caddr, NXTLL_REG_RESULT, 1, __RETVAL__, __TMPBYTE__) }
#define NXTLineLeaderPowerDown(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_POWERDOWN, __RETVAL__) }
#define NXTLineLeaderPowerUp(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_POWERUP, __RETVAL__) }
#define NXTLineLeaderInvert(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_INVERT, __RETVAL__) }
#define NXTLineLeaderReset(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_RESET, __RETVAL__) }
#define NXTLineLeaderSnapshot(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_SNAPSHOT, __RETVAL__) }
#define NXTLineLeaderCalibrateWhite(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_WHITE, __RETVAL__) }
#define NXTLineLeaderCalibrateBlack(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NXTLL_CMD_BLACK, __RETVAL__) }
#define SetNXTLineLeaderSetpoint(_port, _i2caddr, _value) asm { __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_SETPOINT, _value, __RETVAL__) }
#define SetNXTLineLeaderKpValue(_port, _i2caddr, _value) asm { __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KP_VALUE, _value, __RETVAL__) }
#define SetNXTLineLeaderKiValue(_port, _i2caddr, _value) asm { __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KI_VALUE, _value, __RETVAL__) }
#define SetNXTLineLeaderKdValue(_port, _i2caddr, _value) asm { __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KD_VALUE, _value, __RETVAL__) }
#define SetNXTLineLeaderKpFactor(_port, _i2caddr, _value) asm { __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KP_FACTOR, _value, __RETVAL__) }
#define SetNXTLineLeaderKiFactor(_port, _i2caddr, _value) asm { __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KI_FACTOR, _value, __RETVAL__) }
#define SetNXTLineLeaderKdFactor(_port, _i2caddr, _value) asm { __MSWriteToRegister(_port, _i2caddr, NXTLL_REG_KD_FACTOR, _value, __RETVAL__) }

#define PSPNxDigital(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, PSP_CMD_DIGITAL, __RETVAL__) }
#define PSPNxAnalog(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, PSP_CMD_ANALOG, __RETVAL__) }

#define ReadSensorMSPlayStation(_port, _i2caddr, _b1, _b2, _xleft, _yleft, _xright, _yright) asm { __ReadSensorMSPlayStation(_port, _i2caddr, _b1, _b2, _xleft, _yleft, _xright, _yright, __RETVAL__) }

#define NRLink2400(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_2400, __RETVAL__) }
#define NRLink4800(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_4800, __RETVAL__) }
#define NRLinkFlush(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_FLUSH, __RETVAL__) }
#define NRLinkIRLong(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_IR_LONG, __RETVAL__) }
#define NRLinkIRShort(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_IR_SHORT, __RETVAL__) }
#define NRLinkTxRaw(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_TX_RAW, __RETVAL__) }
#define NRLinkSetRCX(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_SET_RCX, __RETVAL__) }
#define NRLinkSetTrain(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_SET_TRAIN, __RETVAL__) }
#define NRLinkSetPF(_port, _i2caddr) asm { __I2CSendCmd(_port, _i2caddr, NRLINK_CMD_SET_PF, __RETVAL__) }

#define RunNRLinkMacro(_port, _i2caddr, _macro) asm { __RunNRLinkMacro(_port, _i2caddr, _macro, __RETVAL__) }

#define NRLinkStatus(_port, _i2caddr) asm { ReadNRLinkStatus(_port, _i2caddr, __RETVAL__, __TMPBYTE__) }

#define WriteNRLinkBytes(_port, _i2caddr, _bytes) asm { __WriteNRLinkBytes(_port, _i2caddr, _bytes, __RETVAL__) }
#define ReadNRLinkBytes(_port, _i2caddr, _bytes) asm { __ReadNRLinkBytes(_port, _i2caddr, _bytes, __RETVAL__) }

#define MSPFComboDirect(_port, _i2caddr, _channel, _outa, _outb) asm { __MSPFComboDirect(_port, _i2caddr, _channel, _outa, _outb, __RETVAL__) }
#define MSPFSinglePin(_port, _i2caddr, _channel, _out, _pin, _func, _cont) asm { __MSPFSinglePin(_port, _i2caddr, _channel, _out, _pin, _func, _cont, __RETVAL__) }
#define MSPFSingleOutputCST(_port, _i2caddr, _channel, _out, _func) asm { __MSPFSingleOutput(_port, _i2caddr, _channel, _out, _func, TRUE, __RETVAL__) }
#define MSPFSingleOutputPWM(_port, _i2caddr, _channel, _out, _func) asm { __MSPFSingleOutput(_port, _i2caddr, _channel, _out, _func, FALSE, __RETVAL__) }
#define MSPFComboPWM(_port, _i2caddr, _channel, _outa, _outb) asm { __MSPFComboPWM(_port, _i2caddr, _channel, _outa, _outb, __RETVAL__) }
#define MSPFTrain(_port, _i2caddr, _channel, _func) asm { __MSIRTrain(_port, _i2caddr, _channel, _func, TRUE, __RETVAL__) }
#define MSIRTrain(_port, _i2caddr, _channel, _func) asm { __MSIRTrain(_port, _i2caddr, _channel, _func, FALSE, __RETVAL__) }
#define MSPFRawOutput(_port, _i2caddr, _nibble0, _nibble1, _nibble2) asm { __MSPFRawOutput(_port, _i2caddr, _nibble0, _nibble1, _nibble2, __RETVAL__) }
#define MSPFRepeat(_port, _i2caddr, _count, _delay) asm { __MSPFRepeatLastCommand(_port, _i2caddr, _count, _delay, __RETVAL__) }

#define MSRCXSetNRLinkPort(_port, _i2caddr) asm { __MSRCXSetNRLink(_port, _i2caddr) }
#define MSRCXPoll(_src, _value) asm { __MSRCXPoll(_src, _value, __RETVAL__) }
#define MSRCXBatteryLevel() asm { __MSRCXBatteryLevel(__RETVAL__) }
#define MSRCXPing() asm { __MSRCXOpNoArgs(RCX_PingOp) }
#define MSRCXDeleteTasks() asm { __MSRCXOpNoArgs(RCX_DeleteTasksOp) }
#define MSRCXStopAllTasks() asm { __MSRCXOpNoArgs(RCX_StopAllTasksOp) }
#define MSRCXPBTurnOff() asm { __MSRCXOpNoArgs(RCX_PBTurnOffOp) }
#define MSRCXDeleteSubs() asm { __MSRCXOpNoArgs(RCX_DeleteSubsOp) }
#define MSRCXClearSound() asm { __MSRCXOpNoArgs(RCX_ClearSoundOp) }
#define MSRCXClearMsg() asm { __MSRCXOpNoArgs(RCX_ClearMsgOp) }
#define MSRCXMuteSound() asm { __MSRCXOpNoArgs(RCX_MuteSoundOp) }
#define MSRCXUnmuteSound() asm { __MSRCXOpNoArgs(RCX_UnmuteSoundOp) }
#define MSRCXClearAllEvents() asm { __MSRCXOpNoArgs(RCX_ClearAllEventsOp) }
#define MSRCXSetOutput(_outputs, _mode) asm { __MSRCXSetOutput(_outputs, _mode) }
#define MSRCXSetDirection(_outputs, _dir) asm { __MSRCXSetDirection(_outputs, _dir) }
#define MSRCXSetPower(_outputs, _pwrsrc, _pwrval) asm { __MSRCXSetPower(_outputs, _pwrsrc, _pwrval) }
#define MSRCXOn(_outputs) asm { __MSRCXSetOutput(_outputs, RCX_OUT_ON) }
#define MSRCXOff(_outputs) asm { __MSRCXSetOutput(_outputs, RCX_OUT_OFF) }
#define MSRCXFloat(_outputs) asm { __MSRCXSetOutput(_outputs, RCX_OUT_FLOAT) }
#define MSRCXToggle(_outputs) asm { __MSRCXSetDirection(_outputs, RCX_OUT_TOGGLE) }
#define MSRCXFwd(_outputs) asm { __MSRCXSetDirection(_outputs, RCX_OUT_FWD) }
#define MSRCXRev(_outputs) asm { __MSRCXSetDirection(_outputs, RCX_OUT_REV) }
#define MSRCXOnFwd(_outputs) asm { __MSRCXOnFwd(_outputs) }
#define MSRCXOnRev(_outputs) asm { __MSRCXOnRev(_outputs) }
#define MSRCXOnFor(_outputs, _ms) asm { __MSRCXOnFor(_outputs, _ms) }
#define MSRCXSetTxPower(_pwr) asm { __MSRCXSetTxPower(_pwr) }
#define MSRCXPlaySound(_snd) asm { __MSRCXPlaySound(_snd) }
#define MSRCXDeleteTask(_t) asm { __MSRCXDeleteTask(_t) }
#define MSRCXStartTask(_t) asm { __MSRCXStartTask(_t) }
#define MSRCXStopTask(_t) asm { __MSRCXStopTask(_t) }
#define MSRCXSelectProgram(_prog) asm { __MSRCXSelectProgram(_prog) }
#define MSRCXClearTimer(_timer) asm { __MSRCXClearTimer(_timer) }
#define MSRCXSetSleepTime(_t) asm { __MSRCXSetSleepTime(_t) }
#define MSRCXDeleteSub(_s) asm { __MSRCXDeleteSub(_s) }
#define MSRCXClearSensor(_port) asm { __MSRCXClearSensor(_port) }
#define MSRCXPlayToneVar(_varnum, _duration) asm { __MSRCXPlayToneVar(_varnum, _duration) }
#define MSRCXSetWatch(_hours, _minutes) asm { __MSRCXSetWatch(_hours, _minutes) }
#define MSRCXSetSensorType(_port, _type) asm { __MSRCXSetSensorType(_port, _type) }
#define MSRCXSetSensorMode(_port, _mode) asm { __MSRCXSetSensorMode(_port, _mode) }
#define MSRCXCreateDatalog(_size) asm { __MSRCXCreateDatalog(_size) }
#define MSRCXAddToDatalog(_src, _value) asm { __MSRCXAddToDatalog(_src, _value) }
#define MSRCXSendSerial(_first, _count) asm { __MSRCXSendSerial(_first, _count) }
#define MSRCXRemote(_cmd) asm { __MSRCXRemote(_cmd) }
#define MSRCXEvent(_src, _value) asm { __MSRCXEvent(_src, _value) }
#define MSRCXPlayTone(_freq, _duration) asm { __MSRCXPlayTone(_freq, _duration) }
#define MSRCXSelectDisplay(_src, _value) asm { __MSRCXSelectDisplay(_src, _value) }
#define MSRCXPollMemory(_memaddress) asm { __MSRCXPollMemory(_memaddress, __RETVAL__) }
#define MSRCXSetEvent(_evt, _src, _type) asm { __MSRCXSetEvent(_evt, _src, _type) }
#define MSRCXSetGlobalOutput(_outputs, _mode) asm { __MSRCXSetGlobalOutput(_outputs, _mode) }
#define MSRCXSetGlobalDirection(_outputs, _dir) asm { __MSRCXSetGlobalDirection(_outputs, _dir) }
#define MSRCXSetMaxPower(_outputs, _pwrsrc, _pwrval) asm { __MSRCXSetMaxPower(_outputs, _pwrsrc, _pwrval) }
#define MSRCXEnableOutput(_outputs) asm { __MSRCXSetGlobalOutput(_outputs, RCX_OUT_ON) }
#define MSRCXDisableOutput(_outputs) asm { __MSRCXSetGlobalOutput(_outputs, RCX_OUT_OFF) }
#define MSRCXInvertOutput(_outputs) asm { __MSRCXSetGlobalDirection(_outputs, RCX_OUT_REV) }
#define MSRCXObvertOutput(_outputs) asm { __MSRCXSetGlobalDirection(_outputs, RCX_OUT_FWD) }
#define MSRCXCalibrateEvent(_evt, _low, _hi, _hyst) asm { __MSRCXCalibrateEvent(_evt, _low, _hi, _hyst) }
#define MSRCXSetVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_SetVarOp, _varnum, _src, _value) }
#define MSRCXSumVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_SumVarOp, _varnum, _src, _value) }
#define MSRCXSubVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_SubVarOp, _varnum, _src, _value) }
#define MSRCXDivVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_DivVarOp, _varnum, _src, _value) }
#define MSRCXMulVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_MulVarOp, _varnum, _src, _value) }
#define MSRCXSgnVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_SgnVarOp, _varnum, _src, _value) }
#define MSRCXAbsVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_AbsVarOp, _varnum, _src, _value) }
#define MSRCXAndVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_AndVarOp, _varnum, _src, _value) }
#define MSRCXOrVar(_varnum, _src, _value) asm { __MSRCXVarOp(RCX_OrVarOp, _varnum, _src, _value) }
#define MSRCXSet(_dstsrc, _dstval, _src, _value) asm { __MSRCXSet(_dstsrc, _dstval, _src, _value) }
#define MSRCXUnlock() asm { __MSRCXUnlock() }
#define MSRCXReset() asm { __MSRCXReset() }
#define MSRCXBoot() asm { __MSRCXBoot() }
#define MSRCXSetUserDisplay(_src, _value, _precision) asm { __MSRCXSetUserDisplay(_src, _value, _precision) }
#define MSRCXIncCounter(_counter) asm { __MSRCXIncCounter(_counter) }
#define MSRCXDecCounter(_counter) asm { __MSRCXDecCounter(_counter) }
#define MSRCXClearCounter(_counter) asm { __MSRCXClearCounter(_counter) }
#define MSRCXSetPriority(_p) asm { __MSRCXSetPriority(_p) }
#define MSRCXSetMessage(_msg) asm { __MSRCXSetMessage(_msg) }

#define MSScoutCalibrateSensor() asm { __MSRCXOpNoArgs(RCX_LSCalibrateOp) }
#define MSScoutMuteSound() asm { __MSScoutMuteSound() }
#define MSScoutUnmuteSound() asm { __MSScoutUnmuteSound() }
#define MSScoutSelectSounds(_grp) asm { __MSScoutSelectSounds(_grp) }
#define MSScoutSetLight(_x) asm { __MSScoutSetLight(_x) }
#define MSScoutSetCounterLimit(_ctr, _src, _value) asm { __MSScoutSetCounterLimit(_ctr, _src, _value) }
#define MSScoutSetTimerLimit(_tmr, _src, _value) asm { __MSScoutSetTimerLimit(_tmr, _src, _value) }
#define MSScoutSetSensorClickTime(_src, _value) asm { __MSScoutSetSensorClickTime(_src, _value) }
#define MSScoutSetSensorHysteresis(_src, _value) asm { __MSScoutSetSensorHysteresis(_src, _value) }
#define MSScoutSetSensorLowerLimit(_src, _value) asm { __MSScoutSetSensorLowerLimit(_src, _value) }
#define MSScoutSetSensorUpperLimit(_src, _value) asm { __MSScoutSetSensorUpperLimit(_src, _value) }
#define MSScoutSetEventFeedback(_src, _value) asm { __MSScoutSetEventFeedback(_src, _value) }
#define MSScoutSendVLL(_src, _value) asm { __MSScoutSendVLL(_src, _value) }
#define MSScoutSetScoutRules(_m, _t, _l, _tm, _fx) asm { __MSScoutSetScoutRules(_m, _t, _l, _tm, _fx) }
#define MSScoutSetScoutMode(_mode) asm { __MSScoutSetScoutMode(_mode) }

#endif

/** @} */ // end of MindSensorsAPI group

///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// Codatex API ///////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup CodatexAPI
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * RFIDInit function.
 * Initialize the Codatex RFID sensor.
 *
 * \param port The port to which the Codatex RFID sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \return The boolean function call result.
 */
inline bool RFIDInit(const byte & port);

/**
 * RFIDMode function.
 * Configure the Codatex RFID sensor mode.
 *
 * \param port The port to which the Codatex RFID sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param mode The RFID sensor mode.  See the \ref CTRFIDModeConstants group.
 * \return The boolean function call result.
 */
inline bool RFIDMode(const byte & port, const byte & mode);

/**
 * RFIDStatus function.
 * Read the Codatex RFID sensor status.
 *
 * \param port The port to which the Codatex RFID sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \return The RFID sensor status.
 */
inline byte RFIDStatus(const byte & port);

/**
 * RFIDRead function.
 * Read the Codatex RFID sensor value.
 *
 * \param port The port to which the Codatex RFID sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param output The five bytes of RFID data.
 * \return The boolean function call result.
 */
inline bool RFIDRead(const byte & port, byte & output[]);

/**
 * RFIDStop function.
 * Stop the Codatex RFID sensor.
 *
 * \param port The port to which the Codatex RFID sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \return The boolean function call result.
 */
inline bool RFIDStop(const byte & port);

/**
 * RFIDReadSingle function.
 * Set the Codatex RFID sensor into single mode and read the RFID data.
 *
 * \param port The port to which the Codatex RFID sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param output The five bytes of RFID data.
 * \return The boolean function call result.
 */
inline bool RFIDReadSingle(const byte & port, byte & output[]);

/**
 * RFIDReadContinuous function.
 * Set the Codatex RFID sensor into continuous mode, if necessary, and read
 * the RFID data.
 *
 * \param port The port to which the Codatex RFID sensor is attached. See the
 * \ref InPorts group. You may use a constant or a variable.
 * \param output The five bytes of RFID data.
 * \return The boolean function call result.
 */
inline bool RFIDReadContinuous(const byte & port, byte & output[]);

#else

#define RFIDInit(_port) asm { __RFIDInit(_port, __RETVAL__) }
#define RFIDMode(_port, _mode) asm { __RFIDMode(_port, _mode, __RETVAL__) }
#define RFIDStatus(_port) asm { __RFIDStatus(_port, __RETVAL__) }
#define RFIDRead(_port, _output) asm { __RFIDRead(_port, _output, __RETVAL__) }
#define RFIDStop(_port) asm { __RFIDStop(_port, __RETVAL__) }
#define RFIDReadSingle(_port, _output) asm { __RFIDReadSingle(_port, _output, __RETVAL__) }
#define RFIDReadContinuous(_port, _output) asm { __RFIDReadContinuous(_port, _output, __RETVAL__) }

#endif

/** @} */ // end of CodatexAPI group

///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// Dexter Industries API /////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup DexterIndustriesAPI
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * SensorDIGPSStatus function.
 * Read the status of the GPS satellite link.
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The boolean GPS status
 */
inline bool SensorDIGPSStatus(byte port);

/**
 * SensorDIGPSTime function.
 * Read the current time reported by the GPS in UTC.
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The current time in UTC
 */
inline long SensorDIGPSTime(byte port);

/**
 * SensorDIGPSLatitude function.
 * Read the integer latitude reported by the GPS
 * (dddddddd; Positive = North; Negative = South).
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The integer latitude
 */
inline long SensorDIGPSLatitude(byte port);

/**
 * SensorDIGPSLongitude function.
 * Read the integer longitude reported by the GPS
 * (ddddddddd; Positive = East; Negative = West).
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The integer longitude
 */
inline long SensorDIGPSLongitude(byte port);

/**
 * SensorDIGPSVelocity function.
 * Read the current velocity in cm/s.
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The current velocity in cm/s
 */
inline long SensorDIGPSVelocity(byte port);

/**
 * SensorDIGPSHeading function.
 * Read the current heading in degrees.
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The current heading in degrees
 */
inline int SensorDIGPSHeading(byte port);

/**
 * SensorDIGPSDistanceToWaypoint function.
 * Read the distance remaining to reach the current waypoint in meters.
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The distance to the waypoint in meters
 */
inline long SensorDIGPSDistanceToWaypoint(byte port);

/**
 * SensorDIGPSHeadingToWaypoint function.
 * Read the heading required to reach the current waypoint.
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The heading to the waypoint in degrees
 */
inline int SensorDIGPSHeadingToWaypoint(byte port);

/**
 * SensorDIGPSRelativeHeading function.
 * Read the angle travelled since last request. Resets the request coordinates
 * on the GPS sensor. Sends the angle of travel since the last call.
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The relative heading in degrees
 */
inline int SensorDIGPSRelativeHeading(byte port);

/**
 * SetSensorDIGPSWaypoint function.
 * Set the coordinates of the waypoint destination. The GPS sensor uses
 * this to calculate the heading and distance required to reach
 * the waypoint.
 *
 * \param port The port to which the Dexter Industries GPS sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param latitude The latitude of the waypoint.
 * \param longitude The longitude of the waypoint.
 * \return The boolean function call result.
 */
inline bool SetSensorDIGPSWaypoint(byte port, long latitude, long longitude);

/**
 * SetSensorDIGyroEx function.
 * Configure DIGyro device on the specified port with the specified scale,
 * output data rate, and bandwidth.
 *
 * \param port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param scale The full scale of the device (250dps, 500dps, or 2000dps).
 * See the \ref DIIMUGyroCtrl4Constants group. You may use a constant or a variable.
 * \param odr The output data rate of the device (100hz, 200hz, 400hz, or 800hz).
 * See the \ref DIIMUGyroCtrl1Constants group. You may use a constant or a variable.
 * \param bw The bandwidth of the device.
 * See the \ref DIIMUGyroCtrl1Constants group. You may use a constant or a variable.
 * \return The boolean function call result.
 */
inline bool SetSensorDIGyroEx(const byte port, byte scale, byte odr, byte bw);

/**
 * SetSensorDIGyro function.
 * Configure DIGyro device on the specified port with default scale of 500dps,
 * output data rate of 100hz, and bandwidth level 1.
 *
 * \param port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The boolean function call result.
 */
inline bool SetSensorDIGyro(const byte port);

/**
 * ReadSensorDIGyroRaw function.
 * Read the raw Dexter Industries IMU Gyro X, Y, and Z axis values.
 *
 * \param port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param vector A variable of type VectorType which will contain the raw X, Y, anx Z values.
 * \return The boolean function call result.
 */
inline bool ReadSensorDIGyroRaw(const byte port, VectorType & vector);

/**
 * ReadSensorDIGyro function.
 * Read the scaled Dexter Industries IMU Gyro X, Y, and Z axis values.
 *
 * \param port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param vector A variable of type VectorType which will contain the scaled X, Y, anx Z values.
 * \return The boolean function call result.
 */
inline bool ReadSensorDIGyro(const byte port, VectorType & vector);

/**
 * SensorDIGyroTemperature function.
 * Read the Dexter Industries IMU Gyro temperature value.
 *
 * \param port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The temperature value.
 */
inline int SensorDIGyroTemperature(const byte port);

/**
 * SensorDIGyroStatus function.
 * Read the Dexter Industries IMU Gyro status value.
 *
 * \param port The port to which the Dexter Industries IMU Gyro sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The status value.
 */
inline byte SensorDIGyroStatus(const byte port);



/**
 * SetSensorDIAcclEx function.
 * Configure DIAccl device on the specified port with the specified mode.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param mode The mode of the device (2G, 4G, or 8G).
 * See the \ref DIIMUAccelModeConstants group. You may use a constant or a variable.
 * \return The boolean function call result.
 */
inline bool SetSensorDIAcclEx(const byte port, byte mode);

/**
 * SetSensorDIAccl function.
 * Configure DIAccl device on the specified port with default mode of 2G.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The boolean function call result.
 */
inline bool SetSensorDIAccl(const byte port);

/**
 * ReadSensorDIAcclRaw function.
 * Read the raw Dexter Industries IMU Accl X, Y, and Z axis 10-bit values.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param vector A variable of type VectorType which will contain the raw X, Y, anx Z 10-bit values.
 * \return The boolean function call result.
 */
inline bool ReadSensorDIAcclRaw(const byte port, VectorType & vector);

/**
 * ReadSensorDIAccl function.
 * Read the scaled Dexter Industries IMU Accl X, Y, and Z axis 10-bit values.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param vector A variable of type VectorType which will contain the scaled X, Y, anx Z 10-bit values.
 * \return The boolean function call result.
 */
inline bool ReadSensorDIAccl(const byte port, VectorType & vector);

/**
 * ReadSensorDIAccl8Raw function.
 * Read the raw Dexter Industries IMU Accl X, Y, and Z axis 8-bit values.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param vector A variable of type VectorType which will contain the raw X, Y, anx Z 8-bit values.
 * \return The boolean function call result.
 */
inline bool ReadSensorDIAccl8Raw(const byte port, VectorType & vector);

/**
 * ReadSensorDIAccl8 function.
 * Read the scaled Dexter Industries IMU Accl X, Y, and Z axis 8-bit values.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param vector A variable of type VectorType which will contain the scaled X, Y, anx Z 8-bit values.
 * \return The boolean function call result.
 */
inline bool ReadSensorDIAccl8(const byte port, VectorType & vector);

/**
 * SensorDIAcclStatus function.
 * Read the Dexter Industries IMU Accl status value.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \return The status value.
 */
inline byte SensorDIAcclStatus(const byte port);

/**
 * ReadSensorDIAcclDrift function.
 * Read the Dexter Industries IMU Accl X, Y, and Z axis 10-bit drift values.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param x The X axis 10-bit drift value.
 * \param y The Y axis 10-bit drift value.
 * \param z The Z axis 10-bit drift value.
 * \return The boolean function call result.
 */
inline bool ReadSensorDIAcclDrift(const byte port, int & x, int & y, int & z);

/**
 * SetSensorDIAcclDrift function.
 * Set the Dexter Industries IMU Accl X, Y, and Z axis 10-bit drift values.
 *
 * \param port The port to which the Dexter Industries IMU Accl sensor is attached.
 * See the \ref InPorts group. You may use a constant or a variable.
 * \param x The X axis 10-bit drift value.
 * \param y The Y axis 10-bit drift value.
 * \param z The Z axis 10-bit drift value.
 * \return The boolean function call result.
 */
inline bool SetSensorDIAcclDrift(const byte port, int x, int y, int z);


#else

#define SensorDIGPSStatus(_port) asm { __ReadSensorDIGPSStatus(_port, __RETVAL__) }
#define SensorDIGPSTime(_port) asm { __ReadSensorDIGPSTime(_port, __RETVAL__) }
#define SensorDIGPSLatitude(_port) asm { __ReadSensorDIGPSLatitude(_port, __RETVAL__) }
#define SensorDIGPSLongitude(_port) asm { __ReadSensorDIGPSLongitude(_port, __RETVAL__) }
#define SensorDIGPSVelocity(_port) asm { __ReadSensorDIGPSVelocity(_port, __RETVAL__) }
#define SensorDIGPSHeading(_port) asm { __ReadSensorDIGPSHeading(_port, __RETVAL__) }
#define SensorDIGPSDistanceToWaypoint(_port) asm { __ReadSensorDIGPSDistanceToWaypoint(_port, __RETVAL__) }
#define SensorDIGPSHeadingToWaypoint(_port) asm { __ReadSensorDIGPSHeadingToWaypoint(_port, __RETVAL__) }
#define SensorDIGPSRelativeHeading(_port) asm { __ReadSensorDIGPSRelativeHeading(_port, __RETVAL__) }
#define SetSensorDIGPSWaypoint(_port, _lat, _long) asm { __SetSensorDIGPSWaypoint(_port, _lat, _long, __RETVAL__) }

#define SetSensorDIGyroEx(_port, _scale, _odr, _bw) asm { __SetSensorDIGyro(_port, _scale, _odr, _bw, __RETVAL__) }
#define SetSensorDIGyro(_port) asm { __SetSensorDIGyro(_port, DIGYRO_CTRL4_SCALE_500, DIGYRO_CTRL1_DATARATE_100, DIGYRO_CTRL1_BANDWIDTH_1, __RETVAL__) }
#define ReadSensorDIGyroRaw(_port, _vector) asm { __ReadSensorDIGyroRaw(_port, _vector, __RETVAL__) }
#define ReadSensorDIGyro(_port, _vector) asm { __ReadSensorDIGyro(_port, _vector, __RETVAL__) }
#define SensorDIGyroStatus(_port) asm { __ReadSensorDIGyroStatus(_port, __RETVAL__, __TMPBYTE__) }
#define SensorDIGyroTemperature(_port) asm { __ReadSensorDIGyroTemperature(_port, __RETVAL__, __TMPBYTE__) }


#define SetSensorDIAcclEx(_port, _mode) asm { __SetSensorDIAccl(_port, _mode, __RETVAL__) }
#define SetSensorDIAccl(_port) asm { __SetSensorDIAccl(_port, DIACCL_MODE_GLVL2, __RETVAL__) }
#define ReadSensorDIAcclRaw(_port, _vector) asm { __ReadSensorDIAcclRaw(_port, DIACCL_REG_XLOW, _vector, __RETVAL__) }
#define ReadSensorDIAccl(_port, _vector) asm { __ReadSensorDIAccl(_port, _vector, __RETVAL__) }
#define ReadSensorDIAccl8Raw(_port, _vector) asm { __ReadSensorDIAccl8Raw(_port, _vector, __RETVAL__) }
#define ReadSensorDIAccl8(_port, _vector) asm { __ReadSensorDIAccl8(_port, _vector, __RETVAL__) }
#define SensorDIAcclStatus(_port) asm { __ReadSensorDIAcclStatus(_port, __RETVAL__, __TMPBYTE__) }
#define ReadSensorDIAcclDrift(_port, _x, _y, _z) asm { __ReadSensorDIAcclDrift(_port, _x, _y, _z, __RETVAL__) }
#define SetSensorDIAcclDrift(_port, _x, _y, _z) asm { __SetSensorDIAcclDrift(_port, _x, _y, _z, __RETVAL__) }



#endif

/** @} */  // end of DexterIndustriesAPI group


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////// Microinfinity API /////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @addtogroup MicroinfinityAPI
 * @{
 */

/** @defgroup MicroinfinityTypes Microinfinity types
 * Types used by various Microinfinity device functions.
 * @{
 */

/**
 * Parameters for the \ref ReadSensorMIXG1300L function.
 * This structure is used when calling the \ref ReadSensorMIXG1300L function.
 * After calling the function read the sensor values from the various
 * structure fields.  The values are all scaled by 100.
 */
struct XGPacketType {
  int AccAngle; /*!< The accumulated angle. */
  int TurnRate; /*!< The turn rate. */
  int XAxis;    /*!< The X axis acceleration. */
  int YAxis;    /*!< The Y axis acceleration. */
  int ZAxis;    /*!< The Z axis acceleration. */
};

/** @} */ // end of MicroinfinityTypes group

/** @defgroup MicroinfinityFunctions Microinfinity functions
 * Functions for interfacing with Microinfinity devices.
 * @{
 */
#ifdef __DOXYGEN_DOCS

/**
 * ResetMIXG1300L function.
 * Reset the Microinfinity CruizCore XG1300L device.
 *
 * During reset, the XG1300L will recomputed the bias drift value, therefore
 * it must remain stationary. The bias drift value will change randomly over
 * time due to temperature variations, however the internal algorithm in
 * the XG1300L will compensate for these changes. We strongly recommend
 * issuing a reset command to the XG1300L at the beginning of the program.
 *
 * The reset function also resets the accumulate angle value to a zero. Since
 * the accelerometers measurements are taken with respect to the sensor
 * reference frame the reset function will have no effect in the accelerometer
 * measurements.
 *
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See the \ref InPorts group.
 * \return The boolean function call result.
 */
inline bool ResetMIXG1300L(byte port);

/**
 * SensorMIXG1300LScale function.
 * Read the Microinfinity CruizCore XG1300L accelerometer scale.
 * The accelerometer in the CruizCore XG1300L can be set to operate with a
 * scale ranging from +/-2G, +/-4G, or +/-8G.
 * Returns the scale value that the device is currently configured to use.
 * The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See the \ref InPorts group.
 * \return The current scale value.
 */
inline int SensorMIXG1300LScale(byte port);

/**
 * SetSensorMIXG1300LScale function.
 * Set the Microinfinity CruizCore XG1300L accelerometer scale.
 * The accelerometer in the CruizCore XG1300L can be set to operate with a
 * scale ranging from +/-2G, +/-4G, or +/-8G.
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See the \ref InPorts group.
 * \param scale This value must be a constant.  See \ref XG1300LScaleConstants.
 * \return The boolean function call result.
 */
inline bool SetSensorMIXG1300LScale(byte port, const byte scale);

/**
 * ReadSensorMIXG1300L function.
 * Read Microinfinity CruizCore XG1300L values.
 * Read accumulated angle, turn rate, and X, Y, and Z axis acceleration values
 * from the Microinfinity CruizCore XG1300L sensor.
 * Returns a boolean value indicating whether or not the operation
 * completed successfully. The port must be configured as a Lowspeed port
 * before using this function.
 *
 * \param port The sensor port. See the \ref InPorts group.
 * \param packet The output XK1300L data structure.  See \ref XGPacketType.
 * \return The boolean function call result.
 */
inline bool ReadSensorMIXG1300L(byte port, XGPacketType & packet);

#else

#define ResetMIXG1300L(_port) asm { __ResetMIXG1300L(_port, __RETVAL__) }
#define SensorMIXG1300LScale(_port) asm { __ReadSensorMIXG1300LScale(_port, __RETVAL__) }
#define SetSensorMIXG1300LScale(_port, _scale) asm { __SetSensorMIXG1300LScale(_port, _scale, __RETVAL__) }
#define ReadSensorMIXG1300L(_port, _packet) asm { \
  compchktype _packet, XGPacketType \
  __ReadSensorMIXG1300L(_port, _packet, __RETVAL__) \
}

#endif

/** @} */ // end of MicroinfinityFunctions group
/** @} */  // end of MicroinfinityAPI group

/** @} */ // end of ThirdPartyDevices group



/** @addtogroup StandardCAPIFunctions
 * @{
 */

///////////////////////////////////////////////////////////////////////////////
////////////////////////////////// cmath API //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @defgroup cmathAPI cmath API
 * Standard C cmath API functions.
 * @{
 */

/**
 * This structure is used for storing three axis values in a single object.
 */
struct VectorType {
  float X;    /*!< The X axis value. */
  float Y;    /*!< The Y axis value. */
  float Z;    /*!< The Z axis value. */
};


#if __FIRMWARE_VERSION > 107

/**
 * Compute square root.
 * Computes the square root of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use sqrt() instead.
 * \param _X Floating point value.
 * \return Square root of _X.
 */
#define Sqrt(_X) asm { sqrt __FLTRETVAL__, _X }

/**
 * Compute square root.
 * Computes the square root of x.
 *
 * \param x Floating point value.
 * \return Square root of x.
 */
inline float sqrt(float x) { asm { sqrt __FLTRETVAL__, x } }

#ifdef __ENHANCED_FIRMWARE

/**
 * Compute sine.
 * Computes the sine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use sin() instead.
 * \param _X Floating point value.
 * \return Sine of _X.
 */
#define Sin(_X) asm { sin __FLTRETVAL__, _X }

/**
 * Compute cosine.
 * Computes the cosine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use cos() instead.
 * \param _X Floating point value.
 * \return Cosine of _X.
 */
#define Cos(_X) asm { cos __FLTRETVAL__, _X }

/**
 * Compute arc sine.
 * Computes the arc sine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use asin() instead.
 * \param _X Floating point value.
 * \return Arc sine of _X.
 */
#define Asin(_X) asm { asin __FLTRETVAL__, _X }

/**
 * Compute arc cosine.
 * Computes the arc cosine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use acos() instead.
 * \param _X Floating point value.
 * \return Arc cosine of _X.
 */
#define Acos(_X) asm { acos __FLTRETVAL__, _X }

/**
 * Compute arc tangent.
 * Computes the arc tangent of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use atan() instead.
 * \param _X Floating point value.
 * \return Arc tangent of _X.
 */
#define Atan(_X) asm { atan __FLTRETVAL__, _X }

/**
 * Round up value.
 * Computes the smallest integral value that is not less than _X.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use ceil() instead.
 * \param _X Floating point value.
 * \return The smallest integral value not less than _X.
 */
#define Ceil(_X) asm { ceil __FLTRETVAL__, _X }

/**
 * Compute exponential function .
 * Computes the base-e exponential function of _X, which is the e number
 * raised to the power _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use exp() instead.
 * \param _X Floating point value.
 * \return Exponential value of _X.
 */
#define Exp(_X) asm { exp __FLTRETVAL__, _X }

/**
 * Round down value.
 * Computes the largest integral value that is not greater than _X.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use floor() instead.
 * \param _X Floating point value.
 * \return The largest integral value not greater than _X.
 */
#define Floor(_X) asm { floor __FLTRETVAL__, _X }

/**
 * Compute tangent.
 * Computes the tangent of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use tan() instead.
 * \param _X Floating point value.
 * \return Tangent of _X.
 */
#define Tan(_X) asm { tan __FLTRETVAL__, _X }

/**
 * Compute hyperbolic tangent.
 * Computes the hyperbolic tangent of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use tanh() instead.
 * \param _X Floating point value.
 * \return Hyperbolic tangent of _X.
 */
#define Tanh(_X) asm { tanh __FLTRETVAL__, _X }

/**
 * Compute hyperbolic cosine.
 * Computes the hyperbolic cosine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use cosh() instead.
 * \param _X Floating point value.
 * \return Hyperbolic cosine of _X.
 */
#define Cosh(_X) asm { cosh __FLTRETVAL__, _X }

/**
 * Compute hyperbolic sine.
 * Computes the hyperbolic sine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use sinh() instead.
 * \param _X Floating point value.
 * \return Hyperbolic sine of _X.
 */
#define Sinh(_X) asm { sinh __FLTRETVAL__, _X }

/**
 * Compute natural logarithm.
 * Computes the natural logarithm of _X. The natural logarithm is the base-e
 * logarithm, the inverse of the natural exponential function (exp). For
 * base-10 logarithms, a specific function Log10() exists.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use log() instead.
 * \param _X Floating point value.
 * \return Natural logarithm of _X.
 */
#define Log(_X) asm { log __FLTRETVAL__, _X }

/**
 * Compute common logarithm.
 * Computes the common logarithm of _X. The common logarithm is the base-10
 * logarithm. For base-e logarithms, a specific function Log() exists.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use log10() instead.
 * \param _X Floating point value.
 * \return Common logarithm of _X.
 */
#define Log10(_X) asm { log10 __FLTRETVAL__, _X }

/**
 * Compute arc tangent with 2 parameters.
 * Computes the principal value of the arc tangent of _Y/_X, expressed in
 * radians. To compute the value, the function uses the sign of both arguments
 * to determine the quadrant.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use atan2() instead.
 * \param _Y Floating point value representing a y coordinate.
 * \param _X Floating point value representing an x coordinate.
 * \return Arc tangent of _Y/_X, in the interval [-pi,+pi] radians.
 */
#define Atan2(_Y,_X) asm { atan2 __FLTRETVAL__, _Y, _X }

/**
 * Raise to power.
 * Computes _Base raised to the power _Exponent.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use pow() instead.
 * \param _Base Floating point value.
 * \param _Exponent Floating point value.
 * \return The result of raising _Base to the power _Exponent.
 */
#define Pow(_Base,_Exponent) asm { pow __FLTRETVAL__, _Base, _Exponent }

/**
 * Compute integral part.
 * Computes the integral part of _X.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use trunc() instead.
 * \param _X Floating point value.
 * \return Integral part of _X.
 */
#define Trunc(_X) asm { trunc __RETVAL__, _X }

/**
 * Compute fractional part.
 * Computes the fractional part of _X.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use frac() instead.
 * \param _X Floating point value.
 * \return Fractional part of _X.
 */
#define Frac(_X) asm { frac __FLTRETVAL__, _X }

/**
 * Multiply and divide.
 * Multiplies two 32-bit values and then divides the 64-bit result by a third
 * 32-bit value.
 * Only constants or variables allowed (no expressions).
 *
 * \deprecated Use muldiv32() instead.
 * \param _A 32-bit long value.
 * \param _B 32-bit long value.
 * \param _C 32-bit long value.
 * \return The result of multiplying _A times _B and dividing by _C.
 */
#define MulDiv32(_A,_B,_C) asm { muldiv __RETVAL__, _A, _B, _C }

/**
 * Compute sine (degrees).
 * Computes the sine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use sind() instead.
 * \param _X Floating point value.
 * \return Sine of _X.
 */
#define SinD(_X) asm { sind __FLTRETVAL__, _X }

/**
 * Compute cosine (degrees).
 * Computes the cosine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use cosd() instead.
 * \param _X Floating point value.
 * \return Cosine of _X.
 */
#define CosD(_X) asm { cosd __FLTRETVAL__, _X }

/**
 * Compute arch sine (degrees).
 * Computes the arc sine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use asind() instead.
 * \param _X Floating point value.
 * \return Arc sine of _X.
 */
#define AsinD(_X) asm { asind __FLTRETVAL__, _X }

/**
 * Compute arc cosine (degrees).
 * Computes the arc cosine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use acosd() instead.
 * \param _X Floating point value.
 * \return Arc cosine of _X.
 */
#define AcosD(_X) asm { acosd __FLTRETVAL__, _X }

/**
 * Compute arc tangent (degrees).
 * Computes the arc tangent of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use atand() instead.
 * \param _X Floating point value.
 * \return Arc tangent of _X.
 */
#define AtanD(_X) asm { atand __FLTRETVAL__, _X }

/**
 * Compute tangent (degrees).
 * Computes the sine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use tand() instead.
 * \param _X Floating point value.
 * \return Tangent of _X.
 */
#define TanD(_X) asm { tand __FLTRETVAL__, _X }

/**
 * Compute hyperbolic tangent (degrees).
 * Computes the hyperbolic tangent of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use tanhd() instead.
 * \param _X Floating point value.
 * \return Hyperbolic tangent of _X.
 */
#define TanhD(_X) asm { tanhd __FLTRETVAL__, _X }

/**
 * Compute hyperbolic cosine (degrees).
 * Computes the hyperbolic cosine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use coshd() instead.
 * \param _X Floating point value.
 * \return Hyperbolic cosine of _X.
 */
#define CoshD(_X) asm { coshd __FLTRETVAL__, _X }

/**
 * Compute hyperbolic sine (degrees).
 * Computes the hyperbolic sine of _X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use sinhd() instead.
 * \param _X Floating point value.
 * \return Hyperbolic sine of _X.
 */
#define SinhD(_X) asm { sinhd __FLTRETVAL__, _X }

/**
 * Compute arc tangent with two parameters (degrees).
 * Computes the arc tangent of _Y/_X. Only constants or variables allowed
 * (no expressions).
 *
 * \deprecated Use atan2d() instead.
 * \param _Y Floating point value.
 * \param _X Floating point value.
 * \return Arc tangent of _Y/_X, in the interval [-180,+180] degrees.
 */
#define Atan2D(_Y,_X) asm { atan2d __FLTRETVAL__, _Y, _X }

/**
 * Compute cosine.
 * Computes the cosine of an angle of x radians.
 *
 * \param x Floating point value representing an angle expressed in radians.
 * \return Cosine of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float cos(float x) { asm { cos __FLTRETVAL__, x } }

/**
 * Compute sine.
 * Computes the sine of an angle of x radians.
 *
 * \param x Floating point value representing an angle expressed in radians.
 * \return Sine of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float sin(float x) { asm { sin __FLTRETVAL__, x } }

/**
 * Compute tangent.
 * Computes the tangent of an angle of x radians.
 *
 * \param x Floating point value representing an angle expressed in radians.
 * \return Tangent of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float tan(float x) { asm { tan __FLTRETVAL__, x } }

/**
 * Compute arc cosine.
 * Computes the principal value of the arc cosine of x, expressed in radians.
 * In trigonometrics, arc cosine is the inverse operation of cosine.
 *
 * \param x Floating point value in the interval [-1,+1].
 * \return Arc cosine of x, in the interval [0,pi] radians.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float acos(float x) { asm { acos __FLTRETVAL__, x } }

/**
 * Compute arc sine.
 * Computes the principal value of the arc sine of x, expressed in radians.
 * In trigonometrics, arc sine is the inverse operation of sine.
 *
 * \param x Floating point value in the interval [-1,+1].
 * \return Arc sine of x, in the interval [-pi/2,+pi/2] radians.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float asin(float x) { asm { asin __FLTRETVAL__, x } }

/**
 * Compute arc tangent.
 * Computes the principal value of the arc tangent of x, expressed in radians.
 * In trigonometrics, arc tangent is the inverse operation of tangent. Notice
 * that because of the sign ambiguity, a function cannot determine with
 * certainty in which quadrant the angle falls only by its tangent value.
 * You can use atan2() if you need to determine the quadrant.
 *
 * \sa atan2()
 * \param x Floating point value.
 * \return Arc tangent of x, in the interval [-pi/2,+pi/2] radians.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float atan(float x) { asm { atan __FLTRETVAL__, x } }

/**
 * Compute arc tangent with 2 parameters.
 * Computes the principal value of the arc tangent of y/x, expressed in
 * radians. To compute the value, the function uses the sign of both arguments
 * to determine the quadrant.
 *
 * \sa atan()
 * \param y Floating point value representing a y coordinate.
 * \param x Floating point value representing an x coordinate.
 * \return Arc tangent of y/x, in the interval [-pi,+pi] radians.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float atan2(float y, float x) { asm { atan2 __FLTRETVAL__, y, x } }

/**
 * Compute hyperbolic cosine.
 * Computes the hyperbolic cosine of x, expressed in radians.
 *
 * \param x Floating point value.
 * \return Hyperbolic cosine of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float cosh(float x) { asm { cosh __FLTRETVAL__, x } }

/**
 * Compute hyperbolic sine.
 * Computes the hyperbolic sine of x, expressed in radians.
 *
 * \param x Floating point value.
 * \return Hyperbolic sine of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float sinh(float x) { asm { sinh __FLTRETVAL__, x } }

/**
 * Compute hyperbolic tangent.
 * Computes the hyperbolic tangent of x, expressed in radians.
 *
 * \param x Floating point value.
 * \return Hyperbolic tangent of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float tanh(float x) { asm { tanh __FLTRETVAL__, x } }

/**
 * Compute exponential function.
 * Computes the base-e exponential function of x, which is the e number
 * raised to the power x.
 *
 * \param x Floating point value.
 * \return Exponential value of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float exp(float x) { asm { exp __FLTRETVAL__, x } }

/**
 * Compute natural logarithm.
 * Computes the natural logarithm of x. The natural logarithm is the base-e
 * logarithm, the inverse of the natural exponential function (exp). For
 * base-10 logarithms, a specific function log10() exists.
 *
 * \sa log10(), exp()
 * \param x Floating point value.
 * \return Natural logarithm of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float log(float x) { asm { log __FLTRETVAL__, x } }

/**
 * Compute common logarithm.
 * Computes the common logarithm of x. The common logarithm is the base-10
 * logarithm. For base-e logarithms, a specific function log() exists.
 *
 * \sa log(), exp()
 * \param x Floating point value.
 * \return Common logarithm of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float log10(float x) { asm { log10 __FLTRETVAL__, x } }

/**
 * Compute integral part.
 * Computes the integral part of x.
 *
 * \param x Floating point value.
 * \return Integral part of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline long trunc(float x) { asm { trunc __RETVAL__, x } }

/**
 * Compute fractional part.
 * Computes the fractional part of x.
 *
 * \param x Floating point value.
 * \return Fractional part of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float frac(float x) { asm { frac __FLTRETVAL__, x } }

/**
 * Raise to power.
 * Computes base raised to the power exponent.
 *
 * \param base Floating point value.
 * \param exponent Floating point value.
 * \return The result of raising base to the power exponent.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float pow(float base, float exponent) { asm { pow __FLTRETVAL__, base, exponent } }

/**
 * Round up value.
 * Computes the smallest integral value that is not less than x.
 *
 * \param x Floating point value.
 * \return The smallest integral value not less than x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float ceil(float x) { asm { ceil __FLTRETVAL__, x } }

/**
 * Round down value.
 * Computes the largest integral value that is not greater than x.
 *
 * \param x Floating point value.
 * \return The largest integral value not greater than x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float floor(float x) { asm { floor __FLTRETVAL__, x } }

/**
 * Multiply and divide.
 * Multiplies two 32-bit values and then divides the 64-bit result by a third
 * 32-bit value.
 *
 * \param a 32-bit long value.
 * \param b 32-bit long value.
 * \param c 32-bit long value.
 * \return The result of multiplying a times b and dividing by c.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline long muldiv32(long a, long b, long c) { asm { muldiv __RETVAL__, a, b, c } }

// degree-based trig functions

/**
 * Compute cosine (degrees).
 * Computes the cosine of an angle of x degrees.
 *
 * \param x Floating point value representing an angle expressed in degrees.
 * \return Cosine of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float cosd(float x) { asm { cosd __FLTRETVAL__, x } }

/**
 * Compute sine (degrees).
 * Computes the sine of an angle of x degrees.
 *
 * \param x Floating point value representing an angle expressed in degrees.
 * \return Sine of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float sind(float x) { asm { sind __FLTRETVAL__, x } }

/**
 * Compute tangent (degrees).
 * Computes the tangent of an angle of x degrees.
 *
 * \param x Floating point value representing an angle expressed in degrees.
 * \return Tangent of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float tand(float x) { asm { tand __FLTRETVAL__, x } }

/**
 * Compute arc cosine (degrees).
 * Computes the principal value of the arc cosine of x, expressed in degrees.
 * In trigonometrics, arc cosine is the inverse operation of cosine.
 *
 * \param x Floating point value in the interval [-1,+1].
 * \return Arc cosine of x, in the interval [0,180] degrees.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float acosd(float x) { asm { acosd __FLTRETVAL__, x } }

/**
 * Compute arc sine (degrees).
 * Computes the principal value of the arc sine of x, expressed in degrees.
 * In trigonometrics, arc sine is the inverse operation of sine.
 *
 * \param x Floating point value in the interval [-1,+1].
 * \return Arc sine of x, in the interval [-90,+90] degrees.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float asind(float x) { asm { asind __FLTRETVAL__, x } }

/**
 * Compute arc tangent (degrees).
 * Computes the principal value of the arc tangent of x, expressed in degrees.
 * In trigonometrics, arc tangent is the inverse operation of tangent. Notice
 * that because of the sign ambiguity, a function cannot determine with
 * certainty in which quadrant the angle falls only by its tangent value.
 * You can use atan2d if you need to determine the quadrant.
 *
 * \param x Floating point value.
 * \return Arc tangent of x, in the interval [-90,+90] degrees.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float atand(float x) { asm { atand __FLTRETVAL__, x } }

/**
 * Compute arc tangent with 2 parameters (degrees).
 * Computes the principal value of the arc tangent of y/x, expressed in
 * degrees. To compute the value, the function uses the sign of both arguments
 * to determine the quadrant.
 *
 * \param y Floating point value representing a y coordinate.
 * \param x Floating point value representing an x coordinate.
 * \return Arc tangent of y/x, in the interval [-180,+180] degrees.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float atan2d(float y, float x) { asm { atan2d __FLTRETVAL__, y, x } }

/**
 * Compute hyperbolic cosine (degrees).
 * Computes the hyperbolic cosine of x, expressed in degrees.
 *
 * \param x Floating point value.
 * \return Hyperbolic cosine of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float coshd(float x) { asm { coshd __FLTRETVAL__, x } }

/**
 * Compute hyperbolic sine (degrees).
 * Computes the hyperbolic sine of x, expressed in degrees.
 *
 * \param x Floating point value.
 * \return Hyperbolic sine of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float sinhd(float x) { asm { sinhd __FLTRETVAL__, x } }

/**
 * Compute hyperbolic tangent (degrees).
 * Computes the hyperbolic tangent of x, expressed in degrees.
 *
 * \param x Floating point value.
 * \return Hyperbolic tangent of x.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline float tanhd(float x) { asm { tanhd __FLTRETVAL__, x } }

#endif

#else

// math functions written by Tamas Sorosy (www.sorosy.com)

// X is any integer; Y is the sqrt value (0->max); if X<0, Y is the sqrt value of absolute X
#define Sqrt(_X) asm { __SQRT(_X,__RETVAL__) }

#endif

#if (__FIRMWARE_VERSION <= 107) || !defined(__ENHANCED_FIRMWARE)

// X is any integer in degrees; Y is 100* the sin value (-100->100)
#define Sin(_X) asm { __SIN(_X,__RETVAL__) }

// X is any integer in degrees; Y is 100* the cos value (-100->100)
#define Cos(_X) asm { __COS(_X,__RETVAL__) }

// X is 100* the sin value (-100->100); Y is -90->90; Y is 101 if X is outside -100->100 range
#define Asin(_X) asm { __ASIN(_X,__RETVAL__) }

// X is 100* the cos value (-100->100); Y is 0->180; Y is -11 if X is outside -100->100 range
#define Acos(_X) asm { __ACOS(_X,__RETVAL__) }

#endif

/**
 * Convert from BCD to decimal
 * Return the decimal equivalent of the binary coded decimal value provided.
 *
 * \param bcd The value you want to convert from bcd to decimal.
 * \return The decimal equivalent of the binary coded decimal byte.
 */
inline byte bcd2dec(byte bcd) { asm { __bcd2dec(bcd, __URETVAL__) } }

#ifdef __DOXYGEN_DOCS

/**
 * Is the value NaN.
 * Returns true if the floating point value is NaN (not a number).
 *
 * \param value A floating point variable.
 * \return Whether the value is NaN.
 */
inline bool isNAN(float value);

/**
 * Sign value.
 * Return the sign of the value argument (-1, 0, or 1). Any scalar type can
 * be passed into this function.
 *
 * \param num The numeric value for which to calculate its sign value.
 * \return -1 if the parameter is negative, 0 if the parameter is zero, or 1 if
 * the parameter is positive.
 */
inline char sign(variant num);

/**
 * VectorCross function.
 * Calculate the cross-product of two vectors.
 *
 * \param a A variable of type VectorType
 * \param b A variable of type VectorType
 * \param out The cross-product vector.
 */
inline void VectorCross(VectorType a, VectorType b, VectorType & out);

/**
 * VectorDot function.
 * Calculate the dot-product of two vectors.
 *
 * \param a A variable of type VectorType
 * \param b A variable of type VectorType
 */
inline float VectorDot(VectorType a, VectorType b);

/**
 * VectorNormalize function.
 * Normalize the vector.
 *
 * \param a A variable of type VectorType
 */
inline void VectorNormalize(VectorType & a);

#else

#define isNAN(_x) ((_x) != (_x))

#define VectorCross(_a, _b, _out) asm { __VectorCross(_a, _b, _out) }
#define VectorDot(_a, _b) asm { __VectorDot(_a, _b, __FLTRETVAL__) }
#define VectorNormalize(_a) asm { __VectorNormalize(_a) }

#endif

/** @} */ // end of cmathAPI group


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// cstdio API //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @defgroup cstdioAPI cstdio API
 * Standard C cstdio API functions.
 * @{
 */
/**
 * Close file.
 * Close the file associated with the specified file handle. The loader
 * result code is returned as the value of the function call.
 *
 * \param handle The handle of the file to be closed.
 * \return The loader result code.
 */
inline int fclose(byte handle) { return CloseFile(handle); }

/**
 * Remove file.
 * Delete the specified file. The loader result code is returned as the value
 * of the function call.
 *
 * \param filename The name of the file to be deleted.
 * \return The loader result code.
 */
inline int remove(string filename) { return DeleteFile(filename); }

/**
 * Rename file.
 * Rename a file from the old filename to the new filename. The loader
 * result code is returned as the value of the function call.
 *
 * \param old The name of the file to be renamed.
 * \param new The new name for the file.
 * \return The loader result code.
 */
inline int rename(string old, string new) { return RenameFile(old, new); }

/**
 * Get character from file.
 * Returns the character currently pointed to by the internal file position
 * indicator of the file specified by the handle. The internal file position
 * indicator is then advanced by one character to point to the next character.
 * The functions fgetc and getc are equivalent.
 *
 * \param handle The handle of the file from which the character is read.
 * \return The character read from the file.
 */
inline char fgetc(byte handle) {
  char ch;
  asm {
    __readValue(handle, ch, __RETVAL__)
    mov __RETVAL__, ch
  }
}

/**
 * Get character from file.
 * Returns the character currently pointed to by the internal file position
 * indicator of the file specified by the handle. The internal file position
 * indicator is then advanced by one character to point to the next character.
 * The functions fgetc and getc are equivalent.
 *
 * \param _handle The handle of the file from which the character is read.
 * \return The character read from the file.
 */
#define getc(_handle) fgetc(_handle)

/**
 * Get string from file.
 * Reads characters from a file and stores them as a string into str until
 * (num-1) characters have been read or either a newline or a the End-of-File
 * is reached, whichever comes first. A newline character makes fgets stop
 * reading, but it is considered a valid character and therefore it is
 * included in the string copied to str. A null character is automatically
 * appended in str after the characters read to signal the end of the string.
 * Returns the string parameter.
 *
 * \param str The string where the characters are stored.
 * \param num The maximum number of characters to be read.
 * \param handle The handle of the file from which the characters are read.
 * \return The string read from the file.
 */
inline string fgets(string & str, int num, byte handle) {
  asm { __readLnStringEx(handle, str, num, __RETVAL__) };
  return str;
}

/**
 * Check End-of-file indicator.
 * Checks whether the End-of-File indicator associated with the handle is
 * set, returning a value different from zero if it is.
 *
 * \param handle The handle of the file to check.
 * \return Currently always returns 0.
 */
inline int feof(byte handle) { return 0; }

unsigned long __fopen_default_size = 1024;

/**
 * Set the default fopen file size.
 * Set the default size of a file created via a call to fopen.
 *
 * \param fsize The default new file size for fopen.
 */
inline void set_fopen_size(unsigned long fsize) { __fopen_default_size = fsize; }

/**
 * Open file.
 * Opens the file whose name is specified in the parameter filename and
 * associates it with a file handle that can be identified in future
 * operations by the handle that is returned. The operations that are allowed
 * on the stream and how these are performed are defined by the mode parameter.
 *
 * \param filename The name of the file to be opened.
 * \param mode The file access mode. Valid values are "r" - opens an existing
 * file for reading, "w" - creates a new file and opens it for writing, and
 * "a" - opens an existing file for appending to the end of the file.
 * \return The handle to the opened file.
 */
byte fopen(string filename, const string mode) {
  byte handle;
  int result = LDR_ILLEGALHANDLE;
  unsigned long fsize;
  switch(mode) {
    case "r" :
      result = OpenFileRead(filename, fsize, handle);
      break;
    case "w" :
      fsize  = __fopen_default_size;
      result = CreateFile(filename, fsize, handle);
      break;
    case "a" :
      result = OpenFileAppend(filename, fsize, handle);
      break;
  }
  if (result != LDR_SUCCESS)
    handle = NULL;
  return handle;
}

/**
 * Flush file.
 * Writes any buffered data to the file. A zero value indicates success.
 *
 * \param handle The handle of the file to be flushed.
 * \return Currently always returns 0.
 */
inline int fflush(byte handle) { return 0; }

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/**
 * Get current position in file.
 * Returns the current value of the file position indicator of the specified
 * handle.
 *
 * \param handle The handle of the file.
 * \return The current file position in the open file.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+.
 */
inline unsigned long ftell(byte handle) {
  FileTellType ftt;
  ftt.FileHandle = handle;
  SysFileTell(ftt);
  return ftt.Position;
}
#endif

/**
 * Write character to file.
 * Writes a character to the file and advances the position indicator.
 * The character is written at the current position of the file as indicated
 * by the internal position indicator, which is then advanced one character.
 * If there are no errors, the same character that has been written is
 * returned. If an error occurs, EOF is returned.
 *
 * \param ch The character to be written.
 * \param handle The handle of the file where the character is to be written.
 * \return The character written to the file.
 */
inline char fputc(char ch, byte handle) {
  if (Write(handle, ch) == LDR_SUCCESS)
    return ch;
  else
    return EOF;
}

/**
 * Write character to file.
 * Writes a character to the file and advances the position indicator.
 * The character is written at the current position of the file as indicated
 * by the internal position indicator, which is then advanced one character.
 * If there are no errors, the same character that has been written is
 * returned. If an error occurs, EOF is returned.
 *
 * \param _ch The character to be written.
 * \param _handle The handle of the file where the character is to be written.
 * \return The character written to the file.
 */
#define putc(_ch, _handle) fputc(_ch, _handle)

/**
 * Write string to file.
 * Writes the string to the file specified by the handle. The null terminating
 * character at the end of the string is not written to the file. If there are
 * no errors, a non-negative value is returned. If an error occurs, EOF is
 * returned.
 *
 * \param str The string of characters to be written.
 * \param handle The handle of the file where the string is to be written.
 * \return The number of characters written to the file.
 */
inline int fputs(string str, byte handle) {
  int cnt;
  if (WriteString(handle, str, cnt) == LDR_SUCCESS)
    return cnt;
  else
    return EOF;
}

#ifdef __ENHANCED_FIRMWARE

#ifdef __DOXYGEN_DOCS

/**
 * Print formatted data to stdout.
 * Writes to the LCD at 0, LCD_LINE1 a sequence of data formatted as the
 * format argument specifies. After the format parameter, the function
 * expects one value argument.
 *
 * \param format A string specifying the desired format.
 * \param value A value to be formatted for writing to the LCD.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void printf(string format, variant value);

/**
 * Write formatted data to file.
 * Writes a sequence of data formatted as the format argument specifies to a
 * file. After the format parameter, the function expects one value
 * argument.
 *
 * \param handle The handle of the file to write to.
 * \param format A string specifying the desired format.
 * \param value A value to be formatted for writing to the file.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void fprintf(byte handle, string format, variant value);

/**
 * Write formatted data to string.
 * Writes a sequence of data formatted as the format argument specifies to a
 * string. After the format parameter, the function expects one value
 * argument.
 *
 * \param str The string to write to.
 * \param format A string specifying the desired format.
 * \param value A value to be formatted for writing to the string.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline void sprintf(string & str, string format, variant value);

#else

#define printf(_format, _value) { \
  string msg = FormatNum(_format, _value); \
  TextOut(0, LCD_LINE1, msg); \
}
#define fprintf(_handle, _format, _value) { \
  int cnt = fputs(FormatNum(_format, _value), _handle); \
}
#define sprintf(_str, _format, _value) { \
  _str = FormatNum(_format, _value); \
}

#endif

#if __FIRMWARE_VERSION > 107

/** @defgroup fseekConstants fseek origin constants
 * Constants for use in calls to fseek.
 * @{
 */
#define SEEK_SET 0 /*!< Seek from the beginning of the file */
#define SEEK_CUR 1 /*!< Seek from the current file position */
#define SEEK_END 2 /*!< Seek from the end of the file */
/** @} */ // end of fseekConstants group

/**
 * Reposition file position indicator.
 * Sets the position indicator associated with the file to a new position
 * defined by adding offset to a reference position specified by origin.
 *
 * \param handle The handle of the file.
 * \param offset The number of bytes to offset from origin.
 * \param origin Position from where offset is added. It is specified by one
 * of the following constants: SEEK_SET - beginning of file, SEEK_CUR - current
 * position of the file pointer, or SEEK_END - end of file. \ref fseekConstants
 * \return A value of zero if successful or non-zero otherwise. See \ref LoaderErrors.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline int fseek(byte handle, long offset, int origin) {
  FileSeekType fst;
  fst.FileHandle = handle;
  fst.Origin = origin;
  fst.Length = offset;
  SysFileSeek(fst);
  return fst.Result;
}

/**
 * Set position indicator to the beginning.
 * Sets the position indicator associated with stream to the beginning of
 * the file.
 *
 * \param handle The handle of the file.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 */
inline void rewind(byte handle) { fseek(handle, 0, SEEK_SET); }

/**
 * Get character from stdin.
 * Returns the next character from the standard input (stdin).
 * It is equivalent to getc with stdin as its argument. On the NXT this means
 * wait for a button press and return the value of the button pressed.
 *
 * \return The pressed button. See \ref ButtonNameConstants.
 *
 */
inline int getchar() {
  int result = -1;
  while (true) {
    if (ButtonPressed(BTN1, false))
      result = BTN1;
    else if (ButtonPressed(BTN2, false))
      result = BTN2;
    else if (ButtonPressed(BTN3, false))
      result = BTN3;
    else if (ButtonPressed(BTN4, false))
      result = BTN4;
    if (result != -1)
      break;
    else
      Yield();
  }
  while(ButtonPressed(result, false));
  return result;
}


#endif
#endif

/*
  size_t fread(ptr, size, count, FILE*); // read blocks of data from file; returns number of blocks read
  size_t fwrite(ptr, size, count, FILE*); // write blocks of data to stream; returns number of blocks written
  int putchar(int character); // write character to stdout
*/



/** @} */ // end of cstdioAPI group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// cstdlib API //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @defgroup cstdlibAPI cstdlib API
 * Standard C cstdlib API functions and types.
 * @{
 */

/** @defgroup cstdlibAPITypes cstdlib API types
 * Standard C cstdlib API types.
 * @{
 */

/**
 * Parameters for the RandomNumber system call.
 * This structure is used when calling the \ref SysRandomNumber system call
 * function.
 * \sa SysRandomNumber()
 */
struct RandomNumberType {
  int Result; /*!< The random number. */
};

/**
 * Parameters for the RandomEx system call.
 * This structure is used when calling the \ref SysRandomEx system call
 * function.
 * \sa SysRandomEx()
 */
struct RandomExType {
  long Seed;   /*!< The random number or the new seed value. */
  bool ReSeed; /*!< A flag indicating whether or not to seed the random number generator. */
};

/**
 * Output type of the div function.
 * div_t structure.
 * Structure used to represent the value of an integral division performed
 * by div. It has two members of the same type, defined in either order as:
 * int quot; int rem;.
 * \sa div()
 */
struct div_t {
  int quot;  /*!< Represents the quotient of the integral division operation
                  performed by div, which is the integer of lesser magnitude
                  that is nearest to the algebraic quotient. */
  int rem;   /*!< Represents the remainder of the integral division operation
                  performed by div, which is the integer resulting from
                  subtracting quot to the numerator of the operation. */
};

/**
 * Output type of the ldiv function.
 * Structure used to represent the value of an integral division performed
 * by ldiv. It has two members of the same type, defined in either order as:
 * long quot; long rem;.
 * \sa ldiv()
 */
struct ldiv_t {
  long quot;  /*!< Represents the quotient of the integral division operation
                  performed by div, which is the integer of lesser magnitude
                  that is nearest to the algebraic quotient. */
  long rem;   /*!< Represents the remainder of the integral division operation
                  performed by div, which is the integer resulting from
                  subtracting quot to the numerator of the operation. */
};

/** @} */ // end of cstdlibAPITypes group

#ifdef __DOXYGEN_DOCS

/**
 * Abort current process.
 * Aborts the process with an abnormal program termination.
 * The function never returns to its caller.
 */
inline void abort();

/**
 * Absolute value.
 * Return the absolute value of the value argument. Any scalar type can
 * be passed into this function.
 *
 * \param num The numeric value.
 * \return The absolute value of num. The return type matches the input type.
 */
inline variant abs(variant num);

/**
 * Seed the random number generator.
 * Provide the random number generator with a new seed value.
 *
 * \param seed The new random number generator seed. A value of zero
 * causes the seed to be based on the current time value.  A value less
 * than zero causes the seed to be restored to the last specified seed.
 *
 * \return The new seed value (useful if you pass in 0 or -1).
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 */
inline long srand(long seed);

/**
 * Generate random number.
 * Returns a pseudo-random integral number in the range 0 to \ref RAND_MAX.
 *
 * This number is generated by an algorithm that returns a sequence of
 * apparently non-related numbers each time it is called.
 *
 * \return An integer value between 0 and \ref RAND_MAX (inclusive).
 */
inline unsigned long rand();

/**
 * Generate random number.
 * Return a signed or unsigned 16-bit random number. If the optional argument n
 * is not provided the function will return a signed value.  Otherwise the
 * returned value will range between 0 and n (exclusive).
 *
 * \param n The maximum unsigned value desired (optional).
 * \return A random number
 */
inline int Random(unsigned int n = 0);

/**
 * Draw a random number.
 * This function lets you obtain a random number via the \ref RandomNumberType
 * structure.
 *
 * \param args The RandomNumberType structure receiving results.
 */
inline void SysRandomNumber(RandomNumberType & args);

/**
 * Call the enhanced random number function.
 * This function lets you either obtain a random number or seed the random
 * number generator via the \ref RandomExType structure.
 *
 * \param args The RandomExType structure for passing inputs and receiving
 * output values.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 */
inline void SysRandomEx(RandomExType & args);

#else

#define abort() Stop(true)

#ifdef __ENHANCED_FIRMWARE
#define srand(_s) asm { __SeedRandomEx(_s, __RETVAL__) }
#define rand() asm { __RandomEx(__RETVAL__) }

#define SysRandomEx(_args) asm { \
  compchktype _args, RandomExType \
  syscall RandomEx, _args \
}

#else
#define rand() (Random()+32768)
#endif

#define SysRandomNumber(_args) asm { \
  compchktype _args, RandomNumberType \
  syscall RandomNumber, _args \
}

#endif

/**
 * Convert string to integer.
 * Parses the string str interpreting its content as an integral number,
 * which is returned as an int value.
 *
 * The function first discards as many whitespace characters as necessary
 * until the first non-whitespace character is found. Then, starting from
 * this character, takes an optional initial plus or minus sign followed by as
 * many numerical digits as possible, and interprets them as a numerical value.
 *
 * The string can contain additional characters after those that form the
 * integral number, which are ignored and have no effect on the behavior of
 * this function.
 *
 * If the first sequence of non-whitespace characters in str does not form a
 * valid integral number, or if no such sequence exists
 * because either str is empty or contains only whitespace characters, no
 * conversion is performed.
 *
 * \param str String beginning with the representation of an integral number.
 * \return On success, the function returns the converted integral number
 * as an int value. If no valid conversion could be performed a zero value
 * is returned.
 */
inline int atoi(const string & str) { return StrToNum(str); }

/**
 * Convert string to long integer.
 * Parses the string str interpreting its content as an integral number,
 * which is returned as a long int value.
 *
 * The function first discards as many whitespace characters as necessary
 * until the first non-whitespace character is found. Then, starting from
 * this character, takes an optional initial plus or minus sign followed by as
 * many numerical digits as possible, and interprets them as a numerical value.
 *
 * The string can contain additional characters after those that form the
 * integral number, which are ignored and have no effect on the behavior of
 * this function.
 *
 * If the first sequence of non-whitespace characters in str does not form a
 * valid integral number, or if no such sequence exists
 * because either str is empty or contains only whitespace characters, no
 * conversion is performed.
 *
 * \param str String beginning with the representation of an integral number.
 * \return On success, the function returns the converted integral number
 * as a long int value. If no valid conversion could be performed a zero value
 * is returned.
 */
inline long atol(const string & str) { return StrToNum(str); }

/**
 * Absolute value.
 * Return the absolute value of parameter n.
 *
 * \param n Integral value.
 * \return The absolute value of n.
 */
inline long labs(long n) { return abs(n); }

#if __FIRMWARE_VERSION > 107
/**
 * Convert string to float.
 * Parses the string str interpreting its content as a floating point number
 * and returns its value as a float.
 *
 * The function first discards as many whitespace characters as necessary until
 * the first non-whitespace character is found. Then, starting from this
 * character, takes as many characters as possible that are valid following a
 * syntax resembling that of floating point literals, and interprets them as a
 * numerical value. The rest of the string after the last valid character is
 * ignored and has no effect on the behavior of this function.
 *
 * A valid floating point number for atof is formed by a succession of:
 * - An optional plus or minus sign
 * - A sequence of digits, optionally containing a decimal-point character
 * - An optional exponent part, which itself consists on an 'e' or 'E'
 * character followed by an optional sign and a sequence of digits.
 *
 * If the first sequence of non-whitespace characters in str does not form a
 * valid floating-point number as just defined, or if no such sequence exists
 * because either str is empty or contains only whitespace characters, no
 * conversion is performed.
 *
 * \param str String beginning with the representation of a floating-point number.
 * \return On success, the function returns the converted floating point number
 * as a float value. If no valid conversion could be performed a zero value
 * (0.0) is returned.
 */
inline float atof(const string & str) {
  float result;
  asm { strtonum result, __TMPWORD__, str, NA, NA }
  return result;
}

/**
 * Convert string to float.
 * Parses the string str interpreting its content as a floating point number
 * and returns its value as a float.
 *
 * The function first discards as many whitespace characters as necessary until
 * the first non-whitespace character is found. Then, starting from this
 * character, takes as many characters as possible that are valid following a
 * syntax resembling that of floating point literals, and interprets them as a
 * numerical value. A string containing the rest of the string after the last
 * valid character is stored in endptr.
 *
 * A valid floating point number for atof is formed by a succession of:
 * - An optional plus or minus sign
 * - A sequence of digits, optionally containing a decimal-point character
 * - An optional exponent part, which itself consists on an 'e' or 'E'
 * character followed by an optional sign and a sequence of digits.
 *
 * If the first sequence of non-whitespace characters in str does not form a
 * valid floating-point number as just defined, or if no such sequence exists
 * because either str is empty or contains only whitespace characters, no
 * conversion is performed.
 *
 * \param str String beginning with the representation of a floating-point number.
 * \param endptr Reference to a string, whose value is set by the function to
 * the remaining characters in str after the numerical value.
 * \return On success, the function returns the converted floating point number
 * as a float value. If no valid conversion could be performed a zero value
 * (0.0) is returned.
 */
inline float strtod(const string & str, string & endptr) {
  float result;
  int offsetpast;
  asm {
    strtonum result, offsetpast, str, NA, NA
    strsubset endptr, str, offsetpast, NA
  }
  return result;
}
#endif

/**
 * Convert string to long integer.
 * Parses the C string str interpreting its content as an integral number of
 * the specified base, which is returned as a long int value.
 *
 * The function first discards as many whitespace characters as necessary
 * until the first non-whitespace character is found. Then, starting from this
 * character, takes as many characters as possible that are valid following a
 * syntax that depends on the base parameter, and interprets them as a
 * numerical value. A string containing the rest of the characters following the
 * integer representation in str is stored in endptr.
 *
 * If the first sequence of non-whitespace characters in str does not form a
 * valid integral number, or if no such sequence exists
 * because either str is empty or contains only whitespace characters, no
 * conversion is performed.
 *
 * \param str String beginning with the representation of an integral number.
 * \param endptr Reference to a string, whose value is set by the function to
 * the remaining characters in str after the numerical value.
 * \param base Optional and ignored if specified.
 * \return On success, the function returns the converted integral number
 * as a long int value. If no valid conversion could be performed a zero value
 * is returned.
 * \warning Only base = 10 is currently supported.
 */
inline long strtol(const string & str, string & endptr, int base = 10) {
  long result;
  int offsetpast;
  asm {
    strtonum result, offsetpast, str, NA, NA
    strsubset endptr, str, offsetpast, NA
  }
  return result;
}

/**
 * Convert string to unsigned long integer.
 * Parses the C string str interpreting its content as an unsigned integral
 * number of the specified base, which is returned as an unsigned long int value.
 *
 * The function first discards as many whitespace characters as necessary
 * until the first non-whitespace character is found. Then, starting from this
 * character, takes as many characters as possible that are valid following a
 * syntax that depends on the base parameter, and interprets them as a
 * numerical value. A string containing the rest of the characters following the
 * integer representation in str is stored in endptr.
 *
 * If the first sequence of non-whitespace characters in str does not form a
 * valid integral number, or if no such sequence exists
 * because either str is empty or contains only whitespace characters, no
 * conversion is performed.
 *
 * \param str String containing the representation of an unsigned integral number.
 * \param endptr Reference to a string, whose value is set by the function to
 * the remaining characters in str after the numerical value.
 * \param base Optional and ignored if specified.
 * \return On success, the function returns the converted integral number
 * as an unsigned long int value. If no valid conversion could be performed a
 * zero value is returned.
 * \warning Only base = 10 is currently supported.
 */
inline long strtoul(const string & str, string & endptr, int base = 10) {
  unsigned long result;
  int offsetpast;
  asm {
    strtonum result, offsetpast, str, NA, NA
    strsubset endptr, str, offsetpast, NA
  }
  return result;
}

/**
 * Integral division.
 * Returns the integral quotient and remainder of the division of numerator by
 * denominator as a structure of type div_t, which has two members:
 * quot and rem.
 *
 * \param numer Numerator.
 * \param denom Denominator.
 * \return The result is returned by value in a structure defined in cstdlib,
 * which has two members. For div_t, these are, in either order:
 * int quot; int rem.
 */
inline div_t div(int numer, int denom) {
  div_t result;
  result.quot = numer / denom;
  result.rem  = numer % denom;
  return result;
}

/**
 * Integral division.
 * Returns the integral quotient and remainder of the division of numerator by
 * denominator as a structure of type ldiv_t, which has two members:
 * quot and rem.
 *
 * \param numer Numerator.
 * \param denom Denominator.
 * \return The result is returned by value in a structure defined in cstdlib,
 * which has two members. For ldiv_t, these are, in either order:
 * long quot; long rem.
 */
inline ldiv_t ldiv(long numer, long denom) {
  ldiv_t result;
  result.quot = numer / denom;
  result.rem  = numer % denom;
  return result;
}

/** @} */ // end of cstdlibAPI group


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////// cstring API //////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @defgroup cstringAPI cstring API
 * Standard C cstring API functions.
 * @{
 */

#ifdef __DOXYGEN_DOCS

/**
 * Convert string to number.
 * Return the numeric value specified by the string passed to the function.
 * If the content of the string is not a numeric value then this function
 * returns zero. The input string parameter
 * may be a variable, constant, or expression.
 *
 * \param str String beginning with the representation of a number.
 * \param str A string.
 * \return A number.
 */
inline variant StrToNum(string str);

/**
 * Get string length.
 * Return the length of the specified string. The length of a string does
 * not include the null terminator at the end of the string. The input
 * string parameter may be a variable, constant, or expression.
 *
 * \param str A string.
 * \return The length of the string.
 */
inline unsigned int StrLen(string str);

/**
 * Extract a character from a string.
 * Return the numeric value of the character in the specified string at the
 * specified index. The input string parameter
 * may be a variable, constant, or expression.
 *
 * \param str A string.
 * \param idx The index of the character to retrieve.
 * \return The numeric value of the character at the specified index.
 */
inline byte StrIndex(string str, unsigned int idx);

/**
 * Convert number to string.
 * Return the string representation of the specified numeric value.
 *
 * \param num A number.
 * \return The string representation of the parameter num.
 */
inline string NumToStr(variant num);

/**
 * Concatenate strings.
 * Return a string which is the result of concatenating all of the
 * string arguments together. This function accepts
 * any number of parameters which may be string variables, constants,
 * or expressions.
 *
 * \param str1 The first string.
 * \param str2 The second string.
 * \param strN The Nth string.
 * \return The concatenated string.
 */
inline string StrCat(string str1, string str2, string strN);

/**
 * Extract a portion of a string.
 * Return a sub-string from the specified input string starting at idx and
 * including the specified number of characters. The input string parameter
 * may be a variable, constant, or expression.
 *
 * \param str A string.
 * \param idx The starting point of the sub-string.
 * \param len The length of the sub-string.
 * \return The sub-string extracted from parameter str.
 */
inline string SubStr(string str, unsigned int idx, unsigned int len);

/**
 * Flatten a number to a string.
 * Return a string containing the byte representation of the specified value.
 *
 * \param num A number.
 * \return A string containing the byte representation of the parameter num.
 */
inline string Flatten(variant num);

/**
 * Replace a portion of a string.
 * Return a string with the part of the string replaced (starting at the
 * specified index) with the contents of the new string value provided in
 * the third argument. The input string parameters
 * may be variables, constants, or expressions.
 *
 * \param str A string.
 * \param idx The starting point for the replace operation.
 * \param strnew The replacement string.
 * \return The modified string.
 */
inline string StrReplace(string str, unsigned int idx, string strnew);

/**
 * Format a number.
 * Return the formatted string using the format and value. Use a standard
 * numeric sprintf format specifier within the format string. The input string
 * parameter may be a variable, constant, or expression.
 *
 * \param fmt The string format containing a sprintf numeric format specifier.
 * \param num A number.
 * \return A string containing the formatted numeric value.
 *
 * \warning This function requires the enhanced NBC/NXC firmware.
 */
inline string FormatNum(string fmt, variant num);

/**
 * Flatten any data to a string.
 * Return a string containing the byte representation of the specified value.
 *
 * \sa UnflattenVar
 * \param x Any NXC datatype.
 * \return A string containing the byte representation of the parameter x.
 */
inline string FlattenVar(variant x);

/**
 * Unflatten a string into a data type.
 * Convert a string containing the byte representation of the specified
 * variable back into the original variable type.
 *
 * \sa FlattenVar, Flatten
 * \param str A string containing flattened data.
 * \param x A variable reference where the unflattened data is stored.
 * \return A boolean value indicating whether the operation succeeded or not.
 */
inline int UnflattenVar(string str, variant & x);

#else

#define FlattenVar(_value) asm { flatten __STRRETVAL__, _value }
#define UnflattenVar(_str, _value) asm { \
  unflatten _value, __RETVAL__, _str, _value \
  not __RETVAL__, __RETVAL__ \
}


#endif

/**
 * Find substring position.
 * Returns the index value of the first character in a specified substring
 * that occurs in a given string.  Pos searches for Substr within S and
 * returns an integer value that is the index of the first character of
 * Substr within S. Pos is case-sensitive. If Substr is not found, Pos
 * returns negative one.
 *
 * \param Substr A substring to search for in another string.
 * \param S A string that might contain the specified substring.
 * \return The position of the substring in the specified string or -1 if it is
 * not found.
 */
inline int Pos(string Substr, string S) { asm { __doPos(Substr, S, __RETVAL__) } }

/**
 * Convert a byte array to a string.
 * Convert the specified array to a string by appending a null terminator to
 * the end of the array elements. The array must be a one-dimensional array
 * of byte.
 *
 * \sa StrToByteArray, ByteArrayToStrEx
 * \param data A byte array.
 * \return A string containing data and a null terminator byte.
 */
inline string ByteArrayToStr(byte data[]) { asm { arrtostr __STRBUFFER__, data } }

/**
 * Convert a byte array to a string.
 * Convert the specified array to a string by appending a null terminator to
 * the end of the array elements. The array must be a one-dimensional array
 * of byte.
 *
 * \sa StrToByteArray, ByteArrayToStr
 * \param data A byte array.
 * \param str A string variable reference which, on output, will contain
 * data and a null terminator byte.
 */
inline void ByteArrayToStrEx(byte data[], string & str) { asm { arrtostr str, data } }

/**
 * Convert a string to a byte array.
 * Convert the specified string to an array of byte by removing the null
 * terminator at the end of the string. The output array variable must be a
 * one-dimensional array of byte.
 *
 * \sa ByteArrayToStr, ByteArrayToStrEx
 * \param str A string
 * \param data A byte array reference which, on output, will contain str
 * without its null terminator.
 */
inline void StrToByteArray(string str, byte & data[]) { asm { strtoarr data, str } }

/**
 * Copy a portion of a string.
 * Returns a substring of a string.
 *
 * \param str A string
 * \param idx The starting index of the substring.
 * \param len The length of the substring.
 * \return The specified substring.
 */
inline string Copy(string str, unsigned int idx, unsigned int len) {
  asm { strsubset __STRBUFFER__, str, idx, len  }
}

/**
 * Copy a portion from the middle of a string.
 * Returns the substring of a specified length that appears at a specified
 * position in a string.
 *
 * \param str A string
 * \param idx The starting index of the substring.
 * \param len The length of the substring.
 * \return The substring of a specified length that appears at a specified
 * position in a string.
 */
inline string MidStr(string str, unsigned int idx, unsigned int len) {
  asm { strsubset __STRBUFFER__, str, idx, len  }
}

/**
 * Copy a portion from the end of a string.
 * Returns the substring of a specified length that appears at the end of a string.
 *
 * \param str A string
 * \param size The size or length of the substring.
 * \return The substring of a specified length that appears at the end of a string.
 */
inline string RightStr(string str, unsigned int size) {
  unsigned int idx;
  asm {
    strlen idx, str
    sub idx, idx, size
    strsubset __STRBUFFER__, str, idx, size
  }
}

/**
 * Copy a portion from the start of a string.
 * Returns the substring of a specified length that appears at the start of a string.
 *
 * \param str A string
 * \param size The size or length of the substring.
 * \return The substring of a specified length that appears at the start of a string.
 */
inline string LeftStr(string str, unsigned int size) {
  asm { strsubset __STRBUFFER__, str, 0, size  }
}

// cstring functions

/**
 * Get string length.
 * Return the length of the specified string. The length of a string does
 * not include the null terminator at the end of the string.
 *
 * \param str A string.
 * \return The length of the string.
 */
inline int strlen(const string & str) { asm { strlen __RETVAL__, str } }

/**
 * Concatenate strings.
 * Appends a copy of the source string to the destination string. The
 * terminating null character in destination is overwritten by the first
 * character of source, and a new null-character is appended at the end of
 * the new string formed by the concatenation of both in destination. The
 * destination string is returned.
 *
 * \param dest The destination string.
 * \param src The string to be appended.
 * \return The destination string.
 */
inline string strcat(string & dest, const string & src) {
  asm {
    strcat __STRBUFFER__, dest, src
    mov dest, __STRBUFFER__
  }
}

/**
 * Append characters from string.
 * Appends the first num characters of source to destination, plus a
 * terminating null-character. If the length of the string in source is less
 * than num, only the content up to the terminating null-character is copied.
 * The destination string is returned.
 *
 * \param dest The destination string.
 * \param src The string to be appended.
 * \param num The maximum number of characters to be appended.
 * \return The destination string.
 */
inline string strncat(string & dest, const string & src, unsigned int num) {
  asm {
    strsubset __STRRETVAL__, src, 0, num
    strcat __STRBUFFER__, dest, __STRRETVAL__
    mov dest, __STRBUFFER__
  }
}

/**
 * Copy string.
 * Copies the string pointed by source into the array pointed by destination,
 * including the terminating null character. The destination string is returned.
 *
 * \param dest The destination string.
 * \param src The string to be appended.
 * \return The destination string.
 */
inline string strcpy(string & dest, const string & src) {
  asm {
    mov __STRBUFFER__, src
    mov dest, __STRBUFFER__
  }
}

/**
 * Copy characters from string.
 * Copies the first num characters of source to destination. The destination
 * string is returned.
 *
 * \param dest The destination string.
 * \param src The string to be appended.
 * \param num The maximum number of characters to be appended.
 * \return The destination string.
 */
inline string strncpy(string & dest, const string & src, unsigned int num) {
  asm {
    strsubset dest, src, 0, num
    mov __STRBUFFER__, dest
  }
}

/**
 * Compare two strings.
 * Compares the string str1 to the string str2.
 *
 * \param str1 A string to be compared.
 * \param str2 A string to be compared.
 * \return Returns an integral value indicating the relationship between the
 * strings. A zero value indicates that both strings are equal. A value
 * greater than zero indicates that the first character that does not match
 * has a greater value in str1 than in str2. A value less than zero indicates
 * the opposite.
 */
inline int strcmp(const string & str1, const string & str2) {
  int result = -1;
  if (str1 == str2)
    result = 0;
  else if (str1 > str2)
    result = 1;
  return result;
}

/**
 * Compare characters of two strings.
 * Compares up to num characters of the string str1 to those of the string str2.
 *
 * \param str1 A string to be compared.
 * \param str2 A string to be compared.
 * \param num The maximum number of characters to be compared.
 * \return Returns an integral value indicating the relationship between the
 * strings. A zero value indicates that the characters compared in both
 * strings are all equal. A value greater than zero indicates that the first
 * character that does not match has a greater value in str1 than in str2. A
 * value less than zero indicates the opposite.
 */
inline int strncmp(const string & str1, const string & str2, unsigned int num) {
  string sub1, sub2;
  asm {
    strsubset sub1, str1, 0, num
    strsubset sub2, str2, 0, num
  }
  int result = -1;
  if (sub1 == sub2)
    result = 0;
  else if (sub1 > sub2)
    result = 1;
  return result;
}

#ifdef __DOXYGEN_DOCS

/**
 * Copy memory.
 * Copies memory contents from the source to the destination. The num
 * argument is ignored.
 *
 * \param dest The destination variable.
 * \param src The source variable.
 * \param num The number of bytes to copy (ignored).
 */
inline void memcpy(variant dest, variant src, byte num);

/**
 * Move memory.
 * Moves memory contents from the source to the destination. The num
 * argument is ignored.
 *
 * \param dest The destination variable.
 * \param src The source variable.
 * \param num The number of bytes to copy (ignored).
 */
inline void memmove(variant dest, variant src, byte num);

/**
 * Compare two blocks of memory.
 * Compares the variant ptr1 to the variant ptr2. Returns an integral value
 * indicating the relationship between the variables. The num argument is
 * ignored.
 *
 * \param ptr1 A variable to be compared.
 * \param ptr2 A variable to be compared.
 * \param num The number of bytes to compare (ignored).
 */
inline char memcmp(variant ptr1, variant ptr2, byte num);

/**
 * Get the absolute address of a variable.
 * Get the absolute address of a variable and return it to the calling routine
 * as an unsigned long value.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param data A variable whose address you wish to get.
 * \return The absolute address of the variable.
 */
inline unsigned long addressOf(variant data);

/**
 * Get the relative address of a variable.
 * Get the relative address of a variable and return it to the calling routine
 * as an unsigned long value.  The relative address is an offset from the
 * Command module's MemoryPool address.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param data A variable whose address you wish to get.
 * \return The relative address of the variable.
 */
inline unsigned long reladdressOf(variant data);

/**
 * Get the absolute or relative address of a variable.
 * Get the absolute or relative address of a variable and return it to the
 * calling routine as an unsigned long value. The relative address is an
 * offset from the Command module's MemoryPool address.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.28+.
 *
 * \param data A variable whose address you wish to get.
 * \param relative A boolean flag indicating whether you want to get the
 * relative or absolute address.
 * \return The absolute or relative address of the variable.
 */
inline unsigned long addressOfEx(variant data, bool relative);

#else

#define memcpy(_dest, _src, _num) asm { mov _dest, _src }
#define memmove(_dest, _src, _num) asm { mov _dest, _src }
#define memcmp(_ptr1, _ptr2, _num) ( (_ptr1 == _ptr2) ? 0 : ( (_ptr1 > _ptr2) ? 1 : -1 ) )

#define addressOf(_data) asm { addrof __URETVAL__, _data, 0 }
#define reladdressOf(_data) asm { addrof __URETVAL__, _data, 1 }
#define addressOfEx(_data, _rel) asm { addrof __URETVAL__, _data, _rel }

#endif

/*
void * memchr (void * ptr, int value, size_t num ); // Locate character in block of memory
char * strchr (       char * str, int character ); // Locate first occurrence of character in string
size_t strcspn ( const char * str1, const char * str2 ); // Get span until character in string
char * strpbrk ( const char *, const char * ); // Locate character in string
char * strrchr ( const char *, int ); // Locate last occurrence of character in string
size_t strspn ( const char * str1, const char * str2 ); // Get span of character set in string
char * strtok ( char * str, const char * delimiters ); // Split string into tokens
char * strstr ( const char *, const char * ); // Locate substring

void * memset ( void * ptr, byte value, size_t num ); // Fill block of memory (something like replace)
*/



/** @} */ // end of cstringAPI group


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////// ctype API ///////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


/** @defgroup ctypeAPI ctype API
 * Standard C ctype API functions.
 * @{
 */
/**
 * Check if character is uppercase letter.
 * Checks if parameter c is an uppercase alphabetic letter.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is an uppercase alphabetic
 * letter, otherwise it returns 0 (false).
 */
inline int isupper(int c) { return ((c >= 'A') && (c <= 'Z')); }

/**
 * Check if character is lowercase letter.
 * Checks if parameter c is an lowercase alphabetic letter.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is an lowercase alphabetic
 * letter, otherwise it returns 0 (false).
 */
inline int islower(int c) { return ((c >= 'a') && (c <= 'z')); }

/**
 * Check if character is alphabetic.
 * Checks if parameter c is either an uppercase or lowercase letter.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is an alphabetic letter,
 * otherwise it returns 0 (false).
 */
inline int isalpha(int c) { return isupper(c) || islower(c); }

/**
 * Check if character is decimal digit.
 * Checks if parameter c is a decimal digit character.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is a decimal digit, otherwise
 * it returns 0 (false).
 */
inline int isdigit(int c) { return ((c >= '0') && (c <= '9')); }

/**
 * Check if character is alphanumeric.
 * Checks if parameter c is either a decimal digit or an uppercase or
 * lowercase letter. The result is true if either isalpha or isdigit would
 * also return true.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is either a digit or a
 * letter, otherwise it returns 0 (false).
 */
inline int isalnum(int c) { return isalpha(c) || isdigit(c); }

/**
 * Check if character is a white-space.
 * Checks if parameter c is a white-space character.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is a white-space character,
 * otherwise it returns 0 (false).
 */
inline int isspace(int c) { return (c == 0x20) || ((c >= 0x09) && (c <= 0x0d)); }

/**
 * Check if character is a control character.
 * Checks if parameter c is a control character.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is a control character,
 * otherwise it returns 0 (false).
 */
inline int iscntrl(int c) { return (c <= 0x1f) || (c == 0x7f); }

/**
 * Check if character is printable.
 * Checks if parameter c is a printable character (i.e., not a control
 * character).
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is a printable character,
 * otherwise it returns 0 (false).
 */
inline int isprint(int c) { return !iscntrl(c); }

/**
 * Check if character has graphical representation.
 * Checks if parameter c is a character with a graphical representation.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c has a graphical representation,
 * otherwise it returns 0 (false).
 */
inline int isgraph(int c) { return (c != 0x20) && isprint(c); }

/**
 * Check if character is a punctuation.
 * Checks if parameter c is a punctuation character.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is a punctuation character,
 * otherwise it returns 0 (false).
 */
inline int ispunct(int c) { return isgraph(c) && !isalnum(c); }

/**
 * Check if character is hexadecimal digit.
 * Checks if parameter c is a hexadecimal digit character.
 *
 * \param c Character to be checked.
 * \return Returns a non-zero value (true) if c is a hexadecimal digit
 * character, otherwise it returns 0 (false).
 */
inline int isxdigit(int c) {  return isdigit(c) || ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')); }

/**
 * Convert lowercase letter to uppercase.
 * Converts parameter c to its uppercase equivalent if c is a lowercase
 * letter and has an uppercase equivalent. If no such conversion is possible,
 * the value returned is c unchanged.
 *
 * \param c Lowercase letter character to be converted.
 * \return The uppercase equivalent to c, if such value exists, or c
 * (unchanged) otherwise..
 */
inline int toupper(int c) { if (islower(c)) c -= 32; return c; }

/**
 * Convert uppercase letter to lowercase.
 * Converts parameter c to its lowercase equivalent if c is an uppercase
 * letter and has a lowercase equivalent. If no such conversion is possible,
 * the value returned is c unchanged.
 *
 * \param c Uppercase letter character to be converted.
 * \return The lowercase equivalent to c, if such value exists, or c
 * (unchanged) otherwise..
 */
inline int tolower(int c) { if (isupper(c)) c += 32; return c; }


/** @} */ // end of ctypeAPI group

/** @} */ // end of StandardCAPIFunctions group


/** @addtogroup RICMacros
 * @{
 */
/**
 * Set the value of an element in an RIC data array.
 * \param _data The RIC data array
 * \param _idx The array index to update
 * \param _newval The new value to write into the RIC data array
 */
#define RICSetValue(_data, _idx, _newval) _data[(_idx)] = (_newval)&0xFF; _data[(_idx)+1] = (_newval)>>8
/** @} */ // end of RICMacros group

/** @addtogroup GraphicsLibrary
 * @{
 */
//------------------------------------------------------------------------------
// File          : nbcGL.nbc
// Description   : Data and subroutines for a very simple 3D engine.
// Programmed by : Arno van der Vegt, legoasimo@gmail.com
//------------------------------------------------------------------------------

/**
 * Initialize graphics library.
 * Setup all the necessary data for the graphics library to function. Call this
 * function before any other graphics library routine.
 */
inline void glInit() { asm { __glInit() } }

/**
 * Set graphics library options.
 * Adjust graphic library settings for circle size and cull mode.
 *
 * \param glType The setting type.  See \ref GLConstantsSettings.
 * \param glValue The setting value. For culling modes see \ref GLConstantsCullMode.
 */
inline void glSet(int glType, int glValue) { asm { __glSet(glType, glValue) } }

/**
 * Begin defining an object.
 * Start the process of defining a graphics library object using low level
 * functions such as \ref glBegin, \ref glAddVertex, and \ref glEnd.
 *
 * \return The object index of the new object being created.
 */
inline int glBeginObject() { asm { __glBeginObject(__RETVAL__) } }

/**
 * Stop defining an object.
 * Finish the process of defining a graphics library object.  Call this function
 * after you have completed the object definition.
 */
inline void glEndObject() { asm { __glEndObject() } }

/**
 * Perform an object action.
 * Execute the specified action on the specified object.
 *
 * \param glObjectId The object id.
 * \param glAction The action to perform on the object. See \ref GLConstantsActions.
 * \param glValue The setting value.
 */
inline void glObjectAction(int glObjectId, int glAction, int glValue) {
  asm { __glObjectAction(glObjectId, glAction, glValue) }
}

/**
 * Add a vertex to an object.
 * Add a vertex to an object currently being defined.  This function should
 * only be used between \ref glBegin and \ref glEnd which are themselves
 * nested within a \ref glBeginObject and \ref glEndObject pair.
 *
 * \param glX The X axis coordinate.
 * \param glY The Y axis coordinate.
 * \param glZ The Z axis coordinate.
 */
inline void glAddVertex(int glX, int glY, int glZ) {
  asm { __glAddVertex(glX, glY, glZ) }
}

/**
 * Begin a new polygon for the current object.
 * Start defining a polygon surface for the current graphics object using
 * the specified begin mode.
 *
 * \param glBeginMode The desired mode.  See \ref GLConstantsBeginModes.
 */
inline void glBegin(int glBeginMode) { asm { __glBegin(glBeginMode) } }

/**
 * Finish a polygon for the current object.
 * Stop defining a polgyon surface for the current graphics object.
 */
inline void glEnd() { asm { __glEnd() } }

/**
 * Begin a new render.
 * Start the process of rendering the existing graphic objects.
 */
inline void glBeginRender() { asm { __glBeginRender() } }

/**
 * Call a graphic object.
 * Tell the graphics library that you want it to include the specified
 * object in the render.
 *
 * \param glObjectId The desired object id.
 */
inline void glCallObject(int glObjectId) { asm { __glCallObject(glObjectId) } }

/**
 * Finish the current render.
 * Rotate the vertex list, clear the screen, and draw the rendered objects
 * to the LCD.
 */
inline void glFinishRender() { asm { __glFinishRender() } }

/**
 * Set the X axis angle.
 * Set the X axis angle to the specified value.
 *
 * \param glValue The new X axis angle.
 */
inline void glSetAngleX(int glValue) { asm { __glSetAngleX(glValue) } }

/**
 * Add to the X axis angle.
 * Add the specified value to the existing X axis angle.
 *
 * \param glValue The value to add to the X axis angle.
 */
inline void glAddToAngleX(int glValue) { asm { __glAddToAngleX(glValue) } }

/**
 * Set the Y axis angle.
 * Set the Y axis angle to the specified value.
 *
 * \param glValue The new Y axis angle.
 */
inline void glSetAngleY(int glValue) { asm { __glSetAngleY(glValue) } }

/**
 * Add to the Y axis angle.
 * Add the specified value to the existing Y axis angle.
 *
 * \param glValue The value to add to the Y axis angle.
 */
inline void glAddToAngleY(int glValue) { asm { __glAddToAngleY(glValue) } }

/**
 * Set the Z axis angle.
 * Set the Z axis angle to the specified value.
 *
 * \param glValue The new Z axis angle.
 */
inline void glSetAngleZ(int glValue) { asm { __glSetAngleZ(glValue) } }

/**
 * Add to the Z axis angle.
 * Add the specified value to the existing Z axis angle.
 *
 * \param glValue The value to add to the Z axis angle.
 */
inline void glAddToAngleZ(int glValue) { asm { __glAddToAngleZ(glValue) } }

/**
 * Table-based sine scaled by 32768.
 * Return the sine of the specified angle in degrees.  The result is scaled
 * by 32768.
 *
 * \param glAngle The angle in degrees.
 * \return The sine value scaled by 32768.
 */
inline int glSin32768(int glAngle) { asm { __glSin32768(__RETVAL__, glAngle) } }

/**
 * Table-based cosine scaled by 32768.
 * Return the cosine of the specified angle in degrees.  The result is scaled
 * by 32768.
 *
 * \param glAngle The angle in degrees.
 * \return The cosine value scaled by 32768.
 */
inline int glCos32768(int glAngle) { asm { __glCos32768(__RETVAL__, glAngle) } }

/**
 * Create a 3D box.
 * Define a 3D box using the specified begin mode for all faces. The center
 * of the box is at the origin of the XYZ axis with width, height, and depth
 * specified via the glSizeX, glSizeY, and glSizeZ parameters.
 *
 * \param glMode The begin mode for each surface.  See \ref GLConstantsBeginModes.
 * \param glSizeX The X axis size (width).
 * \param glSizeY The Y axis size (height).
 * \param glSizeZ The Z axis size (depth).
 */
inline int glBox(int glMode, int glSizeX, int glSizeY, int glSizeZ) {
  asm { __glBox(glMode, glSizeX, glSizeY, glSizeZ, __RETVAL__) }
}

/**
 * Create a 3D cube.
 * Define a 3D cube using the specified begin mode for all faces. The center
 * of the box is at the origin of the XYZ axis with equal width, height, and depth
 * specified via the glSize parameter.
 *
 * \param glMode The begin mode for each surface.  See \ref GLConstantsBeginModes.
 * \param glSize The cube's width, height, and depth.
 */
inline int glCube(int glMode, int glSize) {
  asm { __glBox(glMode, glSize, glSize, glSize, __RETVAL__) }
}

/**
 * Create a 3D pyramid.
 * Define a 3D pyramid using the specified begin mode for all faces. The center
 * of the pyramid is at the origin of the XYZ axis with width, height, and depth
 * specified via the glSizeX, glSizeY, and glSizeZ parameters.
 *
 * \param glMode The begin mode for each surface.  See \ref GLConstantsBeginModes.
 * \param glSizeX The X axis size (width).
 * \param glSizeY The Y axis size (height).
 * \param glSizeZ The Z axis size (depth).
 */
inline int glPyramid(int glMode, int glSizeX, int glSizeY, int glSizeZ) {
  asm { __glPyramid(glMode, glSizeX, glSizeY, glSizeZ, __RETVAL__) }
}

/** @} */ // end of GraphicsLibrary group

#if defined(__ENHANCED_FIRMWARE) && (__FIRMWARE_VERSION > 107)
/** @addtogroup NXTFirmwareModules
 * @{
 */
/** @addtogroup OutputModule
 * @{
 */
/** @addtogroup OutputModuleFunctions
 * @{
 */

/**
 * Enable absolute position regulation with PID factors.
 * Enable absolute position regulation on the specified output.  Motor is kept
 * regulated as long as this is enabled.
 * Optionally specify proportional, integral, and derivative factors.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \param output Desired output port. Can be a constant or a variable, see
 * \ref OutputPortConstants.
 * \param p Proportional factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants. Default value is \ref PID_3.
 * \param i Integral factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants. Default value is \ref PID_1.
 * \param d Derivative factor used by the firmware's PID motor control
 * algorithm. See \ref PIDConstants. Default value is \ref PID_1.
 */
inline void PosRegEnable(byte output, byte p = PID_3, byte i = PID_1, byte d = PID_1)
{
    SetOutput(output,
	       OutputModeField, OUT_MODE_MOTORON+OUT_MODE_BRAKE+OUT_MODE_REGULATED,
	       RegModeField, OUT_REGMODE_POS,
	       RunStateField, OUT_RUNSTATE_RUNNING,
	       PowerField, 0,
	       TurnRatioField, 0,
	       RegPValueField, p, RegIValueField, i, RegDValueField, d,
	       UpdateFlagsField, UF_UPDATE_MODE+UF_UPDATE_SPEED+UF_UPDATE_PID_VALUES+UF_UPDATE_RESET_COUNT);
    Wait(MS_2);
}

/**
 * Change the current value for set angle.
 * Make the absolute position regulation going toward the new provided angle.
 * Returns immediately, but keep regulating.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \param output Desired output port. Can be a constant or a variable, see
 * \ref OutputPortConstants.
 * \param angle New set position, in degree. The 0 angle corresponds to the
 * position of the motor when absolute position regulation was first enabled.
 * Can be negative. Can be greater than 360 degree to make several turns.
 */
inline void PosRegSetAngle(byte output, long angle)
{
    SetOutput(output,
	       TachoLimitField, angle,
	       UpdateFlagsField, UF_UPDATE_TACHO_LIMIT);
}

/**
 * Add to the current value for set angle.
 * Add an offset to the current set position. Returns immediately, but keep
 * regulating.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \param output Desired output port. Can be a constant or a variable, see
 * \ref OutputPortConstants.
 * \param angle_add Value to add to the current set position, in degree. Can
 * be negative. Can be greater than 360 degree to make several turns.
 */
inline void PosRegAddAngle(byte output, long angle_add)
{
    long current_angle = GetOutput(output, TachoLimitField);
    SetOutput(output,
	       TachoLimitField, current_angle + angle_add,
	       UpdateFlagsField, UF_UPDATE_TACHO_LIMIT);
}

/**
 * Set maximum limits.
 * Set maximum speed and acceleration.
 *
 * \warning This function requires the enhanced NBC/NXC firmware version 1.31+
 *
 * \param output Desired output port. Can be a constant or a variable, see
 * \ref OutputPortConstants.
 * \param max_speed Maximum speed, or 0 to disable speed limiting.
 * \param max_acceleration Maximum acceleration, or 0 to disable acceleration
 * limiting. The max_speed parameter should not be 0 if this is not 0.
 */
inline void PosRegSetMax(byte output, byte max_speed, byte max_acceleration)
{
    SetOutput(output,
	       MaxSpeedField, max_speed,
	       MaxAccelerationField, max_acceleration,
	       UpdateFlagsField, UF_UPDATE_PID_VALUES);
    Wait(MS_2);
}

/** @} */ // end of OutputModuleFunctions group
/** @} */ // end of OutputModule group
/** @} */ // end of NXTFirmwareModules group
#endif

#endif // NXCDEFS_H